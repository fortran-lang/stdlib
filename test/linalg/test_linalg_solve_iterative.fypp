#:include "common.fypp"
#:set R_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES, REAL_SUFFIX))
#:set MATRIX_TYPES = ["dense", "CSR"]
! Test linear system iterative solvers
module test_linalg_solve_iterative
    use stdlib_kinds
    use stdlib_sparse
    use stdlib_linalg_iterative_solvers
    use testdrive, only: error_type, check, new_unittest, unittest_type    

    implicit none 
    private
    
    public :: test_linear_systems

    contains

    subroutine test_linear_systems(tests)
        !> Collection of tests
        type(unittest_type), allocatable, intent(out) :: tests(:)

        allocate(tests(0))

        tests = [ new_unittest("stdlib_solve_cg",test_stdlib_solve_cg), &
                  new_unittest("stdlib_solve_pcg",test_stdlib_solve_pcg) ]

    end subroutine test_linear_systems    

    subroutine test_stdlib_solve_cg(error)
        type(error_type), allocatable, intent(out) :: error

        #:for k, t, s in R_KINDS_TYPES
        block
        ${t}$, parameter :: tol = 1000*epsilon(0.0_${k}$)
        ${t}$ :: A(2,2) = reshape([${t}$ ::  4,  1, &
                                             1,  3], [2,2])
        ${t}$ :: x(2), load(2), xref(2)
        
        xref = [0.0909, 0.6364]
        x    = real( [2,1] , kind = ${k}$ ) ! initial guess
        load = real( [1,2] , kind = ${k}$ ) ! load vector

        call stdlib_solve_cg(A, load, x)
        
        call check(error, norm2(x-xref)<1.e-4_${k}$, 'error in conjugate gradient solver')
        if (allocated(error)) return
        end block

        #:endfor
    end subroutine test_stdlib_solve_cg

    subroutine test_stdlib_solve_pcg(error)
        type(error_type), allocatable, intent(out) :: error

        #:for k, t, s in R_KINDS_TYPES
        block
        ${t}$, parameter :: tol = 1000*epsilon(0.0_${k}$)
        ${t}$ :: A(5,5) = reshape([${t}$ :: 1, -1,  0,  0,  0,&
                                           -1,  2, -1,  0,  0,&
                                            0, -1,  2, -1,  0,&
                                            0,  0, -1,  2, -1,&
                                            0,  0,  0, -1,  1] , [5,5])
        ${t}$ :: x(5), load(5), xref(5)
        logical(int8) :: dirichlet(5)
        
        xref = [0.0_${k}$,2.5_${k}$,5.0_${k}$,2.5_${k}$,0.0_${k}$]
        x    = 0.0_${k}$ 
        load = real( [0,0,5,0,0] , kind = ${k}$ ) ! load vector
        dirichlet = .false._int8
        dirichlet([1,5]) = .true._int8

        call stdlib_solve_pcg(A, load, x, di=dirichlet, tol=1.e-6_${k}$)

        call check(error, norm2(x-xref)<1.e-6_${k}$*norm2(xref), 'error in preconditionned conjugate gradient solver')
        if (allocated(error)) return
        end block

        #:endfor
    end subroutine test_stdlib_solve_pcg

end module test_linalg_solve_iterative

program test_solve_iterative
     use, intrinsic :: iso_fortran_env, only : error_unit
     use testdrive, only : run_testsuite, new_testsuite, testsuite_type
     use test_linalg_solve_iterative, only : test_linear_systems
     implicit none
     integer :: stat, is
     type(testsuite_type), allocatable :: testsuites(:)
     character(len=*), parameter :: fmt = '("#", *(1x, a))'

     stat = 0

     testsuites = [ &
         new_testsuite("linalg_solve_iterative", test_linear_systems) &
         ]

     do is = 1, size(testsuites)
         write(error_unit, fmt) "Testing:", testsuites(is)%name
         call run_testsuite(testsuites(is)%collect, error_unit, stat)
     end do

     if (stat > 0) then
         write(error_unit, '(i0, 1x, a)') stat, "test(s) failed!"
         error stop
     end if
end program test_solve_iterative
