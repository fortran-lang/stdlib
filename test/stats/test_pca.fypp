#:include "common.fypp"
module test_stats_pca
    use testdrive, only: new_unittest, unittest_type, error_type, check
    use stdlib_kinds, only: sp, dp, xdp, qp
    use stdlib_stats, only: pca, pca_transform, pca_inverse_transform
    use stdlib_linalg_state, only: linalg_state_type
    implicit none

    public :: collect_stats_pca

    #:for k1 in REAL_KINDS
    real(${k1}$), parameter :: ${k1}$tol = 1000 * epsilon(1._${k1}$)
    #:endfor

contains

    !> Collect all exported unit tests
    subroutine collect_stats_pca(testsuite)
        !> Collection of tests
        type(unittest_type), allocatable, intent(out) :: testsuite(:)

        testsuite = [ &
            #:for k1 in REAL_KINDS
            new_unittest("test_pca_${k1}$", test_pca_${k1}$) ${", &" if k1 != REAL_KINDS[-1] else "&"}$
            #:endfor
        ]
    end subroutine collect_stats_pca

    #:for k1 in REAL_KINDS
    subroutine test_pca_${k1}$(error)
        type(error_type), allocatable, intent(out) :: error
        real(${k1}$) :: x(3, 2), x_copy(3, 2), components(2, 2), s(2), mu(2)
        real(${k1}$) :: x_trans(3, 2), x_inv(3, 2)
        type(linalg_state_type) :: err

        ! Data: [1, 2], [3, 4], [5, 6]
        x = reshape([1.0_${k1}$, 3.0_${k1}$, 5.0_${k1}$, 2.0_${k1}$, 4.0_${k1}$, 6.0_${k1}$], [3, 2])
        x_copy = x

        ! Test SVD method
        call pca(x, components, s, x_mean=mu, method="svd", err=err)
        call check(error, err%ok(), "pca_${k1}$ svd err")
        if (allocated(error)) return

        call check(error, all(abs(mu - [3.0_${k1}$, 4.0_${k1}$]) < ${k1}$tol), "pca_${k1}$ svd mean")
        if (allocated(error)) return

        ! First component should be approx [0.707, 0.707] (or negative)
        call check(error, abs(abs(components(1,1)) - 1.0_${k1}$/sqrt(2.0_${k1}$)) < ${k1}$tol, "pca_${k1}$ svd comp1")
        if (allocated(error)) return

        call check(error, abs(s(1) - 4.0_${k1}$) < ${k1}$tol, "pca_${k1}$ svd s1")
        if (allocated(error)) return

        call check(error, abs(s(2)) < ${k1}$tol, "pca_${k1}$ svd s2")
        if (allocated(error)) return

        ! Test Transform
        call pca_transform(x, components, mu, x_trans)
        ! Second dimension should be zero
        call check(error, all(abs(x_trans(:, 2)) < ${k1}$tol), "pca_${k1}$ transform")
        if (allocated(error)) return

        ! Test Inverse Transform (must run before the no-mean transform overwrites x_trans)
        call pca_inverse_transform(x_trans, components, mu, x_inv)
        call check(error, all(abs(x_inv - x) < ${k1}$tol), "pca_${k1}$ inverse")
        if (allocated(error)) return

        ! Test Transform without x_mean (keyword-based call)
        call pca_transform(x, components, x_transformed=x_trans)
        call check(error, size(x_trans, 1) == 3 .and. size(x_trans, 2) == 2, "pca_${k1}$ transform_no_mean shape")
        if (allocated(error)) return

        ! Test EIG method
        call pca(x, components, s, method="eig", err=err)
        call check(error, err%ok(), "pca_${k1}$ eig err")
        if (allocated(error)) return

        call check(error, abs(s(1) - 4.0_${k1}$) < ${k1}$tol, "pca_${k1}$ eig s1")
        if (allocated(error)) return

        ! Test COV method (alias for EIG)
        call pca(x, components, s, method="cov", err=err)
        call check(error, err%ok(), "pca_${k1}$ cov err")
        if (allocated(error)) return

        call check(error, abs(s(1) - 4.0_${k1}$) < ${k1}$tol, "pca_${k1}$ cov s1")
        if (allocated(error)) return

        ! Test overwrite_x=.true.
        x_copy = x
        call pca(x_copy, components, s, method="svd", overwrite_x=.true., err=err)
        call check(error, err%ok(), "pca_${k1}$ overwrite err")
        if (allocated(error)) return

        call check(error, abs(s(1) - 4.0_${k1}$) < ${k1}$tol, "pca_${k1}$ overwrite s1")
        if (allocated(error)) return

        ! Test case-insensitivity
        call pca(x, components, s, method="SVD", err=err)
        call check(error, err%ok(), "pca_${k1}$ case_insensitive err")
        if (allocated(error)) return

    end subroutine test_pca_${k1}$
    #:endfor

end module test_stats_pca

program tester
    use, intrinsic :: iso_fortran_env, only : error_unit
    use testdrive, only : run_testsuite, new_testsuite, testsuite_type
    use test_stats_pca, only : collect_stats_pca
    implicit none
    integer :: stat, is
    type(testsuite_type), allocatable :: testsuites(:)
    character(len=*), parameter :: fmt = '("#", *(1x, a))'

    stat = 0

    testsuites = [ &
        new_testsuite("stats_pca", collect_stats_pca) &
        ]

    do is = 1, size(testsuites)
        write(error_unit, fmt) "Testing:", testsuites(is)%name
        call run_testsuite(testsuites(is)%collect, error_unit, stat)
    end do

    if (stat > 0) then
        write(error_unit, '(i0, 1x, a)') stat, "test(s) failed!"
        error stop
    end if
end program tester
