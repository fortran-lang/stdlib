#:include "common.fypp" 
module stdlib_linalg_lapack_c
     use stdlib_linalg_constants
     use stdlib_linalg_blas
     use stdlib_linalg_lapack_aux
     use stdlib_linalg_lapack_s
     implicit none(type,external)
     private


     public :: sp,dp,qp,lk,ilp
     public :: stdlib_cbbcsd
     public :: stdlib_cbdsqr
     public :: stdlib_cgbbrd
     public :: stdlib_cgbcon
     public :: stdlib_cgbequ
     public :: stdlib_cgbequb
     public :: stdlib_cgbrfs
     public :: stdlib_cgbsv
     public :: stdlib_cgbsvx
     public :: stdlib_cgbtf2
     public :: stdlib_cgbtrf
     public :: stdlib_cgbtrs
     public :: stdlib_cgebak
     public :: stdlib_cgebal
     public :: stdlib_cgebd2
     public :: stdlib_cgebrd
     public :: stdlib_cgecon
     public :: stdlib_cgeequ
     public :: stdlib_cgeequb
     public :: stdlib_cgees
     public :: stdlib_cgeesx
     public :: stdlib_cgeev
     public :: stdlib_cgeevx
     public :: stdlib_cgehd2
     public :: stdlib_cgehrd
     public :: stdlib_cgejsv
     public :: stdlib_cgelq
     public :: stdlib_cgelq2
     public :: stdlib_cgelqf
     public :: stdlib_cgelqt
     public :: stdlib_cgelqt3
     public :: stdlib_cgels
     public :: stdlib_cgelsd
     public :: stdlib_cgelss
     public :: stdlib_cgelsy
     public :: stdlib_cgemlq
     public :: stdlib_cgemlqt
     public :: stdlib_cgemqr
     public :: stdlib_cgemqrt
     public :: stdlib_cgeql2
     public :: stdlib_cgeqlf
     public :: stdlib_cgeqp3
     public :: stdlib_cgeqr
     public :: stdlib_cgeqr2
     public :: stdlib_cgeqr2p
     public :: stdlib_cgeqrf
     public :: stdlib_cgeqrfp
     public :: stdlib_cgeqrt
     public :: stdlib_cgeqrt2
     public :: stdlib_cgeqrt3
     public :: stdlib_cgerfs
     public :: stdlib_cgerq2
     public :: stdlib_cgerqf
     public :: stdlib_cgesc2
     public :: stdlib_cgesdd
     public :: stdlib_cgesv
     public :: stdlib_cgesvd
     public :: stdlib_cgesvdq
     public :: stdlib_cgesvj
     public :: stdlib_cgesvx
     public :: stdlib_cgetc2
     public :: stdlib_cgetf2
     public :: stdlib_cgetrf
     public :: stdlib_cgetrf2
     public :: stdlib_cgetri
     public :: stdlib_cgetrs
     public :: stdlib_cgetsls
     public :: stdlib_cgetsqrhrt
     public :: stdlib_cggbak
     public :: stdlib_cggbal
     public :: stdlib_cgges
     public :: stdlib_cgges3
     public :: stdlib_cggesx
     public :: stdlib_cggev
     public :: stdlib_cggev3
     public :: stdlib_cggevx
     public :: stdlib_cggglm
     public :: stdlib_cgghd3
     public :: stdlib_cgghrd
     public :: stdlib_cgglse
     public :: stdlib_cggqrf
     public :: stdlib_cggrqf
     public :: stdlib_cgsvj0
     public :: stdlib_cgsvj1
     public :: stdlib_cgtcon
     public :: stdlib_cgtrfs
     public :: stdlib_cgtsv
     public :: stdlib_cgtsvx
     public :: stdlib_cgttrf
     public :: stdlib_cgttrs
     public :: stdlib_cgtts2
     public :: stdlib_chb2st_kernels
     public :: stdlib_chbev
     public :: stdlib_chbevd
     public :: stdlib_chbevx
     public :: stdlib_chbgst
     public :: stdlib_chbgv
     public :: stdlib_chbgvd
     public :: stdlib_chbgvx
     public :: stdlib_chbtrd
     public :: stdlib_checon
     public :: stdlib_checon_rook
     public :: stdlib_cheequb
     public :: stdlib_cheev
     public :: stdlib_cheevd
     public :: stdlib_cheevr
     public :: stdlib_cheevx
     public :: stdlib_chegs2
     public :: stdlib_chegst
     public :: stdlib_chegv
     public :: stdlib_chegvd
     public :: stdlib_chegvx
     public :: stdlib_cherfs
     public :: stdlib_chesv
     public :: stdlib_chesv_aa
     public :: stdlib_chesv_rk
     public :: stdlib_chesv_rook
     public :: stdlib_chesvx
     public :: stdlib_cheswapr
     public :: stdlib_chetd2
     public :: stdlib_chetf2
     public :: stdlib_chetf2_rk
     public :: stdlib_chetf2_rook
     public :: stdlib_chetrd
     public :: stdlib_chetrd_hb2st
     public :: stdlib_chetrd_he2hb
     public :: stdlib_chetrf
     public :: stdlib_chetrf_aa
     public :: stdlib_chetrf_rk
     public :: stdlib_chetrf_rook
     public :: stdlib_chetri
     public :: stdlib_chetri_rook
     public :: stdlib_chetrs
     public :: stdlib_chetrs2
     public :: stdlib_chetrs_3
     public :: stdlib_chetrs_aa
     public :: stdlib_chetrs_rook
     public :: stdlib_chfrk
     public :: stdlib_chgeqz
     public :: stdlib_chpcon
     public :: stdlib_chpev
     public :: stdlib_chpevd
     public :: stdlib_chpevx
     public :: stdlib_chpgst
     public :: stdlib_chpgv
     public :: stdlib_chpgvd
     public :: stdlib_chpgvx
     public :: stdlib_chprfs
     public :: stdlib_chpsv
     public :: stdlib_chpsvx
     public :: stdlib_chptrd
     public :: stdlib_chptrf
     public :: stdlib_chptri
     public :: stdlib_chptrs
     public :: stdlib_chsein
     public :: stdlib_chseqr
     public :: stdlib_cla_gbamv
     public :: stdlib_cla_gbrcond_c
     public :: stdlib_cla_gbrpvgrw
     public :: stdlib_cla_geamv
     public :: stdlib_cla_gercond_c
     public :: stdlib_cla_gerpvgrw
     public :: stdlib_cla_heamv
     public :: stdlib_cla_hercond_c
     public :: stdlib_cla_herpvgrw
     public :: stdlib_cla_lin_berr
     public :: stdlib_cla_porcond_c
     public :: stdlib_cla_porpvgrw
     public :: stdlib_cla_syamv
     public :: stdlib_cla_syrcond_c
     public :: stdlib_cla_syrpvgrw
     public :: stdlib_cla_wwaddw
     public :: stdlib_clabrd
     public :: stdlib_clacgv
     public :: stdlib_clacn2
     public :: stdlib_clacon
     public :: stdlib_clacp2
     public :: stdlib_clacpy
     public :: stdlib_clacrm
     public :: stdlib_clacrt
     public :: stdlib_cladiv
     public :: stdlib_claed0
     public :: stdlib_claed7
     public :: stdlib_claed8
     public :: stdlib_claein
     public :: stdlib_claesy
     public :: stdlib_claev2
     public :: stdlib_clag2z
     public :: stdlib_clags2
     public :: stdlib_clagtm
     public :: stdlib_clahef
     public :: stdlib_clahef_aa
     public :: stdlib_clahef_rk
     public :: stdlib_clahef_rook
     public :: stdlib_clahqr
     public :: stdlib_clahr2
     public :: stdlib_claic1
     public :: stdlib_clals0
     public :: stdlib_clalsa
     public :: stdlib_clalsd
     public :: stdlib_clamswlq
     public :: stdlib_clamtsqr
     public :: stdlib_clangb
     public :: stdlib_clange
     public :: stdlib_clangt
     public :: stdlib_clanhb
     public :: stdlib_clanhe
     public :: stdlib_clanhf
     public :: stdlib_clanhp
     public :: stdlib_clanhs
     public :: stdlib_clanht
     public :: stdlib_clansb
     public :: stdlib_clansp
     public :: stdlib_clansy
     public :: stdlib_clantb
     public :: stdlib_clantp
     public :: stdlib_clantr
     public :: stdlib_clapll
     public :: stdlib_clapmr
     public :: stdlib_clapmt
     public :: stdlib_claqgb
     public :: stdlib_claqge
     public :: stdlib_claqhb
     public :: stdlib_claqhe
     public :: stdlib_claqhp
     public :: stdlib_claqp2
     public :: stdlib_claqps
     public :: stdlib_claqr0
     public :: stdlib_claqr1
     public :: stdlib_claqr2
     public :: stdlib_claqr3
     public :: stdlib_claqr4
     public :: stdlib_claqr5
     public :: stdlib_claqsb
     public :: stdlib_claqsp
     public :: stdlib_claqsy
     public :: stdlib_claqz0
     public :: stdlib_claqz1
     public :: stdlib_claqz2
     public :: stdlib_claqz3
     public :: stdlib_clar1v
     public :: stdlib_clar2v
     public :: stdlib_clarcm
     public :: stdlib_clarf
     public :: stdlib_clarfb
     public :: stdlib_clarfb_gett
     public :: stdlib_clarfg
     public :: stdlib_clarfgp
     public :: stdlib_clarft
     public :: stdlib_clarfx
     public :: stdlib_clarfy
     public :: stdlib_clargv
     public :: stdlib_clarnv
     public :: stdlib_clarrv
     public :: stdlib_clartg
     public :: stdlib_clartv
     public :: stdlib_clarz
     public :: stdlib_clarzb
     public :: stdlib_clarzt
     public :: stdlib_clascl
     public :: stdlib_claset
     public :: stdlib_clasr
     public :: stdlib_classq
     public :: stdlib_claswlq
     public :: stdlib_claswp
     public :: stdlib_clasyf
     public :: stdlib_clasyf_aa
     public :: stdlib_clasyf_rk
     public :: stdlib_clasyf_rook
     public :: stdlib_clatbs
     public :: stdlib_clatdf
     public :: stdlib_clatps
     public :: stdlib_clatrd
     public :: stdlib_clatrs
     public :: stdlib_clatrz
     public :: stdlib_clatsqr
     public :: stdlib_claunhr_col_getrfnp
     public :: stdlib_claunhr_col_getrfnp2
     public :: stdlib_clauu2
     public :: stdlib_clauum
     public :: stdlib_cpbcon
     public :: stdlib_cpbequ
     public :: stdlib_cpbrfs
     public :: stdlib_cpbstf
     public :: stdlib_cpbsv
     public :: stdlib_cpbsvx
     public :: stdlib_cpbtf2
     public :: stdlib_cpbtrf
     public :: stdlib_cpbtrs
     public :: stdlib_cpftrf
     public :: stdlib_cpftri
     public :: stdlib_cpftrs
     public :: stdlib_cpocon
     public :: stdlib_cpoequ
     public :: stdlib_cpoequb
     public :: stdlib_cporfs
     public :: stdlib_cposv
     public :: stdlib_cposvx
     public :: stdlib_cpotf2
     public :: stdlib_cpotrf
     public :: stdlib_cpotrf2
     public :: stdlib_cpotri
     public :: stdlib_cpotrs
     public :: stdlib_cppcon
     public :: stdlib_cppequ
     public :: stdlib_cpprfs
     public :: stdlib_cppsv
     public :: stdlib_cppsvx
     public :: stdlib_cpptrf
     public :: stdlib_cpptri
     public :: stdlib_cpptrs
     public :: stdlib_cpstf2
     public :: stdlib_cpstrf
     public :: stdlib_cptcon
     public :: stdlib_cpteqr
     public :: stdlib_cptrfs
     public :: stdlib_cptsv
     public :: stdlib_cptsvx
     public :: stdlib_cpttrf
     public :: stdlib_cpttrs
     public :: stdlib_cptts2
     public :: stdlib_crot
     public :: stdlib_cspcon
     public :: stdlib_cspmv
     public :: stdlib_cspr
     public :: stdlib_csprfs
     public :: stdlib_cspsv
     public :: stdlib_cspsvx
     public :: stdlib_csptrf
     public :: stdlib_csptri
     public :: stdlib_csptrs
     public :: stdlib_csrscl
     public :: stdlib_cstedc
     public :: stdlib_cstegr
     public :: stdlib_cstein
     public :: stdlib_cstemr
     public :: stdlib_csteqr
     public :: stdlib_csycon
     public :: stdlib_csycon_rook
     public :: stdlib_csyconv
     public :: stdlib_csyconvf
     public :: stdlib_csyconvf_rook
     public :: stdlib_csyequb
     public :: stdlib_csymv
     public :: stdlib_csyr
     public :: stdlib_csyrfs
     public :: stdlib_csysv
     public :: stdlib_csysv_aa
     public :: stdlib_csysv_rk
     public :: stdlib_csysv_rook
     public :: stdlib_csysvx
     public :: stdlib_csyswapr
     public :: stdlib_csytf2
     public :: stdlib_csytf2_rk
     public :: stdlib_csytf2_rook
     public :: stdlib_csytrf
     public :: stdlib_csytrf_aa
     public :: stdlib_csytrf_rk
     public :: stdlib_csytrf_rook
     public :: stdlib_csytri
     public :: stdlib_csytri_rook
     public :: stdlib_csytrs
     public :: stdlib_csytrs2
     public :: stdlib_csytrs_3
     public :: stdlib_csytrs_aa
     public :: stdlib_csytrs_rook
     public :: stdlib_ctbcon
     public :: stdlib_ctbrfs
     public :: stdlib_ctbtrs
     public :: stdlib_ctfsm
     public :: stdlib_ctftri
     public :: stdlib_ctfttp
     public :: stdlib_ctfttr
     public :: stdlib_ctgevc
     public :: stdlib_ctgex2
     public :: stdlib_ctgexc
     public :: stdlib_ctgsen
     public :: stdlib_ctgsja
     public :: stdlib_ctgsna
     public :: stdlib_ctgsy2
     public :: stdlib_ctgsyl
     public :: stdlib_ctpcon
     public :: stdlib_ctplqt
     public :: stdlib_ctplqt2
     public :: stdlib_ctpmlqt
     public :: stdlib_ctpmqrt
     public :: stdlib_ctpqrt
     public :: stdlib_ctpqrt2
     public :: stdlib_ctprfb
     public :: stdlib_ctprfs
     public :: stdlib_ctptri
     public :: stdlib_ctptrs
     public :: stdlib_ctpttf
     public :: stdlib_ctpttr
     public :: stdlib_ctrcon
     public :: stdlib_ctrevc
     public :: stdlib_ctrevc3
     public :: stdlib_ctrexc
     public :: stdlib_ctrrfs
     public :: stdlib_ctrsen
     public :: stdlib_ctrsna
     public :: stdlib_ctrsyl
     public :: stdlib_ctrti2
     public :: stdlib_ctrtri
     public :: stdlib_ctrtrs
     public :: stdlib_ctrttf
     public :: stdlib_ctrttp
     public :: stdlib_ctzrzf
     public :: stdlib_cunbdb
     public :: stdlib_cunbdb1
     public :: stdlib_cunbdb2
     public :: stdlib_cunbdb3
     public :: stdlib_cunbdb4
     public :: stdlib_cunbdb5
     public :: stdlib_cunbdb6
     public :: stdlib_cuncsd
     public :: stdlib_cuncsd2by1
     public :: stdlib_cung2l
     public :: stdlib_cung2r
     public :: stdlib_cungbr
     public :: stdlib_cunghr
     public :: stdlib_cungl2
     public :: stdlib_cunglq
     public :: stdlib_cungql
     public :: stdlib_cungqr
     public :: stdlib_cungr2
     public :: stdlib_cungrq
     public :: stdlib_cungtr
     public :: stdlib_cungtsqr
     public :: stdlib_cungtsqr_row
     public :: stdlib_cunhr_col
     public :: stdlib_cunm22
     public :: stdlib_cunm2l
     public :: stdlib_cunm2r
     public :: stdlib_cunmbr
     public :: stdlib_cunmhr
     public :: stdlib_cunml2
     public :: stdlib_cunmlq
     public :: stdlib_cunmql
     public :: stdlib_cunmqr
     public :: stdlib_cunmr2
     public :: stdlib_cunmr3
     public :: stdlib_cunmrq
     public :: stdlib_cunmrz
     public :: stdlib_cunmtr
     public :: stdlib_cupgtr
     public :: stdlib_cupmtr

     ! 32-bit real constants 
     real(sp),    parameter, private ::     negone = -1.00_sp
     real(sp),    parameter, private ::       zero = 0.00_sp
     real(sp),    parameter, private ::       half = 0.50_sp
     real(sp),    parameter, private ::        one = 1.00_sp
     real(sp),    parameter, private ::        two = 2.00_sp
     real(sp),    parameter, private ::      three = 3.00_sp
     real(sp),    parameter, private ::       four = 4.00_sp
     real(sp),    parameter, private ::      eight = 8.00_sp
     real(sp),    parameter, private ::        ten = 10.00_sp

     ! 32-bit complex constants 
     complex(sp), parameter, private :: czero   = ( 0.0_sp,0.0_sp)
     complex(sp), parameter, private :: chalf   = ( 0.5_sp,0.0_sp)
     complex(sp), parameter, private :: cone    = ( 1.0_sp,0.0_sp)
     complex(sp), parameter, private :: cnegone = (-1.0_sp,0.0_sp)

     ! 32-bit scaling constants 
     integer,     parameter, private :: maxexp = maxexponent(zero) 
     integer,     parameter, private :: minexp = minexponent(zero) 
     real(sp),    parameter, private :: rradix = real(radix(zero),sp) 
     real(sp),    parameter, private :: ulp    = epsilon(zero) 
     real(sp),    parameter, private :: eps    = ulp*half 
     real(sp),    parameter, private :: safmin = rradix**max(minexp-1,1-maxexp) 
     real(sp),    parameter, private :: safmax = one/safmin 
     real(sp),    parameter, private :: smlnum = safmin/ulp 
     real(sp),    parameter, private :: bignum = safmax*ulp 
     real(sp),    parameter, private :: rtmin  = sqrt(smlnum) 
     real(sp),    parameter, private :: rtmax  = sqrt(bignum) 

     ! 32-bit Blue's scaling constants 
     ! ssml>=1/s and sbig==1/S with s,S as defined in https://doi.org/10.1145/355769.355771 
     real(sp),    parameter, private :: tsml   = rradix**ceiling((minexp-1)*half) 
     real(sp),    parameter, private :: tbig   = rradix**floor((maxexp-digits(zero)+1)*half) 
     real(sp),    parameter, private :: ssml   = rradix**(-floor((minexp-digits(zero))*half)) 
     real(sp),    parameter, private :: sbig   = rradix**(-ceiling((maxexp+digits(zero)-1)*half)) 


     contains


     pure subroutine stdlib_cgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )
     !! CGBEQU computes row and column scalings intended to equilibrate an
     !! M-by-N band matrix A and reduce its condition number.  R returns the
     !! row scale factors and C the column scale factors, chosen to try to
     !! make the largest element in each row and column of the matrix B with
     !! elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
     !! R(i) and C(j) are restricted to be between SMLNUM = smallest safe
     !! number and BIGNUM = largest safe number.  Use of these scaling
     !! factors is not guaranteed to reduce the condition number of A but
     !! works well in practice.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, m, n
           real(sp), intent(out) :: amax, colcnd, rowcnd
           ! Array Arguments 
           real(sp), intent(out) :: c(*), r(*)
           complex(sp), intent(in) :: ab(ldab,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, kd
           real(sp) :: bignum, rcmax, rcmin, smlnum
           complex(sp) :: zdum
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,min,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kl<0 ) then
              info = -3
           else if( ku<0 ) then
              info = -4
           else if( ldab<kl+ku+1 ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGBEQU', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              rowcnd = one
              colcnd = one
              amax = zero
              return
           end if
           ! get machine constants.
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           ! compute row scale factors.
           do i = 1, m
              r( i ) = zero
           end do
           ! find the maximum element in each row.
           kd = ku + 1
           do j = 1, n
              do i = max( j-ku, 1 ), min( j+kl, m )
                 r( i ) = max( r( i ), cabs1( ab( kd+i-j, j ) ) )
              end do
           end do
           ! find the maximum and minimum scale factors.
           rcmin = bignum
           rcmax = zero
           do i = 1, m
              rcmax = max( rcmax, r( i ) )
              rcmin = min( rcmin, r( i ) )
           end do
           amax = rcmax
           if( rcmin==zero ) then
              ! find the first zero scale factor and return an error code.
              do i = 1, m
                 if( r( i )==zero ) then
                    info = i
                    return
                 end if
              end do
           else
              ! invert the scale factors.
              do i = 1, m
                 r( i ) = one / min( max( r( i ), smlnum ), bignum )
              end do
              ! compute rowcnd = min(r(i)) / max(r(i))
              rowcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
           end if
           ! compute column scale factors
           do j = 1, n
              c( j ) = zero
           end do
           ! find the maximum element in each column,
           ! assuming the row scaling computed above.
           kd = ku + 1
           do j = 1, n
              do i = max( j-ku, 1 ), min( j+kl, m )
                 c( j ) = max( c( j ), cabs1( ab( kd+i-j, j ) )*r( i ) )
              end do
           end do
           ! find the maximum and minimum scale factors.
           rcmin = bignum
           rcmax = zero
           do j = 1, n
              rcmin = min( rcmin, c( j ) )
              rcmax = max( rcmax, c( j ) )
           end do
           if( rcmin==zero ) then
              ! find the first zero scale factor and return an error code.
              do j = 1, n
                 if( c( j )==zero ) then
                    info = m + j
                    return
                 end if
              end do
           else
              ! invert the scale factors.
              do j = 1, n
                 c( j ) = one / min( max( c( j ), smlnum ), bignum )
              end do
              ! compute colcnd = min(c(j)) / max(c(j))
              colcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
           end if
           return
     end subroutine stdlib_cgbequ


     pure subroutine stdlib_cgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )
     !! CGBEQUB computes row and column scalings intended to equilibrate an
     !! M-by-N matrix A and reduce its condition number.  R returns the row
     !! scale factors and C the column scale factors, chosen to try to make
     !! the largest element in each row and column of the matrix B with
     !! elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
     !! the radix.
     !! R(i) and C(j) are restricted to be a power of the radix between
     !! SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use
     !! of these scaling factors is not guaranteed to reduce the condition
     !! number of A but works well in practice.
     !! This routine differs from CGEEQU by restricting the scaling factors
     !! to a power of the radix.  Barring over- and underflow, scaling by
     !! these factors introduces no additional rounding errors.  However, the
     !! scaled entries' magnitudes are no longer approximately 1 but lie
     !! between sqrt(radix) and 1/sqrt(radix).
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, m, n
           real(sp), intent(out) :: amax, colcnd, rowcnd
           ! Array Arguments 
           real(sp), intent(out) :: c(*), r(*)
           complex(sp), intent(in) :: ab(ldab,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, kd
           real(sp) :: bignum, rcmax, rcmin, smlnum, radix, logrdx
           complex(sp) :: zdum
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,log,real,aimag
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kl<0 ) then
              info = -3
           else if( ku<0 ) then
              info = -4
           else if( ldab<kl+ku+1 ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGBEQUB', -info )
              return
           end if
           ! quick return if possible.
           if( m==0 .or. n==0 ) then
              rowcnd = one
              colcnd = one
              amax = zero
              return
           end if
           ! get machine constants.  assume smlnum is a power of the radix.
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           radix = stdlib_slamch( 'B' )
           logrdx = log(radix)
           ! compute row scale factors.
           do i = 1, m
              r( i ) = zero
           end do
           ! find the maximum element in each row.
           kd = ku + 1
           do j = 1, n
              do i = max( j-ku, 1 ), min( j+kl, m )
                 r( i ) = max( r( i ), cabs1( ab( kd+i-j, j ) ) )
              end do
           end do
           do i = 1, m
              if( r( i )>zero ) then
                 r( i ) = radix**int( log( r( i ) ) / logrdx,KIND=ilp)
              end if
           end do
           ! find the maximum and minimum scale factors.
           rcmin = bignum
           rcmax = zero
           do i = 1, m
              rcmax = max( rcmax, r( i ) )
              rcmin = min( rcmin, r( i ) )
           end do
           amax = rcmax
           if( rcmin==zero ) then
              ! find the first zero scale factor and return an error code.
              do i = 1, m
                 if( r( i )==zero ) then
                    info = i
                    return
                 end if
              end do
           else
              ! invert the scale factors.
              do i = 1, m
                 r( i ) = one / min( max( r( i ), smlnum ), bignum )
              end do
              ! compute rowcnd = min(r(i)) / max(r(i)).
              rowcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
           end if
           ! compute column scale factors.
           do j = 1, n
              c( j ) = zero
           end do
           ! find the maximum element in each column,
           ! assuming the row scaling computed above.
           do j = 1, n
              do i = max( j-ku, 1 ), min( j+kl, m )
                 c( j ) = max( c( j ), cabs1( ab( kd+i-j, j ) )*r( i ) )
              end do
              if( c( j )>zero ) then
                 c( j ) = radix**int( log( c( j ) ) / logrdx,KIND=ilp)
              end if
           end do
           ! find the maximum and minimum scale factors.
           rcmin = bignum
           rcmax = zero
           do j = 1, n
              rcmin = min( rcmin, c( j ) )
              rcmax = max( rcmax, c( j ) )
           end do
           if( rcmin==zero ) then
              ! find the first zero scale factor and return an error code.
              do j = 1, n
                 if( c( j )==zero ) then
                    info = m + j
                    return
                 end if
              end do
           else
              ! invert the scale factors.
              do j = 1, n
                 c( j ) = one / min( max( c( j ), smlnum ), bignum )
              end do
              ! compute colcnd = min(c(j)) / max(c(j)).
              colcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
           end if
           return
     end subroutine stdlib_cgbequb


     pure subroutine stdlib_cgbtf2( m, n, kl, ku, ab, ldab, ipiv, info )
     !! CGBTF2 computes an LU factorization of a complex m-by-n band matrix
     !! A using partial pivoting with row interchanges.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: ab(ldab,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, jp, ju, km, kv
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! kv is the number of superdiagonals in the factor u, allowing for
           ! fill-in.
           kv = ku + kl
           ! test the input parameters.
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kl<0 ) then
              info = -3
           else if( ku<0 ) then
              info = -4
           else if( ldab<kl+kv+1 ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGBTF2', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           ! gaussian elimination with partial pivoting
           ! set fill-in elements in columns ku+2 to kv to czero.
           do j = ku + 2, min( kv, n )
              do i = kv - j + 2, kl
                 ab( i, j ) = czero
              end do
           end do
           ! ju is the index of the last column affected by the current stage
           ! of the factorization.
           ju = 1
           loop_40: do j = 1, min( m, n )
              ! set fill-in elements in column j+kv to czero.
              if( j+kv<=n ) then
                 do i = 1, kl
                    ab( i, j+kv ) = czero
                 end do
              end if
              ! find pivot and test for singularity. km is the number of
              ! subdiagonal elements in the current column.
              km = min( kl, m-j )
              jp = stdlib_icamax( km+1, ab( kv+1, j ), 1 )
              ipiv( j ) = jp + j - 1
              if( ab( kv+jp, j )/=czero ) then
                 ju = max( ju, min( j+ku+jp-1, n ) )
                 ! apply interchange to columns j to ju.
                 if( jp/=1 )call stdlib_cswap( ju-j+1, ab( kv+jp, j ), ldab-1,ab( kv+1, j ), ldab-&
                           1 )
                 if( km>0 ) then
                    ! compute multipliers.
                    call stdlib_cscal( km, cone / ab( kv+1, j ), ab( kv+2, j ), 1 )
                    ! update trailing submatrix within the band.
                    if( ju>j )call stdlib_cgeru( km, ju-j, -cone, ab( kv+2, j ), 1,ab( kv, j+1 ), &
                              ldab-1, ab( kv+1, j+1 ),ldab-1 )
                 end if
              else
                 ! if pivot is czero, set info to the index of the pivot
                 ! unless a czero pivot has already been found.
                 if( info==0 )info = j
              end if
           end do loop_40
           return
     end subroutine stdlib_cgbtf2


     pure subroutine stdlib_cgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
     !! CGEBAK forms the right or left eigenvectors of a complex general
     !! matrix by backward transformation on the computed eigenvectors of the
     !! balanced matrix output by CGEBAL.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(in) :: scale(*)
           complex(sp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, ii, k
           real(sp) :: s
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! decode and test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( m<0 ) then
              info = -7
           else if( ldv<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 do i = ilo, ihi
                    s = scale( i )
                    call stdlib_csscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
              if( leftv ) then
                 do i = ilo, ihi
                    s = one / scale( i )
                    call stdlib_csscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           ! for  i = ilo-1 step -1 until 1,
                    ! ihi+1 step 1 until n do --
                    30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 loop_40: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_40
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_40
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
              end if
              if( leftv ) then
                 loop_50: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_50
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_50
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_50
              end if
           end if
           return
     end subroutine stdlib_cgebak


     pure subroutine stdlib_cgebal( job, n, a, lda, ilo, ihi, scale, info )
     !! CGEBAL balances a general complex matrix A.  This involves, first,
     !! permuting A by a similarity transformation to isolate eigenvalues
     !! in the first 1 to ILO-1 and last IHI+1 to N elements on the
     !! diagonal; and second, applying a diagonal similarity transformation
     !! to rows and columns ILO to IHI to make the rows and columns as
     !! close in norm as possible.  Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrix, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(sp), intent(out) :: scale(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sclfac = 2.0e+0_sp
           real(sp), parameter :: factor = 0.95e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: noconv
           integer(ilp) :: i, ica, iexc, ira, j, k, l, m
           real(sp) :: c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1, sfmin2
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,min,real
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEBAL', -info )
              return
           end if
           k = 1
           l = n
           if( n==0 )go to 210
           if( stdlib_lsame( job, 'N' ) ) then
              do i = 1, n
                 scale( i ) = one
              end do
              go to 210
           end if
           if( stdlib_lsame( job, 'S' ) )go to 120
           ! permutation to isolate eigenvalues if possible
           go to 50
           ! row and column exchange.
           20 continue
           scale( m ) = j
           if( j==m )go to 30
           call stdlib_cswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_cswap( n-k+1, a( j, k ), lda, a( m, k ), lda )
           30 continue
           go to ( 40, 80 )iexc
           ! search for rows isolating an eigenvalue and push them down.
           40 continue
           if( l==1 )go to 210
           l = l - 1
           50 continue
           loop_70: do j = l, 1, -1
              loop_60: do i = 1, l
                 if( i==j )cycle loop_60
                 if( real( a( j, i ),KIND=sp)/=zero .or. aimag( a( j, i ) )/=zero )cycle &
                           loop_70
              end do loop_60
              m = l
              iexc = 1
              go to 20
           end do loop_70
           go to 90
           ! search for columns isolating an eigenvalue and push them left.
           80 continue
           k = k + 1
           90 continue
           loop_110: do j = k, l
              loop_100: do i = k, l
                 if( i==j )cycle loop_100
                 if( real( a( i, j ),KIND=sp)/=zero .or. aimag( a( i, j ) )/=zero )cycle &
                           loop_110
              end do loop_100
              m = k
              iexc = 2
              go to 20
           end do loop_110
           120 continue
           do i = k, l
              scale( i ) = one
           end do
           if( stdlib_lsame( job, 'P' ) )go to 210
           ! balance the submatrix in rows k to l.
           ! iterative loop for norm reduction
           sfmin1 = stdlib_slamch( 'S' ) / stdlib_slamch( 'P' )
           sfmax1 = one / sfmin1
           sfmin2 = sfmin1*sclfac
           sfmax2 = one / sfmin2
           140 continue
           noconv = .false.
           loop_200: do i = k, l
              c = stdlib_scnrm2( l-k+1, a( k, i ), 1 )
              r = stdlib_scnrm2( l-k+1, a( i , k ), lda )
              ica = stdlib_icamax( l, a( 1, i ), 1 )
              ca = abs( a( ica, i ) )
              ira = stdlib_icamax( n-k+1, a( i, k ), lda )
              ra = abs( a( i, ira+k-1 ) )
              ! guard against zero c or r due to underflow.
              if( c==zero .or. r==zero )cycle loop_200
              g = r / sclfac
              f = one
              s = c + r
              160 continue
              if( c>=g .or. max( f, c, ca )>=sfmax2 .or.min( r, g, ra )<=sfmin2 )go to 170
                 if( stdlib_sisnan( c+f+ca+r+g+ra ) ) then
                 ! exit if nan to avoid infinite loop
                 info = -3
                 call stdlib_xerbla( 'CGEBAL', -info )
                 return
              end if
              f = f*sclfac
              c = c*sclfac
              ca = ca*sclfac
              r = r / sclfac
              g = g / sclfac
              ra = ra / sclfac
              go to 160
              170 continue
              g = c / sclfac
              180 continue
              if( g<r .or. max( r, ra )>=sfmax2 .or.min( f, c, g, ca )<=sfmin2 )go to 190
              f = f / sclfac
              c = c / sclfac
              g = g / sclfac
              ca = ca / sclfac
              r = r*sclfac
              ra = ra*sclfac
              go to 180
              ! now balance.
              190 continue
              if( ( c+r )>=factor*s )cycle loop_200
              if( f<one .and. scale( i )<one ) then
                 if( f*scale( i )<=sfmin1 )cycle loop_200
              end if
              if( f>one .and. scale( i )>one ) then
                 if( scale( i )>=sfmax1 / f )cycle loop_200
              end if
              g = one / f
              scale( i ) = scale( i )*f
              noconv = .true.
              call stdlib_csscal( n-k+1, g, a( i, k ), lda )
              call stdlib_csscal( l, f, a( 1, i ), 1 )
           end do loop_200
           if( noconv )go to 140
           210 continue
           ilo = k
           ihi = l
           return
     end subroutine stdlib_cgebal


     pure subroutine stdlib_cgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
     !! CGEEQU computes row and column scalings intended to equilibrate an
     !! M-by-N matrix A and reduce its condition number.  R returns the row
     !! scale factors and C the column scale factors, chosen to try to make
     !! the largest element in each row and column of the matrix B with
     !! elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
     !! R(i) and C(j) are restricted to be between SMLNUM = smallest safe
     !! number and BIGNUM = largest safe number.  Use of these scaling
     !! factors is not guaranteed to reduce the condition number of A but
     !! works well in practice.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           real(sp), intent(out) :: amax, colcnd, rowcnd
           ! Array Arguments 
           real(sp), intent(out) :: c(*), r(*)
           complex(sp), intent(in) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: bignum, rcmax, rcmin, smlnum
           complex(sp) :: zdum
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,min,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEEQU', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              rowcnd = one
              colcnd = one
              amax = zero
              return
           end if
           ! get machine constants.
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           ! compute row scale factors.
           do i = 1, m
              r( i ) = zero
           end do
           ! find the maximum element in each row.
           do j = 1, n
              do i = 1, m
                 r( i ) = max( r( i ), cabs1( a( i, j ) ) )
              end do
           end do
           ! find the maximum and minimum scale factors.
           rcmin = bignum
           rcmax = zero
           do i = 1, m
              rcmax = max( rcmax, r( i ) )
              rcmin = min( rcmin, r( i ) )
           end do
           amax = rcmax
           if( rcmin==zero ) then
              ! find the first zero scale factor and return an error code.
              do i = 1, m
                 if( r( i )==zero ) then
                    info = i
                    return
                 end if
              end do
           else
              ! invert the scale factors.
              do i = 1, m
                 r( i ) = one / min( max( r( i ), smlnum ), bignum )
              end do
              ! compute rowcnd = min(r(i)) / max(r(i))
              rowcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
           end if
           ! compute column scale factors
           do j = 1, n
              c( j ) = zero
           end do
           ! find the maximum element in each column,
           ! assuming the row scaling computed above.
           do j = 1, n
              do i = 1, m
                 c( j ) = max( c( j ), cabs1( a( i, j ) )*r( i ) )
              end do
           end do
           ! find the maximum and minimum scale factors.
           rcmin = bignum
           rcmax = zero
           do j = 1, n
              rcmin = min( rcmin, c( j ) )
              rcmax = max( rcmax, c( j ) )
           end do
           if( rcmin==zero ) then
              ! find the first zero scale factor and return an error code.
              do j = 1, n
                 if( c( j )==zero ) then
                    info = m + j
                    return
                 end if
              end do
           else
              ! invert the scale factors.
              do j = 1, n
                 c( j ) = one / min( max( c( j ), smlnum ), bignum )
              end do
              ! compute colcnd = min(c(j)) / max(c(j))
              colcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
           end if
           return
     end subroutine stdlib_cgeequ


     pure subroutine stdlib_cgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
     !! CGEEQUB computes row and column scalings intended to equilibrate an
     !! M-by-N matrix A and reduce its condition number.  R returns the row
     !! scale factors and C the column scale factors, chosen to try to make
     !! the largest element in each row and column of the matrix B with
     !! elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
     !! the radix.
     !! R(i) and C(j) are restricted to be a power of the radix between
     !! SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use
     !! of these scaling factors is not guaranteed to reduce the condition
     !! number of A but works well in practice.
     !! This routine differs from CGEEQU by restricting the scaling factors
     !! to a power of the radix.  Barring over- and underflow, scaling by
     !! these factors introduces no additional rounding errors.  However, the
     !! scaled entries' magnitudes are no longer approximately 1 but lie
     !! between sqrt(radix) and 1/sqrt(radix).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           real(sp), intent(out) :: amax, colcnd, rowcnd
           ! Array Arguments 
           real(sp), intent(out) :: c(*), r(*)
           complex(sp), intent(in) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: bignum, rcmax, rcmin, smlnum, radix, logrdx
           complex(sp) :: zdum
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,log,real,aimag
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEEQUB', -info )
              return
           end if
           ! quick return if possible.
           if( m==0 .or. n==0 ) then
              rowcnd = one
              colcnd = one
              amax = zero
              return
           end if
           ! get machine constants.  assume smlnum is a power of the radix.
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           radix = stdlib_slamch( 'B' )
           logrdx = log( radix )
           ! compute row scale factors.
           do i = 1, m
              r( i ) = zero
           end do
           ! find the maximum element in each row.
           do j = 1, n
              do i = 1, m
                 r( i ) = max( r( i ), cabs1( a( i, j ) ) )
              end do
           end do
           do i = 1, m
              if( r( i )>zero ) then
                 r( i ) = radix**int( log(r( i ) ) / logrdx,KIND=ilp)
              end if
           end do
           ! find the maximum and minimum scale factors.
           rcmin = bignum
           rcmax = zero
           do i = 1, m
              rcmax = max( rcmax, r( i ) )
              rcmin = min( rcmin, r( i ) )
           end do
           amax = rcmax
           if( rcmin==zero ) then
              ! find the first zero scale factor and return an error code.
              do i = 1, m
                 if( r( i )==zero ) then
                    info = i
                    return
                 end if
              end do
           else
              ! invert the scale factors.
              do i = 1, m
                 r( i ) = one / min( max( r( i ), smlnum ), bignum )
              end do
              ! compute rowcnd = min(r(i)) / max(r(i)).
              rowcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
           end if
           ! compute column scale factors.
           do j = 1, n
              c( j ) = zero
           end do
           ! find the maximum element in each column,
           ! assuming the row scaling computed above.
           do j = 1, n
              do i = 1, m
                 c( j ) = max( c( j ), cabs1( a( i, j ) )*r( i ) )
              end do
              if( c( j )>zero ) then
                 c( j ) = radix**int( log( c( j ) ) / logrdx,KIND=ilp)
              end if
           end do
           ! find the maximum and minimum scale factors.
           rcmin = bignum
           rcmax = zero
           do j = 1, n
              rcmin = min( rcmin, c( j ) )
              rcmax = max( rcmax, c( j ) )
           end do
           if( rcmin==zero ) then
              ! find the first zero scale factor and return an error code.
              do j = 1, n
                 if( c( j )==zero ) then
                    info = m + j
                    return
                 end if
              end do
           else
              ! invert the scale factors.
              do j = 1, n
                 c( j ) = one / min( max( c( j ), smlnum ), bignum )
              end do
              ! compute colcnd = min(c(j)) / max(c(j)).
              colcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
           end if
           return
     end subroutine stdlib_cgeequb


     pure subroutine stdlib_cgetc2( n, a, lda, ipiv, jpiv, info )
     !! CGETC2 computes an LU factorization, using complete pivoting, of the
     !! n-by-n matrix A. The factorization has the form A = P * L * U * Q,
     !! where P and Q are permutation matrices, L is lower triangular with
     !! unit diagonal elements and U is upper triangular.
     !! This is a level 1 BLAS version of the algorithm.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*), jpiv(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, ip, ipv, j, jp, jpv
           real(sp) :: bignum, eps, smin, smlnum, xmax
           ! Intrinsic Functions 
           intrinsic :: abs,cmplx,max
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 )return
           ! set constants to control overflow
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           ! handle the case n=1 by itself
           if( n==1 ) then
              ipiv( 1 ) = 1
              jpiv( 1 ) = 1
              if( abs( a( 1, 1 ) )<smlnum ) then
                 info = 1
                 a( 1, 1 ) = cmplx( smlnum, zero,KIND=sp)
              end if
              return
           end if
           ! factorize a using complete pivoting.
           ! set pivots less than smin to smin
           loop_40: do i = 1, n - 1
              ! find max element in matrix a
              xmax = zero
              do ip = i, n
                 do jp = i, n
                    if( abs( a( ip, jp ) )>=xmax ) then
                       xmax = abs( a( ip, jp ) )
                       ipv = ip
                       jpv = jp
                    end if
                 end do
              end do
              if( i==1 )smin = max( eps*xmax, smlnum )
              ! swap rows
              if( ipv/=i )call stdlib_cswap( n, a( ipv, 1 ), lda, a( i, 1 ), lda )
              ipiv( i ) = ipv
              ! swap columns
              if( jpv/=i )call stdlib_cswap( n, a( 1, jpv ), 1, a( 1, i ), 1 )
              jpiv( i ) = jpv
              ! check for singularity
              if( abs( a( i, i ) )<smin ) then
                 info = i
                 a( i, i ) = cmplx( smin, zero,KIND=sp)
              end if
              do j = i + 1, n
                 a( j, i ) = a( j, i ) / a( i, i )
              end do
              call stdlib_cgeru( n-i, n-i, -cmplx( one,KIND=sp), a( i+1, i ), 1,a( i, i+1 ), lda, &
                        a( i+1, i+1 ), lda )
           end do loop_40
           if( abs( a( n, n ) )<smin ) then
              info = n
              a( n, n ) = cmplx( smin, zero,KIND=sp)
           end if
           ! set last pivots to n
           ipiv( n ) = n
           jpiv( n ) = n
           return
     end subroutine stdlib_cgetc2


     pure subroutine stdlib_cgetf2( m, n, a, lda, ipiv, info )
     !! CGETF2 computes an LU factorization of a general m-by-n matrix A
     !! using partial pivoting with row interchanges.
     !! The factorization has the form
     !! A = P * L * U
     !! where P is a permutation matrix, L is lower triangular with unit
     !! diagonal elements (lower trapezoidal if m > n), and U is upper
     !! triangular (upper trapezoidal if m < n).
     !! This is the right-looking Level 2 BLAS version of the algorithm.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           real(sp) :: sfmin
           integer(ilp) :: i, j, jp
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGETF2', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           ! compute machine safe minimum
           sfmin = stdlib_slamch('S')
           do j = 1, min( m, n )
              ! find pivot and test for singularity.
              jp = j - 1 + stdlib_icamax( m-j+1, a( j, j ), 1 )
              ipiv( j ) = jp
              if( a( jp, j )/=czero ) then
                 ! apply the interchange to columns 1:n.
                 if( jp/=j )call stdlib_cswap( n, a( j, 1 ), lda, a( jp, 1 ), lda )
                 ! compute elements j+1:m of j-th column.
                 if( j<m ) then
                    if( abs(a( j, j )) >= sfmin ) then
                       call stdlib_cscal( m-j, cone / a( j, j ), a( j+1, j ), 1 )
                    else
                       do i = 1, m-j
                          a( j+i, j ) = a( j+i, j ) / a( j, j )
                       end do
                    end if
                 end if
              else if( info==0 ) then
                 info = j
              end if
              if( j<min( m, n ) ) then
                 ! update trailing submatrix.
                 call stdlib_cgeru( m-j, n-j, -cone, a( j+1, j ), 1, a( j, j+1 ),lda, a( j+1, j+1 &
                           ), lda )
              end if
           end do
           return
     end subroutine stdlib_cgetf2


     pure subroutine stdlib_cggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
     !! CGGBAK forms the right or left eigenvectors of a complex generalized
     !! eigenvalue problem A*x = lambda*B*x, by backward transformation on
     !! the computed eigenvectors of the balanced pair of matrices output by
     !! CGGBAL.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(in) :: lscale(*), rscale(*)
           complex(sp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, k
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( n==0 .and. ihi==0 .and. ilo/=1 ) then
              info = -4
           else if( n>0 .and. ( ihi<ilo .or. ihi>max( 1, n ) ) )then
              info = -5
           else if( n==0 .and. ilo==1 .and. ihi/=0 ) then
              info = -5
           else if( m<0 ) then
              info = -8
           else if( ldv<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward transformation on right eigenvectors
              if( rightv ) then
                 do i = ilo, ihi
                    call stdlib_csscal( m, rscale( i ), v( i, 1 ), ldv )
                 end do
              end if
              ! backward transformation on left eigenvectors
              if( leftv ) then
                 do i = ilo, ihi
                    call stdlib_csscal( m, lscale( i ), v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward permutation on right eigenvectors
              if( rightv ) then
                 if( ilo==1 )go to 50
                 loop_40: do i = ilo - 1, 1, -1
                    k = rscale( i )
                    if( k==i )cycle loop_40
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
                 50 continue
                 if( ihi==n )go to 70
                 loop_60: do i = ihi + 1, n
                    k = rscale( i )
                    if( k==i )cycle loop_60
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_60
              end if
              ! backward permutation on left eigenvectors
              70 continue
              if( leftv ) then
                 if( ilo==1 )go to 90
                 loop_80: do i = ilo - 1, 1, -1
                    k = lscale( i )
                    if( k==i )cycle loop_80
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_80
                 90 continue
                 if( ihi==n )go to 110
                 loop_100: do i = ihi + 1, n
                    k = lscale( i )
                    if( k==i )cycle loop_100
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_100
              end if
           end if
           110 continue
           return
     end subroutine stdlib_cggbak


     pure subroutine stdlib_cggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
     !! CGGBAL balances a pair of general complex matrices (A,B).  This
     !! involves, first, permuting A and B by similarity transformations to
     !! isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
     !! elements on the diagonal; and second, applying a diagonal similarity
     !! transformation to rows and columns ILO to IHI to make the rows
     !! and columns as close in norm as possible. Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrices, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors in the
     !! generalized eigenvalue problem A*x = lambda*B*x.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, n
           ! Array Arguments 
           real(sp), intent(out) :: lscale(*), rscale(*), work(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sclfac = 1.0e+1_sp
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, icab, iflow, ip1, ir, irab, it, j, jc, jp1, k, kount, l, lcab, lm1, &
                     lrab, lsfmax, lsfmin, m, nr, nrp2
           real(sp) :: alpha, basl, beta, cab, cmax, coef, coef2, coef5, cor, ew, ewc, gamma, &
                     pgamma, rab, sfmax, sfmin, sum, t, ta, tb, tc
           complex(sp) :: cdum
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,int,log10,max,min,real,sign
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGBAL', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              ilo = 1
              ihi = n
              return
           end if
           if( n==1 ) then
              ilo = 1
              ihi = n
              lscale( 1 ) = one
              rscale( 1 ) = one
              return
           end if
           if( stdlib_lsame( job, 'N' ) ) then
              ilo = 1
              ihi = n
              do i = 1, n
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           k = 1
           l = n
           if( stdlib_lsame( job, 'S' ) )go to 190
           go to 30
           ! permute the matrices a and b to isolate the eigenvalues.
           ! find row with one nonzero in columns 1 through l
           20 continue
           l = lm1
           if( l/=1 )go to 30
           rscale( 1 ) = one
           lscale( 1 ) = one
           go to 190
           30 continue
           lm1 = l - 1
           loop_80: do i = l, 1, -1
              do j = 1, lm1
                 jp1 = j + 1
                 if( a( i, j )/=czero .or. b( i, j )/=czero )go to 50
              end do
              j = l
              go to 70
              50 continue
              do j = jp1, l
                 if( a( i, j )/=czero .or. b( i, j )/=czero )cycle loop_80
              end do
              j = jp1 - 1
              70 continue
              m = l
              iflow = 1
              go to 160
           end do loop_80
           go to 100
           ! find column with one nonzero in rows k through n
           90 continue
           k = k + 1
           100 continue
           loop_150: do j = k, l
              do i = k, lm1
                 ip1 = i + 1
                 if( a( i, j )/=czero .or. b( i, j )/=czero )go to 120
              end do
              i = l
              go to 140
              120 continue
              do i = ip1, l
                 if( a( i, j )/=czero .or. b( i, j )/=czero )cycle loop_150
              end do
              i = ip1 - 1
              140 continue
              m = k
              iflow = 2
              go to 160
           end do loop_150
           go to 190
           ! permute rows m and i
           160 continue
           lscale( m ) = i
           if( i==m )go to 170
           call stdlib_cswap( n-k+1, a( i, k ), lda, a( m, k ), lda )
           call stdlib_cswap( n-k+1, b( i, k ), ldb, b( m, k ), ldb )
           ! permute columns m and j
           170 continue
           rscale( m ) = j
           if( j==m )go to 180
           call stdlib_cswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_cswap( l, b( 1, j ), 1, b( 1, m ), 1 )
           180 continue
           go to ( 20, 90 )iflow
           190 continue
           ilo = k
           ihi = l
           if( stdlib_lsame( job, 'P' ) ) then
              do i = ilo, ihi
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           if( ilo==ihi )return
           ! balance the submatrix in rows ilo to ihi.
           nr = ihi - ilo + 1
           do i = ilo, ihi
              rscale( i ) = zero
              lscale( i ) = zero
              work( i ) = zero
              work( i+n ) = zero
              work( i+2*n ) = zero
              work( i+3*n ) = zero
              work( i+4*n ) = zero
              work( i+5*n ) = zero
           end do
           ! compute right side vector in resulting linear equations
           basl = log10( sclfac )
           do i = ilo, ihi
              do j = ilo, ihi
                 if( a( i, j )==czero ) then
                    ta = zero
                    go to 210
                 end if
                 ta = log10( cabs1( a( i, j ) ) ) / basl
                 210 continue
                 if( b( i, j )==czero ) then
                    tb = zero
                    go to 220
                 end if
                 tb = log10( cabs1( b( i, j ) ) ) / basl
                 220 continue
                 work( i+4*n ) = work( i+4*n ) - ta - tb
                 work( j+5*n ) = work( j+5*n ) - ta - tb
              end do
           end do
           coef = one / real( 2*nr,KIND=sp)
           coef2 = coef*coef
           coef5 = half*coef2
           nrp2 = nr + 2
           beta = zero
           it = 1
           ! start generalized conjugate gradient iteration
           250 continue
           gamma = stdlib_sdot( nr, work( ilo+4*n ), 1, work( ilo+4*n ), 1 ) +stdlib_sdot( nr, &
                     work( ilo+5*n ), 1, work( ilo+5*n ), 1 )
           ew = zero
           ewc = zero
           do i = ilo, ihi
              ew = ew + work( i+4*n )
              ewc = ewc + work( i+5*n )
           end do
           gamma = coef*gamma - coef2*( ew**2+ewc**2 ) - coef5*( ew-ewc )**2
           if( gamma==zero )go to 350
           if( it/=1 )beta = gamma / pgamma
           t = coef5*( ewc-three*ew )
           tc = coef5*( ew-three*ewc )
           call stdlib_sscal( nr, beta, work( ilo ), 1 )
           call stdlib_sscal( nr, beta, work( ilo+n ), 1 )
           call stdlib_saxpy( nr, coef, work( ilo+4*n ), 1, work( ilo+n ), 1 )
           call stdlib_saxpy( nr, coef, work( ilo+5*n ), 1, work( ilo ), 1 )
           do i = ilo, ihi
              work( i ) = work( i ) + tc
              work( i+n ) = work( i+n ) + t
           end do
           ! apply matrix to vector
           do i = ilo, ihi
              kount = 0
              sum = zero
              loop_290: do j = ilo, ihi
                 if( a( i, j )==czero )go to 280
                 kount = kount + 1
                 sum = sum + work( j )
                 280 continue
                 if( b( i, j )==czero )cycle loop_290
                 kount = kount + 1
                 sum = sum + work( j )
              end do loop_290
              work( i+2*n ) = real( kount,KIND=sp)*work( i+n ) + sum
           end do
           do j = ilo, ihi
              kount = 0
              sum = zero
              loop_320: do i = ilo, ihi
                 if( a( i, j )==czero )go to 310
                 kount = kount + 1
                 sum = sum + work( i+n )
                 310 continue
                 if( b( i, j )==czero )cycle loop_320
                 kount = kount + 1
                 sum = sum + work( i+n )
              end do loop_320
              work( j+3*n ) = real( kount,KIND=sp)*work( j ) + sum
           end do
           sum = stdlib_sdot( nr, work( ilo+n ), 1, work( ilo+2*n ), 1 ) +stdlib_sdot( nr, work( &
                     ilo ), 1, work( ilo+3*n ), 1 )
           alpha = gamma / sum
           ! determine correction to current iteration
           cmax = zero
           do i = ilo, ihi
              cor = alpha*work( i+n )
              if( abs( cor )>cmax )cmax = abs( cor )
              lscale( i ) = lscale( i ) + cor
              cor = alpha*work( i )
              if( abs( cor )>cmax )cmax = abs( cor )
              rscale( i ) = rscale( i ) + cor
           end do
           if( cmax<half )go to 350
           call stdlib_saxpy( nr, -alpha, work( ilo+2*n ), 1, work( ilo+4*n ), 1 )
           call stdlib_saxpy( nr, -alpha, work( ilo+3*n ), 1, work( ilo+5*n ), 1 )
           pgamma = gamma
           it = it + 1
           if( it<=nrp2 )go to 250
           ! end generalized conjugate gradient iteration
           350 continue
           sfmin = stdlib_slamch( 'S' )
           sfmax = one / sfmin
           lsfmin = int( log10( sfmin ) / basl+one,KIND=ilp)
           lsfmax = int( log10( sfmax ) / basl,KIND=ilp)
           do i = ilo, ihi
              irab = stdlib_icamax( n-ilo+1, a( i, ilo ), lda )
              rab = abs( a( i, irab+ilo-1 ) )
              irab = stdlib_icamax( n-ilo+1, b( i, ilo ), ldb )
              rab = max( rab, abs( b( i, irab+ilo-1 ) ) )
              lrab = int( log10( rab+sfmin ) / basl+one,KIND=ilp)
              ir = lscale( i ) + sign( half, lscale( i ) )
              ir = min( max( ir, lsfmin ), lsfmax, lsfmax-lrab )
              lscale( i ) = sclfac**ir
              icab = stdlib_icamax( ihi, a( 1, i ), 1 )
              cab = abs( a( icab, i ) )
              icab = stdlib_icamax( ihi, b( 1, i ), 1 )
              cab = max( cab, abs( b( icab, i ) ) )
              lcab = int( log10( cab+sfmin ) / basl+one,KIND=ilp)
              jc = rscale( i ) + sign( half, rscale( i ) )
              jc = min( max( jc, lsfmin ), lsfmax, lsfmax-lcab )
              rscale( i ) = sclfac**jc
           end do
           ! row scaling of matrices a and b
           do i = ilo, ihi
              call stdlib_csscal( n-ilo+1, lscale( i ), a( i, ilo ), lda )
              call stdlib_csscal( n-ilo+1, lscale( i ), b( i, ilo ), ldb )
           end do
           ! column scaling of matrices a and b
           do j = ilo, ihi
              call stdlib_csscal( ihi, rscale( j ), a( 1, j ), 1 )
              call stdlib_csscal( ihi, rscale( j ), b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_cggbal


     pure subroutine stdlib_cgtsv( n, nrhs, dl, d, du, b, ldb, info )
     !! CGTSV solves the equation
     !! A*X = B,
     !! where A is an N-by-N tridiagonal matrix, by Gaussian elimination with
     !! partial pivoting.
     !! Note that the equation  A**T *X = B  may be solved by interchanging the
     !! order of the arguments DU and DL.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           complex(sp), intent(inout) :: b(ldb,*), d(*), dl(*), du(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, k
           complex(sp) :: mult, temp, zdum
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           info = 0
           if( n<0 ) then
              info = -1
           else if( nrhs<0 ) then
              info = -2
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGTSV ', -info )
              return
           end if
           if( n==0 )return
           loop_30: do k = 1, n - 1
              if( dl( k )==czero ) then
                 ! subdiagonal is czero, no elimination is required.
                 if( d( k )==czero ) then
                    ! diagonal is czero: set info = k and return; a unique
                    ! solution can not be found.
                    info = k
                    return
                 end if
              else if( cabs1( d( k ) )>=cabs1( dl( k ) ) ) then
                 ! no row interchange required
                 mult = dl( k ) / d( k )
                 d( k+1 ) = d( k+1 ) - mult*du( k )
                 do j = 1, nrhs
                    b( k+1, j ) = b( k+1, j ) - mult*b( k, j )
                 end do
                 if( k<( n-1 ) )dl( k ) = czero
              else
                 ! interchange rows k and k+1
                 mult = d( k ) / dl( k )
                 d( k ) = dl( k )
                 temp = d( k+1 )
                 d( k+1 ) = du( k ) - mult*temp
                 if( k<( n-1 ) ) then
                    dl( k ) = du( k+1 )
                    du( k+1 ) = -mult*dl( k )
                 end if
                 du( k ) = temp
                 do j = 1, nrhs
                    temp = b( k, j )
                    b( k, j ) = b( k+1, j )
                    b( k+1, j ) = temp - mult*b( k+1, j )
                 end do
              end if
           end do loop_30
           if( d( n )==czero ) then
              info = n
              return
           end if
           ! back solve with the matrix u from the factorization.
           do j = 1, nrhs
              b( n, j ) = b( n, j ) / d( n )
              if( n>1 )b( n-1, j ) = ( b( n-1, j )-du( n-1 )*b( n, j ) ) / d( n-1 )
              do k = n - 2, 1, -1
                 b( k, j ) = ( b( k, j )-du( k )*b( k+1, j )-dl( k )*b( k+2, j ) ) / d( k )
                           
              end do
           end do
           return
     end subroutine stdlib_cgtsv


     pure subroutine stdlib_cgttrf( n, dl, d, du, du2, ipiv, info )
     !! CGTTRF computes an LU factorization of a complex tridiagonal matrix A
     !! using elimination with partial pivoting and row interchanges.
     !! The factorization has the form
     !! A = L * U
     !! where L is a product of permutation and unit lower bidiagonal
     !! matrices and U is upper triangular with nonzeros in only the main
     !! diagonal and first two superdiagonals.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: d(*), dl(*), du(*)
           complex(sp), intent(out) :: du2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(sp) :: fact, temp, zdum
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           info = 0
           if( n<0 ) then
              info = -1
              call stdlib_xerbla( 'CGTTRF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! initialize ipiv(i) = i and du2(i) = 0
           do i = 1, n
              ipiv( i ) = i
           end do
           do i = 1, n - 2
              du2( i ) = zero
           end do
           do i = 1, n - 2
              if( cabs1( d( i ) )>=cabs1( dl( i ) ) ) then
                 ! no row interchange required, eliminate dl(i)
                 if( cabs1( d( i ) )/=zero ) then
                    fact = dl( i ) / d( i )
                    dl( i ) = fact
                    d( i+1 ) = d( i+1 ) - fact*du( i )
                 end if
              else
                 ! interchange rows i and i+1, eliminate dl(i)
                 fact = d( i ) / dl( i )
                 d( i ) = dl( i )
                 dl( i ) = fact
                 temp = du( i )
                 du( i ) = d( i+1 )
                 d( i+1 ) = temp - fact*d( i+1 )
                 du2( i ) = du( i+1 )
                 du( i+1 ) = -fact*du( i+1 )
                 ipiv( i ) = i + 1
              end if
           end do
           if( n>1 ) then
              i = n - 1
              if( cabs1( d( i ) )>=cabs1( dl( i ) ) ) then
                 if( cabs1( d( i ) )/=zero ) then
                    fact = dl( i ) / d( i )
                    dl( i ) = fact
                    d( i+1 ) = d( i+1 ) - fact*du( i )
                 end if
              else
                 fact = d( i ) / dl( i )
                 d( i ) = dl( i )
                 dl( i ) = fact
                 temp = du( i )
                 du( i ) = d( i+1 )
                 d( i+1 ) = temp - fact*d( i+1 )
                 ipiv( i ) = i + 1
              end if
           end if
           ! check for a zero on the diagonal of u.
           do i = 1, n
              if( cabs1( d( i ) )==zero ) then
                 info = i
                 go to 50
              end if
           end do
           50 continue
           return
     end subroutine stdlib_cgttrf


     pure subroutine stdlib_cgtts2( itrans, n, nrhs, dl, d, du, du2, ipiv, b, ldb )
     !! CGTTS2 solves one of the systems of equations
     !! A * X = B,  A**T * X = B,  or  A**H * X = B,
     !! with a tridiagonal matrix A using the LU factorization computed
     !! by CGTTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: itrans, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: b(ldb,*)
           complex(sp), intent(in) :: d(*), dl(*), du(*), du2(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           complex(sp) :: temp
           ! Intrinsic Functions 
           intrinsic :: conjg
           ! Executable Statements 
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( itrans==0 ) then
              ! solve a*x = b using the lu factorization of a,
              ! overwriting each right hand side vector with its solution.
              if( nrhs<=1 ) then
                 j = 1
                 10 continue
                 ! solve l*x = b.
                 do i = 1, n - 1
                    if( ipiv( i )==i ) then
                       b( i+1, j ) = b( i+1, j ) - dl( i )*b( i, j )
                    else
                       temp = b( i, j )
                       b( i, j ) = b( i+1, j )
                       b( i+1, j ) = temp - dl( i )*b( i, j )
                    end if
                 end do
                 ! solve u*x = b.
                 b( n, j ) = b( n, j ) / d( n )
                 if( n>1 )b( n-1, j ) = ( b( n-1, j )-du( n-1 )*b( n, j ) ) /d( n-1 )
                 do i = n - 2, 1, -1
                    b( i, j ) = ( b( i, j )-du( i )*b( i+1, j )-du2( i )*b( i+2, j ) ) / d( i )
                              
                 end do
                 if( j<nrhs ) then
                    j = j + 1
                    go to 10
                 end if
              else
                 do j = 1, nrhs
                 ! solve l*x = b.
                    do i = 1, n - 1
                       if( ipiv( i )==i ) then
                          b( i+1, j ) = b( i+1, j ) - dl( i )*b( i, j )
                       else
                          temp = b( i, j )
                          b( i, j ) = b( i+1, j )
                          b( i+1, j ) = temp - dl( i )*b( i, j )
                       end if
                    end do
                 ! solve u*x = b.
                    b( n, j ) = b( n, j ) / d( n )
                    if( n>1 )b( n-1, j ) = ( b( n-1, j )-du( n-1 )*b( n, j ) ) /d( n-1 )
                    do i = n - 2, 1, -1
                       b( i, j ) = ( b( i, j )-du( i )*b( i+1, j )-du2( i )*b( i+2, j ) ) / d( i )
                                 
                    end do
                 end do
              end if
           else if( itrans==1 ) then
              ! solve a**t * x = b.
              if( nrhs<=1 ) then
                 j = 1
                 70 continue
                 ! solve u**t * x = b.
                 b( 1, j ) = b( 1, j ) / d( 1 )
                 if( n>1 )b( 2, j ) = ( b( 2, j )-du( 1 )*b( 1, j ) ) / d( 2 )
                 do i = 3, n
                    b( i, j ) = ( b( i, j )-du( i-1 )*b( i-1, j )-du2( i-2 )*b( i-2, j ) ) / d( i &
                              )
                 end do
                 ! solve l**t * x = b.
                 do i = n - 1, 1, -1
                    if( ipiv( i )==i ) then
                       b( i, j ) = b( i, j ) - dl( i )*b( i+1, j )
                    else
                       temp = b( i+1, j )
                       b( i+1, j ) = b( i, j ) - dl( i )*temp
                       b( i, j ) = temp
                    end if
                 end do
                 if( j<nrhs ) then
                    j = j + 1
                    go to 70
                 end if
              else
                 do j = 1, nrhs
                 ! solve u**t * x = b.
                    b( 1, j ) = b( 1, j ) / d( 1 )
                    if( n>1 )b( 2, j ) = ( b( 2, j )-du( 1 )*b( 1, j ) ) / d( 2 )
                    do i = 3, n
                       b( i, j ) = ( b( i, j )-du( i-1 )*b( i-1, j )-du2( i-2 )*b( i-2, j ) ) / d(&
                                  i )
                    end do
                 ! solve l**t * x = b.
                    do i = n - 1, 1, -1
                       if( ipiv( i )==i ) then
                          b( i, j ) = b( i, j ) - dl( i )*b( i+1, j )
                       else
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - dl( i )*temp
                          b( i, j ) = temp
                       end if
                    end do
                 end do
              end if
           else
              ! solve a**h * x = b.
              if( nrhs<=1 ) then
                 j = 1
                 130 continue
                 ! solve u**h * x = b.
                 b( 1, j ) = b( 1, j ) / conjg( d( 1 ) )
                 if( n>1 )b( 2, j ) = ( b( 2, j )-conjg( du( 1 ) )*b( 1, j ) ) /conjg( d( 2 ) )
                           
                 do i = 3, n
                    b( i, j ) = ( b( i, j )-conjg( du( i-1 ) )*b( i-1, j )-conjg( du2( i-2 ) )*b( &
                              i-2, j ) ) /conjg( d( i ) )
                 end do
                 ! solve l**h * x = b.
                 do i = n - 1, 1, -1
                    if( ipiv( i )==i ) then
                       b( i, j ) = b( i, j ) - conjg( dl( i ) )*b( i+1, j )
                    else
                       temp = b( i+1, j )
                       b( i+1, j ) = b( i, j ) - conjg( dl( i ) )*temp
                       b( i, j ) = temp
                    end if
                 end do
                 if( j<nrhs ) then
                    j = j + 1
                    go to 130
                 end if
              else
                 do j = 1, nrhs
                 ! solve u**h * x = b.
                    b( 1, j ) = b( 1, j ) / conjg( d( 1 ) )
                    if( n>1 )b( 2, j ) = ( b( 2, j )-conjg( du( 1 ) )*b( 1, j ) ) /conjg( d( 2 ) )
                              
                    do i = 3, n
                       b( i, j ) = ( b( i, j )-conjg( du( i-1 ) )*b( i-1, j )-conjg( du2( i-2 ) )&
                                 *b( i-2, j ) ) / conjg( d( i ) )
                    end do
                 ! solve l**h * x = b.
                    do i = n - 1, 1, -1
                       if( ipiv( i )==i ) then
                          b( i, j ) = b( i, j ) - conjg( dl( i ) )*b( i+1, j )
                       else
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - conjg( dl( i ) )*temp
                          b( i, j ) = temp
                       end if
                    end do
                 end do
              end if
           end if
     end subroutine stdlib_cgtts2


     pure subroutine stdlib_cheswapr( uplo, n, a, lda, i1, i2)
     !! CHESWAPR applies an elementary permutation on the rows and the columns of
     !! a hermitian matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: i1, i2, lda, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,n)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           complex(sp) :: tmp
           ! Executable Statements 
           upper = stdlib_lsame( uplo, 'U' )
           if (upper) then
               ! upper
               ! first swap
                ! - swap column i1 and i2 from i1 to i1-1
              call stdlib_cswap( i1-1, a(1,i1), 1, a(1,i2), 1 )
                ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap row i1 from i1+1 to i2-1 with col i2 from i1+1 to i2-1
                ! - swap a(i2,i1) and a(i1,i2)
              tmp=a(i1,i1)
              a(i1,i1)=a(i2,i2)
              a(i2,i2)=tmp
              do i=1,i2-i1-1
                 tmp=a(i1,i1+i)
                 a(i1,i1+i)=conjg(a(i1+i,i2))
                 a(i1+i,i2)=conjg(tmp)
              end do
               a(i1,i2)=conjg(a(i1,i2))
                ! third swap
                ! - swap row i1 and i2 from i2+1 to n
              do i=i2+1,n
                 tmp=a(i1,i)
                 a(i1,i)=a(i2,i)
                 a(i2,i)=tmp
              end do
             else
               ! lower
               ! first swap
                ! - swap row i1 and i2 from 1 to i1-1
              call stdlib_cswap ( i1-1, a(i1,1), lda, a(i2,1), lda )
               ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap col i1 from i1+1 to i2-1 with row i2 from i1+1 to i2-1
                ! - swap a(i2,i1) and a(i1,i2)
               tmp=a(i1,i1)
               a(i1,i1)=a(i2,i2)
               a(i2,i2)=tmp
               do i=1,i2-i1-1
                  tmp=a(i1+i,i1)
                  a(i1+i,i1)=conjg(a(i2,i1+i))
                  a(i2,i1+i)=conjg(tmp)
               end do
               a(i2,i1)=conjg(a(i2,i1))
               ! third swap
                ! - swap col i1 and i2 from i2+1 to n
               do i=i2+1,n
                  tmp=a(i,i1)
                  a(i,i1)=a(i,i2)
                  a(i,i2)=tmp
               end do
           endif
     end subroutine stdlib_cheswapr


     pure subroutine stdlib_chetf2( uplo, n, a, lda, ipiv, info )
     !! CHETF2 computes the factorization of a complex Hermitian matrix A
     !! using the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**H  or  A = L*D*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**H is the conjugate transpose of U, and D is
     !! Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kk, kp, kstep
           real(sp) :: absakk, alpha, colmax, d, d11, d22, r1, rowmax, tt
           complex(sp) :: d12, d21, t, wk, wkm1, wkp1, zdum
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,conjg,max,real,sqrt
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETF2', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 90
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) .or. stdlib_sisnan(absakk) ) then
                 ! column k is or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=sp)
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_icamax( k-imax, a( imax, imax+1 ), lda )
                    rowmax = cabs1( a( imax, jmax ) )
                    if( imax>1 ) then
                       jmax = stdlib_icamax( imax-1, a( 1, imax ), 1 )
                       rowmax = max( rowmax, cabs1( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( real( a( imax, imax ),KIND=sp) )>=alpha*rowmax )then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_cswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    do j = kp + 1, kk - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    r1 = real( a( kk, kk ),KIND=sp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=sp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       a( k, k ) = real( a( k, k ),KIND=sp)
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 else
                    a( k, k ) = real( a( k, k ),KIND=sp)
                    if( kstep==2 )a( k-1, k-1 ) = real( a( k-1, k-1 ),KIND=sp)
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**h = a - w(k)*1/d(k)*w(k)**h
                    r1 = one / real( a( k, k ),KIND=sp)
                    call stdlib_cher( uplo, k-1, -r1, a( 1, k ), 1, a, lda )
                    ! store u(k) in column k
                    call stdlib_csscal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**h
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**h
                    if( k>2 ) then
                       d = stdlib_slapy2( real( a( k-1, k ),KIND=sp),aimag( a( k-1, k ) ) )
                                 
                       d22 = real( a( k-1, k-1 ),KIND=sp) / d
                       d11 = real( a( k, k ),KIND=sp) / d
                       tt = one / ( d11*d22-one )
                       d12 = a( k-1, k ) / d
                       d = tt / d
                       do j = k - 2, 1, -1
                          wkm1 = d*( d11*a( j, k-1 )-conjg( d12 )*a( j, k ) )
                          wk = d*( d22*a( j, k )-d12*a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - a( i, k )*conjg( wk ) -a( i, k-1 )*conjg( &
                                       wkm1 )
                          end do
                          a( j, k ) = wk
                          a( j, k-1 ) = wkm1
                          a( j, j ) = cmplx( real( a( j, j ),KIND=sp), zero,KIND=sp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              50 continue
              ! if k > n, exit from loop
              if( k>n )go to 90
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) .or. stdlib_sisnan(absakk) ) then
                 ! column k is zero or underflow, contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=sp)
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_icamax( imax-k, a( imax, k ), lda )
                    rowmax = cabs1( a( imax, jmax ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_icamax( n-imax, a( imax+1, imax ), 1 )
                       rowmax = max( rowmax, cabs1( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( real( a( imax, imax ),KIND=sp) )>=alpha*rowmax )then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    do j = kk + 1, kp - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    r1 = real( a( kk, kk ),KIND=sp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=sp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       a( k, k ) = real( a( k, k ),KIND=sp)
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 else
                    a( k, k ) = real( a( k, k ),KIND=sp)
                    if( kstep==2 )a( k+1, k+1 ) = real( a( k+1, k+1 ),KIND=sp)
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**h = a - w(k)*(1/d(k))*w(k)**h
                       r1 = one / real( a( k, k ),KIND=sp)
                       call stdlib_cher( uplo, n-k, -r1, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                 
                       ! store l(k) in column k
                       call stdlib_csscal( n-k, r1, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k)
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**h
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**h
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d = stdlib_slapy2( real( a( k+1, k ),KIND=sp),aimag( a( k+1, k ) ) )
                                 
                       d11 = real( a( k+1, k+1 ),KIND=sp) / d
                       d22 = real( a( k, k ),KIND=sp) / d
                       tt = one / ( d11*d22-one )
                       d21 = a( k+1, k ) / d
                       d =  tt / d
                       do j = k + 2, n
                          wk = d*( d11*a( j, k )-d21*a( j, k+1 ) )
                          wkp1 = d*( d22*a( j, k+1 )-conjg( d21 )*a( j, k ) )
                          do i = j, n
                             a( i, j ) = a( i, j ) - a( i, k )*conjg( wk ) -a( i, k+1 )*conjg( &
                                       wkp1 )
                          end do
                          a( j, k ) = wk
                          a( j, k+1 ) = wkp1
                          a( j, j ) = cmplx( real( a( j, j ),KIND=sp), zero,KIND=sp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 50
           end if
           90 continue
           return
     end subroutine stdlib_chetf2


     pure subroutine stdlib_chetf2_rk( uplo, n, a, lda, e, ipiv, info )
     !! CHETF2_RK computes the factorization of a complex Hermitian matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: e(*)
        ! ======================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: done, upper
           integer(ilp) :: i, ii, imax, itemp, j, jmax, k, kk, kp, kstep, p
           real(sp) :: absakk, alpha, colmax, d, d11, d22, r1, stemp, rowmax, tt, sfmin
           complex(sp) :: d12, d21, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,conjg,max,real,sqrt
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETF2_RK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = czero
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 34
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=sp)
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = czero
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_icamax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_icamax( imax-1, a( 1, imax ), 1 )
                          stemp = cabs1( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=sp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( a( imax, imax ),KIND=sp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 12
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! for only a 2x2 pivot, interchange rows and columns k and p
                 ! in the leading submatrix a(1:k,1:k)
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! (1) swap columnar parts
                    if( p>1 )call stdlib_cswap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = p + 1, k - 1
                       t = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( p, j ) )
                       a( p, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( p, k ) = conjg( a( p, k ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( k, k ),KIND=sp)
                    a( k, k ) = real( a( p, p ),KIND=sp)
                    a( p, p ) = r1
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_cswap( n-k, a( k, k+1 ), lda, a( p, k+1 ), lda )
                 end if
                 ! for both 1x1 and 2x2 pivots, interchange rows and
                 ! columns kk and kp in the leading submatrix a(1:k,1:k)
                 if( kp/=kk ) then
                    ! (1) swap columnar parts
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = kp + 1, kk - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( kk, kk ),KIND=sp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=sp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       ! (*) make sure that diagonal element of pivot is real
                       a( k, k ) = real( a( k, k ),KIND=sp)
                       ! (5) swap row elements
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_cswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                 else
                    ! (*) make sure that diagonal element of pivot is real
                    a( k, k ) = real( a( k, k ),KIND=sp)
                    if( kstep==2 )a( k-1, k-1 ) = real( a( k-1, k-1 ),KIND=sp)
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( abs( real( a( k, k ),KIND=sp) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = one / real( a( k, k ),KIND=sp)
                          call stdlib_cher( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_csscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = real( a( k, k ),KIND=sp)
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_cher( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       ! d = |a12|
                       d = stdlib_slapy2( real( a( k-1, k ),KIND=sp),aimag( a( k-1, k ) ) )
                                 
                       d11 = real( a( k, k ) / d,KIND=sp)
                       d22 = real( a( k-1, k-1 ) / d,KIND=sp)
                       d12 = a( k-1, k ) / d
                       tt = one / ( d11*d22-one )
                       do j = k - 2, 1, -1
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wkm1 = tt*( d11*a( j, k-1 )-conjg( d12 )*a( j, k ) )
                          wk = tt*( d22*a( j, k )-d12*a( j, k-1 ) )
                          ! perform a rank-2 update of a(1:k-2,1:k-2)
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) -( a( i, k ) / d )*conjg( wk ) -( a( i, k-1 ) &
                                       / d )*conjg( wkm1 )
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d
                          a( j, k-1 ) = wkm1 / d
                          ! (*) make sure that diagonal element of pivot is real
                          a( j, j ) = cmplx( real( a( j, j ),KIND=sp), zero,KIND=sp)
                       end do
                    end if
                    ! copy superdiagonal elements of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    e( k ) = a( k-1, k )
                    e( k-1 ) = czero
                    a( k-1, k ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              34 continue
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = czero
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 64
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=sp)
                 ! set e( k ) to zero
                 if( k<n )e( k ) = czero
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_icamax( imax-k, a( imax, k ), lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_icamax( n-imax, a( imax+1, imax ),1 )
                          stemp = cabs1( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=sp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( a( imax, imax ),KIND=sp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 42
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! for only a 2x2 pivot, interchange rows and columns k and p
                 ! in the trailing submatrix a(k:n,k:n)
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! (1) swap columnar parts
                    if( p<n )call stdlib_cswap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = k + 1, p - 1
                       t = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( p, j ) )
                       a( p, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( p, k ) = conjg( a( p, k ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( k, k ),KIND=sp)
                    a( k, k ) = real( a( p, p ),KIND=sp)
                    a( p, p ) = r1
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_cswap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                 end if
                 ! for both 1x1 and 2x2 pivots, interchange rows and
                 ! columns kk and kp in the trailing submatrix a(k:n,k:n)
                 if( kp/=kk ) then
                    ! (1) swap columnar parts
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! (2) swap and conjugate middle parts
                    do j = kk + 1, kp - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( kk, kk ),KIND=sp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=sp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       ! (*) make sure that diagonal element of pivot is real
                       a( k, k ) = real( a( k, k ),KIND=sp)
                       ! (5) swap row elements
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_cswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                 else
                    ! (*) make sure that diagonal element of pivot is real
                    a( k, k ) = real( a( k, k ),KIND=sp)
                    if( kstep==2 )a( k+1, k+1 ) = real( a( k+1, k+1 ),KIND=sp)
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of a now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) and
                       ! store l(k) in column k
                       ! handle division by a small number
                       if( abs( real( a( k, k ),KIND=sp) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = one / real( a( k, k ),KIND=sp)
                          call stdlib_cher( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_csscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = real( a( k, k ),KIND=sp)
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_cher( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       ! d = |a21|
                       d = stdlib_slapy2( real( a( k+1, k ),KIND=sp),aimag( a( k+1, k ) ) )
                                 
                       d11 = real( a( k+1, k+1 ),KIND=sp) / d
                       d22 = real( a( k, k ),KIND=sp) / d
                       d21 = a( k+1, k ) / d
                       tt = one / ( d11*d22-one )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = tt*( d11*a( j, k )-d21*a( j, k+1 ) )
                          wkp1 = tt*( d22*a( j, k+1 )-conjg( d21 )*a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) -( a( i, k ) / d )*conjg( wk ) -( a( i, k+1 ) &
                                       / d )*conjg( wkp1 )
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d
                          a( j, k+1 ) = wkp1 / d
                          ! (*) make sure that diagonal element of pivot is real
                          a( j, j ) = cmplx( real( a( j, j ),KIND=sp), zero,KIND=sp)
                       end do
                    end if
                    ! copy subdiagonal elements of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    e( k ) = a( k+1, k )
                    e( k+1 ) = czero
                    a( k+1, k ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
              64 continue
           end if
           return
     end subroutine stdlib_chetf2_rk


     pure subroutine stdlib_chetf2_rook( uplo, n, a, lda, ipiv, info )
     !! CHETF2_ROOK computes the factorization of a complex Hermitian matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
     !! A = U*D*U**H  or  A = L*D*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**H is the conjugate transpose of U, and D is
     !! Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! ======================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           ! Local Scalars 
           logical(lk) :: done, upper
           integer(ilp) :: i, ii, imax, itemp, j, jmax, k, kk, kp, kstep, p
           real(sp) :: absakk, alpha, colmax, d, d11, d22, r1, stemp, rowmax, tt, sfmin
           complex(sp) :: d12, d21, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,conjg,max,real,sqrt
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETF2_ROOK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=sp)
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_icamax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_icamax( imax-1, a( 1, imax ), 1 )
                          stemp = cabs1( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=sp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( a( imax, imax ),KIND=sp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 12
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! for only a 2x2 pivot, interchange rows and columns k and p
                 ! in the leading submatrix a(1:k,1:k)
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! (1) swap columnar parts
                    if( p>1 )call stdlib_cswap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = p + 1, k - 1
                       t = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( p, j ) )
                       a( p, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( p, k ) = conjg( a( p, k ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( k, k ),KIND=sp)
                    a( k, k ) = real( a( p, p ),KIND=sp)
                    a( p, p ) = r1
                 end if
                 ! for both 1x1 and 2x2 pivots, interchange rows and
                 ! columns kk and kp in the leading submatrix a(1:k,1:k)
                 if( kp/=kk ) then
                    ! (1) swap columnar parts
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = kp + 1, kk - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( kk, kk ),KIND=sp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=sp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       ! (*) make sure that diagonal element of pivot is real
                       a( k, k ) = real( a( k, k ),KIND=sp)
                       ! (5) swap row elements
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 else
                    ! (*) make sure that diagonal element of pivot is real
                    a( k, k ) = real( a( k, k ),KIND=sp)
                    if( kstep==2 )a( k-1, k-1 ) = real( a( k-1, k-1 ),KIND=sp)
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( abs( real( a( k, k ),KIND=sp) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = one / real( a( k, k ),KIND=sp)
                          call stdlib_cher( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_csscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = real( a( k, k ),KIND=sp)
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_cher( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       ! d = |a12|
                       d = stdlib_slapy2( real( a( k-1, k ),KIND=sp),aimag( a( k-1, k ) ) )
                                 
                       d11 = real( a( k, k ) / d,KIND=sp)
                       d22 = real( a( k-1, k-1 ) / d,KIND=sp)
                       d12 = a( k-1, k ) / d
                       tt = one / ( d11*d22-one )
                       do j = k - 2, 1, -1
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wkm1 = tt*( d11*a( j, k-1 )-conjg( d12 )*a( j, k ) )
                          wk = tt*( d22*a( j, k )-d12*a( j, k-1 ) )
                          ! perform a rank-2 update of a(1:k-2,1:k-2)
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) -( a( i, k ) / d )*conjg( wk ) -( a( i, k-1 ) &
                                       / d )*conjg( wkm1 )
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d
                          a( j, k-1 ) = wkm1 / d
                          ! (*) make sure that diagonal element of pivot is real
                          a( j, j ) = cmplx( real( a( j, j ),KIND=sp), zero,KIND=sp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=sp)
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_icamax( imax-k, a( imax, k ), lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_icamax( n-imax, a( imax+1, imax ),1 )
                          stemp = cabs1( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=sp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( a( imax, imax ),KIND=sp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 42
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! for only a 2x2 pivot, interchange rows and columns k and p
                 ! in the trailing submatrix a(k:n,k:n)
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! (1) swap columnar parts
                    if( p<n )call stdlib_cswap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = k + 1, p - 1
                       t = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( p, j ) )
                       a( p, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( p, k ) = conjg( a( p, k ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( k, k ),KIND=sp)
                    a( k, k ) = real( a( p, p ),KIND=sp)
                    a( p, p ) = r1
                 end if
                 ! for both 1x1 and 2x2 pivots, interchange rows and
                 ! columns kk and kp in the trailing submatrix a(k:n,k:n)
                 if( kp/=kk ) then
                    ! (1) swap columnar parts
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! (2) swap and conjugate middle parts
                    do j = kk + 1, kp - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( kk, kk ),KIND=sp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=sp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       ! (*) make sure that diagonal element of pivot is real
                       a( k, k ) = real( a( k, k ),KIND=sp)
                       ! (5) swap row elements
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 else
                    ! (*) make sure that diagonal element of pivot is real
                    a( k, k ) = real( a( k, k ),KIND=sp)
                    if( kstep==2 )a( k+1, k+1 ) = real( a( k+1, k+1 ),KIND=sp)
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of a now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) and
                       ! store l(k) in column k
                       ! handle division by a small number
                       if( abs( real( a( k, k ),KIND=sp) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = one / real( a( k, k ),KIND=sp)
                          call stdlib_cher( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_csscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = real( a( k, k ),KIND=sp)
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_cher( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       ! d = |a21|
                       d = stdlib_slapy2( real( a( k+1, k ),KIND=sp),aimag( a( k+1, k ) ) )
                                 
                       d11 = real( a( k+1, k+1 ),KIND=sp) / d
                       d22 = real( a( k, k ),KIND=sp) / d
                       d21 = a( k+1, k ) / d
                       tt = one / ( d11*d22-one )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = tt*( d11*a( j, k )-d21*a( j, k+1 ) )
                          wkp1 = tt*( d22*a( j, k+1 )-conjg( d21 )*a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) -( a( i, k ) / d )*conjg( wk ) -( a( i, k+1 ) &
                                       / d )*conjg( wkp1 )
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d
                          a( j, k+1 ) = wkp1 / d
                          ! (*) make sure that diagonal element of pivot is real
                          a( j, j ) = cmplx( real( a( j, j ),KIND=sp), zero,KIND=sp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_chetf2_rook


     pure subroutine stdlib_chetri( uplo, n, a, lda, ipiv, work, info )
     !! CHETRI computes the inverse of a complex Hermitian indefinite matrix
     !! A using the factorization A = U*D*U**H or A = L*D*L**H computed by
     !! CHETRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp, kstep
           real(sp) :: ak, akp1, d, t
           complex(sp) :: akkp1, temp
           ! Intrinsic Functions 
           intrinsic :: abs,conjg,max,real
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / real( a( k, k ),KIND=sp)
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_chemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - real( stdlib_cdotc( k-1, work, 1, a( 1,k ), 1 ),&
                              KIND=sp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k+1 ) )
                 ak = real( a( k, k ),KIND=sp) / t
                 akp1 = real( a( k+1, k+1 ),KIND=sp) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-one )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_chemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - real( stdlib_cdotc( k-1, work, 1, a( 1,k ), 1 ),&
                              KIND=sp)
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_cdotc( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_ccopy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_chemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -real( stdlib_cdotc( k-1, work, 1, a( 1, k+1 ),&
                              1 ),KIND=sp)
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 call stdlib_cswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                 do j = kp + 1, k - 1
                    temp = conjg( a( j, k ) )
                    a( j, k ) = conjg( a( kp, j ) )
                    a( kp, j ) = temp
                 end do
                 a( kp, k ) = conjg( a( kp, k ) )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
              end if
              k = k + kstep
              go to 30
              50 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              60 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / real( a( k, k ),KIND=sp)
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_chemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - real( stdlib_cdotc( n-k, work, 1,a( k+1, k ), 1 ),&
                              KIND=sp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k-1 ) )
                 ak = real( a( k-1, k-1 ),KIND=sp) / t
                 akp1 = real( a( k, k ),KIND=sp) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-one )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_chemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - real( stdlib_cdotc( n-k, work, 1,a( k+1, k ), 1 ),&
                              KIND=sp)
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_cdotc( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 &
                              )
                    call stdlib_ccopy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_chemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -real( stdlib_cdotc( n-k, work, 1, a( k+1, k-1 )&
                              ,1 ),KIND=sp)
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 if( kp<n )call stdlib_cswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                 do j = k + 1, kp - 1
                    temp = conjg( a( j, k ) )
                    a( j, k ) = conjg( a( kp, j ) )
                    a( kp, j ) = temp
                 end do
                 a( kp, k ) = conjg( a( kp, k ) )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
              end if
              k = k - kstep
              go to 60
              80 continue
           end if
           return
     end subroutine stdlib_chetri


     pure subroutine stdlib_chetri_rook( uplo, n, a, lda, ipiv, work, info )
     !! CHETRI_ROOK computes the inverse of a complex Hermitian indefinite matrix
     !! A using the factorization A = U*D*U**H or A = L*D*L**H computed by
     !! CHETRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp, kstep
           real(sp) :: ak, akp1, d, t
           complex(sp) :: akkp1, temp
           ! Intrinsic Functions 
           intrinsic :: abs,conjg,max,real
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRI_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 70
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / real( a( k, k ),KIND=sp)
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_chemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - real( stdlib_cdotc( k-1, work, 1, a( 1,k ), 1 ),&
                              KIND=sp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k+1 ) )
                 ak = real( a( k, k ),KIND=sp) / t
                 akp1 = real( a( k+1, k+1 ),KIND=sp) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-one )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_chemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - real( stdlib_cdotc( k-1, work, 1, a( 1,k ), 1 ),&
                              KIND=sp)
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_cdotc( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_ccopy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_chemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -real( stdlib_cdotc( k-1, work, 1, a( 1, k+1 ),&
                              1 ),KIND=sp)
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the leading
                 ! submatrix a(1:k,1:k)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    do j = kp + 1, k - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k+1 with -ipiv(k) and
                 ! -ipiv(k+1) in the leading submatrix a(k+1:n,k+1:n)
                 ! (1) interchange rows and columns k and -ipiv(k)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    do j = kp + 1, k - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
                 ! (2) interchange rows and columns k+1 and -ipiv(k+1)
                 k = k + 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    do j = kp + 1, k - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k + 1
              go to 30
              70 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**h.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              80 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 120
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / real( a( k, k ),KIND=sp)
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_chemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - real( stdlib_cdotc( n-k, work, 1,a( k+1, k ), 1 ),&
                              KIND=sp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k-1 ) )
                 ak = real( a( k-1, k-1 ),KIND=sp) / t
                 akp1 = real( a( k, k ),KIND=sp) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-one )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_chemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - real( stdlib_cdotc( n-k, work, 1,a( k+1, k ), 1 ),&
                              KIND=sp)
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_cdotc( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 &
                              )
                    call stdlib_ccopy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_chemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -real( stdlib_cdotc( n-k, work, 1, a( k+1, k-1 )&
                              ,1 ),KIND=sp)
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the trailing
                 ! submatrix a(k:n,k:n)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    do j = k + 1, kp - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k-1 with -ipiv(k) and
                 ! -ipiv(k-1) in the trailing submatrix a(k-1:n,k-1:n)
                 ! (1) interchange rows and columns k and -ipiv(k)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    do j = k + 1, kp - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
                 ! (2) interchange rows and columns k-1 and -ipiv(k-1)
                 k = k - 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    do j = k + 1, kp - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k - 1
              go to 80
              120 continue
           end if
           return
     end subroutine stdlib_chetri_rook


     pure subroutine stdlib_chetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
     !! CHETRS_3 solves a system of linear equations A * X = B with a complex
     !! Hermitian matrix A using the factorization computed
     !! by CHETRF_RK or CHETRF_BK:
     !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This algorithm is using Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*), e(*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j, k, kp
           real(sp) :: s
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           intrinsic :: abs,conjg,max,real
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRS_3', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! begin upper
              ! solve a*x = b, where a = u*d*u**h.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
              call stdlib_ctrsm( 'L', 'U', 'N', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i = n
              do while ( i>=1 )
                 if( ipiv( i )>0 ) then
                    s = real( cone,KIND=sp) / real( a( i, i ),KIND=sp)
                    call stdlib_csscal( nrhs, s, b( i, 1 ), ldb )
                 else if ( i>1 ) then
                    akm1k = e( i )
                    akm1 = a( i-1, i-1 ) / akm1k
                    ak = a( i, i ) / conjg( akm1k )
                    denom = akm1*ak - cone
                    do j = 1, nrhs
                       bkm1 = b( i-1, j ) / akm1k
                       bk = b( i, j ) / conjg( akm1k )
                       b( i-1, j ) = ( ak*bkm1-bk ) / denom
                       b( i, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i - 1
                 end if
                 i = i - 1
              end do
              ! compute (u**h \ b) -> b   [ u**h \ (d \ (u \p**t * b) ) ]
              call stdlib_ctrsm( 'L', 'U', 'C', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! p * b  [ p * (u**h \ (d \ (u \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
           else
              ! begin lower
              ! solve a*x = b, where a = l*d*l**h.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
              call stdlib_ctrsm( 'L', 'L', 'N', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i = 1
              do while ( i<=n )
                 if( ipiv( i )>0 ) then
                    s = real( cone,KIND=sp) / real( a( i, i ),KIND=sp)
                    call stdlib_csscal( nrhs, s, b( i, 1 ), ldb )
                 else if( i<n ) then
                    akm1k = e( i )
                    akm1 = a( i, i ) / conjg( akm1k )
                    ak = a( i+1, i+1 ) / akm1k
                    denom = akm1*ak - cone
                    do  j = 1, nrhs
                       bkm1 = b( i, j ) / conjg( akm1k )
                       bk = b( i+1, j ) / akm1k
                       b( i, j ) = ( ak*bkm1-bk ) / denom
                       b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i + 1
                 end if
                 i = i + 1
              end do
              ! compute (l**h \ b) -> b   [ l**h \ (d \ (l \p**t * b) ) ]
              call stdlib_ctrsm('L', 'L', 'C', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! p * b  [ p * (l**h \ (d \ (l \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! end lower
           end if
           return
     end subroutine stdlib_chetrs_3


     pure subroutine stdlib_chfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,c )
     !! Level 3 BLAS like routine for C in RFP Format.
     !! CHFRK performs one of the Hermitian rank--k operations
     !! C := alpha*A*A**H + beta*C,
     !! or
     !! C := alpha*A**H*A + beta*C,
     !! where alpha and beta are real scalars, C is an n--by--n Hermitian
     !! matrix and A is an n--by--k matrix in the first case and a k--by--n
     !! matrix in the second case.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, n
           character, intent(in) :: trans, transr, uplo
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: c(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lower, normaltransr, nisodd, notrans
           integer(ilp) :: info, nrowa, j, nk, n1, n2
           complex(sp) :: calpha, cbeta
           ! Intrinsic Functions 
           intrinsic :: max,cmplx
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           notrans = stdlib_lsame( trans, 'N' )
           if( notrans ) then
              nrowa = n
           else
              nrowa = k
           end if
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'C' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( .not.notrans .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 ) then
              info = -5
           else if( lda<max( 1, nrowa ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHFRK ', -info )
              return
           end if
           ! quick return if possible.
           ! the quick return case: ((alpha==0).and.(beta/=zero)) is not
           ! done (it is in stdlib_cherk for example) and left in the general case.
           if( ( n==0 ) .or. ( ( ( alpha==zero ) .or. ( k==0 ) ) .and.( beta==one ) ) )&
                     return
           if( ( alpha==zero ) .and. ( beta==zero ) ) then
              do j = 1, ( ( n*( n+1 ) ) / 2 )
                 c( j ) = czero
              end do
              return
           end if
           calpha = cmplx( alpha, zero,KIND=sp)
           cbeta = cmplx( beta, zero,KIND=sp)
           ! c is n-by-n.
           ! if n is odd, set nisodd = .true., and n1 and n2.
           ! if n is even, nisodd = .false., and nk.
           if( mod( n, 2 )==0 ) then
              nisodd = .false.
              nk = n / 2
           else
              nisodd = .true.
              if( lower ) then
                 n2 = n / 2
                 n1 = n - n2
              else
                 n1 = n / 2
                 n2 = n - n1
              end if
           end if
           if( nisodd ) then
              ! n is odd
              if( normaltransr ) then
                 ! n is odd and transr = 'n'
                 if( lower ) then
                    ! n is odd, transr = 'n', and uplo = 'l'
                    if( notrans ) then
                       ! n is odd, transr = 'n', uplo = 'l', and trans = 'n'
                       call stdlib_cherk( 'L', 'N', n1, k, alpha, a( 1, 1 ), lda,beta, c( 1 ), n )
                                 
                       call stdlib_cherk( 'U', 'N', n2, k, alpha, a( n1+1, 1 ), lda,beta, c( n+1 )&
                                 , n )
                       call stdlib_cgemm( 'N', 'C', n2, n1, k, calpha, a( n1+1, 1 ),lda, a( 1, 1 )&
                                 , lda, cbeta, c( n1+1 ), n )
                    else
                       ! n is odd, transr = 'n', uplo = 'l', and trans = 'c'
                       call stdlib_cherk( 'L', 'C', n1, k, alpha, a( 1, 1 ), lda,beta, c( 1 ), n )
                                 
                       call stdlib_cherk( 'U', 'C', n2, k, alpha, a( 1, n1+1 ), lda,beta, c( n+1 )&
                                 , n )
                       call stdlib_cgemm( 'C', 'N', n2, n1, k, calpha, a( 1, n1+1 ),lda, a( 1, 1 )&
                                 , lda, cbeta, c( n1+1 ), n )
                    end if
                 else
                    ! n is odd, transr = 'n', and uplo = 'u'
                    if( notrans ) then
                       ! n is odd, transr = 'n', uplo = 'u', and trans = 'n'
                       call stdlib_cherk( 'L', 'N', n1, k, alpha, a( 1, 1 ), lda,beta, c( n2+1 ), &
                                 n )
                       call stdlib_cherk( 'U', 'N', n2, k, alpha, a( n2, 1 ), lda,beta, c( n1+1 ),&
                                  n )
                       call stdlib_cgemm( 'N', 'C', n1, n2, k, calpha, a( 1, 1 ),lda, a( n2, 1 ), &
                                 lda, cbeta, c( 1 ), n )
                    else
                       ! n is odd, transr = 'n', uplo = 'u', and trans = 'c'
                       call stdlib_cherk( 'L', 'C', n1, k, alpha, a( 1, 1 ), lda,beta, c( n2+1 ), &
                                 n )
                       call stdlib_cherk( 'U', 'C', n2, k, alpha, a( 1, n2 ), lda,beta, c( n1+1 ),&
                                  n )
                       call stdlib_cgemm( 'C', 'N', n1, n2, k, calpha, a( 1, 1 ),lda, a( 1, n2 ), &
                                 lda, cbeta, c( 1 ), n )
                    end if
                 end if
              else
                 ! n is odd, and transr = 'c'
                 if( lower ) then
                    ! n is odd, transr = 'c', and uplo = 'l'
                    if( notrans ) then
                       ! n is odd, transr = 'c', uplo = 'l', and trans = 'n'
                       call stdlib_cherk( 'U', 'N', n1, k, alpha, a( 1, 1 ), lda,beta, c( 1 ), n1 &
                                 )
                       call stdlib_cherk( 'L', 'N', n2, k, alpha, a( n1+1, 1 ), lda,beta, c( 2 ), &
                                 n1 )
                       call stdlib_cgemm( 'N', 'C', n1, n2, k, calpha, a( 1, 1 ),lda, a( n1+1, 1 )&
                                 , lda, cbeta,c( n1*n1+1 ), n1 )
                    else
                       ! n is odd, transr = 'c', uplo = 'l', and trans = 'c'
                       call stdlib_cherk( 'U', 'C', n1, k, alpha, a( 1, 1 ), lda,beta, c( 1 ), n1 &
                                 )
                       call stdlib_cherk( 'L', 'C', n2, k, alpha, a( 1, n1+1 ), lda,beta, c( 2 ), &
                                 n1 )
                       call stdlib_cgemm( 'C', 'N', n1, n2, k, calpha, a( 1, 1 ),lda, a( 1, n1+1 )&
                                 , lda, cbeta,c( n1*n1+1 ), n1 )
                    end if
                 else
                    ! n is odd, transr = 'c', and uplo = 'u'
                    if( notrans ) then
                       ! n is odd, transr = 'c', uplo = 'u', and trans = 'n'
                       call stdlib_cherk( 'U', 'N', n1, k, alpha, a( 1, 1 ), lda,beta, c( n2*n2+1 &
                                 ), n2 )
                       call stdlib_cherk( 'L', 'N', n2, k, alpha, a( n1+1, 1 ), lda,beta, c( &
                                 n1*n2+1 ), n2 )
                       call stdlib_cgemm( 'N', 'C', n2, n1, k, calpha, a( n1+1, 1 ),lda, a( 1, 1 )&
                                 , lda, cbeta, c( 1 ), n2 )
                    else
                       ! n is odd, transr = 'c', uplo = 'u', and trans = 'c'
                       call stdlib_cherk( 'U', 'C', n1, k, alpha, a( 1, 1 ), lda,beta, c( n2*n2+1 &
                                 ), n2 )
                       call stdlib_cherk( 'L', 'C', n2, k, alpha, a( 1, n1+1 ), lda,beta, c( &
                                 n1*n2+1 ), n2 )
                       call stdlib_cgemm( 'C', 'N', n2, n1, k, calpha, a( 1, n1+1 ),lda, a( 1, 1 )&
                                 , lda, cbeta, c( 1 ), n2 )
                    end if
                 end if
              end if
           else
              ! n is even
              if( normaltransr ) then
                 ! n is even and transr = 'n'
                 if( lower ) then
                    ! n is even, transr = 'n', and uplo = 'l'
                    if( notrans ) then
                       ! n is even, transr = 'n', uplo = 'l', and trans = 'n'
                       call stdlib_cherk( 'L', 'N', nk, k, alpha, a( 1, 1 ), lda,beta, c( 2 ), n+&
                                 1 )
                       call stdlib_cherk( 'U', 'N', nk, k, alpha, a( nk+1, 1 ), lda,beta, c( 1 ), &
                                 n+1 )
                       call stdlib_cgemm( 'N', 'C', nk, nk, k, calpha, a( nk+1, 1 ),lda, a( 1, 1 )&
                                 , lda, cbeta, c( nk+2 ),n+1 )
                    else
                       ! n is even, transr = 'n', uplo = 'l', and trans = 'c'
                       call stdlib_cherk( 'L', 'C', nk, k, alpha, a( 1, 1 ), lda,beta, c( 2 ), n+&
                                 1 )
                       call stdlib_cherk( 'U', 'C', nk, k, alpha, a( 1, nk+1 ), lda,beta, c( 1 ), &
                                 n+1 )
                       call stdlib_cgemm( 'C', 'N', nk, nk, k, calpha, a( 1, nk+1 ),lda, a( 1, 1 )&
                                 , lda, cbeta, c( nk+2 ),n+1 )
                    end if
                 else
                    ! n is even, transr = 'n', and uplo = 'u'
                    if( notrans ) then
                       ! n is even, transr = 'n', uplo = 'u', and trans = 'n'
                       call stdlib_cherk( 'L', 'N', nk, k, alpha, a( 1, 1 ), lda,beta, c( nk+2 ), &
                                 n+1 )
                       call stdlib_cherk( 'U', 'N', nk, k, alpha, a( nk+1, 1 ), lda,beta, c( nk+1 &
                                 ), n+1 )
                       call stdlib_cgemm( 'N', 'C', nk, nk, k, calpha, a( 1, 1 ),lda, a( nk+1, 1 )&
                                 , lda, cbeta, c( 1 ),n+1 )
                    else
                       ! n is even, transr = 'n', uplo = 'u', and trans = 'c'
                       call stdlib_cherk( 'L', 'C', nk, k, alpha, a( 1, 1 ), lda,beta, c( nk+2 ), &
                                 n+1 )
                       call stdlib_cherk( 'U', 'C', nk, k, alpha, a( 1, nk+1 ), lda,beta, c( nk+1 &
                                 ), n+1 )
                       call stdlib_cgemm( 'C', 'N', nk, nk, k, calpha, a( 1, 1 ),lda, a( 1, nk+1 )&
                                 , lda, cbeta, c( 1 ),n+1 )
                    end if
                 end if
              else
                 ! n is even, and transr = 'c'
                 if( lower ) then
                    ! n is even, transr = 'c', and uplo = 'l'
                    if( notrans ) then
                       ! n is even, transr = 'c', uplo = 'l', and trans = 'n'
                       call stdlib_cherk( 'U', 'N', nk, k, alpha, a( 1, 1 ), lda,beta, c( nk+1 ), &
                                 nk )
                       call stdlib_cherk( 'L', 'N', nk, k, alpha, a( nk+1, 1 ), lda,beta, c( 1 ), &
                                 nk )
                       call stdlib_cgemm( 'N', 'C', nk, nk, k, calpha, a( 1, 1 ),lda, a( nk+1, 1 )&
                                 , lda, cbeta,c( ( ( nk+1 )*nk )+1 ), nk )
                    else
                       ! n is even, transr = 'c', uplo = 'l', and trans = 'c'
                       call stdlib_cherk( 'U', 'C', nk, k, alpha, a( 1, 1 ), lda,beta, c( nk+1 ), &
                                 nk )
                       call stdlib_cherk( 'L', 'C', nk, k, alpha, a( 1, nk+1 ), lda,beta, c( 1 ), &
                                 nk )
                       call stdlib_cgemm( 'C', 'N', nk, nk, k, calpha, a( 1, 1 ),lda, a( 1, nk+1 )&
                                 , lda, cbeta,c( ( ( nk+1 )*nk )+1 ), nk )
                    end if
                 else
                    ! n is even, transr = 'c', and uplo = 'u'
                    if( notrans ) then
                       ! n is even, transr = 'c', uplo = 'u', and trans = 'n'
                       call stdlib_cherk( 'U', 'N', nk, k, alpha, a( 1, 1 ), lda,beta, c( nk*( nk+&
                                 1 )+1 ), nk )
                       call stdlib_cherk( 'L', 'N', nk, k, alpha, a( nk+1, 1 ), lda,beta, c( &
                                 nk*nk+1 ), nk )
                       call stdlib_cgemm( 'N', 'C', nk, nk, k, calpha, a( nk+1, 1 ),lda, a( 1, 1 )&
                                 , lda, cbeta, c( 1 ), nk )
                    else
                       ! n is even, transr = 'c', uplo = 'u', and trans = 'c'
                       call stdlib_cherk( 'U', 'C', nk, k, alpha, a( 1, 1 ), lda,beta, c( nk*( nk+&
                                 1 )+1 ), nk )
                       call stdlib_cherk( 'L', 'C', nk, k, alpha, a( 1, nk+1 ), lda,beta, c( &
                                 nk*nk+1 ), nk )
                       call stdlib_cgemm( 'C', 'N', nk, nk, k, calpha, a( 1, nk+1 ),lda, a( 1, 1 )&
                                 , lda, cbeta, c( 1 ), nk )
                    end if
                 end if
              end if
           end if
           return
     end subroutine stdlib_chfrk


     pure subroutine stdlib_chpgst( itype, uplo, n, ap, bp, info )
     !! CHPGST reduces a complex Hermitian-definite generalized
     !! eigenproblem to standard form, using packed storage.
     !! If ITYPE = 1, the problem is A*x = lambda*B*x,
     !! and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
     !! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
     !! B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.
     !! B must have been previously factorized as U**H*U or L*L**H by CPPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: itype, n
           ! Array Arguments 
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(in) :: bp(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, j1, j1j1, jj, k, k1, k1k1, kk
           real(sp) :: ajj, akk, bjj, bkk
           complex(sp) :: ct
           ! Intrinsic Functions 
           intrinsic :: real
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPGST', -info )
              return
           end if
           if( itype==1 ) then
              if( upper ) then
                 ! compute inv(u**h)*a*inv(u)
                 ! j1 and jj are the indices of a(1,j) and a(j,j)
                 jj = 0
                 do j = 1, n
                    j1 = jj + 1
                    jj = jj + j
                    ! compute the j-th column of the upper triangle of a
                    ap( jj ) = real( ap( jj ),KIND=sp)
                    bjj = real( bp( jj ),KIND=sp)
                    call stdlib_ctpsv( uplo, 'CONJUGATE TRANSPOSE', 'NON-UNIT', j,bp, ap( j1 ), 1 &
                              )
                    call stdlib_chpmv( uplo, j-1, -cone, ap, bp( j1 ), 1, cone,ap( j1 ), 1 )
                              
                    call stdlib_csscal( j-1, one / bjj, ap( j1 ), 1 )
                    ap( jj ) = ( ap( jj )-stdlib_cdotc( j-1, ap( j1 ), 1, bp( j1 ),1 ) ) / &
                              bjj
                 end do
              else
                 ! compute inv(l)*a*inv(l**h)
                 ! kk and k1k1 are the indices of a(k,k) and a(k+1,k+1)
                 kk = 1
                 do k = 1, n
                    k1k1 = kk + n - k + 1
                    ! update the lower triangle of a(k:n,k:n)
                    akk = real( ap( kk ),KIND=sp)
                    bkk = real( bp( kk ),KIND=sp)
                    akk = akk / bkk**2
                    ap( kk ) = akk
                    if( k<n ) then
                       call stdlib_csscal( n-k, one / bkk, ap( kk+1 ), 1 )
                       ct = -half*akk
                       call stdlib_caxpy( n-k, ct, bp( kk+1 ), 1, ap( kk+1 ), 1 )
                       call stdlib_chpr2( uplo, n-k, -cone, ap( kk+1 ), 1,bp( kk+1 ), 1, ap( k1k1 &
                                 ) )
                       call stdlib_caxpy( n-k, ct, bp( kk+1 ), 1, ap( kk+1 ), 1 )
                       call stdlib_ctpsv( uplo, 'NO TRANSPOSE', 'NON-UNIT', n-k,bp( k1k1 ), ap( &
                                 kk+1 ), 1 )
                    end if
                    kk = k1k1
                 end do
              end if
           else
              if( upper ) then
                 ! compute u*a*u**h
                 ! k1 and kk are the indices of a(1,k) and a(k,k)
                 kk = 0
                 do k = 1, n
                    k1 = kk + 1
                    kk = kk + k
                    ! update the upper triangle of a(1:k,1:k)
                    akk = real( ap( kk ),KIND=sp)
                    bkk = real( bp( kk ),KIND=sp)
                    call stdlib_ctpmv( uplo, 'NO TRANSPOSE', 'NON-UNIT', k-1, bp,ap( k1 ), 1 )
                              
                    ct = half*akk
                    call stdlib_caxpy( k-1, ct, bp( k1 ), 1, ap( k1 ), 1 )
                    call stdlib_chpr2( uplo, k-1, cone, ap( k1 ), 1, bp( k1 ), 1,ap )
                    call stdlib_caxpy( k-1, ct, bp( k1 ), 1, ap( k1 ), 1 )
                    call stdlib_csscal( k-1, bkk, ap( k1 ), 1 )
                    ap( kk ) = akk*bkk**2
                 end do
              else
                 ! compute l**h *a*l
                 ! jj and j1j1 are the indices of a(j,j) and a(j+1,j+1)
                 jj = 1
                 do j = 1, n
                    j1j1 = jj + n - j + 1
                    ! compute the j-th column of the lower triangle of a
                    ajj = real( ap( jj ),KIND=sp)
                    bjj = real( bp( jj ),KIND=sp)
                    ap( jj ) = ajj*bjj + stdlib_cdotc( n-j, ap( jj+1 ), 1,bp( jj+1 ), 1 )
                    call stdlib_csscal( n-j, bjj, ap( jj+1 ), 1 )
                    call stdlib_chpmv( uplo, n-j, cone, ap( j1j1 ), bp( jj+1 ), 1,cone, ap( jj+1 )&
                              , 1 )
                    call stdlib_ctpmv( uplo, 'CONJUGATE TRANSPOSE', 'NON-UNIT',n-j+1, bp( jj ), &
                              ap( jj ), 1 )
                    jj = j1j1
                 end do
              end if
           end if
           return
     end subroutine stdlib_chpgst


     pure subroutine stdlib_chptrf( uplo, n, ap, ipiv, info )
     !! CHPTRF computes the factorization of a complex Hermitian packed
     !! matrix A using the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**H  or  A = L*D*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: ap(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kc, kk, knc, kp, kpc, kstep, kx, npp
           real(sp) :: absakk, alpha, colmax, d, d11, d22, r1, rowmax, tt
           complex(sp) :: d12, d21, t, wk, wkm1, wkp1, zdum
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,conjg,max,real,sqrt
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPTRF', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              kc = ( n-1 )*n / 2 + 1
              10 continue
              knc = kc
              ! if k < 1, exit from loop
              if( k<1 )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( ap( kc+k-1 ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, ap( kc ), 1 )
                 colmax = cabs1( ap( kc+imax-1 ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ap( kc+k-1 ) = real( ap( kc+k-1 ),KIND=sp)
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    rowmax = zero
                    jmax = imax
                    kx = imax*( imax+1 ) / 2 + imax
                    do j = imax + 1, k
                       if( cabs1( ap( kx ) )>rowmax ) then
                          rowmax = cabs1( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + j
                    end do
                    kpc = ( imax-1 )*imax / 2 + 1
                    if( imax>1 ) then
                       jmax = stdlib_icamax( imax-1, ap( kpc ), 1 )
                       rowmax = max( rowmax, cabs1( ap( kpc+jmax-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( real( ap( kpc+imax-1 ),KIND=sp) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kstep==2 )knc = knc - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_cswap( kp-1, ap( knc ), 1, ap( kpc ), 1 )
                    kx = kpc + kp - 1
                    do j = kp + 1, kk - 1
                       kx = kx + j - 1
                       t = conjg( ap( knc+j-1 ) )
                       ap( knc+j-1 ) = conjg( ap( kx ) )
                       ap( kx ) = t
                    end do
                    ap( kx+kk-1 ) = conjg( ap( kx+kk-1 ) )
                    r1 = real( ap( knc+kk-1 ),KIND=sp)
                    ap( knc+kk-1 ) = real( ap( kpc+kp-1 ),KIND=sp)
                    ap( kpc+kp-1 ) = r1
                    if( kstep==2 ) then
                       ap( kc+k-1 ) = real( ap( kc+k-1 ),KIND=sp)
                       t = ap( kc+k-2 )
                       ap( kc+k-2 ) = ap( kc+kp-1 )
                       ap( kc+kp-1 ) = t
                    end if
                 else
                    ap( kc+k-1 ) = real( ap( kc+k-1 ),KIND=sp)
                    if( kstep==2 )ap( kc-1 ) = real( ap( kc-1 ),KIND=sp)
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**h = a - w(k)*1/d(k)*w(k)**h
                    r1 = one / real( ap( kc+k-1 ),KIND=sp)
                    call stdlib_chpr( uplo, k-1, -r1, ap( kc ), 1, ap )
                    ! store u(k) in column k
                    call stdlib_csscal( k-1, r1, ap( kc ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**h
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**h
                    if( k>2 ) then
                       d = stdlib_slapy2( real( ap( k-1+( k-1 )*k / 2 ),KIND=sp),aimag( ap( k-1+( &
                                 k-1 )*k / 2 ) ) )
                       d22 = real( ap( k-1+( k-2 )*( k-1 ) / 2 ),KIND=sp) / d
                       d11 = real( ap( k+( k-1 )*k / 2 ),KIND=sp) / d
                       tt = one / ( d11*d22-one )
                       d12 = ap( k-1+( k-1 )*k / 2 ) / d
                       d = tt / d
                       do j = k - 2, 1, -1
                          wkm1 = d*( d11*ap( j+( k-2 )*( k-1 ) / 2 )-conjg( d12 )*ap( j+( k-1 )*k &
                                    / 2 ) )
                          wk = d*( d22*ap( j+( k-1 )*k / 2 )-d12*ap( j+( k-2 )*( k-1 ) / 2 ) )
                                    
                          do i = j, 1, -1
                             ap( i+( j-1 )*j / 2 ) = ap( i+( j-1 )*j / 2 ) -ap( i+( k-1 )*k / 2 )&
                                       *conjg( wk ) -ap( i+( k-2 )*( k-1 ) / 2 )*conjg( wkm1 )
                          end do
                          ap( j+( k-1 )*k / 2 ) = wk
                          ap( j+( k-2 )*( k-1 ) / 2 ) = wkm1
                          ap( j+( j-1 )*j / 2 ) = cmplx( real( ap( j+( j-1 )*j / 2 ),KIND=sp), &
                                    zero,KIND=sp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              kc = knc - k
              go to 10
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              kc = 1
              npp = n*( n+1 ) / 2
              60 continue
              knc = kc
              ! if k > n, exit from loop
              if( k>n )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( ap( kc ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, ap( kc+1 ), 1 )
                 colmax = cabs1( ap( kc+imax-k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ap( kc ) = real( ap( kc ),KIND=sp)
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    rowmax = zero
                    kx = kc + imax - k
                    do j = k, imax - 1
                       if( cabs1( ap( kx ) )>rowmax ) then
                          rowmax = cabs1( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + n - j
                    end do
                    kpc = npp - ( n-imax+1 )*( n-imax+2 ) / 2 + 1
                    if( imax<n ) then
                       jmax = imax + stdlib_icamax( n-imax, ap( kpc+1 ), 1 )
                       rowmax = max( rowmax, cabs1( ap( kpc+jmax-imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( real( ap( kpc ),KIND=sp) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kstep==2 )knc = knc + n - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_cswap( n-kp, ap( knc+kp-kk+1 ), 1, ap( kpc+1 ),1 )
                              
                    kx = knc + kp - kk
                    do j = kk + 1, kp - 1
                       kx = kx + n - j + 1
                       t = conjg( ap( knc+j-kk ) )
                       ap( knc+j-kk ) = conjg( ap( kx ) )
                       ap( kx ) = t
                    end do
                    ap( knc+kp-kk ) = conjg( ap( knc+kp-kk ) )
                    r1 = real( ap( knc ),KIND=sp)
                    ap( knc ) = real( ap( kpc ),KIND=sp)
                    ap( kpc ) = r1
                    if( kstep==2 ) then
                       ap( kc ) = real( ap( kc ),KIND=sp)
                       t = ap( kc+1 )
                       ap( kc+1 ) = ap( kc+kp-k )
                       ap( kc+kp-k ) = t
                    end if
                 else
                    ap( kc ) = real( ap( kc ),KIND=sp)
                    if( kstep==2 )ap( knc ) = real( ap( knc ),KIND=sp)
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**h = a - w(k)*(1/d(k))*w(k)**h
                       r1 = one / real( ap( kc ),KIND=sp)
                       call stdlib_chpr( uplo, n-k, -r1, ap( kc+1 ), 1,ap( kc+n-k+1 ) )
                       ! store l(k) in column k
                       call stdlib_csscal( n-k, r1, ap( kc+1 ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**h
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**h
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d = stdlib_slapy2( real( ap( k+1+( k-1 )*( 2*n-k ) / 2 ),KIND=sp),aimag( &
                                 ap( k+1+( k-1 )*( 2*n-k ) / 2 ) ) )
                       d11 = real( ap( k+1+k*( 2*n-k-1 ) / 2 ),KIND=sp) / d
                       d22 = real( ap( k+( k-1 )*( 2*n-k ) / 2 ),KIND=sp) / d
                       tt = one / ( d11*d22-one )
                       d21 = ap( k+1+( k-1 )*( 2*n-k ) / 2 ) / d
                       d = tt / d
                       do j = k + 2, n
                          wk = d*( d11*ap( j+( k-1 )*( 2*n-k ) / 2 )-d21*ap( j+k*( 2*n-k-1 ) / 2 )&
                                     )
                          wkp1 = d*( d22*ap( j+k*( 2*n-k-1 ) / 2 )-conjg( d21 )*ap( j+( k-1 )*( &
                                    2*n-k ) / 2 ) )
                          do i = j, n
                             ap( i+( j-1 )*( 2*n-j ) / 2 ) = ap( i+( j-1 )*( 2*n-j ) / 2 ) - ap( &
                             i+( k-1 )*( 2*n-k ) /2 )*conjg( wk ) - ap( i+k*( 2*n-k-1 ) / 2 )&
                                       *conjg( wkp1 )
                          end do
                          ap( j+( k-1 )*( 2*n-k ) / 2 ) = wk
                          ap( j+k*( 2*n-k-1 ) / 2 ) = wkp1
                          ap( j+( j-1 )*( 2*n-j ) / 2 )= cmplx( real( ap( j+( j-1 )*( 2*n-j ) / 2 &
                                    ),KIND=sp),zero,KIND=sp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              kc = knc + n - k + 2
              go to 60
           end if
           110 continue
           return
     end subroutine stdlib_chptrf


     pure subroutine stdlib_chptri( uplo, n, ap, ipiv, work, info )
     !! CHPTRI computes the inverse of a complex Hermitian indefinite matrix
     !! A in packed storage using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by CHPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kcnext, kp, kpc, kstep, kx, npp
           real(sp) :: ak, akp1, d, t
           complex(sp) :: akkp1, temp
           ! Intrinsic Functions 
           intrinsic :: abs,conjg,real
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              kp = n*( n+1 ) / 2
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. ap( kp )==czero )return
                 kp = kp - info
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              kp = 1
              do info = 1, n
                 if( ipiv( info )>0 .and. ap( kp )==czero )return
                 kp = kp + n - info + 1
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              kcnext = kc + k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc+k-1 ) = one / real( ap( kc+k-1 ),KIND=sp)
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_chpmv( uplo, k-1, -cone, ap, work, 1, czero,ap( kc ), 1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -real( stdlib_cdotc( k-1, work, 1, ap( kc ), 1 ),&
                              KIND=sp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( ap( kcnext+k-1 ) )
                 ak = real( ap( kc+k-1 ),KIND=sp) / t
                 akp1 = real( ap( kcnext+k ),KIND=sp) / t
                 akkp1 = ap( kcnext+k-1 ) / t
                 d = t*( ak*akp1-one )
                 ap( kc+k-1 ) = akp1 / d
                 ap( kcnext+k ) = ak / d
                 ap( kcnext+k-1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_chpmv( uplo, k-1, -cone, ap, work, 1, czero,ap( kc ), 1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -real( stdlib_cdotc( k-1, work, 1, ap( kc ), 1 ),&
                              KIND=sp)
                    ap( kcnext+k-1 ) = ap( kcnext+k-1 ) -stdlib_cdotc( k-1, ap( kc ), 1, ap( &
                              kcnext ),1 )
                    call stdlib_ccopy( k-1, ap( kcnext ), 1, work, 1 )
                    call stdlib_chpmv( uplo, k-1, -cone, ap, work, 1, czero,ap( kcnext ), 1 )
                              
                    ap( kcnext+k ) = ap( kcnext+k ) -real( stdlib_cdotc( k-1, work, 1, ap( kcnext &
                              ),1 ),KIND=sp)
                 end if
                 kstep = 2
                 kcnext = kcnext + k + 1
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kpc = ( kp-1 )*kp / 2 + 1
                 call stdlib_cswap( kp-1, ap( kc ), 1, ap( kpc ), 1 )
                 kx = kpc + kp - 1
                 do j = kp + 1, k - 1
                    kx = kx + j - 1
                    temp = conjg( ap( kc+j-1 ) )
                    ap( kc+j-1 ) = conjg( ap( kx ) )
                    ap( kx ) = temp
                 end do
                 ap( kc+kp-1 ) = conjg( ap( kc+kp-1 ) )
                 temp = ap( kc+k-1 )
                 ap( kc+k-1 ) = ap( kpc+kp-1 )
                 ap( kpc+kp-1 ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc+k+k-1 )
                    ap( kc+k+k-1 ) = ap( kc+k+kp-1 )
                    ap( kc+k+kp-1 ) = temp
                 end if
              end if
              k = k + kstep
              kc = kcnext
              go to 30
              50 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              npp = n*( n+1 ) / 2
              k = n
              kc = npp
              60 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 80
              kcnext = kc - ( n-k+2 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc ) = one / real( ap( kc ),KIND=sp)
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_chpmv( uplo, n-k, -cone, ap( kc+n-k+1 ), work, 1,czero, ap( kc+1 )&
                              , 1 )
                    ap( kc ) = ap( kc ) - real( stdlib_cdotc( n-k, work, 1,ap( kc+1 ), 1 ),&
                              KIND=sp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( ap( kcnext+1 ) )
                 ak = real( ap( kcnext ),KIND=sp) / t
                 akp1 = real( ap( kc ),KIND=sp) / t
                 akkp1 = ap( kcnext+1 ) / t
                 d = t*( ak*akp1-one )
                 ap( kcnext ) = akp1 / d
                 ap( kc ) = ak / d
                 ap( kcnext+1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_chpmv( uplo, n-k, -cone, ap( kc+( n-k+1 ) ), work,1, czero, ap( &
                              kc+1 ), 1 )
                    ap( kc ) = ap( kc ) - real( stdlib_cdotc( n-k, work, 1,ap( kc+1 ), 1 ),&
                              KIND=sp)
                    ap( kcnext+1 ) = ap( kcnext+1 ) -stdlib_cdotc( n-k, ap( kc+1 ), 1,ap( kcnext+&
                              2 ), 1 )
                    call stdlib_ccopy( n-k, ap( kcnext+2 ), 1, work, 1 )
                    call stdlib_chpmv( uplo, n-k, -cone, ap( kc+( n-k+1 ) ), work,1, czero, ap( &
                              kcnext+2 ), 1 )
                    ap( kcnext ) = ap( kcnext ) -real( stdlib_cdotc( n-k, work, 1, ap( kcnext+2 ),&
                              1 ),KIND=sp)
                 end if
                 kstep = 2
                 kcnext = kcnext - ( n-k+3 )
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kpc = npp - ( n-kp+1 )*( n-kp+2 ) / 2 + 1
                 if( kp<n )call stdlib_cswap( n-kp, ap( kc+kp-k+1 ), 1, ap( kpc+1 ), 1 )
                 kx = kc + kp - k
                 do j = k + 1, kp - 1
                    kx = kx + n - j + 1
                    temp = conjg( ap( kc+j-k ) )
                    ap( kc+j-k ) = conjg( ap( kx ) )
                    ap( kx ) = temp
                 end do
                 ap( kc+kp-k ) = conjg( ap( kc+kp-k ) )
                 temp = ap( kc )
                 ap( kc ) = ap( kpc )
                 ap( kpc ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc-n+k-1 )
                    ap( kc-n+k-1 ) = ap( kc-n+kp-1 )
                    ap( kc-n+kp-1 ) = temp
                 end if
              end if
              k = k - kstep
              kc = kcnext
              go to 60
              80 continue
           end if
           return
     end subroutine stdlib_chptri


     subroutine stdlib_cla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,incx, beta, y, incy )
     !! CLA_GBAMV performs one of the matrix-vector operations
     !! y := alpha*abs(A)*abs(x) + beta*abs(y),
     !! or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),
     !! where alpha and beta are scalars, x and y are vectors and A is an
     !! m by n matrix.
     !! This function is primarily used in calculating error bounds.
     !! To protect against underflow during evaluation, components in
     !! the resulting vector are perturbed away from zero by (N+1)
     !! times the underflow threshold.  To prevent unnecessarily large
     !! errors for block-structure embedded in general matrices,
     !! "symbolically" zero components are not perturbed.  A zero
     !! entry is considered "symbolic" if all multiplications involved
     !! in computing that entry have at least one zero multiplicand.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, ldab, m, n, kl, ku, trans
           ! Array Arguments 
           complex(sp), intent(in) :: ab(ldab,*), x(*)
           real(sp), intent(inout) :: y(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: symb_zero
           real(sp) :: temp, safe1
           integer(ilp) :: i, info, iy, j, jx, kx, ky, lenx, leny, kd, ke
           complex(sp) :: cdum
           ! Intrinsic Functions 
           intrinsic :: max,abs,real,aimag,sign
           ! Statement Functions
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if     ( .not.( ( trans==stdlib_ilatrans( 'N' ) ).or. ( trans==stdlib_ilatrans( 'T' ) )&
                     .or. ( trans==stdlib_ilatrans( 'C' ) ) ) ) then
              info = 1
           else if( m<0 )then
              info = 2
           else if( n<0 )then
              info = 3
           else if( kl<0 .or. kl>m-1 ) then
              info = 4
           else if( ku<0 .or. ku>n-1 ) then
              info = 5
           else if( ldab<kl+ku+1 )then
              info = 6
           else if( incx==0 )then
              info = 8
           else if( incy==0 )then
              info = 11
           end if
           if( info/=0 )then
              call stdlib_xerbla( 'CLA_GBAMV ', info )
              return
           end if
           ! quick return if possible.
           if( ( m==0 ).or.( n==0 ).or.( ( alpha==czero ).and.( beta==cone ) ) )return
           ! set  lenx  and  leny, the lengths of the vectors x and y, and set
           ! up the start points in  x  and  y.
           if( trans==stdlib_ilatrans( 'N' ) )then
              lenx = n
              leny = m
           else
              lenx = m
              leny = n
           end if
           if( incx>0 )then
              kx = 1
           else
              kx = 1 - ( lenx - 1 )*incx
           end if
           if( incy>0 )then
              ky = 1
           else
              ky = 1 - ( leny - 1 )*incy
           end if
           ! set safe1 essentially to be the underflow threshold times the
           ! number of additions in each row.
           safe1 = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = (n+1)*safe1
           ! form  y := alpha*abs(a)*abs(x) + beta*abs(y).
           ! the o(m*n) symb_zero tests could be replaced by o(n) queries to
           ! the inexact flag.  still doesn't help change the iteration order
           ! to per-column.
           kd = ku + 1
           ke = kl + 1
           iy = ky
           if ( incx==1 ) then
              if( trans==stdlib_ilatrans( 'N' ) )then
                 do i = 1, leny
                    if ( beta == 0.0_sp ) then
                       symb_zero = .true.
                       y( iy ) = czero
                    else if ( y( iy ) == 0.0_sp ) then
                       symb_zero = .true.
                    else
                       symb_zero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= 0.0_sp ) then
                       do j = max( i-kl, 1 ), min( i+ku, lenx )
                          temp = cabs1( ab( kd+i-j, j ) )
                          symb_zero = symb_zero .and.( x( j ) == czero .or. temp == czero )
                                    
                          y( iy ) = y( iy ) + alpha*cabs1( x( j ) )*temp
                       end do
                    end if
                    if ( .not.symb_zero)y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              else
                 do i = 1, leny
                    if ( beta == 0.0_sp ) then
                       symb_zero = .true.
                       y( iy ) = czero
                    else if ( y( iy ) == 0.0_sp ) then
                       symb_zero = .true.
                    else
                       symb_zero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= 0.0_sp ) then
                       do j = max( i-kl, 1 ), min( i+ku, lenx )
                          temp = cabs1( ab( ke-i+j, i ) )
                          symb_zero = symb_zero .and.( x( j ) == czero .or. temp == czero )
                                    
                          y( iy ) = y( iy ) + alpha*cabs1( x( j ) )*temp
                       end do
                    end if
                    if ( .not.symb_zero)y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              end if
           else
              if( trans==stdlib_ilatrans( 'N' ) )then
                 do i = 1, leny
                    if ( beta == 0.0_sp ) then
                       symb_zero = .true.
                       y( iy ) = czero
                    else if ( y( iy ) == 0.0_sp ) then
                       symb_zero = .true.
                    else
                       symb_zero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= 0.0_sp ) then
                       jx = kx
                       do j = max( i-kl, 1 ), min( i+ku, lenx )
                          temp = cabs1( ab( kd+i-j, j ) )
                          symb_zero = symb_zero .and.( x( jx ) == czero .or. temp == czero )
                                    
                          y( iy ) = y( iy ) + alpha*cabs1( x( jx ) )*temp
                          jx = jx + incx
                       end do
                    end if
                    if ( .not.symb_zero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              else
                 do i = 1, leny
                    if ( beta == 0.0_sp ) then
                       symb_zero = .true.
                       y( iy ) = czero
                    else if ( y( iy ) == 0.0_sp ) then
                       symb_zero = .true.
                    else
                       symb_zero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= 0.0_sp ) then
                       jx = kx
                       do j = max( i-kl, 1 ), min( i+ku, lenx )
                          temp = cabs1( ab( ke-i+j, i ) )
                          symb_zero = symb_zero .and.( x( jx ) == czero .or. temp == czero )
                                    
                          y( iy ) = y( iy ) + alpha*cabs1( x( jx ) )*temp
                          jx = jx + incx
                       end do
                    end if
                    if ( .not.symb_zero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              end if
           end if
           return
     end subroutine stdlib_cla_gbamv


     pure real(sp) function stdlib_cla_gbrpvgrw( n, kl, ku, ncols, ab, ldab, afb,ldafb )
     !! CLA_GBRPVGRW computes the reciprocal pivot growth factor
     !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
     !! much less than 1, the stability of the LU factorization of the
     !! (equilibrated) matrix A could be poor. This also means that the
     !! solution X, estimated condition numbers, and error bounds could be
     !! unreliable.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: n, kl, ku, ncols, ldab, ldafb
           ! Array Arguments 
           complex(sp), intent(in) :: ab(ldab,*), afb(ldafb,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j, kd
           real(sp) :: amax, umax, rpvgrw
           complex(sp) :: zdum
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,real,aimag
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           rpvgrw = one
           kd = ku + 1
           do j = 1, ncols
              amax = zero
              umax = zero
              do i = max( j-ku, 1 ), min( j+kl, n )
                 amax = max( cabs1( ab( kd+i-j, j ) ), amax )
              end do
              do i = max( j-ku, 1 ), j
                 umax = max( cabs1( afb( kd+i-j, j ) ), umax )
              end do
              if ( umax /= 0.0_sp ) then
                 rpvgrw = min( amax / umax, rpvgrw )
              end if
           end do
           stdlib_cla_gbrpvgrw = rpvgrw
     end function stdlib_cla_gbrpvgrw


     subroutine stdlib_cla_geamv( trans, m, n, alpha, a, lda, x, incx, beta,y, incy )
     !! CLA_GEAMV performs one of the matrix-vector operations
     !! y := alpha*abs(A)*abs(x) + beta*abs(y),
     !! or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),
     !! where alpha and beta are scalars, x and y are vectors and A is an
     !! m by n matrix.
     !! This function is primarily used in calculating error bounds.
     !! To protect against underflow during evaluation, components in
     !! the resulting vector are perturbed away from zero by (N+1)
     !! times the underflow threshold.  To prevent unnecessarily large
     !! errors for block-structure embedded in general matrices,
     !! "symbolically" zero components are not perturbed.  A zero
     !! entry is considered "symbolic" if all multiplications involved
     !! in computing that entry have at least one zero multiplicand.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, m, n
           integer(ilp), intent(in) :: trans
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), x(*)
           real(sp), intent(inout) :: y(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: symb_zero
           real(sp) :: temp, safe1
           integer(ilp) :: i, info, iy, j, jx, kx, ky, lenx, leny
           complex(sp) :: cdum
           ! Intrinsic Functions 
           intrinsic :: max,abs,real,aimag,sign
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if     ( .not.( ( trans==stdlib_ilatrans( 'N' ) ).or. ( trans==stdlib_ilatrans( 'T' ) )&
                     .or. ( trans==stdlib_ilatrans( 'C' ) ) ) ) then
              info = 1
           else if( m<0 )then
              info = 2
           else if( n<0 )then
              info = 3
           else if( lda<max( 1, m ) )then
              info = 6
           else if( incx==0 )then
              info = 8
           else if( incy==0 )then
              info = 11
           end if
           if( info/=0 )then
              call stdlib_xerbla( 'CLA_GEAMV ', info )
              return
           end if
           ! quick return if possible.
           if( ( m==0 ).or.( n==0 ).or.( ( alpha==czero ).and.( beta==cone ) ) )return
           ! set  lenx  and  leny, the lengths of the vectors x and y, and set
           ! up the start points in  x  and  y.
           if( trans==stdlib_ilatrans( 'N' ) )then
              lenx = n
              leny = m
           else
              lenx = m
              leny = n
           end if
           if( incx>0 )then
              kx = 1
           else
              kx = 1 - ( lenx - 1 )*incx
           end if
           if( incy>0 )then
              ky = 1
           else
              ky = 1 - ( leny - 1 )*incy
           end if
           ! set safe1 essentially to be the underflow threshold times the
           ! number of additions in each row.
           safe1 = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = (n+1)*safe1
           ! form  y := alpha*abs(a)*abs(x) + beta*abs(y).
           ! the o(m*n) symb_zero tests could be replaced by o(n) queries to
           ! the inexact flag.  still doesn't help change the iteration order
           ! to per-column.
           iy = ky
           if ( incx==1 ) then
              if( trans==stdlib_ilatrans( 'N' ) )then
                 do i = 1, leny
                    if ( beta == 0.0_sp ) then
                       symb_zero = .true.
                       y( iy ) = czero
                    else if ( y( iy ) == 0.0_sp ) then
                       symb_zero = .true.
                    else
                       symb_zero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= 0.0_sp ) then
                       do j = 1, lenx
                          temp = cabs1( a( i, j ) )
                          symb_zero = symb_zero .and.( x( j ) == czero .or. temp == czero )
                                    
                          y( iy ) = y( iy ) + alpha*cabs1( x( j ) )*temp
                       end do
                    end if
                    if ( .not.symb_zero ) y( iy ) =y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              else
                 do i = 1, leny
                    if ( beta == 0.0_sp ) then
                       symb_zero = .true.
                       y( iy ) = czero
                    else if ( y( iy ) == 0.0_sp ) then
                       symb_zero = .true.
                    else
                       symb_zero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= 0.0_sp ) then
                       do j = 1, lenx
                          temp = cabs1( a( j, i ) )
                          symb_zero = symb_zero .and.( x( j ) == czero .or. temp == czero )
                                    
                          y( iy ) = y( iy ) + alpha*cabs1( x( j ) )*temp
                       end do
                    end if
                    if ( .not.symb_zero ) y( iy ) =y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              end if
           else
              if( trans==stdlib_ilatrans( 'N' ) )then
                 do i = 1, leny
                    if ( beta == 0.0_sp ) then
                       symb_zero = .true.
                       y( iy ) = czero
                    else if ( y( iy ) == 0.0_sp ) then
                       symb_zero = .true.
                    else
                       symb_zero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= 0.0_sp ) then
                       jx = kx
                       do j = 1, lenx
                          temp = cabs1( a( i, j ) )
                          symb_zero = symb_zero .and.( x( jx ) == czero .or. temp == czero )
                                    
                          y( iy ) = y( iy ) + alpha*cabs1( x( jx ) )*temp
                          jx = jx + incx
                       end do
                    end if
                    if ( .not.symb_zero ) y( iy ) =y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              else
                 do i = 1, leny
                    if ( beta == 0.0_sp ) then
                       symb_zero = .true.
                       y( iy ) = czero
                    else if ( y( iy ) == 0.0_sp ) then
                       symb_zero = .true.
                    else
                       symb_zero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= 0.0_sp ) then
                       jx = kx
                       do j = 1, lenx
                          temp = cabs1( a( j, i ) )
                          symb_zero = symb_zero .and.( x( jx ) == czero .or. temp == czero )
                                    
                          y( iy ) = y( iy ) + alpha*cabs1( x( jx ) )*temp
                          jx = jx + incx
                       end do
                    end if
                    if ( .not.symb_zero ) y( iy ) =y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              end if
           end if
           return
     end subroutine stdlib_cla_geamv


     pure real(sp) function stdlib_cla_gerpvgrw( n, ncols, a, lda, af, ldaf )
     !! CLA_GERPVGRW computes the reciprocal pivot growth factor
     !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
     !! much less than 1, the stability of the LU factorization of the
     !! (equilibrated) matrix A could be poor. This also means that the
     !! solution X, estimated condition numbers, and error bounds could be
     !! unreliable.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: n, ncols, lda, ldaf
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: amax, umax, rpvgrw
           complex(sp) :: zdum
           ! Intrinsic Functions 
           intrinsic :: max,min,abs,real,aimag
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           rpvgrw = one
           do j = 1, ncols
              amax = zero
              umax = zero
              do i = 1, n
                 amax = max( cabs1( a( i, j ) ), amax )
              end do
              do i = 1, j
                 umax = max( cabs1( af( i, j ) ), umax )
              end do
              if ( umax /= 0.0_sp ) then
                 rpvgrw = min( amax / umax, rpvgrw )
              end if
           end do
           stdlib_cla_gerpvgrw = rpvgrw
     end function stdlib_cla_gerpvgrw


     subroutine stdlib_cla_heamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
     !! CLA_SYAMV  performs the matrix-vector operation
     !! y := alpha*abs(A)*abs(x) + beta*abs(y),
     !! where alpha and beta are scalars, x and y are vectors and A is an
     !! n by n symmetric matrix.
     !! This function is primarily used in calculating error bounds.
     !! To protect against underflow during evaluation, components in
     !! the resulting vector are perturbed away from zero by (N+1)
     !! times the underflow threshold.  To prevent unnecessarily large
     !! errors for block-structure embedded in general matrices,
     !! "symbolically" zero components are not perturbed.  A zero
     !! entry is considered "symbolic" if all multiplications involved
     !! in computing that entry have at least one zero multiplicand.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, n, uplo
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), x(*)
           real(sp), intent(inout) :: y(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: symb_zero
           real(sp) :: temp, safe1
           integer(ilp) :: i, info, iy, j, jx, kx, ky
           complex(sp) :: zdum
           ! Intrinsic Functions 
           intrinsic :: max,abs,sign,real,aimag
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag ( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if     ( uplo/=stdlib_ilauplo( 'U' ) .and.uplo/=stdlib_ilauplo( 'L' ) )then
              info = 1
           else if( n<0 )then
              info = 2
           else if( lda<max( 1, n ) )then
              info = 5
           else if( incx==0 )then
              info = 7
           else if( incy==0 )then
              info = 10
           end if
           if( info/=0 )then
              call stdlib_xerbla( 'CHEMV ', info )
              return
           end if
           ! quick return if possible.
           if( ( n==0 ).or.( ( alpha==zero ).and.( beta==one ) ) )return
           ! set up the start points in  x  and  y.
           if( incx>0 )then
              kx = 1
           else
              kx = 1 - ( n - 1 )*incx
           end if
           if( incy>0 )then
              ky = 1
           else
              ky = 1 - ( n - 1 )*incy
           end if
           ! set safe1 essentially to be the underflow threshold times the
           ! number of additions in each row.
           safe1 = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = (n+1)*safe1
           ! form  y := alpha*abs(a)*abs(x) + beta*abs(y).
           ! the o(n^2) symb_zero tests could be replaced by o(n) queries to
           ! the inexact flag.  still doesn't help change the iteration order
           ! to per-column.
           iy = ky
           if ( incx==1 ) then
              if ( uplo == stdlib_ilauplo( 'U' ) ) then
                 do i = 1, n
                    if ( beta == zero ) then
                       symb_zero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_zero = .true.
                    else
                       symb_zero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= zero ) then
                       do j = 1, i
                          temp = cabs1( a( j, i ) )
                          symb_zero = symb_zero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*cabs1( x( j ) )*temp
                       end do
                       do j = i+1, n
                          temp = cabs1( a( i, j ) )
                          symb_zero = symb_zero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*cabs1( x( j ) )*temp
                       end do
                    end if
                    if (.not.symb_zero)y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              else
                 do i = 1, n
                    if ( beta == zero ) then
                       symb_zero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_zero = .true.
                    else
                       symb_zero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= zero ) then
                       do j = 1, i
                          temp = cabs1( a( i, j ) )
                          symb_zero = symb_zero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*cabs1( x( j ) )*temp
                       end do
                       do j = i+1, n
                          temp = cabs1( a( j, i ) )
                          symb_zero = symb_zero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*cabs1( x( j ) )*temp
                       end do
                    end if
                    if (.not.symb_zero)y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              end if
           else
              if ( uplo == stdlib_ilauplo( 'U' ) ) then
                 do i = 1, n
                    if ( beta == zero ) then
                       symb_zero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_zero = .true.
                    else
                       symb_zero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    jx = kx
                    if ( alpha /= zero ) then
                       do j = 1, i
                          temp = cabs1( a( j, i ) )
                          symb_zero = symb_zero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*cabs1( x( jx ) )*temp
                          jx = jx + incx
                       end do
                       do j = i+1, n
                          temp = cabs1( a( i, j ) )
                          symb_zero = symb_zero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*cabs1( x( jx ) )*temp
                          jx = jx + incx
                       end do
                    end if
                    if ( .not.symb_zero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              else
                 do i = 1, n
                    if ( beta == zero ) then
                       symb_zero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_zero = .true.
                    else
                       symb_zero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    jx = kx
                    if ( alpha /= zero ) then
                       do j = 1, i
                          temp = cabs1( a( i, j ) )
                          symb_zero = symb_zero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*cabs1( x( jx ) )*temp
                          jx = jx + incx
                       end do
                       do j = i+1, n
                          temp = cabs1( a( j, i ) )
                          symb_zero = symb_zero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*cabs1( x( jx ) )*temp
                          jx = jx + incx
                       end do
                    end if
                    if ( .not.symb_zero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              end if
           end if
           return
     end subroutine stdlib_cla_heamv


     pure subroutine stdlib_cla_lin_berr( n, nz, nrhs, res, ayb, berr )
     !! CLA_LIN_BERR computes componentwise relative backward error from
     !! the formula
     !! max(i) ( abs(R(i)) / ( abs(op(A_s))*abs(Y) + abs(B_s) )(i) )
     !! where abs(Z) is the componentwise absolute value of the matrix
     !! or vector Z.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: n, nz, nrhs
           ! Array Arguments 
           real(sp), intent(in) :: ayb(n,nrhs)
           real(sp), intent(out) :: berr(nrhs)
           complex(sp), intent(in) :: res(n,nrhs)
        ! =====================================================================
           ! Local Scalars 
           real(sp) :: tmp,safe1
           integer(ilp) :: i, j
           complex(sp) :: cdum
           ! Intrinsic Functions 
           intrinsic :: abs,real,aimag,max
           ! Statement Functions 
           complex(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! adding safe1 to the numerator guards against spuriously zero
           ! residuals.  a similar safeguard is in the cla_yyamv routine used
           ! to compute ayb.
           safe1 = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = (nz+1)*safe1
           do j = 1, nrhs
              berr(j) = zero
              do i = 1, n
                 if (ayb(i,j) /= 0.0_sp) then
                    tmp = (safe1 + cabs1(res(i,j)))/ayb(i,j)
                    berr(j) = max( berr(j), tmp )
                 end if
           ! if ayb is exactly 0.0_sp (and if computed by cla_yyamv), then we know
           ! the true residual also must be exactly zero.
              end do
           end do
     end subroutine stdlib_cla_lin_berr


     real(sp) function stdlib_cla_porpvgrw( uplo, ncols, a, lda, af, ldaf, work )
     !! CLA_PORPVGRW computes the reciprocal pivot growth factor
     !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
     !! much less than 1, the stability of the LU factorization of the
     !! (equilibrated) matrix A could be poor. This also means that the
     !! solution X, estimated condition numbers, and error bounds could be
     !! unreliable.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: ncols, lda, ldaf
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: amax, umax, rpvgrw
           logical(lk) :: upper
           complex(sp) :: zdum
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,real,aimag
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           upper = stdlib_lsame( 'UPPER', uplo )
           ! stdlib_spotrf will have factored only the ncolsxncols leading minor, so
           ! we restrict the growth search to that minor and use only the first
           ! 2*ncols workspace entries.
           rpvgrw = one
           do i = 1, 2*ncols
              work( i ) = zero
           end do
           ! find the max magnitude entry of each column.
           if ( upper ) then
              do j = 1, ncols
                 do i = 1, j
                    work( ncols+j ) =max( cabs1( a( i, j ) ), work( ncols+j ) )
                 end do
              end do
           else
              do j = 1, ncols
                 do i = j, ncols
                    work( ncols+j ) =max( cabs1( a( i, j ) ), work( ncols+j ) )
                 end do
              end do
           end if
           ! now find the max magnitude entry of each column of the factor in
           ! af.  no pivoting, so no permutations.
           if ( stdlib_lsame( 'UPPER', uplo ) ) then
              do j = 1, ncols
                 do i = 1, j
                    work( j ) = max( cabs1( af( i, j ) ), work( j ) )
                 end do
              end do
           else
              do j = 1, ncols
                 do i = j, ncols
                    work( j ) = max( cabs1( af( i, j ) ), work( j ) )
                 end do
              end do
           end if
           ! compute the *inverse* of the max element growth factor.  dividing
           ! by zero would imply the largest entry of the factor's column is
           ! zero.  than can happen when either the column of a is zero or
           ! massive pivots made the factor underflow to zero.  neither counts
           ! as growth in itself, so simply ignore terms with zero
           ! denominators.
           if ( stdlib_lsame( 'UPPER', uplo ) ) then
              do i = 1, ncols
                 umax = work( i )
                 amax = work( ncols+i )
                 if ( umax /= 0.0_sp ) then
                    rpvgrw = min( amax / umax, rpvgrw )
                 end if
              end do
           else
              do i = 1, ncols
                 umax = work( i )
                 amax = work( ncols+i )
                 if ( umax /= 0.0_sp ) then
                    rpvgrw = min( amax / umax, rpvgrw )
                 end if
              end do
           end if
           stdlib_cla_porpvgrw = rpvgrw
     end function stdlib_cla_porpvgrw


     subroutine stdlib_cla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
     !! CLA_SYAMV performs the matrix-vector operation
     !! y := alpha*abs(A)*abs(x) + beta*abs(y),
     !! where alpha and beta are scalars, x and y are vectors and A is an
     !! n by n symmetric matrix.
     !! This function is primarily used in calculating error bounds.
     !! To protect against underflow during evaluation, components in
     !! the resulting vector are perturbed away from zero by (N+1)
     !! times the underflow threshold.  To prevent unnecessarily large
     !! errors for block-structure embedded in general matrices,
     !! "symbolically" zero components are not perturbed.  A zero
     !! entry is considered "symbolic" if all multiplications involved
     !! in computing that entry have at least one zero multiplicand.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, n
           integer(ilp), intent(in) :: uplo
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), x(*)
           real(sp), intent(inout) :: y(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: symb_zero
           real(sp) :: temp, safe1
           integer(ilp) :: i, info, iy, j, jx, kx, ky
           complex(sp) :: zdum
           ! Intrinsic Functions 
           intrinsic :: max,abs,sign,real,aimag
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag ( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if     ( uplo/=stdlib_ilauplo( 'U' ) .and.uplo/=stdlib_ilauplo( 'L' ) )then
              info = 1
           else if( n<0 )then
              info = 2
           else if( lda<max( 1, n ) )then
              info = 5
           else if( incx==0 )then
              info = 7
           else if( incy==0 )then
              info = 10
           end if
           if( info/=0 )then
              call stdlib_xerbla( 'CLA_SYAMV', info )
              return
           end if
           ! quick return if possible.
           if( ( n==0 ).or.( ( alpha==zero ).and.( beta==one ) ) )return
           ! set up the start points in  x  and  y.
           if( incx>0 )then
              kx = 1
           else
              kx = 1 - ( n - 1 )*incx
           end if
           if( incy>0 )then
              ky = 1
           else
              ky = 1 - ( n - 1 )*incy
           end if
           ! set safe1 essentially to be the underflow threshold times the
           ! number of additions in each row.
           safe1 = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = (n+1)*safe1
           ! form  y := alpha*abs(a)*abs(x) + beta*abs(y).
           ! the o(n^2) symb_zero tests could be replaced by o(n) queries to
           ! the inexact flag.  still doesn't help change the iteration order
           ! to per-column.
           iy = ky
           if ( incx==1 ) then
              if ( uplo == stdlib_ilauplo( 'U' ) ) then
                 do i = 1, n
                    if ( beta == zero ) then
                       symb_zero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_zero = .true.
                    else
                       symb_zero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= zero ) then
                       do j = 1, i
                          temp = cabs1( a( j, i ) )
                          symb_zero = symb_zero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*cabs1( x( j ) )*temp
                       end do
                       do j = i+1, n
                          temp = cabs1( a( i, j ) )
                          symb_zero = symb_zero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*cabs1( x( j ) )*temp
                       end do
                    end if
                    if ( .not.symb_zero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              else
                 do i = 1, n
                    if ( beta == zero ) then
                       symb_zero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_zero = .true.
                    else
                       symb_zero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    if ( alpha /= zero ) then
                       do j = 1, i
                          temp = cabs1( a( i, j ) )
                          symb_zero = symb_zero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*cabs1( x( j ) )*temp
                       end do
                       do j = i+1, n
                          temp = cabs1( a( j, i ) )
                          symb_zero = symb_zero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*cabs1( x( j ) )*temp
                       end do
                    end if
                    if ( .not.symb_zero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              end if
           else
              if ( uplo == stdlib_ilauplo( 'U' ) ) then
                 do i = 1, n
                    if ( beta == zero ) then
                       symb_zero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_zero = .true.
                    else
                       symb_zero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    jx = kx
                    if ( alpha /= zero ) then
                       do j = 1, i
                          temp = cabs1( a( j, i ) )
                          symb_zero = symb_zero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*cabs1( x( jx ) )*temp
                          jx = jx + incx
                       end do
                       do j = i+1, n
                          temp = cabs1( a( i, j ) )
                          symb_zero = symb_zero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*cabs1( x( jx ) )*temp
                          jx = jx + incx
                       end do
                    end if
                    if ( .not.symb_zero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              else
                 do i = 1, n
                    if ( beta == zero ) then
                       symb_zero = .true.
                       y( iy ) = zero
                    else if ( y( iy ) == zero ) then
                       symb_zero = .true.
                    else
                       symb_zero = .false.
                       y( iy ) = beta * abs( y( iy ) )
                    end if
                    jx = kx
                    if ( alpha /= zero ) then
                       do j = 1, i
                          temp = cabs1( a( i, j ) )
                          symb_zero = symb_zero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*cabs1( x( jx ) )*temp
                          jx = jx + incx
                       end do
                       do j = i+1, n
                          temp = cabs1( a( j, i ) )
                          symb_zero = symb_zero .and.( x( j ) == zero .or. temp == zero )
                          y( iy ) = y( iy ) + alpha*cabs1( x( jx ) )*temp
                          jx = jx + incx
                       end do
                    end if
                    if ( .not.symb_zero )y( iy ) = y( iy ) + sign( safe1, y( iy ) )
                    iy = iy + incy
                 end do
              end if
           end if
           return
     end subroutine stdlib_cla_syamv


     pure subroutine stdlib_cla_wwaddw( n, x, y, w )
     !! CLA_WWADDW adds a vector W into a doubled-single vector (X, Y).
     !! This works for all extant IBM's hex and binary floating point
     !! arithmetic, but not for decimal.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           complex(sp), intent(inout) :: x(*), y(*)
           complex(sp), intent(in) :: w(*)
        ! =====================================================================
           ! Local Scalars 
           complex(sp) :: s
           integer(ilp) :: i
           ! Executable Statements 
           do 10 i = 1, n
             s = x(i) + w(i)
             s = (s + s) - s
             y(i) = ((x(i) - s) + w(i)) + y(i)
             x(i) = s
             10 continue
           return
     end subroutine stdlib_cla_wwaddw


     pure subroutine stdlib_clacgv( n, x, incx )
     !! CLACGV conjugates a complex vector of length N.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, n
           ! Array Arguments 
           complex(sp), intent(inout) :: x(*)
       ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ioff
           ! Intrinsic Functions 
           intrinsic :: conjg
           ! Executable Statements 
           if( incx==1 ) then
              do i = 1, n
                 x( i ) = conjg( x( i ) )
              end do
           else
              ioff = 1
              if( incx<0 )ioff = 1 - ( n-1 )*incx
              do i = 1, n
                 x( ioff ) = conjg( x( ioff ) )
                 ioff = ioff + incx
              end do
           end if
           return
     end subroutine stdlib_clacgv


     pure subroutine stdlib_clacn2( n, v, x, est, kase, isave )
     !! CLACN2 estimates the 1-norm of a square, complex matrix A.
     !! Reverse communication is used for evaluating matrix-vector products.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(inout) :: kase
           integer(ilp), intent(in) :: n
           real(sp), intent(inout) :: est
           ! Array Arguments 
           integer(ilp), intent(inout) :: isave(3)
           complex(sp), intent(out) :: v(*)
           complex(sp), intent(inout) :: x(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, jlast
           real(sp) :: absxi, altsgn, estold, safmin, temp
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,real
           ! Executable Statements 
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           if( kase==0 ) then
              do i = 1, n
                 x( i ) = cmplx( one / real( n,KIND=sp),KIND=sp)
              end do
              kase = 1
              isave( 1 ) = 1
              return
           end if
           go to ( 20, 40, 70, 90, 120 )isave( 1 )
           ! ................ entry   (isave( 1 ) = 1)
           ! first iteration.  x has been overwritten by a*x.
           20 continue
           if( n==1 ) then
              v( 1 ) = x( 1 )
              est = abs( v( 1 ) )
              ! ... quit
              go to 130
           end if
           est = stdlib_scsum1( n, x, 1 )
           do i = 1, n
              absxi = abs( x( i ) )
              if( absxi>safmin ) then
                 x( i ) = cmplx( real( x( i ),KIND=sp) / absxi,aimag( x( i ) ) / absxi,KIND=sp)
                           
              else
                 x( i ) = cone
              end if
           end do
           kase = 2
           isave( 1 ) = 2
           return
           ! ................ entry   (isave( 1 ) = 2)
           ! first iteration.  x has been overwritten by ctrans(a)*x.
           40 continue
           isave( 2 ) = stdlib_icmax1( n, x, 1 )
           isave( 3 ) = 2
           ! main loop - iterations 2,3,...,itmax.
           50 continue
           do i = 1, n
              x( i ) = czero
           end do
           x( isave( 2 ) ) = cone
           kase = 1
           isave( 1 ) = 3
           return
           ! ................ entry   (isave( 1 ) = 3)
           ! x has been overwritten by a*x.
           70 continue
           call stdlib_ccopy( n, x, 1, v, 1 )
           estold = est
           est = stdlib_scsum1( n, v, 1 )
           ! test for cycling.
           if( est<=estold )go to 100
           do i = 1, n
              absxi = abs( x( i ) )
              if( absxi>safmin ) then
                 x( i ) = cmplx( real( x( i ),KIND=sp) / absxi,aimag( x( i ) ) / absxi,KIND=sp)
                           
              else
                 x( i ) = cone
              end if
           end do
           kase = 2
           isave( 1 ) = 4
           return
           ! ................ entry   (isave( 1 ) = 4)
           ! x has been overwritten by ctrans(a)*x.
           90 continue
           jlast = isave( 2 )
           isave( 2 ) = stdlib_icmax1( n, x, 1 )
           if( ( abs( x( jlast ) )/=abs( x( isave( 2 ) ) ) ) .and.( isave( 3 )<itmax ) ) &
                     then
              isave( 3 ) = isave( 3 ) + 1
              go to 50
           end if
           ! iteration complete.  final stage.
           100 continue
           altsgn = one
           do i = 1, n
              x( i ) = cmplx( altsgn*( one + real( i-1,KIND=sp) / real( n-1,KIND=sp) ),KIND=sp)
                        
              altsgn = -altsgn
           end do
           kase = 1
           isave( 1 ) = 5
           return
           ! ................ entry   (isave( 1 ) = 5)
           ! x has been overwritten by a*x.
           120 continue
           temp = two*( stdlib_scsum1( n, x, 1 ) / real( 3*n,KIND=sp) )
           if( temp>est ) then
              call stdlib_ccopy( n, x, 1, v, 1 )
              est = temp
           end if
           130 continue
           kase = 0
           return
     end subroutine stdlib_clacn2


     subroutine stdlib_clacon( n, v, x, est, kase )
     !! CLACON estimates the 1-norm of a square, complex matrix A.
     !! Reverse communication is used for evaluating matrix-vector products.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(inout) :: kase
           integer(ilp), intent(in) :: n
           real(sp), intent(inout) :: est
           ! Array Arguments 
           complex(sp), intent(out) :: v(n)
           complex(sp), intent(inout) :: x(n)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, iter, j, jlast, jump
           real(sp) :: absxi, altsgn, estold, safmin, temp
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,real
           ! Save Statement 
           save
           ! Executable Statements 
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           if( kase==0 ) then
              do i = 1, n
                 x( i ) = cmplx( one / real( n,KIND=sp),KIND=sp)
              end do
              kase = 1
              jump = 1
              return
           end if
           go to ( 20, 40, 70, 90, 120 )jump
           ! ................ entry   (jump = 1)
           ! first iteration.  x has been overwritten by a*x.
           20 continue
           if( n==1 ) then
              v( 1 ) = x( 1 )
              est = abs( v( 1 ) )
              ! ... quit
              go to 130
           end if
           est = stdlib_scsum1( n, x, 1 )
           do i = 1, n
              absxi = abs( x( i ) )
              if( absxi>safmin ) then
                 x( i ) = cmplx( real( x( i ),KIND=sp) / absxi,aimag( x( i ) ) / absxi,KIND=sp)
                           
              else
                 x( i ) = cone
              end if
           end do
           kase = 2
           jump = 2
           return
           ! ................ entry   (jump = 2)
           ! first iteration.  x has been overwritten by ctrans(a)*x.
           40 continue
           j = stdlib_icmax1( n, x, 1 )
           iter = 2
           ! main loop - iterations 2,3,...,itmax.
           50 continue
           do i = 1, n
              x( i ) = czero
           end do
           x( j ) = cone
           kase = 1
           jump = 3
           return
           ! ................ entry   (jump = 3)
           ! x has been overwritten by a*x.
           70 continue
           call stdlib_ccopy( n, x, 1, v, 1 )
           estold = est
           est = stdlib_scsum1( n, v, 1 )
           ! test for cycling.
           if( est<=estold )go to 100
           do i = 1, n
              absxi = abs( x( i ) )
              if( absxi>safmin ) then
                 x( i ) = cmplx( real( x( i ),KIND=sp) / absxi,aimag( x( i ) ) / absxi,KIND=sp)
                           
              else
                 x( i ) = cone
              end if
           end do
           kase = 2
           jump = 4
           return
           ! ................ entry   (jump = 4)
           ! x has been overwritten by ctrans(a)*x.
           90 continue
           jlast = j
           j = stdlib_icmax1( n, x, 1 )
           if( ( abs( x( jlast ) )/=abs( x( j ) ) ) .and.( iter<itmax ) ) then
              iter = iter + 1
              go to 50
           end if
           ! iteration complete.  final stage.
           100 continue
           altsgn = one
           do i = 1, n
              x( i ) = cmplx( altsgn*( one+real( i-1,KIND=sp) / real( n-1,KIND=sp) ),KIND=sp)
                        
              altsgn = -altsgn
           end do
           kase = 1
           jump = 5
           return
           ! ................ entry   (jump = 5)
           ! x has been overwritten by a*x.
           120 continue
           temp = two*( stdlib_scsum1( n, x, 1 ) / real( 3*n,KIND=sp) )
           if( temp>est ) then
              call stdlib_ccopy( n, x, 1, v, 1 )
              est = temp
           end if
           130 continue
           kase = 0
           return
     end subroutine stdlib_clacon


     pure subroutine stdlib_clacp2( uplo, m, n, a, lda, b, ldb )
     !! CLACP2 copies all or part of a real two-dimensional matrix A to a
     !! complex matrix B.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, ldb, m, n
           ! Array Arguments 
           real(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: b(ldb,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           if( stdlib_lsame( uplo, 'U' ) ) then
              do j = 1, n
                 do i = 1, min( j, m )
                    b( i, j ) = a( i, j )
                 end do
              end do
           else if( stdlib_lsame( uplo, 'L' ) ) then
              do j = 1, n
                 do i = j, m
                    b( i, j ) = a( i, j )
                 end do
              end do
           else
              do j = 1, n
                 do i = 1, m
                    b( i, j ) = a( i, j )
                 end do
              end do
           end if
           return
     end subroutine stdlib_clacp2


     pure subroutine stdlib_clacpy( uplo, m, n, a, lda, b, ldb )
     !! CLACPY copies all or part of a two-dimensional matrix A to another
     !! matrix B.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, ldb, m, n
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: b(ldb,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           if( stdlib_lsame( uplo, 'U' ) ) then
              do j = 1, n
                 do i = 1, min( j, m )
                    b( i, j ) = a( i, j )
                 end do
              end do
           else if( stdlib_lsame( uplo, 'L' ) ) then
              do j = 1, n
                 do i = j, m
                    b( i, j ) = a( i, j )
                 end do
              end do
           else
              do j = 1, n
                 do i = 1, m
                    b( i, j ) = a( i, j )
                 end do
              end do
           end if
           return
     end subroutine stdlib_clacpy


     pure subroutine stdlib_clacrm( m, n, a, lda, b, ldb, c, ldc, rwork )
     !! CLACRM performs a very simple matrix-matrix multiplication:
     !! C := A * B,
     !! where A is M by N and complex; B is N by N and real;
     !! C is M by N and complex.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: lda, ldb, ldc, m, n
           ! Array Arguments 
           real(sp), intent(in) :: b(ldb,*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: c(ldc,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, l
           ! Intrinsic Functions 
           intrinsic :: aimag,cmplx,real
           ! Executable Statements 
           ! quick return if possible.
           if( ( m==0 ) .or. ( n==0 ) )return
           do j = 1, n
              do i = 1, m
                 rwork( ( j-1 )*m+i ) = real( a( i, j ),KIND=sp)
              end do
           end do
           l = m*n + 1
           call stdlib_sgemm( 'N', 'N', m, n, n, one, rwork, m, b, ldb, zero,rwork( l ), m )
                     
           do j = 1, n
              do i = 1, m
                 c( i, j ) = rwork( l+( j-1 )*m+i-1 )
              end do
           end do
           do j = 1, n
              do i = 1, m
                 rwork( ( j-1 )*m+i ) = aimag( a( i, j ) )
              end do
           end do
           call stdlib_sgemm( 'N', 'N', m, n, n, one, rwork, m, b, ldb, zero,rwork( l ), m )
                     
           do j = 1, n
              do i = 1, m
                 c( i, j ) = cmplx( real( c( i, j ),KIND=sp),rwork( l+( j-1 )*m+i-1 ),KIND=sp)
                           
              end do
           end do
           return
     end subroutine stdlib_clacrm


     pure subroutine stdlib_clacrt( n, cx, incx, cy, incy, c, s )
     !! CLACRT performs the operation
     !! (  c  s )( x )  ==> ( x )
     !! ( -s  c )( y )      ( y )
     !! where c and s are complex and the vectors x and y are complex.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, incy, n
           complex(sp), intent(in) :: c, s
           ! Array Arguments 
           complex(sp), intent(inout) :: cx(*), cy(*)
       ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ix, iy
           complex(sp) :: ctemp
           ! Executable Statements 
           if( n<=0 )return
           if( incx==1 .and. incy==1 )go to 20
           ! code for unequal increments or equal increments not equal to 1
           ix = 1
           iy = 1
           if( incx<0 )ix = ( -n+1 )*incx + 1
           if( incy<0 )iy = ( -n+1 )*incy + 1
           do i = 1, n
              ctemp = c*cx( ix ) + s*cy( iy )
              cy( iy ) = c*cy( iy ) - s*cx( ix )
              cx( ix ) = ctemp
              ix = ix + incx
              iy = iy + incy
           end do
           return
           ! code for both increments equal to 1
           20 continue
           do i = 1, n
              ctemp = c*cx( i ) + s*cy( i )
              cy( i ) = c*cy( i ) - s*cx( i )
              cx( i ) = ctemp
           end do
           return
     end subroutine stdlib_clacrt


     pure complex(sp) function stdlib_cladiv( x, y )
     !! CLADIV := X / Y, where X and Y are complex.  The computation of X / Y
     !! will not overflow on an intermediary step unless the results
     !! overflows.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           complex(sp), intent(in) :: x, y
        ! =====================================================================
           ! Local Scalars 
           real(sp) :: zi, zr
           ! Intrinsic Functions 
           intrinsic :: aimag,cmplx,real
           ! Executable Statements 
           call stdlib_sladiv( real( x,KIND=sp), aimag( x ), real( y,KIND=sp), aimag( y ), zr,zi )
                     
           stdlib_cladiv = cmplx( zr, zi,KIND=sp)
           return
     end function stdlib_cladiv


     pure subroutine stdlib_claed8( k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda,q2, ldq2, w, &
     !! CLAED8 merges the two sets of eigenvalues together into a single
     !! sorted set.  Then it tries to deflate the size of the problem.
     !! There are two ways in which deflation can occur:  when two or more
     !! eigenvalues are close together or if there is a tiny element in the
     !! Z vector.  For each such occurrence the order of the related secular
     !! equation problem is reduced by one.
               indxp, indx, indxq, perm, givptr,givcol, givnum, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: cutpnt, ldq, ldq2, n, qsiz
           integer(ilp), intent(out) :: givptr, info, k
           real(sp), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(out) :: givcol(2,*), indx(*), indxp(*), perm(*)
           integer(ilp), intent(inout) :: indxq(*)
           real(sp), intent(inout) :: d(*), z(*)
           real(sp), intent(out) :: dlamda(*), givnum(2,*), w(*)
           complex(sp), intent(inout) :: q(ldq,*)
           complex(sp), intent(out) :: q2(ldq2,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: mone = -1.0_sp
           
           ! Local Scalars 
           integer(ilp) :: i, imax, j, jlam, jmax, jp, k2, n1, n1p1, n2
           real(sp) :: c, eps, s, t, tau, tol
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -2
           else if( qsiz<n ) then
              info = -3
           else if( ldq<max( 1, n ) ) then
              info = -5
           else if( cutpnt<min( 1, n ) .or. cutpnt>n ) then
              info = -8
           else if( ldq2<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAED8', -info )
              return
           end if
           ! need to initialize givptr to o here in case of quick exit
           ! to prevent an unspecified code behavior (usually sigfault)
           ! when iwork array on entry to *stedc is not zeroed
           ! (or at least some iwork entries which used in *laed7 for givptr).
           givptr = 0
           ! quick return if possible
           if( n==0 )return
           n1 = cutpnt
           n2 = n - n1
           n1p1 = n1 + 1
           if( rho<zero ) then
              call stdlib_sscal( n2, mone, z( n1p1 ), 1 )
           end if
           ! normalize z so that norm(z) = 1
           t = one / sqrt( two )
           do j = 1, n
              indx( j ) = j
           end do
           call stdlib_sscal( n, t, z, 1 )
           rho = abs( two*rho )
           ! sort the eigenvalues into increasing order
           do i = cutpnt + 1, n
              indxq( i ) = indxq( i ) + cutpnt
           end do
           do i = 1, n
              dlamda( i ) = d( indxq( i ) )
              w( i ) = z( indxq( i ) )
           end do
           i = 1
           j = cutpnt + 1
           call stdlib_slamrg( n1, n2, dlamda, 1, 1, indx )
           do i = 1, n
              d( i ) = dlamda( indx( i ) )
              z( i ) = w( indx( i ) )
           end do
           ! calculate the allowable deflation tolerance
           imax = stdlib_isamax( n, z, 1 )
           jmax = stdlib_isamax( n, d, 1 )
           eps = stdlib_slamch( 'EPSILON' )
           tol = eight*eps*abs( d( jmax ) )
           ! if the rank-1 modifier is small enough, no more needs to be done
           ! -- except to reorganize q so that its columns correspond with the
           ! elements in d.
           if( rho*abs( z( imax ) )<=tol ) then
              k = 0
              do j = 1, n
                 perm( j ) = indxq( indx( j ) )
                 call stdlib_ccopy( qsiz, q( 1, perm( j ) ), 1, q2( 1, j ), 1 )
              end do
              call stdlib_clacpy( 'A', qsiz, n, q2( 1, 1 ), ldq2, q( 1, 1 ), ldq )
              return
           end if
           ! if there are multiple eigenvalues then the problem deflates.  here
           ! the number of equal eigenvalues are found.  as each equal
           ! eigenvalue is found, an elementary reflector is computed to rotate
           ! the corresponding eigensubspace so that the corresponding
           ! components of z are zero in this new basis.
           k = 0
           k2 = n + 1
           do j = 1, n
              if( rho*abs( z( j ) )<=tol ) then
                 ! deflate due to small z component.
                 k2 = k2 - 1
                 indxp( k2 ) = j
                 if( j==n )go to 100
              else
                 jlam = j
                 go to 70
              end if
           end do
           70 continue
           j = j + 1
           if( j>n )go to 90
           if( rho*abs( z( j ) )<=tol ) then
              ! deflate due to small z component.
              k2 = k2 - 1
              indxp( k2 ) = j
           else
              ! check if eigenvalues are close enough to allow deflation.
              s = z( jlam )
              c = z( j )
              ! find sqrt(a**2+b**2) without overflow or
              ! destructive underflow.
              tau = stdlib_slapy2( c, s )
              t = d( j ) - d( jlam )
              c = c / tau
              s = -s / tau
              if( abs( t*c*s )<=tol ) then
                 ! deflation is possible.
                 z( j ) = tau
                 z( jlam ) = zero
                 ! record the appropriate givens rotation
                 givptr = givptr + 1
                 givcol( 1, givptr ) = indxq( indx( jlam ) )
                 givcol( 2, givptr ) = indxq( indx( j ) )
                 givnum( 1, givptr ) = c
                 givnum( 2, givptr ) = s
                 call stdlib_csrot( qsiz, q( 1, indxq( indx( jlam ) ) ), 1,q( 1, indxq( indx( j ) &
                           ) ), 1, c, s )
                 t = d( jlam )*c*c + d( j )*s*s
                 d( j ) = d( jlam )*s*s + d( j )*c*c
                 d( jlam ) = t
                 k2 = k2 - 1
                 i = 1
                 80 continue
                 if( k2+i<=n ) then
                    if( d( jlam )<d( indxp( k2+i ) ) ) then
                       indxp( k2+i-1 ) = indxp( k2+i )
                       indxp( k2+i ) = jlam
                       i = i + 1
                       go to 80
                    else
                       indxp( k2+i-1 ) = jlam
                    end if
                 else
                    indxp( k2+i-1 ) = jlam
                 end if
                 jlam = j
              else
                 k = k + 1
                 w( k ) = z( jlam )
                 dlamda( k ) = d( jlam )
                 indxp( k ) = jlam
                 jlam = j
              end if
           end if
           go to 70
           90 continue
           ! record the last eigenvalue.
           k = k + 1
           w( k ) = z( jlam )
           dlamda( k ) = d( jlam )
           indxp( k ) = jlam
           100 continue
           ! sort the eigenvalues and corresponding eigenvectors into dlamda
           ! and q2 respectively.  the eigenvalues/vectors which were not
           ! deflated go into the first k slots of dlamda and q2 respectively,
           ! while those which were deflated go into the last n - k slots.
           do j = 1, n
              jp = indxp( j )
              dlamda( j ) = d( jp )
              perm( j ) = indxq( indx( jp ) )
              call stdlib_ccopy( qsiz, q( 1, perm( j ) ), 1, q2( 1, j ), 1 )
           end do
           ! the deflated eigenvalues and their corresponding vectors go back
           ! into the last n - k slots of d and q respectively.
           if( k<n ) then
              call stdlib_scopy( n-k, dlamda( k+1 ), 1, d( k+1 ), 1 )
              call stdlib_clacpy( 'A', qsiz, n-k, q2( 1, k+1 ), ldq2, q( 1, k+1 ),ldq )
           end if
           return
     end subroutine stdlib_claed8


     pure subroutine stdlib_claesy( a, b, c, rt1, rt2, evscal, cs1, sn1 )
     !! CLAESY computes the eigendecomposition of a 2-by-2 symmetric matrix
     !! ( ( A, B );( B, C ) )
     !! provided the norm of the matrix of eigenvectors is larger than
     !! some threshold value.
     !! RT1 is the eigenvalue of larger absolute value, and RT2 of
     !! smaller absolute value.  If the eigenvectors are computed, then
     !! on return ( CS1, SN1 ) is the unit eigenvector for RT1, hence
     !! [  CS1     SN1   ] . [ A  B ] . [ CS1    -SN1   ] = [ RT1  0  ]
     !! [ -SN1     CS1   ]   [ B  C ]   [ SN1     CS1   ]   [  0  RT2 ]
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           complex(sp), intent(in) :: a, b, c
           complex(sp), intent(out) :: cs1, evscal, rt1, rt2, sn1
       ! =====================================================================
           ! Parameters 
           real(sp), parameter :: thresh = 0.1_sp
           
           
           
           
           
           ! Local Scalars 
           real(sp) :: babs, evnorm, tabs, z
           complex(sp) :: s, t, tmp
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt
           ! Executable Statements 
           ! special case:  the matrix is actually diagonal.
           ! to avoid divide by zero later, we treat this case separately.
           if( abs( b )==zero ) then
              rt1 = a
              rt2 = c
              if( abs( rt1 )<abs( rt2 ) ) then
                 tmp = rt1
                 rt1 = rt2
                 rt2 = tmp
                 cs1 = zero
                 sn1 = one
              else
                 cs1 = one
                 sn1 = zero
              end if
           else
              ! compute the eigenvalues and eigenvectors.
              ! the characteristic equation is
                 ! lambda **2 - (a+c) lambda + (a*c - b*b)
              ! and we solve it using the quadratic formula.
              s = ( a+c )*half
              t = ( a-c )*half
              ! take the square root carefully to avoid over/under flow.
              babs = abs( b )
              tabs = abs( t )
              z = max( babs, tabs )
              if( z>zero )t = z*sqrt( ( t / z )**2+( b / z )**2 )
              ! compute the two eigenvalues.  rt1 and rt2 are exchanged
              ! if necessary so that rt1 will have the greater magnitude.
              rt1 = s + t
              rt2 = s - t
              if( abs( rt1 )<abs( rt2 ) ) then
                 tmp = rt1
                 rt1 = rt2
                 rt2 = tmp
              end if
              ! choose cs1 = 1 and sn1 to satisfy the first equation, then
              ! scale the components of this eigenvector so that the matrix
              ! of eigenvectors x satisfies  x * x**t = i .  (no scaling is
              ! done if the norm of the eigenvalue matrix is less than thresh.)
              sn1 = ( rt1-a ) / b
              tabs = abs( sn1 )
              if( tabs>one ) then
                 t = tabs*sqrt( ( one / tabs )**2+( sn1 / tabs )**2 )
              else
                 t = sqrt( cone+sn1*sn1 )
              end if
              evnorm = abs( t )
              if( evnorm>=thresh ) then
                 evscal = cone / t
                 cs1 = evscal
                 sn1 = sn1*evscal
              else
                 evscal = zero
              end if
           end if
           return
     end subroutine stdlib_claesy


     pure subroutine stdlib_claev2( a, b, c, rt1, rt2, cs1, sn1 )
     !! CLAEV2 computes the eigendecomposition of a 2-by-2 Hermitian matrix
     !! [  A         B  ]
     !! [  CONJG(B)  C  ].
     !! On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
     !! eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
     !! eigenvector for RT1, giving the decomposition
     !! [ CS1  CONJG(SN1) ] [    A     B ] [ CS1 -CONJG(SN1) ] = [ RT1  0  ]
     !! [-SN1     CS1     ] [ CONJG(B) C ] [ SN1     CS1     ]   [  0  RT2 ].
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(sp), intent(out) :: cs1, rt1, rt2
           complex(sp), intent(in) :: a, b, c
           complex(sp), intent(out) :: sn1
       ! =====================================================================
           
           
           ! Local Scalars 
           real(sp) :: t
           complex(sp) :: w
           ! Intrinsic Functions 
           intrinsic :: abs,conjg,real
           ! Executable Statements 
           if( abs( b )==zero ) then
              w = one
           else
              w = conjg( b ) / abs( b )
           end if
           call stdlib_slaev2( real( a,KIND=sp), abs( b ), real( c,KIND=sp), rt1, rt2, cs1, t )
                     
           sn1 = w*t
           return
     end subroutine stdlib_claev2


     pure subroutine stdlib_clag2z( m, n, sa, ldsa, a, lda, info )
     !! CLAG2Z converts a COMPLEX matrix, SA, to a COMPLEX*16 matrix, A.
     !! Note that while it is possible to overflow while converting
     !! from double to single, it is not possible to overflow when
     !! converting from single to double.
     !! This is an auxiliary routine so there is no argument checking.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldsa, m, n
           ! Array Arguments 
           complex(sp), intent(in) :: sa(ldsa,*)
           complex(dp), intent(out) :: a(lda,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           ! Executable Statements 
           info = 0
           do j = 1, n
              do i = 1, m
                 a( i, j ) = sa( i, j )
              end do
           end do
           return
     end subroutine stdlib_clag2z


     pure subroutine stdlib_clagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,b, ldb )
     !! CLAGTM performs a matrix-vector product of the form
     !! B := alpha * A * X + beta * B
     !! where A is a tridiagonal matrix of order N, B and X are N by NRHS
     !! matrices, and alpha and beta are real scalars, each of which may be
     !! 0., 1., or -1.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(sp), intent(in) :: alpha, beta
           ! Array Arguments 
           complex(sp), intent(inout) :: b(ldb,*)
           complex(sp), intent(in) :: d(*), dl(*), du(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j
           ! Intrinsic Functions 
           intrinsic :: conjg
           ! Executable Statements 
           if( n==0 )return
           ! multiply b by beta if beta/=1.
           if( beta==zero ) then
              do j = 1, nrhs
                 do i = 1, n
                    b( i, j ) = zero
                 end do
              end do
           else if( beta==-one ) then
              do j = 1, nrhs
                 do i = 1, n
                    b( i, j ) = -b( i, j )
                 end do
              end do
           end if
           if( alpha==one ) then
              if( stdlib_lsame( trans, 'N' ) ) then
                 ! compute b := b + a*x
                 do j = 1, nrhs
                    if( n==1 ) then
                       b( 1, j ) = b( 1, j ) + d( 1 )*x( 1, j )
                    else
                       b( 1, j ) = b( 1, j ) + d( 1 )*x( 1, j ) +du( 1 )*x( 2, j )
                       b( n, j ) = b( n, j ) + dl( n-1 )*x( n-1, j ) +d( n )*x( n, j )
                       do i = 2, n - 1
                          b( i, j ) = b( i, j ) + dl( i-1 )*x( i-1, j ) +d( i )*x( i, j ) + du( i &
                                    )*x( i+1, j )
                       end do
                    end if
                 end do
              else if( stdlib_lsame( trans, 'T' ) ) then
                 ! compute b := b + a**t * x
                 do j = 1, nrhs
                    if( n==1 ) then
                       b( 1, j ) = b( 1, j ) + d( 1 )*x( 1, j )
                    else
                       b( 1, j ) = b( 1, j ) + d( 1 )*x( 1, j ) +dl( 1 )*x( 2, j )
                       b( n, j ) = b( n, j ) + du( n-1 )*x( n-1, j ) +d( n )*x( n, j )
                       do i = 2, n - 1
                          b( i, j ) = b( i, j ) + du( i-1 )*x( i-1, j ) +d( i )*x( i, j ) + dl( i &
                                    )*x( i+1, j )
                       end do
                    end if
                 end do
              else if( stdlib_lsame( trans, 'C' ) ) then
                 ! compute b := b + a**h * x
                 do j = 1, nrhs
                    if( n==1 ) then
                       b( 1, j ) = b( 1, j ) + conjg( d( 1 ) )*x( 1, j )
                    else
                       b( 1, j ) = b( 1, j ) + conjg( d( 1 ) )*x( 1, j ) +conjg( dl( 1 ) )*x( 2, &
                                 j )
                       b( n, j ) = b( n, j ) + conjg( du( n-1 ) )*x( n-1, j ) + conjg( d( n ) )*x(&
                                  n, j )
                       do i = 2, n - 1
                          b( i, j ) = b( i, j ) + conjg( du( i-1 ) )*x( i-1, j ) + conjg( d( i ) )&
                                    *x( i, j ) + conjg( dl( i ) )*x( i+1, j )
                       end do
                    end if
                 end do
              end if
           else if( alpha==-one ) then
              if( stdlib_lsame( trans, 'N' ) ) then
                 ! compute b := b - a*x
                 do j = 1, nrhs
                    if( n==1 ) then
                       b( 1, j ) = b( 1, j ) - d( 1 )*x( 1, j )
                    else
                       b( 1, j ) = b( 1, j ) - d( 1 )*x( 1, j ) -du( 1 )*x( 2, j )
                       b( n, j ) = b( n, j ) - dl( n-1 )*x( n-1, j ) -d( n )*x( n, j )
                       do i = 2, n - 1
                          b( i, j ) = b( i, j ) - dl( i-1 )*x( i-1, j ) -d( i )*x( i, j ) - du( i &
                                    )*x( i+1, j )
                       end do
                    end if
                 end do
              else if( stdlib_lsame( trans, 'T' ) ) then
                 ! compute b := b - a**t*x
                 do j = 1, nrhs
                    if( n==1 ) then
                       b( 1, j ) = b( 1, j ) - d( 1 )*x( 1, j )
                    else
                       b( 1, j ) = b( 1, j ) - d( 1 )*x( 1, j ) -dl( 1 )*x( 2, j )
                       b( n, j ) = b( n, j ) - du( n-1 )*x( n-1, j ) -d( n )*x( n, j )
                       do i = 2, n - 1
                          b( i, j ) = b( i, j ) - du( i-1 )*x( i-1, j ) -d( i )*x( i, j ) - dl( i &
                                    )*x( i+1, j )
                       end do
                    end if
                 end do
              else if( stdlib_lsame( trans, 'C' ) ) then
                 ! compute b := b - a**h*x
                 do j = 1, nrhs
                    if( n==1 ) then
                       b( 1, j ) = b( 1, j ) - conjg( d( 1 ) )*x( 1, j )
                    else
                       b( 1, j ) = b( 1, j ) - conjg( d( 1 ) )*x( 1, j ) -conjg( dl( 1 ) )*x( 2, &
                                 j )
                       b( n, j ) = b( n, j ) - conjg( du( n-1 ) )*x( n-1, j ) - conjg( d( n ) )*x(&
                                  n, j )
                       do i = 2, n - 1
                          b( i, j ) = b( i, j ) - conjg( du( i-1 ) )*x( i-1, j ) - conjg( d( i ) )&
                                    *x( i, j ) - conjg( dl( i ) )*x( i+1, j )
                       end do
                    end if
                 end do
              end if
           end if
           return
     end subroutine stdlib_clagtm


     pure subroutine stdlib_clahef( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
     !! CLAHEF computes a partial factorization of a complex Hermitian
     !! matrix A using the Bunch-Kaufman diagonal pivoting method. The
     !! partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0      I     )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! Note that U**H denotes the conjugate transpose of U.
     !! CLAHEF is an auxiliary routine called by CHETRF. It uses blocked code
     !! (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
     !! A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           integer(ilp) :: imax, j, jb, jj, jmax, jp, k, kk, kkw, kp, kstep, kw
           real(sp) :: absakk, alpha, colmax, r1, rowmax, t
           complex(sp) :: d11, d21, d22, z
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,conjg,max,min,real,sqrt
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11 (note that conjg(w) is actually stored)
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              ! copy column k of a to column kw of w and update it
              call stdlib_ccopy( k-1, a( 1, k ), 1, w( 1, kw ), 1 )
              w( k, kw ) = real( a( k, k ),KIND=sp)
              if( k<n ) then
                 call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ), lda,w( k, kw+1 ), &
                           ldw, cone, w( 1, kw ), 1 )
                 w( k, kw ) = real( w( k, kw ),KIND=sp)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, kw ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=sp)
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! begin pivot search along imax row
                    ! copy column imax to column kw-1 of w and update it
                    call stdlib_ccopy( imax-1, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                    w( imax, kw-1 ) = real( a( imax, imax ),KIND=sp)
                    call stdlib_ccopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                              
                    call stdlib_clacgv( k-imax, w( imax+1, kw-1 ), 1 )
                    if( k<n ) then
                       call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda, w( imax,&
                                  kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                       w( imax, kw-1 ) = real( w( imax, kw-1 ),KIND=sp)
                    end if
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value.
                    ! determine only rowmax.
                    jmax = imax + stdlib_icamax( k-imax, w( imax+1, kw-1 ), 1 )
                    rowmax = cabs1( w( jmax, kw-1 ) )
                    if( imax>1 ) then
                       jmax = stdlib_icamax( imax-1, w( 1, kw-1 ), 1 )
                       rowmax = max( rowmax, cabs1( w( jmax, kw-1 ) ) )
                    end if
                    ! case(2)
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    ! case(3)
                    else if( abs( real( w( imax, kw-1 ),KIND=sp) )>=alpha*rowmax )then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column kw-1 of w to column kw of w
                       call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                    ! case(4)
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                    ! end pivot search along imax row
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=sp)
                    call stdlib_ccopy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_clacgv( kk-1-kp, a( kp, kp+1 ), lda )
                    if( kp>1 )call stdlib_ccopy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_cswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_cswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! (1) store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element u(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=sp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_ccopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(4))
                       r1 = one / real( a( k, k ),KIND=sp)
                       call stdlib_csscal( k-1, r1, a( 1, k ), 1 )
                       ! (2) conjugate column w(kw)
                       call stdlib_clacgv( k-1, w( 1, kw ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! (1) store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! (note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored)
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! = ( conj(d21)*( d11 ) d21*(  -1 ) )
                         ! (           (  -1 )     ( d22 ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = t/d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0, since in 2x2 pivot case(4)
                            ! |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / conjg( d21 )
                       d22 = w( k-1, kw-1 ) / d21
                       t = one / ( real( d11*d22,KIND=sp)-one )
                       d21 = t / d21
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = d21*( d11*w( j, kw-1 )-w( j, kw ) )
                          a( j, k ) = conjg( d21 )*( d22*w( j, kw )-w( j, kw-1 ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                    ! (2) conjugate columns w(kw) and w(kw-1)
                    call stdlib_clacgv( k-1, w( 1, kw ), 1 )
                    call stdlib_clacgv( k-2, w( 1, kw-1 ), 1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**h = a11 - u12*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                    call stdlib_cgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                 end do
                 ! update the rectangular superdiagonal block
                 call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k,-cone, a( 1, k+1 ), &
                           lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in of rows in columns k+1:n looping backwards from k+1 to n
              j = k + 1
              60 continue
                 ! undo the interchanges (if any) of rows j and jp
                 ! at each step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j + 1
                 end if
                 ! (note: here, j is used to determine row length. length n-j+1
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j + 1
                 if( jp/=jj .and. j<=n )call stdlib_cswap( n-j+1, a( jp, j ), lda, a( jj, j ), &
                           lda )
              if( j<=n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22 (note that conjg(w) is actually stored)
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              ! copy column k of a to column k of w and update it
              w( k, k ) = real( a( k, k ),KIND=sp)
              if( k<n )call stdlib_ccopy( n-k, a( k+1, k ), 1, w( k+1, k ), 1 )
              call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ), lda,w( k, 1 ), ldw,&
                         cone, w( k, k ), 1 )
              w( k, k ) = real( w( k, k ),KIND=sp)
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=sp)
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! begin pivot search along imax row
                    ! copy column imax to column k+1 of w and update it
                    call stdlib_ccopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1 )
                    call stdlib_clacgv( imax-k, w( k, k+1 ), 1 )
                    w( imax, k+1 ) = real( a( imax, imax ),KIND=sp)
                    if( imax<n )call stdlib_ccopy( n-imax, a( imax+1, imax ), 1,w( imax+1, k+1 ), &
                              1 )
                    call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( imax, &
                              1 ), ldw, cone, w( k, k+1 ),1 )
                    w( imax, k+1 ) = real( w( imax, k+1 ),KIND=sp)
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value.
                    ! determine only rowmax.
                    jmax = k - 1 + stdlib_icamax( imax-k, w( k, k+1 ), 1 )
                    rowmax = cabs1( w( jmax, k+1 ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_icamax( n-imax, w( imax+1, k+1 ), 1 )
                       rowmax = max( rowmax, cabs1( w( jmax, k+1 ) ) )
                    end if
                    ! case(2)
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    ! case(3)
                    else if( abs( real( w( imax, k+1 ),KIND=sp) )>=alpha*rowmax )then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column k+1 of w to column k of w
                       call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                    ! case(4)
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                    ! end pivot search along imax row
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=sp)
                    call stdlib_ccopy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    call stdlib_clacgv( kp-kk-1, a( kp, kk+1 ), lda )
                    if( kp<n )call stdlib_ccopy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (columns k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_cswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_cswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! (1) store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=sp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_ccopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(4))
                       r1 = one / real( a( k, k ),KIND=sp)
                       call stdlib_csscal( n-k, r1, a( k+1, k ), 1 )
                       ! (2) conjugate column w(k)
                       call stdlib_clacgv( n-k, w( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! (1) store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! (note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored)
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! = ( conj(d21)*( d11 ) d21*(  -1 ) )
                         ! (           (  -1 )     ( d22 ) )
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = t/d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0, since in 2x2 pivot case(4)
                            ! |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / conjg( d21 )
                       t = one / ( real( d11*d22,KIND=sp)-one )
                       d21 = t / d21
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = conjg( d21 )*( d11*w( j, k )-w( j, k+1 ) )
                          a( j, k+1 ) = d21*( d22*w( j, k+1 )-w( j, k ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    ! (2) conjugate columns w(k) and w(k+1)
                    call stdlib_clacgv( n-k, w( k+1, k ), 1 )
                    call stdlib_clacgv( n-k-1, w( k+2, k+1 ), 1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**h = a22 - l21*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                    call stdlib_cgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! of rows in columns 1:k-1 looping backwards from k-1 to 1
              j = k - 1
              120 continue
                 ! undo the interchanges (if any) of rows j and jp
                 ! at each step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j - 1
                 end if
                 ! (note: here, j is used to determine row length. length j
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j - 1
                 if( jp/=jj .and. j>=1 )call stdlib_cswap( j, a( jp, 1 ), lda, a( jj, 1 ), lda )
                           
              if( j>=1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_clahef


     pure subroutine stdlib_clahef_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
     !! CLAHEF_RK computes a partial factorization of a complex Hermitian
     !! matrix A using the bounded Bunch-Kaufman (rook) diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L',
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! CLAHEF_RK is an auxiliary routine called by CHETRF_RK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: w(ldw,*), e(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, ii, j, jb, jj, jmax, k, kk, kkw, kp, kstep, kw, p
           real(sp) :: absakk, alpha, colmax, stemp, r1, rowmax, t, sfmin
           complex(sp) :: d11, d21, d22, z
           ! Intrinsic Functions 
           intrinsic :: abs,conjg,aimag,max,min,real,sqrt
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11 (note that conjg(w) is actually stored)
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = czero
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              if( k>1 )call stdlib_ccopy( k-1, a( 1, k ), 1, w( 1, kw ), 1 )
              w( k, kw ) = real( a( k, k ),KIND=sp)
              if( k<n ) then
                 call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ), lda,w( k, kw+1 ), &
                           ldw, cone, w( 1, kw ), 1 )
                 w( k, kw ) = real( w( k, kw ),KIND=sp)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, kw ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( w( k, kw ),KIND=sp)
                 if( k>1 )call stdlib_ccopy( k-1, w( 1, kw ), 1, a( 1, k ), 1 )
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = czero
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! lop until pivot found
                    done = .false.
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       if( imax>1 )call stdlib_ccopy( imax-1, a( 1, imax ), 1, w( 1, kw-1 ),1 )
                                 
                       w( imax, kw-1 ) = real( a( imax, imax ),KIND=sp)
                       call stdlib_ccopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       call stdlib_clacgv( k-imax, w( imax+1, kw-1 ), 1 )
                       if( k<n ) then
                          call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda, w( &
                                    imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                          w( imax, kw-1 ) = real( w( imax, kw-1 ),KIND=sp)
                       end if
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_icamax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = cabs1( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_icamax( imax-1, w( 1, kw-1 ), 1 )
                          stemp = cabs1( w( itemp, kw-1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=sp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( w( imax,kw-1 ),KIND=sp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 12
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns p and k.
                 ! updated column p is already stored in column kw of w.
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p of submatrix a
                    ! at step k. no need to copy element into columns
                    ! k and k-1 of a for 2-by-2 pivot, since these columns
                    ! will be later overwritten.
                    a( p, p ) = real( a( k, k ),KIND=sp)
                    call stdlib_ccopy( k-1-p, a( p+1, k ), 1, a( p, p+1 ),lda )
                    call stdlib_clacgv( k-1-p, a( p, p+1 ), lda )
                    if( p>1 )call stdlib_ccopy( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in the last k+1 to n columns of a
                    ! (columns k and k-1 of a for 2-by-2 pivot will be
                    ! later overwritten). interchange rows k and p
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_cswap( n-k, a( k, k+1 ), lda, a( p, k+1 ),lda )
                    call stdlib_cswap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ),ldw )
                 end if
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=sp)
                    call stdlib_ccopy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_clacgv( kk-1-kp, a( kp, kp+1 ), lda )
                    if( kp>1 )call stdlib_ccopy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_cswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_cswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! (1) store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element u(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=sp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_ccopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(3))
                       ! handle division by a small number
                       t = real( a( k, k ),KIND=sp)
                       if( abs( t )>=sfmin ) then
                          r1 = one / t
                          call stdlib_csscal( k-1, r1, a( 1, k ), 1 )
                       else
                          do ii = 1, k-1
                             a( ii, k ) = a( ii, k ) / t
                          end do
                       end if
                       ! (2) conjugate column w(kw)
                       call stdlib_clacgv( k-1, w( 1, kw ), 1 )
                       ! store the superdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! (1) store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! (note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored)
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! handle division by a small number. (note: order of
                       ! operations is important)
                       ! = ( t*(( d11 )/conj(d21)) t*((  -1 )/d21 ) )
                         ! (   ((  -1 )          )   (( d22 )     ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0 in 2x2 pivot case(4),
                            ! since |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / conjg( d21 )
                       d22 = w( k-1, kw-1 ) / d21
                       t = one / ( real( d11*d22,KIND=sp)-one )
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( ( d11*w( j, kw-1 )-w( j, kw ) ) /d21 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /conjg( d21 ) )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy superdiagonal element of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = czero
                    a( k, k ) = w( k, kw )
                    e( k ) = w( k-1, kw )
                    e( k-1 ) = czero
                    ! (2) conjugate columns w(kw) and w(kw-1)
                    call stdlib_clacgv( k-1, w( 1, kw ), 1 )
                    call stdlib_clacgv( k-2, w( 1, kw-1 ), 1 )
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**h = a11 - u12*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                    call stdlib_cgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k,-cone, a( &
                           1, k+1 ), lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22 (note that conjg(w) is actually stored)
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = czero
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update column k of w
              w( k, k ) = real( a( k, k ),KIND=sp)
              if( k<n )call stdlib_ccopy( n-k, a( k+1, k ), 1, w( k+1, k ), 1 )
              if( k>1 ) then
                 call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( k, 1 ), &
                           ldw, cone, w( k, k ), 1 )
                 w( k, k ) = real( w( k, k ),KIND=sp)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( w( k, k ),KIND=sp)
                 if( k<n )call stdlib_ccopy( n-k, w( k+1, k ), 1, a( k+1, k ), 1 )
                 ! set e( k ) to zero
                 if( k<n )e( k ) = czero
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_ccopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_clacgv( imax-k, w( k, k+1 ), 1 )
                       w( imax, k+1 ) = real( a( imax, imax ),KIND=sp)
                       if( imax<n )call stdlib_ccopy( n-imax, a( imax+1, imax ), 1,w( imax+1, k+1 &
                                 ), 1 )
                       if( k>1 ) then
                          call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone,a( k, 1 ), lda, w( &
                                    imax, 1 ), ldw,cone, w( k, k+1 ), 1 )
                          w( imax, k+1 ) = real( w( imax, k+1 ),KIND=sp)
                       end if
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_icamax( imax-k, w( k, k+1 ), 1 )
                          rowmax = cabs1( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_icamax( n-imax, w( imax+1, k+1 ), 1)
                          stemp = cabs1( w( itemp, k+1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,k+1 ),KIND=sp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( w( imax,k+1 ),KIND=sp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 72
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns p and k (only for 2-by-2 pivot).
                 ! updated column p is already stored in column k of w.
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column kk-1 to column p of submatrix a
                    ! at step k. no need to copy element into columns
                    ! k and k+1 of a for 2-by-2 pivot, since these columns
                    ! will be later overwritten.
                    a( p, p ) = real( a( k, k ),KIND=sp)
                    call stdlib_ccopy( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                    call stdlib_clacgv( p-k-1, a( p, k+1 ), lda )
                    if( p<n )call stdlib_ccopy( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    ! interchange rows k and p in first k-1 columns of a
                    ! (columns k and k+1 of a for 2-by-2 pivot will be
                    ! later overwritten). interchange rows k and p
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_cswap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_cswap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=sp)
                    call stdlib_ccopy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    call stdlib_clacgv( kp-kk-1, a( kp, kk+1 ), lda )
                    if( kp<n )call stdlib_ccopy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (column k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_cswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_cswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! (1) store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=sp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_ccopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(3))
                       ! handle division by a small number
                       t = real( a( k, k ),KIND=sp)
                       if( abs( t )>=sfmin ) then
                          r1 = one / t
                          call stdlib_csscal( n-k, r1, a( k+1, k ), 1 )
                       else
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / t
                          end do
                       end if
                       ! (2) conjugate column w(k)
                       call stdlib_clacgv( n-k, w( k+1, k ), 1 )
                       ! store the subdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! (1) store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored.
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! handle division by a small number. (note: order of
                       ! operations is important)
                       ! = ( t*(( d11 )/conj(d21)) t*((  -1 )/d21 ) )
                         ! (   ((  -1 )          )   (( d22 )     ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0 in 2x2 pivot case(4),
                            ! since |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / conjg( d21 )
                       t = one / ( real( d11*d22,KIND=sp)-one )
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /conjg( d21 ) )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy subdiagonal element of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = czero
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    e( k ) = w( k+1, k )
                    e( k+1 ) = czero
                    ! (2) conjugate columns w(k) and w(k+1)
                    call stdlib_clacgv( n-k, w( k+1, k ), 1 )
                    call stdlib_clacgv( n-k-1, w( k+2, k+1 ), 1 )
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**h = a22 - l21*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                    call stdlib_cgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_clahef_rk


     pure subroutine stdlib_clahef_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
     !! CLAHEF_ROOK computes a partial factorization of a complex Hermitian
     !! matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting
     !! method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0      I     )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! Note that U**H denotes the conjugate transpose of U.
     !! CLAHEF_ROOK is an auxiliary routine called by CHETRF_ROOK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, ii, j, jb, jj, jmax, jp1, jp2, k, kk, kkw, kp, kstep, kw, &
                     p
           real(sp) :: absakk, alpha, colmax, stemp, r1, rowmax, t, sfmin
           complex(sp) :: d11, d21, d22, z
           ! Intrinsic Functions 
           intrinsic :: abs,conjg,aimag,max,min,real,sqrt
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11 (note that conjg(w) is actually stored)
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              if( k>1 )call stdlib_ccopy( k-1, a( 1, k ), 1, w( 1, kw ), 1 )
              w( k, kw ) = real( a( k, k ),KIND=sp)
              if( k<n ) then
                 call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ), lda,w( k, kw+1 ), &
                           ldw, cone, w( 1, kw ), 1 )
                 w( k, kw ) = real( w( k, kw ),KIND=sp)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, kw ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( w( k, kw ),KIND=sp)
                 if( k>1 )call stdlib_ccopy( k-1, w( 1, kw ), 1, a( 1, k ), 1 )
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! lop until pivot found
                    done = .false.
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       if( imax>1 )call stdlib_ccopy( imax-1, a( 1, imax ), 1, w( 1, kw-1 ),1 )
                                 
                       w( imax, kw-1 ) = real( a( imax, imax ),KIND=sp)
                       call stdlib_ccopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       call stdlib_clacgv( k-imax, w( imax+1, kw-1 ), 1 )
                       if( k<n ) then
                          call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda, w( &
                                    imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                          w( imax, kw-1 ) = real( w( imax, kw-1 ),KIND=sp)
                       end if
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_icamax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = cabs1( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_icamax( imax-1, w( 1, kw-1 ), 1 )
                          stemp = cabs1( w( itemp, kw-1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=sp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( w( imax,kw-1 ),KIND=sp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 12
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns p and k.
                 ! updated column p is already stored in column kw of w.
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p of submatrix a
                    ! at step k. no need to copy element into columns
                    ! k and k-1 of a for 2-by-2 pivot, since these columns
                    ! will be later overwritten.
                    a( p, p ) = real( a( k, k ),KIND=sp)
                    call stdlib_ccopy( k-1-p, a( p+1, k ), 1, a( p, p+1 ),lda )
                    call stdlib_clacgv( k-1-p, a( p, p+1 ), lda )
                    if( p>1 )call stdlib_ccopy( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in the last k+1 to n columns of a
                    ! (columns k and k-1 of a for 2-by-2 pivot will be
                    ! later overwritten). interchange rows k and p
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_cswap( n-k, a( k, k+1 ), lda, a( p, k+1 ),lda )
                    call stdlib_cswap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ),ldw )
                 end if
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=sp)
                    call stdlib_ccopy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_clacgv( kk-1-kp, a( kp, kp+1 ), lda )
                    if( kp>1 )call stdlib_ccopy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_cswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_cswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! (1) store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element u(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=sp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_ccopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(3))
                       ! handle division by a small number
                       t = real( a( k, k ),KIND=sp)
                       if( abs( t )>=sfmin ) then
                          r1 = one / t
                          call stdlib_csscal( k-1, r1, a( 1, k ), 1 )
                       else
                          do ii = 1, k-1
                             a( ii, k ) = a( ii, k ) / t
                          end do
                       end if
                       ! (2) conjugate column w(kw)
                       call stdlib_clacgv( k-1, w( 1, kw ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! (1) store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! (note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored)
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! handle division by a small number. (note: order of
                       ! operations is important)
                       ! = ( t*(( d11 )/conj(d21)) t*((  -1 )/d21 ) )
                         ! (   ((  -1 )          )   (( d22 )     ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0 in 2x2 pivot case(4),
                            ! since |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / conjg( d21 )
                       d22 = w( k-1, kw-1 ) / d21
                       t = one / ( real( d11*d22,KIND=sp)-one )
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( ( d11*w( j, kw-1 )-w( j, kw ) ) /d21 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /conjg( d21 ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                    ! (2) conjugate columns w(kw) and w(kw-1)
                    call stdlib_clacgv( k-1, w( 1, kw ), 1 )
                    call stdlib_clacgv( k-2, w( 1, kw-1 ), 1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**h = a11 - u12*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                    call stdlib_cgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k,-cone, a( &
                           1, k+1 ), lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in of rows in columns k+1:n looping backwards from k+1 to n
              j = k + 1
              60 continue
                 ! undo the interchanges (if any) of rows j and jp2
                 ! (or j and jp2, and j+1 and jp1) at each step j
                 kstep = 1
                 jp1 = 1
                 ! (here, j is a diagonal index)
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    ! (here, j is a diagonal index)
                    j = j + 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 ! (note: here, j is used to determine row length. length n-j+1
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j + 1
                 if( jp2/=jj .and. j<=n )call stdlib_cswap( n-j+1, a( jp2, j ), lda, a( jj, j ), &
                           lda )
                 jj = jj + 1
                 if( kstep==2 .and. jp1/=jj .and. j<=n )call stdlib_cswap( n-j+1, a( jp1, j ), &
                           lda, a( jj, j ), lda )
              if( j<n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22 (note that conjg(w) is actually stored)
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update column k of w
              w( k, k ) = real( a( k, k ),KIND=sp)
              if( k<n )call stdlib_ccopy( n-k, a( k+1, k ), 1, w( k+1, k ), 1 )
              if( k>1 ) then
                 call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( k, 1 ), &
                           ldw, cone, w( k, k ), 1 )
                 w( k, k ) = real( w( k, k ),KIND=sp)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( w( k, k ),KIND=sp)
                 if( k<n )call stdlib_ccopy( n-k, w( k+1, k ), 1, a( k+1, k ), 1 )
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_ccopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_clacgv( imax-k, w( k, k+1 ), 1 )
                       w( imax, k+1 ) = real( a( imax, imax ),KIND=sp)
                       if( imax<n )call stdlib_ccopy( n-imax, a( imax+1, imax ), 1,w( imax+1, k+1 &
                                 ), 1 )
                       if( k>1 ) then
                          call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone,a( k, 1 ), lda, w( &
                                    imax, 1 ), ldw,cone, w( k, k+1 ), 1 )
                          w( imax, k+1 ) = real( w( imax, k+1 ),KIND=sp)
                       end if
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_icamax( imax-k, w( k, k+1 ), 1 )
                          rowmax = cabs1( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_icamax( n-imax, w( imax+1, k+1 ), 1)
                          stemp = cabs1( w( itemp, k+1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,k+1 ),KIND=sp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( w( imax,k+1 ),KIND=sp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 72
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns p and k (only for 2-by-2 pivot).
                 ! updated column p is already stored in column k of w.
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column kk-1 to column p of submatrix a
                    ! at step k. no need to copy element into columns
                    ! k and k+1 of a for 2-by-2 pivot, since these columns
                    ! will be later overwritten.
                    a( p, p ) = real( a( k, k ),KIND=sp)
                    call stdlib_ccopy( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                    call stdlib_clacgv( p-k-1, a( p, k+1 ), lda )
                    if( p<n )call stdlib_ccopy( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    ! interchange rows k and p in first k-1 columns of a
                    ! (columns k and k+1 of a for 2-by-2 pivot will be
                    ! later overwritten). interchange rows k and p
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_cswap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_cswap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=sp)
                    call stdlib_ccopy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    call stdlib_clacgv( kp-kk-1, a( kp, kk+1 ), lda )
                    if( kp<n )call stdlib_ccopy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (column k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_cswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_cswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! (1) store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=sp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_ccopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(3))
                       ! handle division by a small number
                       t = real( a( k, k ),KIND=sp)
                       if( abs( t )>=sfmin ) then
                          r1 = one / t
                          call stdlib_csscal( n-k, r1, a( k+1, k ), 1 )
                       else
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / t
                          end do
                       end if
                       ! (2) conjugate column w(k)
                       call stdlib_clacgv( n-k, w( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! (1) store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored.
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! handle division by a small number. (note: order of
                       ! operations is important)
                       ! = ( t*(( d11 )/conj(d21)) t*((  -1 )/d21 ) )
                         ! (   ((  -1 )          )   (( d22 )     ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0 in 2x2 pivot case(4),
                            ! since |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / conjg( d21 )
                       t = one / ( real( d11*d22,KIND=sp)-one )
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /conjg( d21 ) )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    ! (2) conjugate columns w(k) and w(k+1)
                    call stdlib_clacgv( n-k, w( k+1, k ), 1 )
                    call stdlib_clacgv( n-k-1, w( k+2, k+1 ), 1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**h = a22 - l21*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                    call stdlib_cgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! of rows in columns 1:k-1 looping backwards from k-1 to 1
              j = k - 1
              120 continue
                 ! undo the interchanges (if any) of rows j and jp2
                 ! (or j and jp2, and j-1 and jp1) at each step j
                 kstep = 1
                 jp1 = 1
                 ! (here, j is a diagonal index)
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    ! (here, j is a diagonal index)
                    j = j - 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 ! (note: here, j is used to determine row length. length j
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j - 1
                 if( jp2/=jj .and. j>=1 )call stdlib_cswap( j, a( jp2, 1 ), lda, a( jj, 1 ), lda )
                           
                 jj = jj -1
                 if( kstep==2 .and. jp1/=jj .and. j>=1 )call stdlib_cswap( j, a( jp1, 1 ), lda, a(&
                            jj, 1 ), lda )
              if( j>1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_clahef_rook


     pure subroutine stdlib_claic1( job, j, x, sest, w, gamma, sestpr, s, c )
     !! CLAIC1 applies one step of incremental condition estimation in
     !! its simplest version:
     !! Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j
     !! lower triangular matrix L, such that
     !! twonorm(L*x) = sest
     !! Then CLAIC1 computes sestpr, s, c such that
     !! the vector
     !! [ s*x ]
     !! xhat = [  c  ]
     !! is an approximate singular vector of
     !! [ L      0  ]
     !! Lhat = [ w**H gamma ]
     !! in the sense that
     !! twonorm(Lhat*xhat) = sestpr.
     !! Depending on JOB, an estimate for the largest or smallest singular
     !! value is computed.
     !! Note that [s c]**H and sestpr**2 is an eigenpair of the system
     !! diag(sest*sest, 0) + [alpha  gamma] * [ conjg(alpha) ]
     !! [ conjg(gamma) ]
     !! where  alpha =  x**H*w.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: j, job
           real(sp), intent(in) :: sest
           real(sp), intent(out) :: sestpr
           complex(sp), intent(out) :: c, s
           complex(sp), intent(in) :: gamma
           ! Array Arguments 
           complex(sp), intent(in) :: w(j), x(j)
        ! =====================================================================
           
           
           ! Local Scalars 
           real(sp) :: absalp, absest, absgam, b, eps, norma, s1, s2, scl, t, test, tmp, zeta1, &
                     zeta2
           complex(sp) :: alpha, cosine, sine
           ! Intrinsic Functions 
           intrinsic :: abs,conjg,max,sqrt
           ! Executable Statements 
           eps = stdlib_slamch( 'EPSILON' )
           alpha = stdlib_cdotc( j, x, 1, w, 1 )
           absalp = abs( alpha )
           absgam = abs( gamma )
           absest = abs( sest )
           if( job==1 ) then
              ! estimating largest singular value
              ! special cases
              if( sest==zero ) then
                 s1 = max( absgam, absalp )
                 if( s1==zero ) then
                    s = zero
                    c = one
                    sestpr = zero
                 else
                    s = alpha / s1
                    c = gamma / s1
                    tmp = real( sqrt( s*conjg( s )+c*conjg( c ) ),KIND=sp)
                    s = s / tmp
                    c = c / tmp
                    sestpr = s1*tmp
                 end if
                 return
              else if( absgam<=eps*absest ) then
                 s = one
                 c = zero
                 tmp = max( absest, absalp )
                 s1 = absest / tmp
                 s2 = absalp / tmp
                 sestpr = tmp*sqrt( s1*s1+s2*s2 )
                 return
              else if( absalp<=eps*absest ) then
                 s1 = absgam
                 s2 = absest
                 if( s1<=s2 ) then
                    s = one
                    c = zero
                    sestpr = s2
                 else
                    s = zero
                    c = one
                    sestpr = s1
                 end if
                 return
              else if( absest<=eps*absalp .or. absest<=eps*absgam ) then
                 s1 = absgam
                 s2 = absalp
                 if( s1<=s2 ) then
                    tmp = s1 / s2
                    scl = sqrt( one+tmp*tmp )
                    sestpr = s2*scl
                    s = ( alpha / s2 ) / scl
                    c = ( gamma / s2 ) / scl
                 else
                    tmp = s2 / s1
                    scl = sqrt( one+tmp*tmp )
                    sestpr = s1*scl
                    s = ( alpha / s1 ) / scl
                    c = ( gamma / s1 ) / scl
                 end if
                 return
              else
                 ! normal case
                 zeta1 = absalp / absest
                 zeta2 = absgam / absest
                 b = ( one-zeta1*zeta1-zeta2*zeta2 )*half
                 c = zeta1*zeta1
                 if( b>zero ) then
                    t = real( c / ( b+sqrt( b*b+c ) ),KIND=sp)
                 else
                    t = real( sqrt( b*b+c ) - b,KIND=sp)
                 end if
                 sine = -( alpha / absest ) / t
                 cosine = -( gamma / absest ) / ( one+t )
                 tmp = real( sqrt( sine * conjg( sine )+ cosine * conjg( cosine ) ),KIND=sp)
                           
                 s = sine / tmp
                 c = cosine / tmp
                 sestpr = sqrt( t+one )*absest
                 return
              end if
           else if( job==2 ) then
              ! estimating smallest singular value
              ! special cases
              if( sest==zero ) then
                 sestpr = zero
                 if( max( absgam, absalp )==zero ) then
                    sine = one
                    cosine = zero
                 else
                    sine = -conjg( gamma )
                    cosine = conjg( alpha )
                 end if
                 s1 = max( abs( sine ), abs( cosine ) )
                 s = sine / s1
                 c = cosine / s1
                 tmp = real( sqrt( s*conjg( s )+c*conjg( c ) ),KIND=sp)
                 s = s / tmp
                 c = c / tmp
                 return
              else if( absgam<=eps*absest ) then
                 s = zero
                 c = one
                 sestpr = absgam
                 return
              else if( absalp<=eps*absest ) then
                 s1 = absgam
                 s2 = absest
                 if( s1<=s2 ) then
                    s = zero
                    c = one
                    sestpr = s1
                 else
                    s = one
                    c = zero
                    sestpr = s2
                 end if
                 return
              else if( absest<=eps*absalp .or. absest<=eps*absgam ) then
                 s1 = absgam
                 s2 = absalp
                 if( s1<=s2 ) then
                    tmp = s1 / s2
                    scl = sqrt( one+tmp*tmp )
                    sestpr = absest*( tmp / scl )
                    s = -( conjg( gamma ) / s2 ) / scl
                    c = ( conjg( alpha ) / s2 ) / scl
                 else
                    tmp = s2 / s1
                    scl = sqrt( one+tmp*tmp )
                    sestpr = absest / scl
                    s = -( conjg( gamma ) / s1 ) / scl
                    c = ( conjg( alpha ) / s1 ) / scl
                 end if
                 return
              else
                 ! normal case
                 zeta1 = absalp / absest
                 zeta2 = absgam / absest
                 norma = max( one+zeta1*zeta1+zeta1*zeta2,zeta1*zeta2+zeta2*zeta2 )
                 ! see if root is closer to zero or to one
                 test = one + two*( zeta1-zeta2 )*( zeta1+zeta2 )
                 if( test>=zero ) then
                    ! root is close to zero, compute directly
                    b = ( zeta1*zeta1+zeta2*zeta2+one )*half
                    c = zeta2*zeta2
                    t = real( c / ( b+sqrt( abs( b*b-c ) ) ),KIND=sp)
                    sine = ( alpha / absest ) / ( one-t )
                    cosine = -( gamma / absest ) / t
                    sestpr = sqrt( t+four*eps*eps*norma )*absest
                 else
                    ! root is closer to one, shift by that amount
                    b = ( zeta2*zeta2+zeta1*zeta1-one )*half
                    c = zeta1*zeta1
                    if( b>=zero ) then
                       t = real( -c / ( b+sqrt( b*b+c ) ),KIND=sp)
                    else
                       t = real( b - sqrt( b*b+c ),KIND=sp)
                    end if
                    sine = -( alpha / absest ) / t
                    cosine = -( gamma / absest ) / ( one+t )
                    sestpr = sqrt( one+t+four*eps*eps*norma )*absest
                 end if
                 tmp = real( sqrt( sine * conjg( sine )+ cosine * conjg( cosine ) ),KIND=sp)
                           
                 s = sine / tmp
                 c = cosine / tmp
                 return
              end if
           end if
           return
     end subroutine stdlib_claic1


     pure subroutine stdlib_clapmr( forwrd, m, n, x, ldx, k )
     !! CLAPMR rearranges the rows of the M by N matrix X as specified
     !! by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
     !! If FORWRD = .TRUE.,  forward permutation:
     !! X(K(I),*) is moved X(I,*) for I = 1,2,...,M.
     !! If FORWRD = .FALSE., backward permutation:
     !! X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: forwrd
           integer(ilp), intent(in) :: ldx, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: k(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, in, j, jj
           complex(sp) :: temp
           ! Executable Statements 
           if( m<=1 )return
           do i = 1, m
              k( i ) = -k( i )
           end do
           if( forwrd ) then
              ! forward permutation
              do i = 1, m
                 if( k( i )>0 )go to 40
                 j = i
                 k( j ) = -k( j )
                 in = k( j )
                 20 continue
                 if( k( in )>0 )go to 40
                 do jj = 1, n
                    temp = x( j, jj )
                    x( j, jj ) = x( in, jj )
                    x( in, jj ) = temp
                 end do
                 k( in ) = -k( in )
                 j = in
                 in = k( in )
                 go to 20
                 40 continue
              end do
           else
              ! backward permutation
              do i = 1, m
                 if( k( i )>0 )go to 80
                 k( i ) = -k( i )
                 j = k( i )
                 60 continue
                 if( j==i )go to 80
                 do jj = 1, n
                    temp = x( i, jj )
                    x( i, jj ) = x( j, jj )
                    x( j, jj ) = temp
                 end do
                 k( j ) = -k( j )
                 j = k( j )
                 go to 60
                 80 continue
              end do
           end if
           return
     end subroutine stdlib_clapmr


     pure subroutine stdlib_clapmt( forwrd, m, n, x, ldx, k )
     !! CLAPMT rearranges the columns of the M by N matrix X as specified
     !! by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
     !! If FORWRD = .TRUE.,  forward permutation:
     !! X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
     !! If FORWRD = .FALSE., backward permutation:
     !! X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: forwrd
           integer(ilp), intent(in) :: ldx, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: k(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ii, j, in
           complex(sp) :: temp
           ! Executable Statements 
           if( n<=1 )return
           do i = 1, n
              k( i ) = -k( i )
           end do
           if( forwrd ) then
              ! forward permutation
              do i = 1, n
                 if( k( i )>0 )go to 40
                 j = i
                 k( j ) = -k( j )
                 in = k( j )
                 20 continue
                 if( k( in )>0 )go to 40
                 do ii = 1, m
                    temp = x( ii, j )
                    x( ii, j ) = x( ii, in )
                    x( ii, in ) = temp
                 end do
                 k( in ) = -k( in )
                 j = in
                 in = k( in )
                 go to 20
                 40 continue
              end do
           else
              ! backward permutation
              do i = 1, n
                 if( k( i )>0 )go to 100
                 k( i ) = -k( i )
                 j = k( i )
                 80 continue
                 if( j==i )go to 100
                 do ii = 1, m
                    temp = x( ii, i )
                    x( ii, i ) = x( ii, j )
                    x( ii, j ) = temp
                 end do
                 k( j ) = -k( j )
                 j = k( j )
                 go to 80
                 100 continue
              end do
           end if
           return
     end subroutine stdlib_clapmt


     pure subroutine stdlib_claqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, equed )
     !! CLAQGB equilibrates a general M by N band matrix A with KL
     !! subdiagonals and KU superdiagonals using the row and scaling factors
     !! in the vectors R and C.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(out) :: equed
           integer(ilp), intent(in) :: kl, ku, ldab, m, n
           real(sp), intent(in) :: amax, colcnd, rowcnd
           ! Array Arguments 
           real(sp), intent(in) :: c(*), r(*)
           complex(sp), intent(inout) :: ab(ldab,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: thresh = 0.1e+0_sp
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: cj, large, small
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! quick return if possible
           if( m<=0 .or. n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_slamch( 'SAFE MINIMUM' ) / stdlib_slamch( 'PRECISION' )
           large = one / small
           if( rowcnd>=thresh .and. amax>=small .and. amax<=large )then
              ! no row scaling
              if( colcnd>=thresh ) then
                 ! no column scaling
                 equed = 'N'
              else
                 ! column scaling
                 do j = 1, n
                    cj = c( j )
                    do i = max( 1, j-ku ), min( m, j+kl )
                       ab( ku+1+i-j, j ) = cj*ab( ku+1+i-j, j )
                    end do
                 end do
                 equed = 'C'
              end if
           else if( colcnd>=thresh ) then
              ! row scaling, no column scaling
              do j = 1, n
                 do i = max( 1, j-ku ), min( m, j+kl )
                    ab( ku+1+i-j, j ) = r( i )*ab( ku+1+i-j, j )
                 end do
              end do
              equed = 'R'
           else
              ! row and column scaling
              do j = 1, n
                 cj = c( j )
                 do i = max( 1, j-ku ), min( m, j+kl )
                    ab( ku+1+i-j, j ) = cj*r( i )*ab( ku+1+i-j, j )
                 end do
              end do
              equed = 'B'
           end if
           return
     end subroutine stdlib_claqgb


     pure subroutine stdlib_claqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,equed )
     !! CLAQGE equilibrates a general M by N matrix A using the row and
     !! column scaling factors in the vectors R and C.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(out) :: equed
           integer(ilp), intent(in) :: lda, m, n
           real(sp), intent(in) :: amax, colcnd, rowcnd
           ! Array Arguments 
           real(sp), intent(in) :: c(*), r(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: thresh = 0.1e+0_sp
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: cj, large, small
           ! Executable Statements 
           ! quick return if possible
           if( m<=0 .or. n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_slamch( 'SAFE MINIMUM' ) / stdlib_slamch( 'PRECISION' )
           large = one / small
           if( rowcnd>=thresh .and. amax>=small .and. amax<=large )then
              ! no row scaling
              if( colcnd>=thresh ) then
                 ! no column scaling
                 equed = 'N'
              else
                 ! column scaling
                 do j = 1, n
                    cj = c( j )
                    do i = 1, m
                       a( i, j ) = cj*a( i, j )
                    end do
                 end do
                 equed = 'C'
              end if
           else if( colcnd>=thresh ) then
              ! row scaling, no column scaling
              do j = 1, n
                 do i = 1, m
                    a( i, j ) = r( i )*a( i, j )
                 end do
              end do
              equed = 'R'
           else
              ! row and column scaling
              do j = 1, n
                 cj = c( j )
                 do i = 1, m
                    a( i, j ) = cj*r( i )*a( i, j )
                 end do
              end do
              equed = 'B'
           end if
           return
     end subroutine stdlib_claqge


     pure subroutine stdlib_claqhb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
     !! CLAQHB equilibrates an Hermitian band matrix A using the scaling
     !! factors in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: kd, ldab, n
           real(sp), intent(in) :: amax, scond
           ! Array Arguments 
           real(sp), intent(out) :: s(*)
           complex(sp), intent(inout) :: ab(ldab,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: thresh = 0.1e+0_sp
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: cj, large, small
           ! Intrinsic Functions 
           intrinsic :: max,min,real
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_slamch( 'SAFE MINIMUM' ) / stdlib_slamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored in band format.
                 do j = 1, n
                    cj = s( j )
                    do i = max( 1, j-kd ), j - 1
                       ab( kd+1+i-j, j ) = cj*s( i )*ab( kd+1+i-j, j )
                    end do
                    ab( kd+1, j ) = cj*cj*real( ab( kd+1, j ),KIND=sp)
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    ab( 1, j ) = cj*cj*real( ab( 1, j ),KIND=sp)
                    do i = j + 1, min( n, j+kd )
                       ab( 1+i-j, j ) = cj*s( i )*ab( 1+i-j, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_claqhb


     pure subroutine stdlib_claqhe( uplo, n, a, lda, s, scond, amax, equed )
     !! CLAQHE equilibrates a Hermitian matrix A using the scaling factors
     !! in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(in) :: amax, scond
           ! Array Arguments 
           real(sp), intent(in) :: s(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: thresh = 0.1e+0_sp
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: cj, large, small
           ! Intrinsic Functions 
           intrinsic :: real
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_slamch( 'SAFE MINIMUM' ) / stdlib_slamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = 1, j - 1
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                    a( j, j ) = cj*cj*real( a( j, j ),KIND=sp)
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    a( j, j ) = cj*cj*real( a( j, j ),KIND=sp)
                    do i = j + 1, n
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_claqhe


     pure subroutine stdlib_claqhp( uplo, n, ap, s, scond, amax, equed )
     !! CLAQHP equilibrates a Hermitian matrix A using the scaling factors
     !! in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n
           real(sp), intent(in) :: amax, scond
           ! Array Arguments 
           real(sp), intent(in) :: s(*)
           complex(sp), intent(inout) :: ap(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: thresh = 0.1e+0_sp
           
           ! Local Scalars 
           integer(ilp) :: i, j, jc
           real(sp) :: cj, large, small
           ! Intrinsic Functions 
           intrinsic :: real
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_slamch( 'SAFE MINIMUM' ) / stdlib_slamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored.
                 jc = 1
                 do j = 1, n
                    cj = s( j )
                    do i = 1, j - 1
                       ap( jc+i-1 ) = cj*s( i )*ap( jc+i-1 )
                    end do
                    ap( jc+j-1 ) = cj*cj*real( ap( jc+j-1 ),KIND=sp)
                    jc = jc + j
                 end do
              else
                 ! lower triangle of a is stored.
                 jc = 1
                 do j = 1, n
                    cj = s( j )
                    ap( jc ) = cj*cj*real( ap( jc ),KIND=sp)
                    do i = j + 1, n
                       ap( jc+i-j ) = cj*s( i )*ap( jc+i-j )
                    end do
                    jc = jc + n - j + 1
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_claqhp


     pure subroutine stdlib_claqr1( n, h, ldh, s1, s2, v )
     !! Given a 2-by-2 or 3-by-3 matrix H, CLAQR1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (H - s1*I)*(H - s2*I)
     !! scaling to avoid overflows and most underflows.
     !! This is useful for starting double implicit shift bulges
     !! in the QR algorithm.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           complex(sp), intent(in) :: s1, s2
           integer(ilp), intent(in) :: ldh, n
           ! Array Arguments 
           complex(sp), intent(in) :: h(ldh,*)
           complex(sp), intent(out) :: v(*)
        ! ================================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0_sp
           
           
           ! Local Scalars 
           complex(sp) :: cdum, h21s, h31s
           real(sp) :: s
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! quick return if possible
           if( n/=2 .and. n/=3 ) then
              return
           end if
           if( n==2 ) then
              s = cabs1( h( 1, 1 )-s2 ) + cabs1( h( 2, 1 ) )
              if( s==rzero ) then
                 v( 1 ) = czero
                 v( 2 ) = czero
              else
                 h21s = h( 2, 1 ) / s
                 v( 1 ) = h21s*h( 1, 2 ) + ( h( 1, 1 )-s1 )*( ( h( 1, 1 )-s2 ) / s )
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-s1-s2 )
              end if
           else
              s = cabs1( h( 1, 1 )-s2 ) + cabs1( h( 2, 1 ) ) +cabs1( h( 3, 1 ) )
              if( s==czero ) then
                 v( 1 ) = czero
                 v( 2 ) = czero
                 v( 3 ) = czero
              else
                 h21s = h( 2, 1 ) / s
                 h31s = h( 3, 1 ) / s
                 v( 1 ) = ( h( 1, 1 )-s1 )*( ( h( 1, 1 )-s2 ) / s ) +h( 1, 2 )*h21s + h( 1, 3 )&
                           *h31s
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-s1-s2 ) + h( 2, 3 )*h31s
                 v( 3 ) = h31s*( h( 1, 1 )+h( 3, 3 )-s1-s2 ) + h21s*h( 3, 2 )
              end if
           end if
     end subroutine stdlib_claqr1


     pure subroutine stdlib_claqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
     !! CLAQSB equilibrates a symmetric band matrix A using the scaling
     !! factors in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: kd, ldab, n
           real(sp), intent(in) :: amax, scond
           ! Array Arguments 
           real(sp), intent(in) :: s(*)
           complex(sp), intent(inout) :: ab(ldab,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: thresh = 0.1e+0_sp
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: cj, large, small
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_slamch( 'SAFE MINIMUM' ) / stdlib_slamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored in band format.
                 do j = 1, n
                    cj = s( j )
                    do i = max( 1, j-kd ), j
                       ab( kd+1+i-j, j ) = cj*s( i )*ab( kd+1+i-j, j )
                    end do
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = j, min( n, j+kd )
                       ab( 1+i-j, j ) = cj*s( i )*ab( 1+i-j, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_claqsb


     pure subroutine stdlib_claqsp( uplo, n, ap, s, scond, amax, equed )
     !! CLAQSP equilibrates a symmetric matrix A using the scaling factors
     !! in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n
           real(sp), intent(in) :: amax, scond
           ! Array Arguments 
           real(sp), intent(in) :: s(*)
           complex(sp), intent(inout) :: ap(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: thresh = 0.1e+0_sp
           
           ! Local Scalars 
           integer(ilp) :: i, j, jc
           real(sp) :: cj, large, small
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_slamch( 'SAFE MINIMUM' ) / stdlib_slamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored.
                 jc = 1
                 do j = 1, n
                    cj = s( j )
                    do i = 1, j
                       ap( jc+i-1 ) = cj*s( i )*ap( jc+i-1 )
                    end do
                    jc = jc + j
                 end do
              else
                 ! lower triangle of a is stored.
                 jc = 1
                 do j = 1, n
                    cj = s( j )
                    do i = j, n
                       ap( jc+i-j ) = cj*s( i )*ap( jc+i-j )
                    end do
                    jc = jc + n - j + 1
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_claqsp


     pure subroutine stdlib_claqsy( uplo, n, a, lda, s, scond, amax, equed )
     !! CLAQSY equilibrates a symmetric matrix A using the scaling factors
     !! in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(in) :: amax, scond
           ! Array Arguments 
           real(sp), intent(in) :: s(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: thresh = 0.1e+0_sp
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: cj, large, small
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_slamch( 'SAFE MINIMUM' ) / stdlib_slamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = 1, j
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = j, n
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_claqsy


     pure subroutine stdlib_clar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc, &
     !! CLAR1V computes the (scaled) r-th column of the inverse of
     !! the sumbmatrix in rows B1 through BN of the tridiagonal matrix
     !! L D L**T - sigma I. When sigma is close to an eigenvalue, the
     !! computed vector is an accurate eigenvector. Usually, r corresponds
     !! to the index where the eigenvector is largest in magnitude.
     !! The following steps accomplish this computation :
     !! (a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,
     !! (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
     !! (c) Computation of the diagonal elements of the inverse of
     !! L D L**T - sigma I by combining the above transforms, and choosing
     !! r as the index where the diagonal of the inverse is (one of the)
     !! largest in magnitude.
     !! (d) Computation of the (scaled) r-th column of the inverse using the
     !! twisted factorization obtained by combining the top part of the
     !! the stationary and the bottom part of the progressive transform.
               negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantnc
           integer(ilp), intent(in) :: b1, bn, n
           integer(ilp), intent(out) :: negcnt
           integer(ilp), intent(inout) :: r
           real(sp), intent(in) :: gaptol, lambda, pivmin
           real(sp), intent(out) :: mingma, nrminv, resid, rqcorr, ztz
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*)
           real(sp), intent(in) :: d(*), l(*), ld(*), lld(*)
           real(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: z(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: sawnan1, sawnan2
           integer(ilp) :: i, indlpl, indp, inds, indumn, neg1, neg2, r1, r2
           real(sp) :: dminus, dplus, eps, s, tmp
           ! Intrinsic Functions 
           intrinsic :: abs,real
           ! Executable Statements 
           eps = stdlib_slamch( 'PRECISION' )
           if( r==0 ) then
              r1 = b1
              r2 = bn
           else
              r1 = r
              r2 = r
           end if
           ! storage for lplus
           indlpl = 0
           ! storage for uminus
           indumn = n
           inds = 2*n + 1
           indp = 3*n + 1
           if( b1==1 ) then
              work( inds ) = zero
           else
              work( inds+b1-1 ) = lld( b1-1 )
           end if
           ! compute the stationary transform (using the differential form)
           ! until the index r2.
           sawnan1 = .false.
           neg1 = 0
           s = work( inds+b1-1 ) - lambda
           do i = b1, r1 - 1
              dplus = d( i ) + s
              work( indlpl+i ) = ld( i ) / dplus
              if(dplus<zero) neg1 = neg1 + 1
              work( inds+i ) = s*work( indlpl+i )*l( i )
              s = work( inds+i ) - lambda
           end do
           sawnan1 = stdlib_sisnan( s )
           if( sawnan1 ) goto 60
           do i = r1, r2 - 1
              dplus = d( i ) + s
              work( indlpl+i ) = ld( i ) / dplus
              work( inds+i ) = s*work( indlpl+i )*l( i )
              s = work( inds+i ) - lambda
           end do
           sawnan1 = stdlib_sisnan( s )
           60 continue
           if( sawnan1 ) then
              ! runs a slower version of the above loop if a nan is detected
              neg1 = 0
              s = work( inds+b1-1 ) - lambda
              do i = b1, r1 - 1
                 dplus = d( i ) + s
                 if(abs(dplus)<pivmin) dplus = -pivmin
                 work( indlpl+i ) = ld( i ) / dplus
                 if(dplus<zero) neg1 = neg1 + 1
                 work( inds+i ) = s*work( indlpl+i )*l( i )
                 if( work( indlpl+i )==zero )work( inds+i ) = lld( i )
                 s = work( inds+i ) - lambda
              end do
              do i = r1, r2 - 1
                 dplus = d( i ) + s
                 if(abs(dplus)<pivmin) dplus = -pivmin
                 work( indlpl+i ) = ld( i ) / dplus
                 work( inds+i ) = s*work( indlpl+i )*l( i )
                 if( work( indlpl+i )==zero )work( inds+i ) = lld( i )
                 s = work( inds+i ) - lambda
              end do
           end if
           ! compute the progressive transform (using the differential form)
           ! until the index r1
           sawnan2 = .false.
           neg2 = 0
           work( indp+bn-1 ) = d( bn ) - lambda
           do i = bn - 1, r1, -1
              dminus = lld( i ) + work( indp+i )
              tmp = d( i ) / dminus
              if(dminus<zero) neg2 = neg2 + 1
              work( indumn+i ) = l( i )*tmp
              work( indp+i-1 ) = work( indp+i )*tmp - lambda
           end do
           tmp = work( indp+r1-1 )
           sawnan2 = stdlib_sisnan( tmp )
           if( sawnan2 ) then
              ! runs a slower version of the above loop if a nan is detected
              neg2 = 0
              do i = bn-1, r1, -1
                 dminus = lld( i ) + work( indp+i )
                 if(abs(dminus)<pivmin) dminus = -pivmin
                 tmp = d( i ) / dminus
                 if(dminus<zero) neg2 = neg2 + 1
                 work( indumn+i ) = l( i )*tmp
                 work( indp+i-1 ) = work( indp+i )*tmp - lambda
                 if( tmp==zero )work( indp+i-1 ) = d( i ) - lambda
              end do
           end if
           ! find the index (from r1 to r2) of the largest (in magnitude)
           ! diagonal element of the inverse
           mingma = work( inds+r1-1 ) + work( indp+r1-1 )
           if( mingma<zero ) neg1 = neg1 + 1
           if( wantnc ) then
              negcnt = neg1 + neg2
           else
              negcnt = -1
           endif
           if( abs(mingma)==zero )mingma = eps*work( inds+r1-1 )
           r = r1
           do i = r1, r2 - 1
              tmp = work( inds+i ) + work( indp+i )
              if( tmp==zero )tmp = eps*work( inds+i )
              if( abs( tmp )<=abs( mingma ) ) then
                 mingma = tmp
                 r = i + 1
              end if
           end do
           ! compute the fp vector: solve n^t v = e_r
           isuppz( 1 ) = b1
           isuppz( 2 ) = bn
           z( r ) = cone
           ztz = one
           ! compute the fp vector upwards from r
           if( .not.sawnan1 .and. .not.sawnan2 ) then
              do i = r-1, b1, -1
                 z( i ) = -( work( indlpl+i )*z( i+1 ) )
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i ) = zero
                    isuppz( 1 ) = i + 1
                    goto 220
                 endif
                 ztz = ztz + real( z( i )*z( i ),KIND=sp)
              end do
              220 continue
           else
              ! run slower loop if nan occurred.
              do i = r - 1, b1, -1
                 if( z( i+1 )==zero ) then
                    z( i ) = -( ld( i+1 ) / ld( i ) )*z( i+2 )
                 else
                    z( i ) = -( work( indlpl+i )*z( i+1 ) )
                 end if
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i ) = zero
                    isuppz( 1 ) = i + 1
                    go to 240
                 end if
                 ztz = ztz + real( z( i )*z( i ),KIND=sp)
              end do
              240 continue
           endif
           ! compute the fp vector downwards from r in blocks of size blksiz
           if( .not.sawnan1 .and. .not.sawnan2 ) then
              do i = r, bn-1
                 z( i+1 ) = -( work( indumn+i )*z( i ) )
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i+1 ) = zero
                    isuppz( 2 ) = i
                    go to 260
                 end if
                 ztz = ztz + real( z( i+1 )*z( i+1 ),KIND=sp)
              end do
              260 continue
           else
              ! run slower loop if nan occurred.
              do i = r, bn - 1
                 if( z( i )==zero ) then
                    z( i+1 ) = -( ld( i-1 ) / ld( i ) )*z( i-1 )
                 else
                    z( i+1 ) = -( work( indumn+i )*z( i ) )
                 end if
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i+1 ) = zero
                    isuppz( 2 ) = i
                    go to 280
                 end if
                 ztz = ztz + real( z( i+1 )*z( i+1 ),KIND=sp)
              end do
              280 continue
           end if
           ! compute quantities for convergence test
           tmp = one / ztz
           nrminv = sqrt( tmp )
           resid = abs( mingma )*nrminv
           rqcorr = mingma*tmp
           return
     end subroutine stdlib_clar1v


     pure subroutine stdlib_clar2v( n, x, y, z, incx, c, s, incc )
     !! CLAR2V applies a vector of complex plane rotations with real cosines
     !! from both sides to a sequence of 2-by-2 complex Hermitian matrices,
     !! defined by the elements of the vectors x, y and z. For i = 1,2,...,n
     !! (       x(i)  z(i) ) :=
     !! ( conjg(z(i)) y(i) )
     !! (  c(i) conjg(s(i)) ) (       x(i)  z(i) ) ( c(i) -conjg(s(i)) )
     !! ( -s(i)       c(i)  ) ( conjg(z(i)) y(i) ) ( s(i)        c(i)  )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incc, incx, n
           ! Array Arguments 
           real(sp), intent(in) :: c(*)
           complex(sp), intent(in) :: s(*)
           complex(sp), intent(inout) :: x(*), y(*), z(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ic, ix
           real(sp) :: ci, sii, sir, t1i, t1r, t5, t6, xi, yi, zii, zir
           complex(sp) :: si, t2, t3, t4, zi
           ! Intrinsic Functions 
           intrinsic :: aimag,cmplx,conjg,real
           ! Executable Statements 
           ix = 1
           ic = 1
           do i = 1, n
              xi = real( x( ix ),KIND=sp)
              yi = real( y( ix ),KIND=sp)
              zi = z( ix )
              zir = real( zi,KIND=sp)
              zii = aimag( zi )
              ci = c( ic )
              si = s( ic )
              sir = real( si,KIND=sp)
              sii = aimag( si )
              t1r = sir*zir - sii*zii
              t1i = sir*zii + sii*zir
              t2 = ci*zi
              t3 = t2 - conjg( si )*xi
              t4 = conjg( t2 ) + si*yi
              t5 = ci*xi + t1r
              t6 = ci*yi - t1r
              x( ix ) = ci*t5 + ( sir*real( t4,KIND=sp)+sii*aimag( t4 ) )
              y( ix ) = ci*t6 - ( sir*real( t3,KIND=sp)-sii*aimag( t3 ) )
              z( ix ) = ci*t3 + conjg( si )*cmplx( t6, t1i,KIND=sp)
              ix = ix + incx
              ic = ic + incc
           end do
           return
     end subroutine stdlib_clar2v


     pure subroutine stdlib_clarcm( m, n, a, lda, b, ldb, c, ldc, rwork )
     !! CLARCM performs a very simple matrix-matrix multiplication:
     !! C := A * B,
     !! where A is M by M and real; B is M by N and complex;
     !! C is M by N and complex.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: lda, ldb, ldc, m, n
           ! Array Arguments 
           real(sp), intent(in) :: a(lda,*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(in) :: b(ldb,*)
           complex(sp), intent(out) :: c(ldc,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, l
           ! Intrinsic Functions 
           intrinsic :: aimag,cmplx,real
           ! Executable Statements 
           ! quick return if possible.
           if( ( m==0 ) .or. ( n==0 ) )return
           do j = 1, n
              do i = 1, m
                 rwork( ( j-1 )*m+i ) = real( b( i, j ),KIND=sp)
              end do
           end do
           l = m*n + 1
           call stdlib_sgemm( 'N', 'N', m, n, m, one, a, lda, rwork, m, zero,rwork( l ), m )
                     
           do j = 1, n
              do i = 1, m
                 c( i, j ) = rwork( l+( j-1 )*m+i-1 )
              end do
           end do
           do j = 1, n
              do i = 1, m
                 rwork( ( j-1 )*m+i ) = aimag( b( i, j ) )
              end do
           end do
           call stdlib_sgemm( 'N', 'N', m, n, m, one, a, lda, rwork, m, zero,rwork( l ), m )
                     
           do j = 1, n
              do i = 1, m
                 c( i, j ) = cmplx( real( c( i, j ),KIND=sp),rwork( l+( j-1 )*m+i-1 ),KIND=sp)
                           
              end do
           end do
           return
     end subroutine stdlib_clarcm


     pure subroutine stdlib_clarf( side, m, n, v, incv, tau, c, ldc, work )
     !! CLARF applies a complex elementary reflector H to a complex M-by-N
     !! matrix C, from either the left or the right. H is represented in the
     !! form
     !! H = I - tau * v * v**H
     !! where tau is a complex scalar and v is a complex vector.
     !! If tau = 0, then H is taken to be the unit matrix.
     !! To apply H**H (the conjugate transpose of H), supply conjg(tau) instead
     !! tau.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side
           integer(ilp), intent(in) :: incv, ldc, m, n
           complex(sp), intent(in) :: tau
           ! Array Arguments 
           complex(sp), intent(inout) :: c(ldc,*)
           complex(sp), intent(in) :: v(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: applyleft
           integer(ilp) :: i, lastv, lastc
           ! Executable Statements 
           applyleft = stdlib_lsame( side, 'L' )
           lastv = 0
           lastc = 0
           if( tau/=czero ) then
           ! set up variables for scanning v.  lastv begins pointing to the end
           ! of v.
              if( applyleft ) then
                 lastv = m
              else
                 lastv = n
              end if
              if( incv>0 ) then
                 i = 1 + (lastv-1) * incv
              else
                 i = 1
              end if
           ! look for the last non-czero row in v.
              do while( lastv>0 .and. v( i )==czero )
                 lastv = lastv - 1
                 i = i - incv
              end do
              if( applyleft ) then
           ! scan for the last non-czero column in c(1:lastv,:).
                 lastc = stdlib_ilaclc(lastv, n, c, ldc)
              else
           ! scan for the last non-czero row in c(:,1:lastv).
                 lastc = stdlib_ilaclr(m, lastv, c, ldc)
              end if
           end if
           ! note that lastc.eq.0_sp renders the blas operations null; no special
           ! case is needed at this level.
           if( applyleft ) then
              ! form  h * c
              if( lastv>0 ) then
                 ! w(1:lastc,1) := c(1:lastv,1:lastc)**h * v(1:lastv,1)
                 call stdlib_cgemv( 'CONJUGATE TRANSPOSE', lastv, lastc, cone,c, ldc, v, incv, &
                           czero, work, 1 )
                 ! c(1:lastv,1:lastc) := c(...) - v(1:lastv,1) * w(1:lastc,1)**h
                 call stdlib_cgerc( lastv, lastc, -tau, v, incv, work, 1, c, ldc )
              end if
           else
              ! form  c * h
              if( lastv>0 ) then
                 ! w(1:lastc,1) := c(1:lastc,1:lastv) * v(1:lastv,1)
                 call stdlib_cgemv( 'NO TRANSPOSE', lastc, lastv, cone, c, ldc,v, incv, czero, &
                           work, 1 )
                 ! c(1:lastc,1:lastv) := c(...) - w(1:lastc,1) * v(1:lastv,1)**h
                 call stdlib_cgerc( lastc, lastv, -tau, work, 1, v, incv, c, ldc )
              end if
           end if
           return
     end subroutine stdlib_clarf


     pure subroutine stdlib_clarfb( side, trans, direct, storev, m, n, k, v, ldv,t, ldt, c, ldc, &
     !! CLARFB applies a complex block reflector H or its transpose H**H to a
     !! complex M-by-N matrix C, from either the left or the right.
               work, ldwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: direct, side, storev, trans
           integer(ilp), intent(in) :: k, ldc, ldt, ldv, ldwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: c(ldc,*)
           complex(sp), intent(in) :: t(ldt,*), v(ldv,*)
           complex(sp), intent(out) :: work(ldwork,*)
        ! =====================================================================
           
           ! Local Scalars 
           character :: transt
           integer(ilp) :: i, j
           ! Intrinsic Functions 
           intrinsic :: conjg
           ! Executable Statements 
           ! quick return if possible
           if( m<=0 .or. n<=0 )return
           if( stdlib_lsame( trans, 'N' ) ) then
              transt = 'C'
           else
              transt = 'N'
           end if
           if( stdlib_lsame( storev, 'C' ) ) then
              if( stdlib_lsame( direct, 'F' ) ) then
                 ! let  v =  ( v1 )    (first k rows)
                           ! ( v2 )
                 ! where  v1  is unit lower triangular.
                 if( stdlib_lsame( side, 'L' ) ) then
                    ! form  h * c  or  h**h * c  where  c = ( c1 )
                                                          ! ( c2 )
                    ! w := c**h * v  =  (c1**h * v1 + c2**h * v2)  (stored in work)
                    ! w := c1**h
                    do j = 1, k
                       call stdlib_ccopy( n, c( j, 1 ), ldc, work( 1, j ), 1 )
                       call stdlib_clacgv( n, work( 1, j ), 1 )
                    end do
                    ! w := w * v1
                    call stdlib_ctrmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE', 'UNIT', n,k, cone, v, &
                              ldv, work, ldwork )
                    if( m>k ) then
                       ! w := w + c2**h *v2
                       call stdlib_cgemm( 'CONJUGATE TRANSPOSE', 'NO TRANSPOSE', n,k, m-k, cone, &
                                 c( k+1, 1 ), ldc,v( k+1, 1 ), ldv, cone, work, ldwork )
                    end if
                    ! w := w * t**h  or  w * t
                    call stdlib_ctrmm( 'RIGHT', 'UPPER', transt, 'NON-UNIT', n, k,cone, t, ldt, &
                              work, ldwork )
                    ! c := c - v * w**h
                    if( m>k ) then
                       ! c2 := c2 - v2 * w**h
                       call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',m-k, n, k, -cone, &
                                 v( k+1, 1 ), ldv, work,ldwork, cone, c( k+1, 1 ), ldc )
                    end if
                    ! w := w * v1**h
                    call stdlib_ctrmm( 'RIGHT', 'LOWER', 'CONJUGATE TRANSPOSE','UNIT', n, k, cone,&
                               v, ldv, work, ldwork )
                    ! c1 := c1 - w**h
                    do j = 1, k
                       do i = 1, n
                          c( j, i ) = c( j, i ) - conjg( work( i, j ) )
                       end do
                    end do
                 else if( stdlib_lsame( side, 'R' ) ) then
                    ! form  c * h  or  c * h**h  where  c = ( c1  c2 )
                    ! w := c * v  =  (c1*v1 + c2*v2)  (stored in work)
                    ! w := c1
                    do j = 1, k
                       call stdlib_ccopy( m, c( 1, j ), 1, work( 1, j ), 1 )
                    end do
                    ! w := w * v1
                    call stdlib_ctrmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE', 'UNIT', m,k, cone, v, &
                              ldv, work, ldwork )
                    if( n>k ) then
                       ! w := w + c2 * v2
                       call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', m, k, n-k,cone, c( 1, k+&
                                 1 ), ldc, v( k+1, 1 ), ldv,cone, work, ldwork )
                    end if
                    ! w := w * t  or  w * t**h
                    call stdlib_ctrmm( 'RIGHT', 'UPPER', trans, 'NON-UNIT', m, k,cone, t, ldt, &
                              work, ldwork )
                    ! c := c - w * v**h
                    if( n>k ) then
                       ! c2 := c2 - w * v2**h
                       call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE', m,n-k, k, -cone, &
                                 work, ldwork, v( k+1, 1 ),ldv, cone, c( 1, k+1 ), ldc )
                    end if
                    ! w := w * v1**h
                    call stdlib_ctrmm( 'RIGHT', 'LOWER', 'CONJUGATE TRANSPOSE','UNIT', m, k, cone,&
                               v, ldv, work, ldwork )
                    ! c1 := c1 - w
                    do j = 1, k
                       do i = 1, m
                          c( i, j ) = c( i, j ) - work( i, j )
                       end do
                    end do
                 end if
              else
                 ! let  v =  ( v1 )
                           ! ( v2 )    (last k rows)
                 ! where  v2  is unit upper triangular.
                 if( stdlib_lsame( side, 'L' ) ) then
                    ! form  h * c  or  h**h * c  where  c = ( c1 )
                                                        ! ( c2 )
                    ! w := c**h * v  =  (c1**h * v1 + c2**h * v2)  (stored in work)
                    ! w := c2**h
                    do j = 1, k
                       call stdlib_ccopy( n, c( m-k+j, 1 ), ldc, work( 1, j ), 1 )
                       call stdlib_clacgv( n, work( 1, j ), 1 )
                    end do
                    ! w := w * v2
                    call stdlib_ctrmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE', 'UNIT', n,k, cone, v( m-&
                              k+1, 1 ), ldv, work, ldwork )
                    if( m>k ) then
                       ! w := w + c1**h * v1
                       call stdlib_cgemm( 'CONJUGATE TRANSPOSE', 'NO TRANSPOSE', n,k, m-k, cone, &
                                 c, ldc, v, ldv, cone, work,ldwork )
                    end if
                    ! w := w * t**h  or  w * t
                    call stdlib_ctrmm( 'RIGHT', 'LOWER', transt, 'NON-UNIT', n, k,cone, t, ldt, &
                              work, ldwork )
                    ! c := c - v * w**h
                    if( m>k ) then
                       ! c1 := c1 - v1 * w**h
                       call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',m-k, n, k, -cone, &
                                 v, ldv, work, ldwork,cone, c, ldc )
                    end if
                    ! w := w * v2**h
                    call stdlib_ctrmm( 'RIGHT', 'UPPER', 'CONJUGATE TRANSPOSE','UNIT', n, k, cone,&
                               v( m-k+1, 1 ), ldv, work,ldwork )
                    ! c2 := c2 - w**h
                    do j = 1, k
                       do i = 1, n
                          c( m-k+j, i ) = c( m-k+j, i ) -conjg( work( i, j ) )
                       end do
                    end do
                 else if( stdlib_lsame( side, 'R' ) ) then
                    ! form  c * h  or  c * h**h  where  c = ( c1  c2 )
                    ! w := c * v  =  (c1*v1 + c2*v2)  (stored in work)
                    ! w := c2
                    do j = 1, k
                       call stdlib_ccopy( m, c( 1, n-k+j ), 1, work( 1, j ), 1 )
                    end do
                    ! w := w * v2
                    call stdlib_ctrmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE', 'UNIT', m,k, cone, v( n-&
                              k+1, 1 ), ldv, work, ldwork )
                    if( n>k ) then
                       ! w := w + c1 * v1
                       call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', m, k, n-k,cone, c, ldc, &
                                 v, ldv, cone, work, ldwork )
                    end if
                    ! w := w * t  or  w * t**h
                    call stdlib_ctrmm( 'RIGHT', 'LOWER', trans, 'NON-UNIT', m, k,cone, t, ldt, &
                              work, ldwork )
                    ! c := c - w * v**h
                    if( n>k ) then
                       ! c1 := c1 - w * v1**h
                       call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE', m,n-k, k, -cone, &
                                 work, ldwork, v, ldv, cone,c, ldc )
                    end if
                    ! w := w * v2**h
                    call stdlib_ctrmm( 'RIGHT', 'UPPER', 'CONJUGATE TRANSPOSE','UNIT', m, k, cone,&
                               v( n-k+1, 1 ), ldv, work,ldwork )
                    ! c2 := c2 - w
                    do j = 1, k
                       do i = 1, m
                          c( i, n-k+j ) = c( i, n-k+j ) - work( i, j )
                       end do
                    end do
                 end if
              end if
           else if( stdlib_lsame( storev, 'R' ) ) then
              if( stdlib_lsame( direct, 'F' ) ) then
                 ! let  v =  ( v1  v2 )    (v1: first k columns)
                 ! where  v1  is unit upper triangular.
                 if( stdlib_lsame( side, 'L' ) ) then
                    ! form  h * c  or  h**h * c  where  c = ( c1 )
                                                          ! ( c2 )
                    ! w := c**h * v**h  =  (c1**h * v1**h + c2**h * v2**h) (stored in work)
                    ! w := c1**h
                    do j = 1, k
                       call stdlib_ccopy( n, c( j, 1 ), ldc, work( 1, j ), 1 )
                       call stdlib_clacgv( n, work( 1, j ), 1 )
                    end do
                    ! w := w * v1**h
                    call stdlib_ctrmm( 'RIGHT', 'UPPER', 'CONJUGATE TRANSPOSE','UNIT', n, k, cone,&
                               v, ldv, work, ldwork )
                    if( m>k ) then
                       ! w := w + c2**h * v2**h
                       call stdlib_cgemm( 'CONJUGATE TRANSPOSE','CONJUGATE TRANSPOSE', n, k, m-k, &
                                 cone,c( k+1, 1 ), ldc, v( 1, k+1 ), ldv, cone,work, ldwork )
                    end if
                    ! w := w * t**h  or  w * t
                    call stdlib_ctrmm( 'RIGHT', 'UPPER', transt, 'NON-UNIT', n, k,cone, t, ldt, &
                              work, ldwork )
                    ! c := c - v**h * w**h
                    if( m>k ) then
                       ! c2 := c2 - v2**h * w**h
                       call stdlib_cgemm( 'CONJUGATE TRANSPOSE','CONJUGATE TRANSPOSE', m-k, n, k, &
                                 -cone,v( 1, k+1 ), ldv, work, ldwork, cone,c( k+1, 1 ), ldc )
                    end if
                    ! w := w * v1
                    call stdlib_ctrmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE', 'UNIT', n,k, cone, v, &
                              ldv, work, ldwork )
                    ! c1 := c1 - w**h
                    do j = 1, k
                       do i = 1, n
                          c( j, i ) = c( j, i ) - conjg( work( i, j ) )
                       end do
                    end do
                 else if( stdlib_lsame( side, 'R' ) ) then
                    ! form  c * h  or  c * h**h  where  c = ( c1  c2 )
                    ! w := c * v**h  =  (c1*v1**h + c2*v2**h)  (stored in work)
                    ! w := c1
                    do j = 1, k
                       call stdlib_ccopy( m, c( 1, j ), 1, work( 1, j ), 1 )
                    end do
                    ! w := w * v1**h
                    call stdlib_ctrmm( 'RIGHT', 'UPPER', 'CONJUGATE TRANSPOSE','UNIT', m, k, cone,&
                               v, ldv, work, ldwork )
                    if( n>k ) then
                       ! w := w + c2 * v2**h
                       call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE', m,k, n-k, cone, &
                                 c( 1, k+1 ), ldc,v( 1, k+1 ), ldv, cone, work, ldwork )
                    end if
                    ! w := w * t  or  w * t**h
                    call stdlib_ctrmm( 'RIGHT', 'UPPER', trans, 'NON-UNIT', m, k,cone, t, ldt, &
                              work, ldwork )
                    ! c := c - w * v
                    if( n>k ) then
                       ! c2 := c2 - w * v2
                       call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', m, n-k, k,-cone, work, &
                                 ldwork, v( 1, k+1 ), ldv, cone,c( 1, k+1 ), ldc )
                    end if
                    ! w := w * v1
                    call stdlib_ctrmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE', 'UNIT', m,k, cone, v, &
                              ldv, work, ldwork )
                    ! c1 := c1 - w
                    do j = 1, k
                       do i = 1, m
                          c( i, j ) = c( i, j ) - work( i, j )
                       end do
                    end do
                 end if
              else
                 ! let  v =  ( v1  v2 )    (v2: last k columns)
                 ! where  v2  is unit lower triangular.
                 if( stdlib_lsame( side, 'L' ) ) then
                    ! form  h * c  or  h**h * c  where  c = ( c1 )
                                                          ! ( c2 )
                    ! w := c**h * v**h  =  (c1**h * v1**h + c2**h * v2**h) (stored in work)
                    ! w := c2**h
                    do j = 1, k
                       call stdlib_ccopy( n, c( m-k+j, 1 ), ldc, work( 1, j ), 1 )
                       call stdlib_clacgv( n, work( 1, j ), 1 )
                    end do
                    ! w := w * v2**h
                    call stdlib_ctrmm( 'RIGHT', 'LOWER', 'CONJUGATE TRANSPOSE','UNIT', n, k, cone,&
                               v( 1, m-k+1 ), ldv, work,ldwork )
                    if( m>k ) then
                       ! w := w + c1**h * v1**h
                       call stdlib_cgemm( 'CONJUGATE TRANSPOSE','CONJUGATE TRANSPOSE', n, k, m-k, &
                                 cone, c,ldc, v, ldv, cone, work, ldwork )
                    end if
                    ! w := w * t**h  or  w * t
                    call stdlib_ctrmm( 'RIGHT', 'LOWER', transt, 'NON-UNIT', n, k,cone, t, ldt, &
                              work, ldwork )
                    ! c := c - v**h * w**h
                    if( m>k ) then
                       ! c1 := c1 - v1**h * w**h
                       call stdlib_cgemm( 'CONJUGATE TRANSPOSE','CONJUGATE TRANSPOSE', m-k, n, k, &
                                 -cone, v,ldv, work, ldwork, cone, c, ldc )
                    end if
                    ! w := w * v2
                    call stdlib_ctrmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE', 'UNIT', n,k, cone, v( 1, &
                              m-k+1 ), ldv, work, ldwork )
                    ! c2 := c2 - w**h
                    do j = 1, k
                       do i = 1, n
                          c( m-k+j, i ) = c( m-k+j, i ) -conjg( work( i, j ) )
                       end do
                    end do
                 else if( stdlib_lsame( side, 'R' ) ) then
                    ! form  c * h  or  c * h**h  where  c = ( c1  c2 )
                    ! w := c * v**h  =  (c1*v1**h + c2*v2**h)  (stored in work)
                    ! w := c2
                    do j = 1, k
                       call stdlib_ccopy( m, c( 1, n-k+j ), 1, work( 1, j ), 1 )
                    end do
                    ! w := w * v2**h
                    call stdlib_ctrmm( 'RIGHT', 'LOWER', 'CONJUGATE TRANSPOSE','UNIT', m, k, cone,&
                               v( 1, n-k+1 ), ldv, work,ldwork )
                    if( n>k ) then
                       ! w := w + c1 * v1**h
                       call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE', m,k, n-k, cone, &
                                 c, ldc, v, ldv, cone, work,ldwork )
                    end if
                    ! w := w * t  or  w * t**h
                    call stdlib_ctrmm( 'RIGHT', 'LOWER', trans, 'NON-UNIT', m, k,cone, t, ldt, &
                              work, ldwork )
                    ! c := c - w * v
                    if( n>k ) then
                       ! c1 := c1 - w * v1
                       call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', m, n-k, k,-cone, work, &
                                 ldwork, v, ldv, cone, c, ldc )
                    end if
                    ! w := w * v2
                    call stdlib_ctrmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE', 'UNIT', m,k, cone, v( 1, &
                              n-k+1 ), ldv, work, ldwork )
                    ! c1 := c1 - w
                    do j = 1, k
                       do i = 1, m
                          c( i, n-k+j ) = c( i, n-k+j ) - work( i, j )
                       end do
                    end do
                 end if
              end if
           end if
           return
     end subroutine stdlib_clarfb


     pure subroutine stdlib_clarfb_gett( ident, m, n, k, t, ldt, a, lda, b, ldb,work, ldwork )
     !! CLARFB_GETT applies a complex Householder block reflector H from the
     !! left to a complex (K+M)-by-N  "triangular-pentagonal" matrix
     !! composed of two block matrices: an upper trapezoidal K-by-N matrix A
     !! stored in the array A, and a rectangular M-by-(N-K) matrix B, stored
     !! in the array B. The block reflector H is stored in a compact
     !! WY-representation, where the elementary reflectors are in the
     !! arrays A, B and T. See Further Details section.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: ident
           integer(ilp), intent(in) :: k, lda, ldb, ldt, ldwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(in) :: t(ldt,*)
           complex(sp), intent(out) :: work(ldwork,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lnotident
           integer(ilp) :: i, j
           ! Executable Statements 
           ! quick return if possible
           if( m<0 .or. n<=0 .or. k==0 .or. k>n )return
           lnotident = .not.stdlib_lsame( ident, 'I' )
           ! ------------------------------------------------------------------
           ! first step. computation of the column block 2:
              ! ( a2 ) := h * ( a2 )
              ! ( b2 )        ( b2 )
           ! ------------------------------------------------------------------
           if( n>k ) then
              ! col2_(1) compute w2: = a2. therefore, copy a2 = a(1:k, k+1:n)
              ! into w2=work(1:k, 1:n-k) column-by-column.
              do j = 1, n-k
                 call stdlib_ccopy( k, a( 1, k+j ), 1, work( 1, j ), 1 )
              end do
              if( lnotident ) then
                 ! col2_(2) compute w2: = (v1**h) * w2 = (a1**h) * w2,
                 ! v1 is not an identy matrix, but unit lower-triangular
                 ! v1 stored in a1 (diagonal ones are not stored).
                 call stdlib_ctrmm( 'L', 'L', 'C', 'U', k, n-k, cone, a, lda,work, ldwork )
                           
              end if
              ! col2_(3) compute w2: = w2 + (v2**h) * b2 = w2 + (b1**h) * b2
              ! v2 stored in b1.
              if( m>0 ) then
                 call stdlib_cgemm( 'C', 'N', k, n-k, m, cone, b, ldb,b( 1, k+1 ), ldb, cone, &
                           work, ldwork )
              end if
              ! col2_(4) compute w2: = t * w2,
              ! t is upper-triangular.
              call stdlib_ctrmm( 'L', 'U', 'N', 'N', k, n-k, cone, t, ldt,work, ldwork )
              ! col2_(5) compute b2: = b2 - v2 * w2 = b2 - b1 * w2,
              ! v2 stored in b1.
              if( m>0 ) then
                 call stdlib_cgemm( 'N', 'N', m, n-k, k, -cone, b, ldb,work, ldwork, cone, b( 1, &
                           k+1 ), ldb )
              end if
              if( lnotident ) then
                 ! col2_(6) compute w2: = v1 * w2 = a1 * w2,
                 ! v1 is not an identity matrix, but unit lower-triangular,
                 ! v1 stored in a1 (diagonal ones are not stored).
                 call stdlib_ctrmm( 'L', 'L', 'N', 'U', k, n-k, cone, a, lda,work, ldwork )
                           
              end if
              ! col2_(7) compute a2: = a2 - w2 =
                                   ! = a(1:k, k+1:n-k) - work(1:k, 1:n-k),
              ! column-by-column.
              do j = 1, n-k
                 do i = 1, k
                    a( i, k+j ) = a( i, k+j ) - work( i, j )
                 end do
              end do
           end if
           ! ------------------------------------------------------------------
           ! second step. computation of the column block 1:
              ! ( a1 ) := h * ( a1 )
              ! ( b1 )        (  0 )
           ! ------------------------------------------------------------------
           ! col1_(1) compute w1: = a1. copy the upper-triangular
           ! a1 = a(1:k, 1:k) into the upper-triangular
           ! w1 = work(1:k, 1:k) column-by-column.
           do j = 1, k
              call stdlib_ccopy( j, a( 1, j ), 1, work( 1, j ), 1 )
           end do
           ! set the subdiagonal elements of w1 to zero column-by-column.
           do j = 1, k - 1
              do i = j + 1, k
                 work( i, j ) = czero
              end do
           end do
           if( lnotident ) then
              ! col1_(2) compute w1: = (v1**h) * w1 = (a1**h) * w1,
              ! v1 is not an identity matrix, but unit lower-triangular
              ! v1 stored in a1 (diagonal ones are not stored),
              ! w1 is upper-triangular with zeroes below the diagonal.
              call stdlib_ctrmm( 'L', 'L', 'C', 'U', k, k, cone, a, lda,work, ldwork )
           end if
           ! col1_(3) compute w1: = t * w1,
           ! t is upper-triangular,
           ! w1 is upper-triangular with zeroes below the diagonal.
           call stdlib_ctrmm( 'L', 'U', 'N', 'N', k, k, cone, t, ldt,work, ldwork )
           ! col1_(4) compute b1: = - v2 * w1 = - b1 * w1,
           ! v2 = b1, w1 is upper-triangular with zeroes below the diagonal.
           if( m>0 ) then
              call stdlib_ctrmm( 'R', 'U', 'N', 'N', m, k, -cone, work, ldwork,b, ldb )
           end if
           if( lnotident ) then
              ! col1_(5) compute w1: = v1 * w1 = a1 * w1,
              ! v1 is not an identity matrix, but unit lower-triangular
              ! v1 stored in a1 (diagonal ones are not stored),
              ! w1 is upper-triangular on input with zeroes below the diagonal,
              ! and square on output.
              call stdlib_ctrmm( 'L', 'L', 'N', 'U', k, k, cone, a, lda,work, ldwork )
              ! col1_(6) compute a1: = a1 - w1 = a(1:k, 1:k) - work(1:k, 1:k)
              ! column-by-column. a1 is upper-triangular on input.
              ! if ident, a1 is square on output, and w1 is square,
              ! if not ident, a1 is upper-triangular on output,
              ! w1 is upper-triangular.
              ! col1_(6)_a compute elements of a1 below the diagonal.
              do j = 1, k - 1
                 do i = j + 1, k
                    a( i, j ) = - work( i, j )
                 end do
              end do
           end if
           ! col1_(6)_b compute elements of a1 on and above the diagonal.
           do j = 1, k
              do i = 1, j
                 a( i, j ) = a( i, j ) - work( i, j )
              end do
           end do
           return
     end subroutine stdlib_clarfb_gett


     pure subroutine stdlib_clarfg( n, alpha, x, incx, tau )
     !! CLARFG generates a complex elementary reflector H of order n, such
     !! that
     !! H**H * ( alpha ) = ( beta ),   H**H * H = I.
     !! (   x   )   (   0  )
     !! where alpha and beta are scalars, with beta real, and x is an
     !! (n-1)-element complex vector. H is represented in the form
     !! H = I - tau * ( 1 ) * ( 1 v**H ) ,
     !! ( v )
     !! where tau is a complex scalar and v is a complex (n-1)-element
     !! vector. Note that H is not hermitian.
     !! If the elements of x are all zero and alpha is real, then tau = 0
     !! and H is taken to be the unit matrix.
     !! Otherwise  1 <= real(tau) <= 2  and  abs(tau-1) <= 1 .
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, n
           complex(sp), intent(inout) :: alpha
           complex(sp), intent(out) :: tau
           ! Array Arguments 
           complex(sp), intent(inout) :: x(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, knt
           real(sp) :: alphi, alphr, beta, rsafmn, safmin, xnorm
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,real,sign
           ! Executable Statements 
           if( n<=0 ) then
              tau = zero
              return
           end if
           xnorm = stdlib_scnrm2( n-1, x, incx )
           alphr = real( alpha,KIND=sp)
           alphi = aimag( alpha )
           if( xnorm==zero .and. alphi==zero ) then
              ! h  =  i
              tau = zero
           else
              ! general case
              beta = -sign( stdlib_slapy3( alphr, alphi, xnorm ), alphr )
              safmin = stdlib_slamch( 'S' ) / stdlib_slamch( 'E' )
              rsafmn = one / safmin
              knt = 0
              if( abs( beta )<safmin ) then
                 ! xnorm, beta may be inaccurate; scale x and recompute them
                 10 continue
                 knt = knt + 1
                 call stdlib_csscal( n-1, rsafmn, x, incx )
                 beta = beta*rsafmn
                 alphi = alphi*rsafmn
                 alphr = alphr*rsafmn
                 if( (abs( beta )<safmin) .and. (knt < 20) )go to 10
                 ! new beta is at most 1, at least safmin
                 xnorm = stdlib_scnrm2( n-1, x, incx )
                 alpha = cmplx( alphr, alphi,KIND=sp)
                 beta = -sign( stdlib_slapy3( alphr, alphi, xnorm ), alphr )
              end if
              tau = cmplx( ( beta-alphr ) / beta, -alphi / beta,KIND=sp)
              alpha = stdlib_cladiv( cmplx( one,KIND=sp), alpha-beta )
              call stdlib_cscal( n-1, alpha, x, incx )
              ! if alpha is subnormal, it may lose relative accuracy
              do j = 1, knt
                 beta = beta*safmin
              end do
              alpha = beta
           end if
           return
     end subroutine stdlib_clarfg


     subroutine stdlib_clarfgp( n, alpha, x, incx, tau )
     !! CLARFGP generates a complex elementary reflector H of order n, such
     !! that
     !! H**H * ( alpha ) = ( beta ),   H**H * H = I.
     !! (   x   )   (   0  )
     !! where alpha and beta are scalars, beta is real and non-negative, and
     !! x is an (n-1)-element complex vector.  H is represented in the form
     !! H = I - tau * ( 1 ) * ( 1 v**H ) ,
     !! ( v )
     !! where tau is a complex scalar and v is a complex (n-1)-element
     !! vector. Note that H is not hermitian.
     !! If the elements of x are all zero and alpha is real, then tau = 0
     !! and H is taken to be the unit matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, n
           complex(sp), intent(inout) :: alpha
           complex(sp), intent(out) :: tau
           ! Array Arguments 
           complex(sp), intent(inout) :: x(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, knt
           real(sp) :: alphi, alphr, beta, bignum, smlnum, xnorm
           complex(sp) :: savealpha
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,real,sign
           ! Executable Statements 
           if( n<=0 ) then
              tau = zero
              return
           end if
           xnorm = stdlib_scnrm2( n-1, x, incx )
           alphr = real( alpha,KIND=sp)
           alphi = aimag( alpha )
           if( xnorm==zero ) then
              ! h  =  [1-alpha/abs(alpha) 0; 0 i], sign chosen so alpha >= 0.
              if( alphi==zero ) then
                 if( alphr>=zero ) then
                    ! when tau.eq.zero, the vector is special-cased to be
                    ! all zeros in the application routines.  we do not need
                    ! to clear it.
                    tau = zero
                 else
                    ! however, the application routines rely on explicit
                    ! zero checks when tau.ne.zero, and we must clear x.
                    tau = two
                    do j = 1, n-1
                       x( 1 + (j-1)*incx ) = zero
                    end do
                    alpha = -alpha
                 end if
              else
                 ! only "reflecting" the diagonal entry to be real and non-negative.
                 xnorm = stdlib_slapy2( alphr, alphi )
                 tau = cmplx( one - alphr / xnorm, -alphi / xnorm,KIND=sp)
                 do j = 1, n-1
                    x( 1 + (j-1)*incx ) = zero
                 end do
                 alpha = xnorm
              end if
           else
              ! general case
              beta = sign( stdlib_slapy3( alphr, alphi, xnorm ), alphr )
              smlnum = stdlib_slamch( 'S' ) / stdlib_slamch( 'E' )
              bignum = one / smlnum
              knt = 0
              if( abs( beta )<smlnum ) then
                 ! xnorm, beta may be inaccurate; scale x and recompute them
                 10 continue
                 knt = knt + 1
                 call stdlib_csscal( n-1, bignum, x, incx )
                 beta = beta*bignum
                 alphi = alphi*bignum
                 alphr = alphr*bignum
                 if( (abs( beta )<smlnum) .and. (knt < 20) )go to 10
                 ! new beta is at most 1, at least smlnum
                 xnorm = stdlib_scnrm2( n-1, x, incx )
                 alpha = cmplx( alphr, alphi,KIND=sp)
                 beta = sign( stdlib_slapy3( alphr, alphi, xnorm ), alphr )
              end if
              savealpha = alpha
              alpha = alpha + beta
              if( beta<zero ) then
                 beta = -beta
                 tau = -alpha / beta
              else
                 alphr = alphi * (alphi/real( alpha,KIND=sp))
                 alphr = alphr + xnorm * (xnorm/real( alpha,KIND=sp))
                 tau = cmplx( alphr/beta, -alphi/beta,KIND=sp)
                 alpha = cmplx( -alphr, alphi,KIND=sp)
              end if
              alpha = stdlib_cladiv( cmplx( one,KIND=sp), alpha )
              if ( abs(tau)<=smlnum ) then
                 ! in the case where the computed tau ends up being a denormalized number,
                 ! it loses relative accuracy. this is a big problem. solution: flush tau
                 ! to zero (or two or whatever makes a nonnegative real number for beta).
                 ! (bug report provided by pat quillen from mathworks on jul 29, 2009.)
                 ! (thanks pat. thanks mathworks.)
                 alphr = real( savealpha,KIND=sp)
                 alphi = aimag( savealpha )
                 if( alphi==zero ) then
                    if( alphr>=zero ) then
                       tau = zero
                    else
                       tau = two
                       do j = 1, n-1
                          x( 1 + (j-1)*incx ) = zero
                       end do
                       beta = real( -savealpha,KIND=sp)
                    end if
                 else
                    xnorm = stdlib_slapy2( alphr, alphi )
                    tau = cmplx( one - alphr / xnorm, -alphi / xnorm,KIND=sp)
                    do j = 1, n-1
                       x( 1 + (j-1)*incx ) = zero
                    end do
                    beta = xnorm
                 end if
              else
                 ! this is the general case.
                 call stdlib_cscal( n-1, alpha, x, incx )
              end if
              ! if beta is subnormal, it may lose relative accuracy
              do j = 1, knt
                 beta = beta*smlnum
              end do
              alpha = beta
           end if
           return
     end subroutine stdlib_clarfgp


     pure subroutine stdlib_clarft( direct, storev, n, k, v, ldv, tau, t, ldt )
     !! CLARFT forms the triangular factor T of a complex block reflector H
     !! of order n, which is defined as a product of k elementary reflectors.
     !! If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
     !! If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
     !! If STOREV = 'C', the vector which defines the elementary reflector
     !! H(i) is stored in the i-th column of the array V, and
     !! H  =  I - V * T * V**H
     !! If STOREV = 'R', the vector which defines the elementary reflector
     !! H(i) is stored in the i-th row of the array V, and
     !! H  =  I - V**H * T * V
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: direct, storev
           integer(ilp), intent(in) :: k, ldt, ldv, n
           ! Array Arguments 
           complex(sp), intent(out) :: t(ldt,*)
           complex(sp), intent(in) :: tau(*), v(ldv,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, prevlastv, lastv
           ! Executable Statements 
           ! quick return if possible
           if( n==0 )return
           if( stdlib_lsame( direct, 'F' ) ) then
              prevlastv = n
              do i = 1, k
                 prevlastv = max( prevlastv, i )
                 if( tau( i )==czero ) then
                    ! h(i)  =  i
                    do j = 1, i
                       t( j, i ) = czero
                    end do
                 else
                    ! general case
                    if( stdlib_lsame( storev, 'C' ) ) then
                       ! skip any trailing zeros.
                       do lastv = n, i+1, -1
                          if( v( lastv, i )/=czero ) exit
                       end do
                       do j = 1, i-1
                          t( j, i ) = -tau( i ) * conjg( v( i , j ) )
                       end do
                       j = min( lastv, prevlastv )
                       ! t(1:i-1,i) := - tau(i) * v(i:j,1:i-1)**h * v(i:j,i)
                       call stdlib_cgemv( 'CONJUGATE TRANSPOSE', j-i, i-1,-tau( i ), v( i+1, 1 ), &
                                 ldv,v( i+1, i ), 1,cone, t( 1, i ), 1 )
                    else
                       ! skip any trailing zeros.
                       do lastv = n, i+1, -1
                          if( v( i, lastv )/=czero ) exit
                       end do
                       do j = 1, i-1
                          t( j, i ) = -tau( i ) * v( j , i )
                       end do
                       j = min( lastv, prevlastv )
                       ! t(1:i-1,i) := - tau(i) * v(1:i-1,i:j) * v(i,i:j)**h
                       call stdlib_cgemm( 'N', 'C', i-1, 1, j-i, -tau( i ),v( 1, i+1 ), ldv, v( i,&
                                  i+1 ), ldv,cone, t( 1, i ), ldt )
                    end if
                    ! t(1:i-1,i) := t(1:i-1,1:i-1) * t(1:i-1,i)
                    call stdlib_ctrmv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', i-1, t,ldt, t( 1, i ),&
                               1 )
                    t( i, i ) = tau( i )
                    if( i>1 ) then
                       prevlastv = max( prevlastv, lastv )
                    else
                       prevlastv = lastv
                    end if
                 end if
              end do
           else
              prevlastv = 1
              do i = k, 1, -1
                 if( tau( i )==czero ) then
                    ! h(i)  =  i
                    do j = i, k
                       t( j, i ) = czero
                    end do
                 else
                    ! general case
                    if( i<k ) then
                       if( stdlib_lsame( storev, 'C' ) ) then
                          ! skip any leading zeros.
                          do lastv = 1, i-1
                             if( v( lastv, i )/=czero ) exit
                          end do
                          do j = i+1, k
                             t( j, i ) = -tau( i ) * conjg( v( n-k+i , j ) )
                          end do
                          j = max( lastv, prevlastv )
                          ! t(i+1:k,i) = -tau(i) * v(j:n-k+i,i+1:k)**h * v(j:n-k+i,i)
                          call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k+i-j, k-i,-tau( i ), v( j, &
                                    i+1 ), ldv, v( j, i ),1, cone, t( i+1, i ), 1 )
                       else
                          ! skip any leading zeros.
                          do lastv = 1, i-1
                             if( v( i, lastv )/=czero ) exit
                          end do
                          do j = i+1, k
                             t( j, i ) = -tau( i ) * v( j, n-k+i )
                          end do
                          j = max( lastv, prevlastv )
                          ! t(i+1:k,i) = -tau(i) * v(i+1:k,j:n-k+i) * v(i,j:n-k+i)**h
                          call stdlib_cgemm( 'N', 'C', k-i, 1, n-k+i-j, -tau( i ),v( i+1, j ), &
                                    ldv, v( i, j ), ldv,cone, t( i+1, i ), ldt )
                       end if
                       ! t(i+1:k,i) := t(i+1:k,i+1:k) * t(i+1:k,i)
                       call stdlib_ctrmv( 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', k-i,t( i+1, i+1 ), &
                                 ldt, t( i+1, i ), 1 )
                       if( i>1 ) then
                          prevlastv = min( prevlastv, lastv )
                       else
                          prevlastv = lastv
                       end if
                    end if
                    t( i, i ) = tau( i )
                 end if
              end do
           end if
           return
     end subroutine stdlib_clarft


     pure subroutine stdlib_clarfx( side, m, n, v, tau, c, ldc, work )
     !! CLARFX applies a complex elementary reflector H to a complex m by n
     !! matrix C, from either the left or the right. H is represented in the
     !! form
     !! H = I - tau * v * v**H
     !! where tau is a complex scalar and v is a complex vector.
     !! If tau = 0, then H is taken to be the unit matrix
     !! This version uses inline code if H has order < 11.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side
           integer(ilp), intent(in) :: ldc, m, n
           complex(sp), intent(in) :: tau
           ! Array Arguments 
           complex(sp), intent(inout) :: c(ldc,*)
           complex(sp), intent(in) :: v(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j
           complex(sp) :: sum, t1, t10, t2, t3, t4, t5, t6, t7, t8, t9, v1, v10, v2, v3, v4, v5, &
                     v6, v7, v8, v9
           ! Intrinsic Functions 
           intrinsic :: conjg
           ! Executable Statements 
           if( tau==czero )return
           if( stdlib_lsame( side, 'L' ) ) then
              ! form  h * c, where h has order m.
              go to ( 10, 30, 50, 70, 90, 110, 130, 150,170, 190 )m
              ! code for general m
              call stdlib_clarf( side, m, n, v, 1, tau, c, ldc, work )
              go to 410
              10 continue
              ! special code for 1 x 1 householder
              t1 = cone - tau*v( 1 )*conjg( v( 1 ) )
              do j = 1, n
                 c( 1, j ) = t1*c( 1, j )
              end do
              go to 410
              30 continue
              ! special code for 2 x 2 householder
              v1 = conjg( v( 1 ) )
              t1 = tau*conjg( v1 )
              v2 = conjg( v( 2 ) )
              t2 = tau*conjg( v2 )
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j )
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
              end do
              go to 410
              50 continue
              ! special code for 3 x 3 householder
              v1 = conjg( v( 1 ) )
              t1 = tau*conjg( v1 )
              v2 = conjg( v( 2 ) )
              t2 = tau*conjg( v2 )
              v3 = conjg( v( 3 ) )
              t3 = tau*conjg( v3 )
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j ) + v3*c( 3, j )
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
                 c( 3, j ) = c( 3, j ) - sum*t3
              end do
              go to 410
              70 continue
              ! special code for 4 x 4 householder
              v1 = conjg( v( 1 ) )
              t1 = tau*conjg( v1 )
              v2 = conjg( v( 2 ) )
              t2 = tau*conjg( v2 )
              v3 = conjg( v( 3 ) )
              t3 = tau*conjg( v3 )
              v4 = conjg( v( 4 ) )
              t4 = tau*conjg( v4 )
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j ) + v3*c( 3, j ) +v4*c( 4, j )
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
                 c( 3, j ) = c( 3, j ) - sum*t3
                 c( 4, j ) = c( 4, j ) - sum*t4
              end do
              go to 410
              90 continue
              ! special code for 5 x 5 householder
              v1 = conjg( v( 1 ) )
              t1 = tau*conjg( v1 )
              v2 = conjg( v( 2 ) )
              t2 = tau*conjg( v2 )
              v3 = conjg( v( 3 ) )
              t3 = tau*conjg( v3 )
              v4 = conjg( v( 4 ) )
              t4 = tau*conjg( v4 )
              v5 = conjg( v( 5 ) )
              t5 = tau*conjg( v5 )
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j ) + v3*c( 3, j ) +v4*c( 4, j ) + v5*c( 5, j )
                           
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
                 c( 3, j ) = c( 3, j ) - sum*t3
                 c( 4, j ) = c( 4, j ) - sum*t4
                 c( 5, j ) = c( 5, j ) - sum*t5
              end do
              go to 410
              110 continue
              ! special code for 6 x 6 householder
              v1 = conjg( v( 1 ) )
              t1 = tau*conjg( v1 )
              v2 = conjg( v( 2 ) )
              t2 = tau*conjg( v2 )
              v3 = conjg( v( 3 ) )
              t3 = tau*conjg( v3 )
              v4 = conjg( v( 4 ) )
              t4 = tau*conjg( v4 )
              v5 = conjg( v( 5 ) )
              t5 = tau*conjg( v5 )
              v6 = conjg( v( 6 ) )
              t6 = tau*conjg( v6 )
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j ) + v3*c( 3, j ) +v4*c( 4, j ) + v5*c( 5, j ) + &
                           v6*c( 6, j )
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
                 c( 3, j ) = c( 3, j ) - sum*t3
                 c( 4, j ) = c( 4, j ) - sum*t4
                 c( 5, j ) = c( 5, j ) - sum*t5
                 c( 6, j ) = c( 6, j ) - sum*t6
              end do
              go to 410
              130 continue
              ! special code for 7 x 7 householder
              v1 = conjg( v( 1 ) )
              t1 = tau*conjg( v1 )
              v2 = conjg( v( 2 ) )
              t2 = tau*conjg( v2 )
              v3 = conjg( v( 3 ) )
              t3 = tau*conjg( v3 )
              v4 = conjg( v( 4 ) )
              t4 = tau*conjg( v4 )
              v5 = conjg( v( 5 ) )
              t5 = tau*conjg( v5 )
              v6 = conjg( v( 6 ) )
              t6 = tau*conjg( v6 )
              v7 = conjg( v( 7 ) )
              t7 = tau*conjg( v7 )
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j ) + v3*c( 3, j ) +v4*c( 4, j ) + v5*c( 5, j ) + &
                           v6*c( 6, j ) +v7*c( 7, j )
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
                 c( 3, j ) = c( 3, j ) - sum*t3
                 c( 4, j ) = c( 4, j ) - sum*t4
                 c( 5, j ) = c( 5, j ) - sum*t5
                 c( 6, j ) = c( 6, j ) - sum*t6
                 c( 7, j ) = c( 7, j ) - sum*t7
              end do
              go to 410
              150 continue
              ! special code for 8 x 8 householder
              v1 = conjg( v( 1 ) )
              t1 = tau*conjg( v1 )
              v2 = conjg( v( 2 ) )
              t2 = tau*conjg( v2 )
              v3 = conjg( v( 3 ) )
              t3 = tau*conjg( v3 )
              v4 = conjg( v( 4 ) )
              t4 = tau*conjg( v4 )
              v5 = conjg( v( 5 ) )
              t5 = tau*conjg( v5 )
              v6 = conjg( v( 6 ) )
              t6 = tau*conjg( v6 )
              v7 = conjg( v( 7 ) )
              t7 = tau*conjg( v7 )
              v8 = conjg( v( 8 ) )
              t8 = tau*conjg( v8 )
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j ) + v3*c( 3, j ) +v4*c( 4, j ) + v5*c( 5, j ) + &
                           v6*c( 6, j ) +v7*c( 7, j ) + v8*c( 8, j )
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
                 c( 3, j ) = c( 3, j ) - sum*t3
                 c( 4, j ) = c( 4, j ) - sum*t4
                 c( 5, j ) = c( 5, j ) - sum*t5
                 c( 6, j ) = c( 6, j ) - sum*t6
                 c( 7, j ) = c( 7, j ) - sum*t7
                 c( 8, j ) = c( 8, j ) - sum*t8
              end do
              go to 410
              170 continue
              ! special code for 9 x 9 householder
              v1 = conjg( v( 1 ) )
              t1 = tau*conjg( v1 )
              v2 = conjg( v( 2 ) )
              t2 = tau*conjg( v2 )
              v3 = conjg( v( 3 ) )
              t3 = tau*conjg( v3 )
              v4 = conjg( v( 4 ) )
              t4 = tau*conjg( v4 )
              v5 = conjg( v( 5 ) )
              t5 = tau*conjg( v5 )
              v6 = conjg( v( 6 ) )
              t6 = tau*conjg( v6 )
              v7 = conjg( v( 7 ) )
              t7 = tau*conjg( v7 )
              v8 = conjg( v( 8 ) )
              t8 = tau*conjg( v8 )
              v9 = conjg( v( 9 ) )
              t9 = tau*conjg( v9 )
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j ) + v3*c( 3, j ) +v4*c( 4, j ) + v5*c( 5, j ) + &
                           v6*c( 6, j ) +v7*c( 7, j ) + v8*c( 8, j ) + v9*c( 9, j )
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
                 c( 3, j ) = c( 3, j ) - sum*t3
                 c( 4, j ) = c( 4, j ) - sum*t4
                 c( 5, j ) = c( 5, j ) - sum*t5
                 c( 6, j ) = c( 6, j ) - sum*t6
                 c( 7, j ) = c( 7, j ) - sum*t7
                 c( 8, j ) = c( 8, j ) - sum*t8
                 c( 9, j ) = c( 9, j ) - sum*t9
              end do
              go to 410
              190 continue
              ! special code for 10 x 10 householder
              v1 = conjg( v( 1 ) )
              t1 = tau*conjg( v1 )
              v2 = conjg( v( 2 ) )
              t2 = tau*conjg( v2 )
              v3 = conjg( v( 3 ) )
              t3 = tau*conjg( v3 )
              v4 = conjg( v( 4 ) )
              t4 = tau*conjg( v4 )
              v5 = conjg( v( 5 ) )
              t5 = tau*conjg( v5 )
              v6 = conjg( v( 6 ) )
              t6 = tau*conjg( v6 )
              v7 = conjg( v( 7 ) )
              t7 = tau*conjg( v7 )
              v8 = conjg( v( 8 ) )
              t8 = tau*conjg( v8 )
              v9 = conjg( v( 9 ) )
              t9 = tau*conjg( v9 )
              v10 = conjg( v( 10 ) )
              t10 = tau*conjg( v10 )
              do j = 1, n
                 sum = v1*c( 1, j ) + v2*c( 2, j ) + v3*c( 3, j ) +v4*c( 4, j ) + v5*c( 5, j ) + &
                           v6*c( 6, j ) +v7*c( 7, j ) + v8*c( 8, j ) + v9*c( 9, j ) +v10*c( 10, j )
                 c( 1, j ) = c( 1, j ) - sum*t1
                 c( 2, j ) = c( 2, j ) - sum*t2
                 c( 3, j ) = c( 3, j ) - sum*t3
                 c( 4, j ) = c( 4, j ) - sum*t4
                 c( 5, j ) = c( 5, j ) - sum*t5
                 c( 6, j ) = c( 6, j ) - sum*t6
                 c( 7, j ) = c( 7, j ) - sum*t7
                 c( 8, j ) = c( 8, j ) - sum*t8
                 c( 9, j ) = c( 9, j ) - sum*t9
                 c( 10, j ) = c( 10, j ) - sum*t10
              end do
              go to 410
           else
              ! form  c * h, where h has order n.
              go to ( 210, 230, 250, 270, 290, 310, 330, 350,370, 390 )n
              ! code for general n
              call stdlib_clarf( side, m, n, v, 1, tau, c, ldc, work )
              go to 410
              210 continue
              ! special code for 1 x 1 householder
              t1 = cone - tau*v( 1 )*conjg( v( 1 ) )
              do j = 1, m
                 c( j, 1 ) = t1*c( j, 1 )
              end do
              go to 410
              230 continue
              ! special code for 2 x 2 householder
              v1 = v( 1 )
              t1 = tau*conjg( v1 )
              v2 = v( 2 )
              t2 = tau*conjg( v2 )
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 )
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
              end do
              go to 410
              250 continue
              ! special code for 3 x 3 householder
              v1 = v( 1 )
              t1 = tau*conjg( v1 )
              v2 = v( 2 )
              t2 = tau*conjg( v2 )
              v3 = v( 3 )
              t3 = tau*conjg( v3 )
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 ) + v3*c( j, 3 )
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
                 c( j, 3 ) = c( j, 3 ) - sum*t3
              end do
              go to 410
              270 continue
              ! special code for 4 x 4 householder
              v1 = v( 1 )
              t1 = tau*conjg( v1 )
              v2 = v( 2 )
              t2 = tau*conjg( v2 )
              v3 = v( 3 )
              t3 = tau*conjg( v3 )
              v4 = v( 4 )
              t4 = tau*conjg( v4 )
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 ) + v3*c( j, 3 ) +v4*c( j, 4 )
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
                 c( j, 3 ) = c( j, 3 ) - sum*t3
                 c( j, 4 ) = c( j, 4 ) - sum*t4
              end do
              go to 410
              290 continue
              ! special code for 5 x 5 householder
              v1 = v( 1 )
              t1 = tau*conjg( v1 )
              v2 = v( 2 )
              t2 = tau*conjg( v2 )
              v3 = v( 3 )
              t3 = tau*conjg( v3 )
              v4 = v( 4 )
              t4 = tau*conjg( v4 )
              v5 = v( 5 )
              t5 = tau*conjg( v5 )
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 ) + v3*c( j, 3 ) +v4*c( j, 4 ) + v5*c( j, 5 )
                           
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
                 c( j, 3 ) = c( j, 3 ) - sum*t3
                 c( j, 4 ) = c( j, 4 ) - sum*t4
                 c( j, 5 ) = c( j, 5 ) - sum*t5
              end do
              go to 410
              310 continue
              ! special code for 6 x 6 householder
              v1 = v( 1 )
              t1 = tau*conjg( v1 )
              v2 = v( 2 )
              t2 = tau*conjg( v2 )
              v3 = v( 3 )
              t3 = tau*conjg( v3 )
              v4 = v( 4 )
              t4 = tau*conjg( v4 )
              v5 = v( 5 )
              t5 = tau*conjg( v5 )
              v6 = v( 6 )
              t6 = tau*conjg( v6 )
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 ) + v3*c( j, 3 ) +v4*c( j, 4 ) + v5*c( j, 5 ) + &
                           v6*c( j, 6 )
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
                 c( j, 3 ) = c( j, 3 ) - sum*t3
                 c( j, 4 ) = c( j, 4 ) - sum*t4
                 c( j, 5 ) = c( j, 5 ) - sum*t5
                 c( j, 6 ) = c( j, 6 ) - sum*t6
              end do
              go to 410
              330 continue
              ! special code for 7 x 7 householder
              v1 = v( 1 )
              t1 = tau*conjg( v1 )
              v2 = v( 2 )
              t2 = tau*conjg( v2 )
              v3 = v( 3 )
              t3 = tau*conjg( v3 )
              v4 = v( 4 )
              t4 = tau*conjg( v4 )
              v5 = v( 5 )
              t5 = tau*conjg( v5 )
              v6 = v( 6 )
              t6 = tau*conjg( v6 )
              v7 = v( 7 )
              t7 = tau*conjg( v7 )
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 ) + v3*c( j, 3 ) +v4*c( j, 4 ) + v5*c( j, 5 ) + &
                           v6*c( j, 6 ) +v7*c( j, 7 )
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
                 c( j, 3 ) = c( j, 3 ) - sum*t3
                 c( j, 4 ) = c( j, 4 ) - sum*t4
                 c( j, 5 ) = c( j, 5 ) - sum*t5
                 c( j, 6 ) = c( j, 6 ) - sum*t6
                 c( j, 7 ) = c( j, 7 ) - sum*t7
              end do
              go to 410
              350 continue
              ! special code for 8 x 8 householder
              v1 = v( 1 )
              t1 = tau*conjg( v1 )
              v2 = v( 2 )
              t2 = tau*conjg( v2 )
              v3 = v( 3 )
              t3 = tau*conjg( v3 )
              v4 = v( 4 )
              t4 = tau*conjg( v4 )
              v5 = v( 5 )
              t5 = tau*conjg( v5 )
              v6 = v( 6 )
              t6 = tau*conjg( v6 )
              v7 = v( 7 )
              t7 = tau*conjg( v7 )
              v8 = v( 8 )
              t8 = tau*conjg( v8 )
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 ) + v3*c( j, 3 ) +v4*c( j, 4 ) + v5*c( j, 5 ) + &
                           v6*c( j, 6 ) +v7*c( j, 7 ) + v8*c( j, 8 )
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
                 c( j, 3 ) = c( j, 3 ) - sum*t3
                 c( j, 4 ) = c( j, 4 ) - sum*t4
                 c( j, 5 ) = c( j, 5 ) - sum*t5
                 c( j, 6 ) = c( j, 6 ) - sum*t6
                 c( j, 7 ) = c( j, 7 ) - sum*t7
                 c( j, 8 ) = c( j, 8 ) - sum*t8
              end do
              go to 410
              370 continue
              ! special code for 9 x 9 householder
              v1 = v( 1 )
              t1 = tau*conjg( v1 )
              v2 = v( 2 )
              t2 = tau*conjg( v2 )
              v3 = v( 3 )
              t3 = tau*conjg( v3 )
              v4 = v( 4 )
              t4 = tau*conjg( v4 )
              v5 = v( 5 )
              t5 = tau*conjg( v5 )
              v6 = v( 6 )
              t6 = tau*conjg( v6 )
              v7 = v( 7 )
              t7 = tau*conjg( v7 )
              v8 = v( 8 )
              t8 = tau*conjg( v8 )
              v9 = v( 9 )
              t9 = tau*conjg( v9 )
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 ) + v3*c( j, 3 ) +v4*c( j, 4 ) + v5*c( j, 5 ) + &
                           v6*c( j, 6 ) +v7*c( j, 7 ) + v8*c( j, 8 ) + v9*c( j, 9 )
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
                 c( j, 3 ) = c( j, 3 ) - sum*t3
                 c( j, 4 ) = c( j, 4 ) - sum*t4
                 c( j, 5 ) = c( j, 5 ) - sum*t5
                 c( j, 6 ) = c( j, 6 ) - sum*t6
                 c( j, 7 ) = c( j, 7 ) - sum*t7
                 c( j, 8 ) = c( j, 8 ) - sum*t8
                 c( j, 9 ) = c( j, 9 ) - sum*t9
              end do
              go to 410
              390 continue
              ! special code for 10 x 10 householder
              v1 = v( 1 )
              t1 = tau*conjg( v1 )
              v2 = v( 2 )
              t2 = tau*conjg( v2 )
              v3 = v( 3 )
              t3 = tau*conjg( v3 )
              v4 = v( 4 )
              t4 = tau*conjg( v4 )
              v5 = v( 5 )
              t5 = tau*conjg( v5 )
              v6 = v( 6 )
              t6 = tau*conjg( v6 )
              v7 = v( 7 )
              t7 = tau*conjg( v7 )
              v8 = v( 8 )
              t8 = tau*conjg( v8 )
              v9 = v( 9 )
              t9 = tau*conjg( v9 )
              v10 = v( 10 )
              t10 = tau*conjg( v10 )
              do j = 1, m
                 sum = v1*c( j, 1 ) + v2*c( j, 2 ) + v3*c( j, 3 ) +v4*c( j, 4 ) + v5*c( j, 5 ) + &
                           v6*c( j, 6 ) +v7*c( j, 7 ) + v8*c( j, 8 ) + v9*c( j, 9 ) +v10*c( j, 10 )
                 c( j, 1 ) = c( j, 1 ) - sum*t1
                 c( j, 2 ) = c( j, 2 ) - sum*t2
                 c( j, 3 ) = c( j, 3 ) - sum*t3
                 c( j, 4 ) = c( j, 4 ) - sum*t4
                 c( j, 5 ) = c( j, 5 ) - sum*t5
                 c( j, 6 ) = c( j, 6 ) - sum*t6
                 c( j, 7 ) = c( j, 7 ) - sum*t7
                 c( j, 8 ) = c( j, 8 ) - sum*t8
                 c( j, 9 ) = c( j, 9 ) - sum*t9
                 c( j, 10 ) = c( j, 10 ) - sum*t10
              end do
              go to 410
           end if
       410 return
     end subroutine stdlib_clarfx


     pure subroutine stdlib_clarfy( uplo, n, v, incv, tau, c, ldc, work )
     !! CLARFY applies an elementary reflector, or Householder matrix, H,
     !! to an n x n Hermitian matrix C, from both the left and the right.
     !! H is represented in the form
     !! H = I - tau * v * v'
     !! where  tau  is a scalar and  v  is a vector.
     !! If  tau  is  zero, then  H  is taken to be the unit matrix.
        ! -- lapack test routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: incv, ldc, n
           complex(sp), intent(in) :: tau
           ! Array Arguments 
           complex(sp), intent(inout) :: c(ldc,*)
           complex(sp), intent(in) :: v(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           complex(sp) :: alpha
           ! Executable Statements 
           if( tau==czero )return
           ! form  w:= c * v
           call stdlib_chemv( uplo, n, cone, c, ldc, v, incv, czero, work, 1 )
           alpha = -chalf*tau*stdlib_cdotc( n, work, 1, v, incv )
           call stdlib_caxpy( n, alpha, v, incv, work, 1 )
           ! c := c - v * w' - w * v'
           call stdlib_cher2( uplo, n, -tau, v, incv, work, 1, c, ldc )
           return
     end subroutine stdlib_clarfy


     pure subroutine stdlib_clarnv( idist, iseed, n, x )
     !! CLARNV returns a vector of n random complex numbers from a uniform or
     !! normal distribution.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: idist, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: iseed(4)
           complex(sp), intent(out) :: x(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: lv = 128
           real(sp), parameter :: twopi = 6.28318530717958647692528676655900576839e+0_sp
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, il, iv
           ! Local Arrays 
           real(sp) :: u(lv)
           ! Intrinsic Functions 
           intrinsic :: cmplx,exp,log,min,sqrt
           ! Executable Statements 
           do 60 iv = 1, n, lv / 2
              il = min( lv / 2, n-iv+1 )
              ! call stdlib_slaruv to generate 2*il realnumbers from a uniform (0,1,KIND=sp)
              ! distribution (2*il <= lv)
              call stdlib_slaruv( iseed, 2*il, u )
              if( idist==1 ) then
                 ! copy generated numbers
                 do i = 1, il
                    x( iv+i-1 ) = cmplx( u( 2*i-1 ), u( 2*i ),KIND=sp)
                 end do
              else if( idist==2 ) then
                 ! convert generated numbers to uniform (-1,1) distribution
                 do i = 1, il
                    x( iv+i-1 ) = cmplx( two*u( 2*i-1 )-one,two*u( 2*i )-one,KIND=sp)
                 end do
              else if( idist==3 ) then
                 ! convert generated numbers to normal (0,1) distribution
                 do i = 1, il
                    x( iv+i-1 ) = sqrt( -two*log( u( 2*i-1 ) ) )*exp( cmplx( zero, twopi*u( 2*i ),&
                              KIND=sp) )
                 end do
              else if( idist==4 ) then
                 ! convert generated numbers to complex numbers uniformly
                 ! distributed on the unit disk
                 do i = 1, il
                    x( iv+i-1 ) = sqrt( u( 2*i-1 ) )*exp( cmplx( zero, twopi*u( 2*i ),KIND=sp) )
                              
                 end do
              else if( idist==5 ) then
                 ! convert generated numbers to complex numbers uniformly
                 ! distributed on the unit circle
                 do i = 1, il
                    x( iv+i-1 ) = exp( cmplx( zero, twopi*u( 2*i ),KIND=sp) )
                 end do
              end if
              60 continue
           return
     end subroutine stdlib_clarnv


     pure subroutine stdlib_clartg( f, g, c, s, r )
     !! CLARTG generates a plane rotation so that
     !! [  C         S  ] . [ F ]  =  [ R ]
     !! [ -conjg(S)  C  ]   [ G ]     [ 0 ]
     !! where C is real and C**2 + |S|**2 = 1.
     !! The mathematical formulas used for C and S are
     !! sgn(x) = {  x / |x|,   x != 0
     !! {  1,         x = 0
     !! R = sgn(F) * sqrt(|F|**2 + |G|**2)
     !! C = |F| / sqrt(|F|**2 + |G|**2)
     !! S = sgn(F) * conjg(G) / sqrt(|F|**2 + |G|**2)
     !! When F and G are real, the formulas simplify to C = F/R and
     !! S = G/R, and the returned values of C, S, and R should be
     !! identical to those returned by CLARTG.
     !! The algorithm used to compute these quantities incorporates scaling
     !! to avoid overflow or underflow in computing the square root of the
     !! sum of squares.
     !! This is a faster version of the BLAS1 routine CROTG, except for
     !! the following differences:
     !! F and G are unchanged on return.
     !! If G=0, then C=1 and S=0.
     !! If F=0, then C=0 and S is chosen so that R is real.
     !! Below, wp=>sp stands for single precision from LA_CONSTANTS module.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! february 2021
        ! Scalar Arguments 
        real(sp), intent(out) :: c
        complex(sp), intent(in) :: f, g
        complex(sp), intent(out) :: r, s
        ! Local Scalars 
        real(sp) :: d, f1, f2, g1, g2, h2, p, u, uu, v, vv, w
        complex(sp) :: fs, gs, t
        ! Intrinsic Functions 
        intrinsic :: abs,aimag,conjg,max,min,real,sqrt
        ! Statement Functions 
        real(sp) :: abssq
        ! Statement Function Definitions 
        abssq( t ) = real( t,KIND=sp)**2 + aimag( t )**2
        ! Executable Statements 
        if( g == czero ) then
           c = one
           s = czero
           r = f
        else if( f == czero ) then
           c = zero
           g1 = max( abs(real(g,KIND=sp)), abs(aimag(g)) )
           if( g1 > rtmin .and. g1 < rtmax ) then
              ! use unscaled algorithm
              g2 = abssq( g )
              d = sqrt( g2 )
              s = conjg( g ) / d
              r = d
           else
              ! use scaled algorithm
              u = min( safmax, max( safmin, g1 ) )
              uu = one / u
              gs = g*uu
              g2 = abssq( gs )
              d = sqrt( g2 )
              s = conjg( gs ) / d
              r = d*u
           end if
        else
           f1 = max( abs(real(f,KIND=sp)), abs(aimag(f)) )
           g1 = max( abs(real(g,KIND=sp)), abs(aimag(g)) )
     if( f1 > rtmin .and. f1 < rtmax .and.          g1 > rtmin .and. g1 < rtmax ) then
              ! use unscaled algorithm
              f2 = abssq( f )
              g2 = abssq( g )
              h2 = f2 + g2
              if( f2 > rtmin .and. h2 < rtmax ) then
                 d = sqrt( f2*h2 )
              else
                 d = sqrt( f2 )*sqrt( h2 )
              end if
              p = 1 / d
              c = f2*p
              s = conjg( g )*( f*p )
              r = f*( h2*p )
           else
              ! use scaled algorithm
              u = min( safmax, max( safmin, f1, g1 ) )
              uu = one / u
              gs = g*uu
              g2 = abssq( gs )
              if( f1*uu < rtmin ) then
                 ! f is not well-scaled when scaled by g1.
                 ! use a different scaling for f.
                 v = min( safmax, max( safmin, f1 ) )
                 vv = one / v
                 w = v * uu
                 fs = f*vv
                 f2 = abssq( fs )
                 h2 = f2*w**2 + g2
              else
                 ! otherwise use the same scaling for f and g.
                 w = one
                 fs = f*uu
                 f2 = abssq( fs )
                 h2 = f2 + g2
              end if
              if( f2 > rtmin .and. h2 < rtmax ) then
                 d = sqrt( f2*h2 )
              else
                 d = sqrt( f2 )*sqrt( h2 )
              end if
              p = 1 / d
              c = ( f2*p )*w
              s = conjg( gs )*( fs*p )
              r = ( fs*( h2*p ) )*u
           end if
        end if
        return
     end subroutine stdlib_clartg


     pure subroutine stdlib_clartv( n, x, incx, y, incy, c, s, incc )
     !! CLARTV applies a vector of complex plane rotations with real cosines
     !! to elements of the complex vectors x and y. For i = 1,2,...,n
     !! ( x(i) ) := (        c(i)   s(i) ) ( x(i) )
     !! ( y(i) )    ( -conjg(s(i))  c(i) ) ( y(i) )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incc, incx, incy, n
           ! Array Arguments 
           real(sp), intent(in) :: c(*)
           complex(sp), intent(in) :: s(*)
           complex(sp), intent(inout) :: x(*), y(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ic, ix, iy
           complex(sp) :: xi, yi
           ! Intrinsic Functions 
           intrinsic :: conjg
           ! Executable Statements 
           ix = 1
           iy = 1
           ic = 1
           do i = 1, n
              xi = x( ix )
              yi = y( iy )
              x( ix ) = c( ic )*xi + s( ic )*yi
              y( iy ) = c( ic )*yi - conjg( s( ic ) )*xi
              ix = ix + incx
              iy = iy + incy
              ic = ic + incc
           end do
           return
     end subroutine stdlib_clartv


     pure subroutine stdlib_clarz( side, m, n, l, v, incv, tau, c, ldc, work )
     !! CLARZ applies a complex elementary reflector H to a complex
     !! M-by-N matrix C, from either the left or the right. H is represented
     !! in the form
     !! H = I - tau * v * v**H
     !! where tau is a complex scalar and v is a complex vector.
     !! If tau = 0, then H is taken to be the unit matrix.
     !! To apply H**H (the conjugate transpose of H), supply conjg(tau) instead
     !! tau.
     !! H is a product of k elementary reflectors as returned by CTZRZF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side
           integer(ilp), intent(in) :: incv, l, ldc, m, n
           complex(sp), intent(in) :: tau
           ! Array Arguments 
           complex(sp), intent(inout) :: c(ldc,*)
           complex(sp), intent(in) :: v(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Executable Statements 
           if( stdlib_lsame( side, 'L' ) ) then
              ! form  h * c
              if( tau/=czero ) then
                 ! w( 1:n ) = conjg( c( 1, 1:n ) )
                 call stdlib_ccopy( n, c, ldc, work, 1 )
                 call stdlib_clacgv( n, work, 1 )
                 ! w( 1:n ) = conjg( w( 1:n ) + c( m-l+1:m, 1:n )**h * v( 1:l ) )
                 call stdlib_cgemv( 'CONJUGATE TRANSPOSE', l, n, cone, c( m-l+1, 1 ),ldc, v, incv,&
                            cone, work, 1 )
                 call stdlib_clacgv( n, work, 1 )
                 ! c( 1, 1:n ) = c( 1, 1:n ) - tau * w( 1:n )
                 call stdlib_caxpy( n, -tau, work, 1, c, ldc )
                 ! c( m-l+1:m, 1:n ) = c( m-l+1:m, 1:n ) - ...
                                     ! tau * v( 1:l ) * w( 1:n )**h
                 call stdlib_cgeru( l, n, -tau, v, incv, work, 1, c( m-l+1, 1 ),ldc )
              end if
           else
              ! form  c * h
              if( tau/=czero ) then
                 ! w( 1:m ) = c( 1:m, 1 )
                 call stdlib_ccopy( m, c, 1, work, 1 )
                 ! w( 1:m ) = w( 1:m ) + c( 1:m, n-l+1:n, 1:n ) * v( 1:l )
                 call stdlib_cgemv( 'NO TRANSPOSE', m, l, cone, c( 1, n-l+1 ), ldc,v, incv, cone, &
                           work, 1 )
                 ! c( 1:m, 1 ) = c( 1:m, 1 ) - tau * w( 1:m )
                 call stdlib_caxpy( m, -tau, work, 1, c, 1 )
                 ! c( 1:m, n-l+1:n ) = c( 1:m, n-l+1:n ) - ...
                                     ! tau * w( 1:m ) * v( 1:l )**h
                 call stdlib_cgerc( m, l, -tau, work, 1, v, incv, c( 1, n-l+1 ),ldc )
              end if
           end if
           return
     end subroutine stdlib_clarz


     pure subroutine stdlib_clarzb( side, trans, direct, storev, m, n, k, l, v,ldv, t, ldt, c, &
     !! CLARZB applies a complex block reflector H or its transpose H**H
     !! to a complex distributed M-by-N  C from the left or the right.
     !! Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
               ldc, work, ldwork )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: direct, side, storev, trans
           integer(ilp), intent(in) :: k, l, ldc, ldt, ldv, ldwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: c(ldc,*), t(ldt,*), v(ldv,*)
           complex(sp), intent(out) :: work(ldwork,*)
        ! =====================================================================
           
           ! Local Scalars 
           character :: transt
           integer(ilp) :: i, info, j
           ! Executable Statements 
           ! quick return if possible
           if( m<=0 .or. n<=0 )return
           ! check for currently supported options
           info = 0
           if( .not.stdlib_lsame( direct, 'B' ) ) then
              info = -3
           else if( .not.stdlib_lsame( storev, 'R' ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLARZB', -info )
              return
           end if
           if( stdlib_lsame( trans, 'N' ) ) then
              transt = 'C'
           else
              transt = 'N'
           end if
           if( stdlib_lsame( side, 'L' ) ) then
              ! form  h * c  or  h**h * c
              ! w( 1:n, 1:k ) = c( 1:k, 1:n )**h
              do j = 1, k
                 call stdlib_ccopy( n, c( j, 1 ), ldc, work( 1, j ), 1 )
              end do
              ! w( 1:n, 1:k ) = w( 1:n, 1:k ) + ...
                              ! c( m-l+1:m, 1:n )**h * v( 1:k, 1:l )**t
              if( l>0 )call stdlib_cgemm( 'TRANSPOSE', 'CONJUGATE TRANSPOSE', n, k, l,cone, c( m-&
                        l+1, 1 ), ldc, v, ldv, cone, work,ldwork )
              ! w( 1:n, 1:k ) = w( 1:n, 1:k ) * t**t  or  w( 1:m, 1:k ) * t
              call stdlib_ctrmm( 'RIGHT', 'LOWER', transt, 'NON-UNIT', n, k, cone, t,ldt, work, &
                        ldwork )
              ! c( 1:k, 1:n ) = c( 1:k, 1:n ) - w( 1:n, 1:k )**h
              do j = 1, n
                 do i = 1, k
                    c( i, j ) = c( i, j ) - work( j, i )
                 end do
              end do
              ! c( m-l+1:m, 1:n ) = c( m-l+1:m, 1:n ) - ...
                                  ! v( 1:k, 1:l )**h * w( 1:n, 1:k )**h
              if( l>0 )call stdlib_cgemm( 'TRANSPOSE', 'TRANSPOSE', l, n, k, -cone, v, ldv,work, &
                        ldwork, cone, c( m-l+1, 1 ), ldc )
           else if( stdlib_lsame( side, 'R' ) ) then
              ! form  c * h  or  c * h**h
              ! w( 1:m, 1:k ) = c( 1:m, 1:k )
              do j = 1, k
                 call stdlib_ccopy( m, c( 1, j ), 1, work( 1, j ), 1 )
              end do
              ! w( 1:m, 1:k ) = w( 1:m, 1:k ) + ...
                              ! c( 1:m, n-l+1:n ) * v( 1:k, 1:l )**h
              if( l>0 )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', m, k, l, cone,c( 1, n-l+1 )&
                        , ldc, v, ldv, cone, work, ldwork )
              ! w( 1:m, 1:k ) = w( 1:m, 1:k ) * conjg( t )  or
                              ! w( 1:m, 1:k ) * t**h
              do j = 1, k
                 call stdlib_clacgv( k-j+1, t( j, j ), 1 )
              end do
              call stdlib_ctrmm( 'RIGHT', 'LOWER', trans, 'NON-UNIT', m, k, cone, t,ldt, work, &
                        ldwork )
              do j = 1, k
                 call stdlib_clacgv( k-j+1, t( j, j ), 1 )
              end do
              ! c( 1:m, 1:k ) = c( 1:m, 1:k ) - w( 1:m, 1:k )
              do j = 1, k
                 do i = 1, m
                    c( i, j ) = c( i, j ) - work( i, j )
                 end do
              end do
              ! c( 1:m, n-l+1:n ) = c( 1:m, n-l+1:n ) - ...
                                  ! w( 1:m, 1:k ) * conjg( v( 1:k, 1:l ) )
              do j = 1, l
                 call stdlib_clacgv( k, v( 1, j ), 1 )
              end do
              if( l>0 )call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', m, l, k, -cone,work, &
                        ldwork, v, ldv, cone, c( 1, n-l+1 ), ldc )
              do j = 1, l
                 call stdlib_clacgv( k, v( 1, j ), 1 )
              end do
           end if
           return
     end subroutine stdlib_clarzb


     pure subroutine stdlib_clarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
     !! CLARZT forms the triangular factor T of a complex block reflector
     !! H of order > n, which is defined as a product of k elementary
     !! reflectors.
     !! If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
     !! If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
     !! If STOREV = 'C', the vector which defines the elementary reflector
     !! H(i) is stored in the i-th column of the array V, and
     !! H  =  I - V * T * V**H
     !! If STOREV = 'R', the vector which defines the elementary reflector
     !! H(i) is stored in the i-th row of the array V, and
     !! H  =  I - V**H * T * V
     !! Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: direct, storev
           integer(ilp), intent(in) :: k, ldt, ldv, n
           ! Array Arguments 
           complex(sp), intent(out) :: t(ldt,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, info, j
           ! Executable Statements 
           ! check for currently supported options
           info = 0
           if( .not.stdlib_lsame( direct, 'B' ) ) then
              info = -1
           else if( .not.stdlib_lsame( storev, 'R' ) ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLARZT', -info )
              return
           end if
           do i = k, 1, -1
              if( tau( i )==czero ) then
                 ! h(i)  =  i
                 do j = i, k
                    t( j, i ) = czero
                 end do
              else
                 ! general case
                 if( i<k ) then
                    ! t(i+1:k,i) = - tau(i) * v(i+1:k,1:n) * v(i,1:n)**h
                    call stdlib_clacgv( n, v( i, 1 ), ldv )
                    call stdlib_cgemv( 'NO TRANSPOSE', k-i, n, -tau( i ),v( i+1, 1 ), ldv, v( i, &
                              1 ), ldv, czero,t( i+1, i ), 1 )
                    call stdlib_clacgv( n, v( i, 1 ), ldv )
                    ! t(i+1:k,i) = t(i+1:k,i+1:k) * t(i+1:k,i)
                    call stdlib_ctrmv( 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', k-i,t( i+1, i+1 ), &
                              ldt, t( i+1, i ), 1 )
                 end if
                 t( i, i ) = tau( i )
              end if
           end do
           return
     end subroutine stdlib_clarzt


     pure subroutine stdlib_clascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
     !! CLASCL multiplies the M by N complex matrix A by the real scalar
     !! CTO/CFROM.  This is done without over/underflow as long as the final
     !! result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
     !! A may be full, upper triangular, lower triangular, upper Hessenberg,
     !! or banded.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: type
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, lda, m, n
           real(sp), intent(in) :: cfrom, cto
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: i, itype, j, k1, k2, k3, k4
           real(sp) :: bignum, cfrom1, cfromc, cto1, ctoc, mul, smlnum
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( stdlib_lsame( type, 'G' ) ) then
              itype = 0
           else if( stdlib_lsame( type, 'L' ) ) then
              itype = 1
           else if( stdlib_lsame( type, 'U' ) ) then
              itype = 2
           else if( stdlib_lsame( type, 'H' ) ) then
              itype = 3
           else if( stdlib_lsame( type, 'B' ) ) then
              itype = 4
           else if( stdlib_lsame( type, 'Q' ) ) then
              itype = 5
           else if( stdlib_lsame( type, 'Z' ) ) then
              itype = 6
           else
              itype = -1
           end if
           if( itype==-1 ) then
              info = -1
           else if( cfrom==zero .or. stdlib_sisnan(cfrom) ) then
              info = -4
           else if( stdlib_sisnan(cto) ) then
              info = -5
           else if( m<0 ) then
              info = -6
           else if( n<0 .or. ( itype==4 .and. n/=m ) .or.( itype==5 .and. n/=m ) ) then
              info = -7
           else if( itype<=3 .and. lda<max( 1, m ) ) then
              info = -9
           else if( itype>=4 ) then
              if( kl<0 .or. kl>max( m-1, 0 ) ) then
                 info = -2
              else if( ku<0 .or. ku>max( n-1, 0 ) .or.( ( itype==4 .or. itype==5 ) .and. kl/=ku ) &
                        )then
                 info = -3
              else if( ( itype==4 .and. lda<kl+1 ) .or.( itype==5 .and. lda<ku+1 ) .or.( itype==6 &
                        .and. lda<2*kl+ku+1 ) ) then
                 info = -9
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLASCL', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. m==0 )return
           ! get machine parameters
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           cfromc = cfrom
           ctoc = cto
           10 continue
           cfrom1 = cfromc*smlnum
           if( cfrom1==cfromc ) then
              ! cfromc is an inf.  multiply by a correctly signed zero for
              ! finite ctoc, or a nan if ctoc is infinite.
              mul = ctoc / cfromc
              done = .true.
              cto1 = ctoc
           else
              cto1 = ctoc / bignum
              if( cto1==ctoc ) then
                 ! ctoc is either 0 or an inf.  in both cases, ctoc itself
                 ! serves as the correct multiplication factor.
                 mul = ctoc
                 done = .true.
                 cfromc = one
              else if( abs( cfrom1 )>abs( ctoc ) .and. ctoc/=zero ) then
                 mul = smlnum
                 done = .false.
                 cfromc = cfrom1
              else if( abs( cto1 )>abs( cfromc ) ) then
                 mul = bignum
                 done = .false.
                 ctoc = cto1
              else
                 mul = ctoc / cfromc
                 done = .true.
              end if
           end if
           if( itype==0 ) then
              ! full matrix
              do j = 1, n
                 do i = 1, m
                    a( i, j ) = a( i, j )*mul
                 end do
              end do
           else if( itype==1 ) then
              ! lower triangular matrix
              do j = 1, n
                 do i = j, m
                    a( i, j ) = a( i, j )*mul
                 end do
              end do
           else if( itype==2 ) then
              ! upper triangular matrix
              do j = 1, n
                 do i = 1, min( j, m )
                    a( i, j ) = a( i, j )*mul
                 end do
              end do
           else if( itype==3 ) then
              ! upper hessenberg matrix
              do j = 1, n
                 do i = 1, min( j+1, m )
                    a( i, j ) = a( i, j )*mul
                 end do
              end do
           else if( itype==4 ) then
              ! lower chalf of a symmetric band matrix
              k3 = kl + 1
              k4 = n + 1
              do j = 1, n
                 do i = 1, min( k3, k4-j )
                    a( i, j ) = a( i, j )*mul
                 end do
              end do
           else if( itype==5 ) then
              ! upper chalf of a symmetric band matrix
              k1 = ku + 2
              k3 = ku + 1
              do j = 1, n
                 do i = max( k1-j, 1 ), k3
                    a( i, j ) = a( i, j )*mul
                 end do
              end do
           else if( itype==6 ) then
              ! band matrix
              k1 = kl + ku + 2
              k2 = kl + 1
              k3 = 2*kl + ku + 1
              k4 = kl + ku + 1 + m
              do j = 1, n
                 do i = max( k1-j, k2 ), min( k3, k4-j )
                    a( i, j ) = a( i, j )*mul
                 end do
              end do
           end if
           if( .not.done )go to 10
           return
     end subroutine stdlib_clascl


     pure subroutine stdlib_claset( uplo, m, n, alpha, beta, a, lda )
     !! CLASET initializes a 2-D array A to BETA on the diagonal and
     !! ALPHA on the offdiagonals.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, m, n
           complex(sp), intent(in) :: alpha, beta
           ! Array Arguments 
           complex(sp), intent(out) :: a(lda,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! set the diagonal to beta and the strictly upper triangular
              ! part of the array to alpha.
              do j = 2, n
                 do i = 1, min( j-1, m )
                    a( i, j ) = alpha
                 end do
              end do
              do i = 1, min( n, m )
                 a( i, i ) = beta
              end do
           else if( stdlib_lsame( uplo, 'L' ) ) then
              ! set the diagonal to beta and the strictly lower triangular
              ! part of the array to alpha.
              do j = 1, min( m, n )
                 do i = j + 1, m
                    a( i, j ) = alpha
                 end do
              end do
              do i = 1, min( n, m )
                 a( i, i ) = beta
              end do
           else
              ! set the array to beta on the diagonal and alpha on the
              ! offdiagonal.
              do j = 1, n
                 do i = 1, m
                    a( i, j ) = alpha
                 end do
              end do
              do i = 1, min( m, n )
                 a( i, i ) = beta
              end do
           end if
           return
     end subroutine stdlib_claset


     pure subroutine stdlib_clasr( side, pivot, direct, m, n, c, s, a, lda )
     !! CLASR applies a sequence of real plane rotations to a complex matrix
     !! A, from either the left or the right.
     !! When SIDE = 'L', the transformation takes the form
     !! A := P*A
     !! and when SIDE = 'R', the transformation takes the form
     !! A := A*P**T
     !! where P is an orthogonal matrix consisting of a sequence of z plane
     !! rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
     !! and P**T is the transpose of P.
     !! When DIRECT = 'F' (Forward sequence), then
     !! P = P(z-1) * ... * P(2) * P(1)
     !! and when DIRECT = 'B' (Backward sequence), then
     !! P = P(1) * P(2) * ... * P(z-1)
     !! where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
     !! R(k) = (  c(k)  s(k) )
     !! = ( -s(k)  c(k) ).
     !! When PIVOT = 'V' (Variable pivot), the rotation is performed
     !! for the plane (k,k+1), i.e., P(k) has the form
     !! P(k) = (  1                                            )
     !! (       ...                                     )
     !! (              1                                )
     !! (                   c(k)  s(k)                  )
     !! (                  -s(k)  c(k)                  )
     !! (                                1              )
     !! (                                     ...       )
     !! (                                            1  )
     !! where R(k) appears as a rank-2 modification to the identity matrix in
     !! rows and columns k and k+1.
     !! When PIVOT = 'T' (Top pivot), the rotation is performed for the
     !! plane (1,k+1), so P(k) has the form
     !! P(k) = (  c(k)                    s(k)                 )
     !! (         1                                     )
     !! (              ...                              )
     !! (                     1                         )
     !! ( -s(k)                    c(k)                 )
     !! (                                 1             )
     !! (                                      ...      )
     !! (                                             1 )
     !! where R(k) appears in rows and columns 1 and k+1.
     !! Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
     !! performed for the plane (k,z), giving P(k) the form
     !! P(k) = ( 1                                             )
     !! (      ...                                      )
     !! (             1                                 )
     !! (                  c(k)                    s(k) )
     !! (                         1                     )
     !! (                              ...              )
     !! (                                     1         )
     !! (                 -s(k)                    c(k) )
     !! where R(k) appears in rows and columns k and z.  The rotations are
     !! performed without ever forming P(k) explicitly.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: direct, pivot, side
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           real(sp), intent(in) :: c(*), s(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, info, j
           real(sp) :: ctemp, stemp
           complex(sp) :: temp
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( .not.( stdlib_lsame( side, 'L' ) .or. stdlib_lsame( side, 'R' ) ) ) then
              info = 1
           else if( .not.( stdlib_lsame( pivot, 'V' ) .or. stdlib_lsame( pivot,'T' ) .or. &
                     stdlib_lsame( pivot, 'B' ) ) ) then
              info = 2
           else if( .not.( stdlib_lsame( direct, 'F' ) .or. stdlib_lsame( direct, 'B' ) ) )&
                     then
              info = 3
           else if( m<0 ) then
              info = 4
           else if( n<0 ) then
              info = 5
           else if( lda<max( 1, m ) ) then
              info = 9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLASR ', info )
              return
           end if
           ! quick return if possible
           if( ( m==0 ) .or. ( n==0 ) )return
           if( stdlib_lsame( side, 'L' ) ) then
              ! form  p * a
              if( stdlib_lsame( pivot, 'V' ) ) then
                 if( stdlib_lsame( direct, 'F' ) ) then
                    do j = 1, m - 1
                       ctemp = c( j )
                       stemp = s( j )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, n
                             temp = a( j+1, i )
                             a( j+1, i ) = ctemp*temp - stemp*a( j, i )
                             a( j, i ) = stemp*temp + ctemp*a( j, i )
                          end do
                       end if
                    end do
                 else if( stdlib_lsame( direct, 'B' ) ) then
                    do j = m - 1, 1, -1
                       ctemp = c( j )
                       stemp = s( j )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, n
                             temp = a( j+1, i )
                             a( j+1, i ) = ctemp*temp - stemp*a( j, i )
                             a( j, i ) = stemp*temp + ctemp*a( j, i )
                          end do
                       end if
                    end do
                 end if
              else if( stdlib_lsame( pivot, 'T' ) ) then
                 if( stdlib_lsame( direct, 'F' ) ) then
                    do j = 2, m
                       ctemp = c( j-1 )
                       stemp = s( j-1 )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, n
                             temp = a( j, i )
                             a( j, i ) = ctemp*temp - stemp*a( 1, i )
                             a( 1, i ) = stemp*temp + ctemp*a( 1, i )
                          end do
                       end if
                    end do
                 else if( stdlib_lsame( direct, 'B' ) ) then
                    do j = m, 2, -1
                       ctemp = c( j-1 )
                       stemp = s( j-1 )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, n
                             temp = a( j, i )
                             a( j, i ) = ctemp*temp - stemp*a( 1, i )
                             a( 1, i ) = stemp*temp + ctemp*a( 1, i )
                          end do
                       end if
                    end do
                 end if
              else if( stdlib_lsame( pivot, 'B' ) ) then
                 if( stdlib_lsame( direct, 'F' ) ) then
                    do j = 1, m - 1
                       ctemp = c( j )
                       stemp = s( j )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, n
                             temp = a( j, i )
                             a( j, i ) = stemp*a( m, i ) + ctemp*temp
                             a( m, i ) = ctemp*a( m, i ) - stemp*temp
                          end do
                       end if
                    end do
                 else if( stdlib_lsame( direct, 'B' ) ) then
                    do j = m - 1, 1, -1
                       ctemp = c( j )
                       stemp = s( j )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, n
                             temp = a( j, i )
                             a( j, i ) = stemp*a( m, i ) + ctemp*temp
                             a( m, i ) = ctemp*a( m, i ) - stemp*temp
                          end do
                       end if
                    end do
                 end if
              end if
           else if( stdlib_lsame( side, 'R' ) ) then
              ! form a * p**t
              if( stdlib_lsame( pivot, 'V' ) ) then
                 if( stdlib_lsame( direct, 'F' ) ) then
                    do j = 1, n - 1
                       ctemp = c( j )
                       stemp = s( j )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, m
                             temp = a( i, j+1 )
                             a( i, j+1 ) = ctemp*temp - stemp*a( i, j )
                             a( i, j ) = stemp*temp + ctemp*a( i, j )
                          end do
                       end if
                    end do
                 else if( stdlib_lsame( direct, 'B' ) ) then
                    do j = n - 1, 1, -1
                       ctemp = c( j )
                       stemp = s( j )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, m
                             temp = a( i, j+1 )
                             a( i, j+1 ) = ctemp*temp - stemp*a( i, j )
                             a( i, j ) = stemp*temp + ctemp*a( i, j )
                          end do
                       end if
                    end do
                 end if
              else if( stdlib_lsame( pivot, 'T' ) ) then
                 if( stdlib_lsame( direct, 'F' ) ) then
                    do j = 2, n
                       ctemp = c( j-1 )
                       stemp = s( j-1 )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, m
                             temp = a( i, j )
                             a( i, j ) = ctemp*temp - stemp*a( i, 1 )
                             a( i, 1 ) = stemp*temp + ctemp*a( i, 1 )
                          end do
                       end if
                    end do
                 else if( stdlib_lsame( direct, 'B' ) ) then
                    do j = n, 2, -1
                       ctemp = c( j-1 )
                       stemp = s( j-1 )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, m
                             temp = a( i, j )
                             a( i, j ) = ctemp*temp - stemp*a( i, 1 )
                             a( i, 1 ) = stemp*temp + ctemp*a( i, 1 )
                          end do
                       end if
                    end do
                 end if
              else if( stdlib_lsame( pivot, 'B' ) ) then
                 if( stdlib_lsame( direct, 'F' ) ) then
                    do j = 1, n - 1
                       ctemp = c( j )
                       stemp = s( j )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, m
                             temp = a( i, j )
                             a( i, j ) = stemp*a( i, n ) + ctemp*temp
                             a( i, n ) = ctemp*a( i, n ) - stemp*temp
                          end do
                       end if
                    end do
                 else if( stdlib_lsame( direct, 'B' ) ) then
                    do j = n - 1, 1, -1
                       ctemp = c( j )
                       stemp = s( j )
                       if( ( ctemp/=one ) .or. ( stemp/=zero ) ) then
                          do i = 1, m
                             temp = a( i, j )
                             a( i, j ) = stemp*a( i, n ) + ctemp*temp
                             a( i, n ) = ctemp*a( i, n ) - stemp*temp
                          end do
                       end if
                    end do
                 end if
              end if
           end if
           return
     end subroutine stdlib_clasr


     pure subroutine stdlib_classq( n, x, incx, scl, sumsq )
     !! CLASSQ returns the values  scl  and  smsq  such that
     !! ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
     !! where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
     !! assumed to be non-negative.
     !! scale and sumsq must be supplied in SCALE and SUMSQ and
     !! scl and smsq are overwritten on SCALE and SUMSQ respectively.
     !! If scale * sqrt( sumsq ) > tbig then
     !! we require:   scale >= sqrt( TINY*EPS ) / sbig   on entry,
     !! and if 0 < scale * sqrt( sumsq ) < tsml then
     !! we require:   scale <= sqrt( HUGE ) / ssml       on entry,
     !! where
     !! tbig -- upper threshold for values whose square is representable;
     !! sbig -- scaling constant for big numbers; \see la_constants.f90
     !! tsml -- lower threshold for values whose square is representable;
     !! ssml -- scaling constant for small numbers; \see la_constants.f90
     !! and
     !! TINY*EPS -- tiniest representable number;
     !! HUGE     -- biggest representable number.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
        ! Scalar Arguments 
     integer(ilp), intent(in) :: incx, n
        real(sp), intent(inout) :: scl, sumsq
        ! Array Arguments 
        complex(sp), intent(in) :: x(*)
        ! Local Scalars 
     integer(ilp) :: i, ix
     logical(lk) :: notbig
        real(sp) :: abig, amed, asml, ax, ymax, ymin
        ! quick return if possible
        if( ieee_is_nan(scl) .or. ieee_is_nan(sumsq) ) return
        if( sumsq == zero ) scl = one
        if( scl == zero ) then
           scl = one
           sumsq = zero
        end if
        if (n <= 0) then
           return
        end if
        ! compute the sum of squares in 3 accumulators:
           ! abig -- sums of squares scaled down to avoid overflow
           ! asml -- sums of squares scaled up to avoid underflow
           ! amed -- sums of squares that do not require scaling
        ! the thresholds and multipliers are
           ! tbig -- values bigger than this are scaled down by sbig
           ! tsml -- values smaller than this are scaled up by ssml
        notbig = .true.
        asml = zero
        amed = zero
        abig = zero
        ix = 1
        if( incx < 0 ) ix = 1 - (n-1)*incx
        do i = 1, n
           ax = abs(real(x(ix),KIND=sp))
           if (ax > tbig) then
              abig = abig + (ax*sbig)**2
              notbig = .false.
           else if (ax < tsml) then
              if (notbig) asml = asml + (ax*ssml)**2
           else
              amed = amed + ax**2
           end if
           ax = abs(aimag(x(ix)))
           if (ax > tbig) then
              abig = abig + (ax*sbig)**2
              notbig = .false.
           else if (ax < tsml) then
              if (notbig) asml = asml + (ax*ssml)**2
           else
              amed = amed + ax**2
           end if
           ix = ix + incx
        end do
        ! put the existing sum of squares into one of the accumulators
        if( sumsq > zero ) then
           ax = scl*sqrt( sumsq )
           if (ax > tbig) then
              ! we assume scl >= sqrt( tiny*eps ) / sbig
              abig = abig + (scl*sbig)**2 * sumsq
           else if (ax < tsml) then
              ! we assume scl <= sqrt( huge ) / ssml
              if (notbig) asml = asml + (scl*ssml)**2 * sumsq
           else
              amed = amed + scl**2 * sumsq
           end if
        end if
        ! combine abig and amed or amed and asml if more than one
        ! accumulator was used.
        if (abig > zero) then
           ! combine abig and amed if abig > 0.
           if (amed > zero .or. ieee_is_nan(amed)) then
              abig = abig + (amed*sbig)*sbig
           end if
           scl = one / sbig
           sumsq = abig
        else if (asml > zero) then
           ! combine amed and asml if asml > 0.
           if (amed > zero .or. ieee_is_nan(amed)) then
              amed = sqrt(amed)
              asml = sqrt(asml) / ssml
              if (asml > amed) then
                 ymin = amed
                 ymax = asml
              else
                 ymin = asml
                 ymax = amed
              end if
              scl = one
              sumsq = ymax**2*( one + (ymin/ymax)**2 )
           else
              scl = one / ssml
              sumsq = asml
           end if
        else
           ! otherwise all values are mid-range or zero
           scl = one
           sumsq = amed
        end if
        return
     end subroutine stdlib_classq


     pure subroutine stdlib_claswp( n, a, lda, k1, k2, ipiv, incx )
     !! CLASWP performs a series of row interchanges on the matrix A.
     !! One row interchange is initiated for each of rows K1 through K2 of A.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, k1, k2, lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
       ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, i1, i2, inc, ip, ix, ix0, j, k, n32
           complex(sp) :: temp
           ! Executable Statements 
           ! interchange row i with row ipiv(k1+(i-k1)*abs(incx)) for each of rows
           ! k1 through k2.
           if( incx>0 ) then
              ix0 = k1
              i1 = k1
              i2 = k2
              inc = 1
           else if( incx<0 ) then
              ix0 = k1 + ( k1-k2 )*incx
              i1 = k2
              i2 = k1
              inc = -1
           else
              return
           end if
           n32 = ( n / 32 )*32
           if( n32/=0 ) then
              do j = 1, n32, 32
                 ix = ix0
                 do i = i1, i2, inc
                    ip = ipiv( ix )
                    if( ip/=i ) then
                       do k = j, j + 31
                          temp = a( i, k )
                          a( i, k ) = a( ip, k )
                          a( ip, k ) = temp
                       end do
                    end if
                    ix = ix + incx
                 end do
              end do
           end if
           if( n32/=n ) then
              n32 = n32 + 1
              ix = ix0
              do i = i1, i2, inc
                 ip = ipiv( ix )
                 if( ip/=i ) then
                    do k = n32, n
                       temp = a( i, k )
                       a( i, k ) = a( ip, k )
                       a( ip, k ) = temp
                    end do
                 end if
                 ix = ix + incx
              end do
           end if
           return
     end subroutine stdlib_claswp


     pure subroutine stdlib_clasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
     !! CLASYF computes a partial factorization of a complex symmetric matrix
     !! A using the Bunch-Kaufman diagonal pivoting method. The partial
     !! factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) ( D    0  ) ( L11**T L21**T )  if UPLO = 'L'
     !! ( L21  I ) ( 0   A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! Note that U**T denotes the transpose of U.
     !! CLASYF is an auxiliary routine called by CSYTRF. It uses blocked code
     !! (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
     !! A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           integer(ilp) :: imax, j, jb, jj, jmax, jp, k, kk, kkw, kp, kstep, kw
           real(sp) :: absakk, alpha, colmax, rowmax
           complex(sp) :: d11, d21, d22, r1, t, z
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,min,real,sqrt
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              ! kw is the column of w which corresponds to column k of a
              k = n
              10 continue
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              ! copy column k of a to column kw of w and update it
              call stdlib_ccopy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ), lda,w( k, &
                        kw+1 ), ldw, cone, w( 1, kw ), 1 )
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! copy column imax to column kw-1 of w and update it
                    call stdlib_ccopy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                    call stdlib_ccopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                              
                    if( k<n )call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda, w(&
                               imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_icamax( k-imax, w( imax+1, kw-1 ), 1 )
                    rowmax = cabs1( w( jmax, kw-1 ) )
                    if( imax>1 ) then
                       jmax = stdlib_icamax( imax-1, w( 1, kw-1 ), 1 )
                       rowmax = max( rowmax, cabs1( w( jmax, kw-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( w( imax, kw-1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column kw-1 of w to column kw of w
                       call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = a( kk, kk )
                    call stdlib_ccopy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    if( kp>1 )call stdlib_ccopy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_cswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_cswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! note: diagonal element u(k,k) is a unit element
                    ! and not stored.
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    call stdlib_ccopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    r1 = cone / a( k, k )
                    call stdlib_cscal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored.
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! compose the columns of the inverse of 2-by-2 pivot
                       ! block d in the following way to reduce the number
                       ! of flops when we myltiply panel ( w(kw-1) w(kw) ) by
                       ! this inverse
                       ! d**(-1) = ( d11 d21 )**(-1) =
                                 ! ( d21 d22 )
                       ! = 1/(d11*d22-d21**2) * ( ( d22 ) (-d21 ) ) =
                                              ! ( (-d21 ) ( d11 ) )
                       ! = 1/d21 * 1/((d11/d21)*(d22/d21)-1) *
                         ! * ( ( d22/d21 ) (      -1 ) ) =
                           ! ( (      -1 ) ( d11/d21 ) )
                       ! = 1/d21 * 1/(d22*d11-1) * ( ( d11 ) (  -1 ) ) =
                                                 ! ( ( -1  ) ( d22 ) )
                       ! = 1/d21 * t * ( ( d11 ) (  -1 ) )
                                     ! ( (  -1 ) ( d22 ) )
                       ! = d21 * ( ( d11 ) (  -1 ) )
                               ! ( (  -1 ) ( d22 ) )
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / d21
                       d22 = w( k-1, kw-1 ) / d21
                       t = cone / ( d11*d22-cone )
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       d21 = t / d21
                       do j = 1, k - 2
                          a( j, k-1 ) = d21*( d11*w( j, kw-1 )-w( j, kw ) )
                          a( j, k ) = d21*( d22*w( j, kw )-w( j, kw-1 ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_cgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k,-cone, a( 1, k+1 ), &
                           lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n looping backwards from k+1 to n
              j = k + 1
              60 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j + 1
                 end if
                 ! (note: here, j is used to determine row length. length n-j+1
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j + 1
                 if( jp/=jj .and. j<=n )call stdlib_cswap( n-j+1, a( jp, j ), lda, a( jj, j ), &
                           lda )
              if( j<n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              ! copy column k of a to column k of w and update it
              call stdlib_ccopy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ), lda,w( k, 1 ), ldw,&
                         cone, w( k, k ), 1 )
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! copy column imax to column k+1 of w and update it
                    call stdlib_ccopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1 )
                    call stdlib_ccopy( n-imax+1, a( imax, imax ), 1, w( imax, k+1 ),1 )
                    call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( imax, &
                              1 ), ldw, cone, w( k, k+1 ),1 )
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_icamax( imax-k, w( k, k+1 ), 1 )
                    rowmax = cabs1( w( jmax, k+1 ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_icamax( n-imax, w( imax+1, k+1 ), 1 )
                       rowmax = max( rowmax, cabs1( w( jmax, k+1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( w( imax, k+1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column k+1 of w to column k of w
                       call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = a( kk, kk )
                    call stdlib_ccopy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    if( kp<n )call stdlib_ccopy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (columns k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_cswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_cswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    call stdlib_ccopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       r1 = cone / a( k, k )
                       call stdlib_cscal( n-k, r1, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! (note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored)
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! compose the columns of the inverse of 2-by-2 pivot
                       ! block d in the following way to reduce the number
                       ! of flops when we myltiply panel ( w(k) w(k+1) ) by
                       ! this inverse
                       ! d**(-1) = ( d11 d21 )**(-1) =
                                 ! ( d21 d22 )
                       ! = 1/(d11*d22-d21**2) * ( ( d22 ) (-d21 ) ) =
                                              ! ( (-d21 ) ( d11 ) )
                       ! = 1/d21 * 1/((d11/d21)*(d22/d21)-1) *
                         ! * ( ( d22/d21 ) (      -1 ) ) =
                           ! ( (      -1 ) ( d11/d21 ) )
                       ! = 1/d21 * 1/(d22*d11-1) * ( ( d11 ) (  -1 ) ) =
                                                 ! ( ( -1  ) ( d22 ) )
                       ! = 1/d21 * t * ( ( d11 ) (  -1 ) )
                                     ! ( (  -1 ) ( d22 ) )
                       ! = d21 * ( ( d11 ) (  -1 ) )
                               ! ( (  -1 ) ( d22 ) )
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       d21 = t / d21
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = d21*( d11*w( j, k )-w( j, k+1 ) )
                          a( j, k+1 ) = d21*( d22*w( j, k+1 )-w( j, k ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_cgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! of rows in columns 1:k-1 looping backwards from k-1 to 1
              j = k - 1
              120 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j - 1
                 end if
                 ! (note: here, j is used to determine row length. length j
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j - 1
                 if( jp/=jj .and. j>=1 )call stdlib_cswap( j, a( jp, 1 ), lda, a( jj, 1 ), lda )
                           
              if( j>1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_clasyf


     pure subroutine stdlib_clasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
     !! CLASYF_RK computes a partial factorization of a complex symmetric
     !! matrix A using the bounded Bunch-Kaufman (rook) diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L',
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! CLASYF_RK is an auxiliary routine called by CSYTRF_RK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: e(*), w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, j, jb, jj, jmax, k, kk, kw, kkw, kp, kstep, p, ii
           real(sp) :: absakk, alpha, colmax, rowmax, sfmin, stemp
           complex(sp) :: d11, d12, d21, d22, r1, t, z
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,min,real,sqrt
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = czero
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              call stdlib_ccopy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ),lda, w( k, &
                        kw+1 ), ldw, cone, w( 1, kw ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_ccopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = czero
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       call stdlib_ccopy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                       call stdlib_ccopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       if( k<n )call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda,&
                                  w( imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_icamax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = cabs1( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_icamax( imax-1, w( 1, kw-1 ), 1 )
                          stemp = cabs1( w( itemp, kw-1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! cabs1( w( imax, kw-1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.(cabs1( w( imax, kw-1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_ccopy( k-p, a( p+1, k ), 1, a( p, p+1 ), lda )
                    call stdlib_ccopy( p, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in last n-k+1 columns of a
                    ! and last n-k+2 columns of w
                    call stdlib_cswap( n-k+1, a( k, k ), lda, a( p, k ), lda )
                    call stdlib_cswap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ), ldw )
                 end if
                 ! updated column kp is already stored in column kkw of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_ccopy( k-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_ccopy( kp, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last n-kk+1 columns
                    ! of a and w
                    call stdlib_cswap( n-kk+1, a( kk, kk ), lda, a( kp, kk ), lda )
                    call stdlib_cswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! store u(k) in column k of a
                    call stdlib_ccopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          r1 = cone / a( k, k )
                          call stdlib_cscal( k-1, r1, a( 1, k ), 1 )
                       else if( a( k, k )/=czero ) then
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now
                    ! hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    if( k>2 ) then
                       ! store u(k) and u(k-1) in columns k and k-1 of a
                       d12 = w( k-1, kw )
                       d11 = w( k, kw ) / d12
                       d22 = w( k-1, kw-1 ) / d12
                       t = cone / ( d11*d22-cone )
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( (d11*w( j, kw-1 )-w( j, kw ) ) /d12 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /d12 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy superdiagonal element of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = czero
                    a( k, k ) = w( k, kw )
                    e( k ) = w( k-1, kw )
                    e( k-1 ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_cgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb,n-k, -cone, a( &
                           1, k+1 ), lda, w( j, kw+1 ),ldw, cone, a( 1, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = czero
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update it
              call stdlib_ccopy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              if( k>1 )call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( k, &
                        1 ), ldw, cone, w( k, k ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_ccopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                 ! set e( k ) to zero
                 if( k<n )e( k ) = czero
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_ccopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_ccopy( n-imax+1, a( imax, imax ), 1,w( imax, k+1 ), 1 )
                       if( k>1 )call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone,a( k, 1 ), &
                                 lda, w( imax, 1 ), ldw,cone, w( k, k+1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_icamax( imax-k, w( k, k+1 ), 1 )
                          rowmax = cabs1( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_icamax( n-imax, w( imax+1, k+1 ), 1)
                          stemp = cabs1( w( itemp, k+1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! cabs1( w( imax, k+1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( cabs1( w( imax, k+1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 72
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_ccopy( p-k, a( k, k ), 1, a( p, k ), lda )
                    call stdlib_ccopy( n-p+1, a( p, k ), 1, a( p, p ), 1 )
                    ! interchange rows k and p in first k columns of a
                    ! and first k+1 columns of w
                    call stdlib_cswap( k, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_cswap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! updated column kp is already stored in column kk of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_ccopy( kp-k-1, a( k+1, kk ), 1, a( kp, k+1 ), lda )
                    call stdlib_ccopy( n-kp+1, a( kp, kk ), 1, a( kp, kp ), 1 )
                    ! interchange rows kk and kp in first kk columns of a and w
                    call stdlib_cswap( kk, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_cswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    ! store l(k) in column k of a
                    call stdlib_ccopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          r1 = cone / a( k, k )
                          call stdlib_cscal( n-k, r1, a( k+1, k ), 1 )
                       else if( a( k, k )/=czero ) then
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! store l(k) and l(k+1) in columns k and k+1 of a
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /d21 )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy subdiagonal element of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = czero
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    e( k ) = w( k+1, k )
                    e( k+1 ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_cgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_clasyf_rk


     pure subroutine stdlib_clasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
     !! CLASYF_ROOK computes a partial factorization of a complex symmetric
     !! matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! CLASYF_ROOK is an auxiliary routine called by CSYTRF_ROOK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, j, jb, jj, jmax, jp1, jp2, k, kk, kw, kkw, kp, kstep, p, &
                     ii
           real(sp) :: absakk, alpha, colmax, rowmax, stemp, sfmin
           complex(sp) :: d11, d12, d21, d22, r1, t, z
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt,aimag,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              call stdlib_ccopy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ),lda, w( k, &
                        kw+1 ), ldw, cone, w( 1, kw ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_ccopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       call stdlib_ccopy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                       call stdlib_ccopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       if( k<n )call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda,&
                                  w( imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_icamax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = cabs1( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_icamax( imax-1, w( 1, kw-1 ), 1 )
                          stemp = cabs1( w( itemp, kw-1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! cabs1( w( imax, kw-1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.(cabs1( w( imax, kw-1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_ccopy( k-p, a( p+1, k ), 1, a( p, p+1 ), lda )
                    call stdlib_ccopy( p, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in last n-k+1 columns of a
                    ! and last n-k+2 columns of w
                    call stdlib_cswap( n-k+1, a( k, k ), lda, a( p, k ), lda )
                    call stdlib_cswap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ), ldw )
                 end if
                 ! updated column kp is already stored in column kkw of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_ccopy( k-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_ccopy( kp, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last n-kk+1 columns
                    ! of a and w
                    call stdlib_cswap( n-kk+1, a( kk, kk ), lda, a( kp, kk ), lda )
                    call stdlib_cswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! store u(k) in column k of a
                    call stdlib_ccopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          r1 = cone / a( k, k )
                          call stdlib_cscal( k-1, r1, a( 1, k ), 1 )
                       else if( a( k, k )/=czero ) then
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now
                    ! hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    if( k>2 ) then
                       ! store u(k) and u(k-1) in columns k and k-1 of a
                       d12 = w( k-1, kw )
                       d11 = w( k, kw ) / d12
                       d22 = w( k-1, kw-1 ) / d12
                       t = cone / ( d11*d22-cone )
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( (d11*w( j, kw-1 )-w( j, kw ) ) /d12 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /d12 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_cgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb,n-k, -cone, a( &
                           1, k+1 ), lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n
              j = k + 1
              60 continue
                 kstep = 1
                 jp1 = 1
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    j = j + 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 j = j + 1
                 if( jp2/=jj .and. j<=n )call stdlib_cswap( n-j+1, a( jp2, j ), lda, a( jj, j ), &
                           lda )
                 jj = j - 1
                 if( jp1/=jj .and. kstep==2 )call stdlib_cswap( n-j+1, a( jp1, j ), lda, a( jj, j &
                           ), lda )
              if( j<=n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update it
              call stdlib_ccopy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              if( k>1 )call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( k, &
                        1 ), ldw, cone, w( k, k ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_ccopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_ccopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_ccopy( n-imax+1, a( imax, imax ), 1,w( imax, k+1 ), 1 )
                       if( k>1 )call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone,a( k, 1 ), &
                                 lda, w( imax, 1 ), ldw,cone, w( k, k+1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_icamax( imax-k, w( k, k+1 ), 1 )
                          rowmax = cabs1( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_icamax( n-imax, w( imax+1, k+1 ), 1)
                          stemp = cabs1( w( itemp, k+1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! cabs1( w( imax, k+1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( cabs1( w( imax, k+1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 72
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_ccopy( p-k, a( k, k ), 1, a( p, k ), lda )
                    call stdlib_ccopy( n-p+1, a( p, k ), 1, a( p, p ), 1 )
                    ! interchange rows k and p in first k columns of a
                    ! and first k+1 columns of w
                    call stdlib_cswap( k, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_cswap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! updated column kp is already stored in column kk of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_ccopy( kp-k-1, a( k+1, kk ), 1, a( kp, k+1 ), lda )
                    call stdlib_ccopy( n-kp+1, a( kp, kk ), 1, a( kp, kp ), 1 )
                    ! interchange rows kk and kp in first kk columns of a and w
                    call stdlib_cswap( kk, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_cswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    ! store l(k) in column k of a
                    call stdlib_ccopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          r1 = cone / a( k, k )
                          call stdlib_cscal( n-k, r1, a( k+1, k ), 1 )
                       else if( a( k, k )/=czero ) then
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! store l(k) and l(k+1) in columns k and k+1 of a
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /d21 )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_cgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ), ldw,cone, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! in columns 1:k-1
              j = k - 1
              120 continue
                 kstep = 1
                 jp1 = 1
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    j = j - 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 j = j - 1
                 if( jp2/=jj .and. j>=1 )call stdlib_cswap( j, a( jp2, 1 ), lda, a( jj, 1 ), lda )
                           
                 jj = j + 1
                 if( jp1/=jj .and. kstep==2 )call stdlib_cswap( j, a( jp1, 1 ), lda, a( jj, 1 ), &
                           lda )
              if( j>=1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_clasyf_rook


     pure subroutine stdlib_clatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,scale, cnorm, &
     !! CLATBS solves one of the triangular systems
     !! A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
     !! with scaling to prevent overflow, where A is an upper or lower
     !! triangular band matrix.  Here A**T denotes the transpose of A, x and b
     !! are n-element vectors, and s is a scaling factor, usually less than
     !! or equal to 1, chosen so that the components of x will be less than
     !! the overflow threshold.  If the unscaled problem will not cause
     !! overflow, the Level 2 BLAS routine CTBSV is called.  If the matrix A
     !! is singular (A(j,j) = 0 for some j), then s is set to 0 and a
     !! non-trivial solution to A*x = 0 is returned.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, normin, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, n
           real(sp), intent(out) :: scale
           ! Array Arguments 
           real(sp), intent(inout) :: cnorm(*)
           complex(sp), intent(in) :: ab(ldab,*)
           complex(sp), intent(inout) :: x(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notran, nounit, upper
           integer(ilp) :: i, imax, j, jfirst, jinc, jlast, jlen, maind
           real(sp) :: bignum, grow, rec, smlnum, tjj, tmax, tscal, xbnd, xj, xmax
           complex(sp) :: csumj, tjjs, uscal, zdum
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,conjg,max,min,real
           ! Statement Functions 
           real(sp) :: cabs1, cabs2
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           cabs2( zdum ) = abs( real( zdum,KIND=sp) / 2. ) +abs( aimag( zdum ) / 2. )
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           notran = stdlib_lsame( trans, 'N' )
           nounit = stdlib_lsame( diag, 'N' )
           ! test the input parameters.
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( .not.stdlib_lsame( normin, 'Y' ) .and. .not.stdlib_lsame( normin, 'N' ) ) &
                     then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( kd<0 ) then
              info = -6
           else if( ldab<kd+1 ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLATBS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine machine dependent parameters to control overflow.
           smlnum = stdlib_slamch( 'SAFE MINIMUM' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = smlnum / stdlib_slamch( 'PRECISION' )
           bignum = one / smlnum
           scale = one
           if( stdlib_lsame( normin, 'N' ) ) then
              ! compute the 1-norm of each column, not including the diagonal.
              if( upper ) then
                 ! a is upper triangular.
                 do j = 1, n
                    jlen = min( kd, j-1 )
                    cnorm( j ) = stdlib_scasum( jlen, ab( kd+1-jlen, j ), 1 )
                 end do
              else
                 ! a is lower triangular.
                 do j = 1, n
                    jlen = min( kd, n-j )
                    if( jlen>0 ) then
                       cnorm( j ) = stdlib_scasum( jlen, ab( 2, j ), 1 )
                    else
                       cnorm( j ) = zero
                    end if
                 end do
              end if
           end if
           ! scale the column norms by tscal if the maximum element in cnorm is
           ! greater than bignum/2.
           imax = stdlib_isamax( n, cnorm, 1 )
           tmax = cnorm( imax )
           if( tmax<=bignum*half ) then
              tscal = one
           else
              tscal = half / ( smlnum*tmax )
              call stdlib_sscal( n, tscal, cnorm, 1 )
           end if
           ! compute a bound on the computed solution vector to see if the
           ! level 2 blas routine stdlib_ctbsv can be used.
           xmax = zero
           do j = 1, n
              xmax = max( xmax, cabs2( x( j ) ) )
           end do
           xbnd = xmax
           if( notran ) then
              ! compute the growth in a * x = b.
              if( upper ) then
                 jfirst = n
                 jlast = 1
                 jinc = -1
                 maind = kd + 1
              else
                 jfirst = 1
                 jlast = n
                 jinc = 1
                 maind = 1
              end if
              if( tscal/=one ) then
                 grow = zero
                 go to 60
              end if
              if( nounit ) then
                 ! a is non-unit triangular.
                 ! compute grow = 1/g(j) and xbnd = 1/m(j).
                 ! initially, g(0) = max{x(i), i=1,...,n}.
                 grow = half / max( xbnd, smlnum )
                 xbnd = grow
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 60
                    tjjs = ab( maind, j )
                    tjj = cabs1( tjjs )
                    if( tjj>=smlnum ) then
                       ! m(j) = g(j-1) / abs(a(j,j))
                       xbnd = min( xbnd, min( one, tjj )*grow )
                    else
                       ! m(j) could overflow, set xbnd to 0.
                       xbnd = zero
                    end if
                    if( tjj+cnorm( j )>=smlnum ) then
                       ! g(j) = g(j-1)*( 1 + cnorm(j) / abs(a(j,j)) )
                       grow = grow*( tjj / ( tjj+cnorm( j ) ) )
                    else
                       ! g(j) could overflow, set grow to 0.
                       grow = zero
                    end if
                 end do
                 grow = xbnd
              else
                 ! a is unit triangular.
                 ! compute grow = 1/g(j), where g(0) = max{x(i), i=1,...,n}.
                 grow = min( one, half / max( xbnd, smlnum ) )
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 60
                    ! g(j) = g(j-1)*( 1 + cnorm(j) )
                    grow = grow*( one / ( one+cnorm( j ) ) )
                 end do
              end if
              60 continue
           else
              ! compute the growth in a**t * x = b  or  a**h * x = b.
              if( upper ) then
                 jfirst = 1
                 jlast = n
                 jinc = 1
                 maind = kd + 1
              else
                 jfirst = n
                 jlast = 1
                 jinc = -1
                 maind = 1
              end if
              if( tscal/=one ) then
                 grow = zero
                 go to 90
              end if
              if( nounit ) then
                 ! a is non-unit triangular.
                 ! compute grow = 1/g(j) and xbnd = 1/m(j).
                 ! initially, m(0) = max{x(i), i=1,...,n}.
                 grow = half / max( xbnd, smlnum )
                 xbnd = grow
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 90
                    ! g(j) = max( g(j-1), m(j-1)*( 1 + cnorm(j) ) )
                    xj = one + cnorm( j )
                    grow = min( grow, xbnd / xj )
                    tjjs = ab( maind, j )
                    tjj = cabs1( tjjs )
                    if( tjj>=smlnum ) then
                       ! m(j) = m(j-1)*( 1 + cnorm(j) ) / abs(a(j,j))
                       if( xj>tjj )xbnd = xbnd*( tjj / xj )
                    else
                       ! m(j) could overflow, set xbnd to 0.
                       xbnd = zero
                    end if
                 end do
                 grow = min( grow, xbnd )
              else
                 ! a is unit triangular.
                 ! compute grow = 1/g(j), where g(0) = max{x(i), i=1,...,n}.
                 grow = min( one, half / max( xbnd, smlnum ) )
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 90
                    ! g(j) = ( 1 + cnorm(j) )*g(j-1)
                    xj = one + cnorm( j )
                    grow = grow / xj
                 end do
              end if
              90 continue
           end if
           if( ( grow*tscal )>smlnum ) then
              ! use the level 2 blas solve if the reciprocal of the bound on
              ! elements of x is not too small.
              call stdlib_ctbsv( uplo, trans, diag, n, kd, ab, ldab, x, 1 )
           else
              ! use a level 1 blas solve, scaling intermediate results.
              if( xmax>bignum*half ) then
                 ! scale x so that its components are less than or equal to
                 ! bignum in absolute value.
                 scale = ( bignum*half ) / xmax
                 call stdlib_csscal( n, scale, x, 1 )
                 xmax = bignum
              else
                 xmax = xmax*two
              end if
              if( notran ) then
                 ! solve a * x = b
                 loop_110: do j = jfirst, jlast, jinc
                    ! compute x(j) = b(j) / a(j,j), scaling x if necessary.
                    xj = cabs1( x( j ) )
                    if( nounit ) then
                       tjjs = ab( maind, j )*tscal
                    else
                       tjjs = tscal
                       if( tscal==one )go to 105
                    end if
                       tjj = cabs1( tjjs )
                       if( tjj>smlnum ) then
                          ! abs(a(j,j)) > smlnum:
                          if( tjj<one ) then
                             if( xj>tjj*bignum ) then
                                ! scale x by 1/b(j).
                                rec = one / xj
                                call stdlib_csscal( n, rec, x, 1 )
                                scale = scale*rec
                                xmax = xmax*rec
                             end if
                          end if
                          x( j ) = stdlib_cladiv( x( j ), tjjs )
                          xj = cabs1( x( j ) )
                       else if( tjj>zero ) then
                          ! 0 < abs(a(j,j)) <= smlnum:
                          if( xj>tjj*bignum ) then
                             ! scale x by (1/abs(x(j)))*abs(a(j,j))*bignum
                             ! to avoid overflow when dividing by a(j,j).
                             rec = ( tjj*bignum ) / xj
                             if( cnorm( j )>one ) then
                                ! scale by 1/cnorm(j) to avoid overflow when
                                ! multiplying x(j) times column j.
                                rec = rec / cnorm( j )
                             end if
                             call stdlib_csscal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                          x( j ) = stdlib_cladiv( x( j ), tjjs )
                          xj = cabs1( x( j ) )
                       else
                          ! a(j,j) = 0:  set x(1:n) = 0, x(j) = 1, and
                          ! scale = 0, and compute a solution to a*x = 0.
                          do i = 1, n
                             x( i ) = zero
                          end do
                          x( j ) = one
                          xj = one
                          scale = zero
                          xmax = zero
                       end if
                       105 continue
                    ! scale x if necessary to avoid overflow when adding a
                    ! multiple of column j of a.
                    if( xj>one ) then
                       rec = one / xj
                       if( cnorm( j )>( bignum-xmax )*rec ) then
                          ! scale x by 1/(2*abs(x(j))).
                          rec = rec*half
                          call stdlib_csscal( n, rec, x, 1 )
                          scale = scale*rec
                       end if
                    else if( xj*cnorm( j )>( bignum-xmax ) ) then
                       ! scale x by 1/2.
                       call stdlib_csscal( n, half, x, 1 )
                       scale = scale*half
                    end if
                    if( upper ) then
                       if( j>1 ) then
                          ! compute the update
                             ! x(max(1,j-kd):j-1) := x(max(1,j-kd):j-1) -
                                                   ! x(j)* a(max(1,j-kd):j-1,j)
                          jlen = min( kd, j-1 )
                          call stdlib_caxpy( jlen, -x( j )*tscal,ab( kd+1-jlen, j ), 1, x( j-jlen &
                                    ), 1 )
                          i = stdlib_icamax( j-1, x, 1 )
                          xmax = cabs1( x( i ) )
                       end if
                    else if( j<n ) then
                       ! compute the update
                          ! x(j+1:min(j+kd,n)) := x(j+1:min(j+kd,n)) -
                                                ! x(j) * a(j+1:min(j+kd,n),j)
                       jlen = min( kd, n-j )
                       if( jlen>0 )call stdlib_caxpy( jlen, -x( j )*tscal, ab( 2, j ), 1,x( j+1 ),&
                                  1 )
                       i = j + stdlib_icamax( n-j, x( j+1 ), 1 )
                       xmax = cabs1( x( i ) )
                    end if
                 end do loop_110
              else if( stdlib_lsame( trans, 'T' ) ) then
                 ! solve a**t * x = b
                 loop_150: do j = jfirst, jlast, jinc
                    ! compute x(j) = b(j) - sum a(k,j)*x(k).
                                          ! k<>j
                    xj = cabs1( x( j ) )
                    uscal = tscal
                    rec = one / max( xmax, one )
                    if( cnorm( j )>( bignum-xj )*rec ) then
                       ! if x(j) could overflow, scale x by 1/(2*xmax).
                       rec = rec*half
                       if( nounit ) then
                          tjjs = ab( maind, j )*tscal
                       else
                          tjjs = tscal
                       end if
                          tjj = cabs1( tjjs )
                          if( tjj>one ) then
                             ! divide by a(j,j) when scaling x if a(j,j) > 1.
                             rec = min( one, rec*tjj )
                             uscal = stdlib_cladiv( uscal, tjjs )
                          end if
                       if( rec<one ) then
                          call stdlib_csscal( n, rec, x, 1 )
                          scale = scale*rec
                          xmax = xmax*rec
                       end if
                    end if
                    csumj = zero
                    if( uscal==cmplx( one,KIND=sp) ) then
                       ! if the scaling needed for a in the dot product is 1,
                       ! call stdlib_cdotu to perform the dot product.
                       if( upper ) then
                          jlen = min( kd, j-1 )
                          csumj = stdlib_cdotu( jlen, ab( kd+1-jlen, j ), 1,x( j-jlen ), 1 )
                                    
                       else
                          jlen = min( kd, n-j )
                          if( jlen>1 )csumj = stdlib_cdotu( jlen, ab( 2, j ), 1, x( j+1 ),1 )
                                    
                       end if
                    else
                       ! otherwise, use in-line code for the dot product.
                       if( upper ) then
                          jlen = min( kd, j-1 )
                          do i = 1, jlen
                             csumj = csumj + ( ab( kd+i-jlen, j )*uscal )*x( j-jlen-1+i )
                          end do
                       else
                          jlen = min( kd, n-j )
                          do i = 1, jlen
                             csumj = csumj + ( ab( i+1, j )*uscal )*x( j+i )
                          end do
                       end if
                    end if
                    if( uscal==cmplx( tscal,KIND=sp) ) then
                       ! compute x(j) := ( x(j) - csumj ) / a(j,j) if 1/a(j,j)
                       ! was not used to scale the dotproduct.
                       x( j ) = x( j ) - csumj
                       xj = cabs1( x( j ) )
                       if( nounit ) then
                          ! compute x(j) = x(j) / a(j,j), scaling if necessary.
                          tjjs = ab( maind, j )*tscal
                       else
                          tjjs = tscal
                          if( tscal==one )go to 145
                       end if
                          tjj = cabs1( tjjs )
                          if( tjj>smlnum ) then
                             ! abs(a(j,j)) > smlnum:
                             if( tjj<one ) then
                                if( xj>tjj*bignum ) then
                                   ! scale x by 1/abs(x(j)).
                                   rec = one / xj
                                   call stdlib_csscal( n, rec, x, 1 )
                                   scale = scale*rec
                                   xmax = xmax*rec
                                end if
                             end if
                             x( j ) = stdlib_cladiv( x( j ), tjjs )
                          else if( tjj>zero ) then
                             ! 0 < abs(a(j,j)) <= smlnum:
                             if( xj>tjj*bignum ) then
                                ! scale x by (1/abs(x(j)))*abs(a(j,j))*bignum.
                                rec = ( tjj*bignum ) / xj
                                call stdlib_csscal( n, rec, x, 1 )
                                scale = scale*rec
                                xmax = xmax*rec
                             end if
                             x( j ) = stdlib_cladiv( x( j ), tjjs )
                          else
                             ! a(j,j) = 0:  set x(1:n) = 0, x(j) = 1, and
                             ! scale = 0 and compute a solution to a**t *x = 0.
                             do i = 1, n
                                x( i ) = zero
                             end do
                             x( j ) = one
                             scale = zero
                             xmax = zero
                          end if
                          145 continue
                    else
                       ! compute x(j) := x(j) / a(j,j) - csumj if the dot
                       ! product has already been divided by 1/a(j,j).
                       x( j ) = stdlib_cladiv( x( j ), tjjs ) - csumj
                    end if
                    xmax = max( xmax, cabs1( x( j ) ) )
                 end do loop_150
              else
                 ! solve a**h * x = b
                 loop_190: do j = jfirst, jlast, jinc
                    ! compute x(j) = b(j) - sum a(k,j)*x(k).
                                          ! k<>j
                    xj = cabs1( x( j ) )
                    uscal = tscal
                    rec = one / max( xmax, one )
                    if( cnorm( j )>( bignum-xj )*rec ) then
                       ! if x(j) could overflow, scale x by 1/(2*xmax).
                       rec = rec*half
                       if( nounit ) then
                          tjjs = conjg( ab( maind, j ) )*tscal
                       else
                          tjjs = tscal
                       end if
                          tjj = cabs1( tjjs )
                          if( tjj>one ) then
                             ! divide by a(j,j) when scaling x if a(j,j) > 1.
                             rec = min( one, rec*tjj )
                             uscal = stdlib_cladiv( uscal, tjjs )
                          end if
                       if( rec<one ) then
                          call stdlib_csscal( n, rec, x, 1 )
                          scale = scale*rec
                          xmax = xmax*rec
                       end if
                    end if
                    csumj = zero
                    if( uscal==cmplx( one,KIND=sp) ) then
                       ! if the scaling needed for a in the dot product is 1,
                       ! call stdlib_cdotc to perform the dot product.
                       if( upper ) then
                          jlen = min( kd, j-1 )
                          csumj = stdlib_cdotc( jlen, ab( kd+1-jlen, j ), 1,x( j-jlen ), 1 )
                                    
                       else
                          jlen = min( kd, n-j )
                          if( jlen>1 )csumj = stdlib_cdotc( jlen, ab( 2, j ), 1, x( j+1 ),1 )
                                    
                       end if
                    else
                       ! otherwise, use in-line code for the dot product.
                       if( upper ) then
                          jlen = min( kd, j-1 )
                          do i = 1, jlen
                             csumj = csumj + ( conjg( ab( kd+i-jlen, j ) )*uscal )*x( j-jlen-1+i )
                                       
                          end do
                       else
                          jlen = min( kd, n-j )
                          do i = 1, jlen
                             csumj = csumj + ( conjg( ab( i+1, j ) )*uscal )*x( j+i )
                          end do
                       end if
                    end if
                    if( uscal==cmplx( tscal,KIND=sp) ) then
                       ! compute x(j) := ( x(j) - csumj ) / a(j,j) if 1/a(j,j)
                       ! was not used to scale the dotproduct.
                       x( j ) = x( j ) - csumj
                       xj = cabs1( x( j ) )
                       if( nounit ) then
                          ! compute x(j) = x(j) / a(j,j), scaling if necessary.
                          tjjs = conjg( ab( maind, j ) )*tscal
                       else
                          tjjs = tscal
                          if( tscal==one )go to 185
                       end if
                          tjj = cabs1( tjjs )
                          if( tjj>smlnum ) then
                             ! abs(a(j,j)) > smlnum:
                             if( tjj<one ) then
                                if( xj>tjj*bignum ) then
                                   ! scale x by 1/abs(x(j)).
                                   rec = one / xj
                                   call stdlib_csscal( n, rec, x, 1 )
                                   scale = scale*rec
                                   xmax = xmax*rec
                                end if
                             end if
                             x( j ) = stdlib_cladiv( x( j ), tjjs )
                          else if( tjj>zero ) then
                             ! 0 < abs(a(j,j)) <= smlnum:
                             if( xj>tjj*bignum ) then
                                ! scale x by (1/abs(x(j)))*abs(a(j,j))*bignum.
                                rec = ( tjj*bignum ) / xj
                                call stdlib_csscal( n, rec, x, 1 )
                                scale = scale*rec
                                xmax = xmax*rec
                             end if
                             x( j ) = stdlib_cladiv( x( j ), tjjs )
                          else
                             ! a(j,j) = 0:  set x(1:n) = 0, x(j) = 1, and
                             ! scale = 0 and compute a solution to a**h *x = 0.
                             do i = 1, n
                                x( i ) = zero
                             end do
                             x( j ) = one
                             scale = zero
                             xmax = zero
                          end if
                          185 continue
                    else
                       ! compute x(j) := x(j) / a(j,j) - csumj if the dot
                       ! product has already been divided by 1/a(j,j).
                       x( j ) = stdlib_cladiv( x( j ), tjjs ) - csumj
                    end if
                    xmax = max( xmax, cabs1( x( j ) ) )
                 end do loop_190
              end if
              scale = scale / tscal
           end if
           ! scale the column norms by 1/tscal for return.
           if( tscal/=one ) then
              call stdlib_sscal( n, one / tscal, cnorm, 1 )
           end if
           return
     end subroutine stdlib_clatbs


     pure subroutine stdlib_clatps( uplo, trans, diag, normin, n, ap, x, scale,cnorm, info )
     !! CLATPS solves one of the triangular systems
     !! A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
     !! with scaling to prevent overflow, where A is an upper or lower
     !! triangular matrix stored in packed form.  Here A**T denotes the
     !! transpose of A, A**H denotes the conjugate transpose of A, x and b
     !! are n-element vectors, and s is a scaling factor, usually less than
     !! or equal to 1, chosen so that the components of x will be less than
     !! the overflow threshold.  If the unscaled problem will not cause
     !! overflow, the Level 2 BLAS routine CTPSV is called. If the matrix A
     !! is singular (A(j,j) = 0 for some j), then s is set to 0 and a
     !! non-trivial solution to A*x = 0 is returned.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, normin, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(sp), intent(out) :: scale
           ! Array Arguments 
           real(sp), intent(inout) :: cnorm(*)
           complex(sp), intent(in) :: ap(*)
           complex(sp), intent(inout) :: x(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notran, nounit, upper
           integer(ilp) :: i, imax, ip, j, jfirst, jinc, jlast, jlen
           real(sp) :: bignum, grow, rec, smlnum, tjj, tmax, tscal, xbnd, xj, xmax
           complex(sp) :: csumj, tjjs, uscal, zdum
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,conjg,max,min,real
           ! Statement Functions 
           real(sp) :: cabs1, cabs2
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           cabs2( zdum ) = abs( real( zdum,KIND=sp) / 2. ) +abs( aimag( zdum ) / 2. )
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           notran = stdlib_lsame( trans, 'N' )
           nounit = stdlib_lsame( diag, 'N' )
           ! test the input parameters.
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( .not.stdlib_lsame( normin, 'Y' ) .and. .not.stdlib_lsame( normin, 'N' ) ) &
                     then
              info = -4
           else if( n<0 ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLATPS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine machine dependent parameters to control overflow.
           smlnum = stdlib_slamch( 'SAFE MINIMUM' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = smlnum / stdlib_slamch( 'PRECISION' )
           bignum = one / smlnum
           scale = one
           if( stdlib_lsame( normin, 'N' ) ) then
              ! compute the 1-norm of each column, not including the diagonal.
              if( upper ) then
                 ! a is upper triangular.
                 ip = 1
                 do j = 1, n
                    cnorm( j ) = stdlib_scasum( j-1, ap( ip ), 1 )
                    ip = ip + j
                 end do
              else
                 ! a is lower triangular.
                 ip = 1
                 do j = 1, n - 1
                    cnorm( j ) = stdlib_scasum( n-j, ap( ip+1 ), 1 )
                    ip = ip + n - j + 1
                 end do
                 cnorm( n ) = zero
              end if
           end if
           ! scale the column norms by tscal if the maximum element in cnorm is
           ! greater than bignum/2.
           imax = stdlib_isamax( n, cnorm, 1 )
           tmax = cnorm( imax )
           if( tmax<=bignum*half ) then
              tscal = one
           else
              tscal = half / ( smlnum*tmax )
              call stdlib_sscal( n, tscal, cnorm, 1 )
           end if
           ! compute a bound on the computed solution vector to see if the
           ! level 2 blas routine stdlib_ctpsv can be used.
           xmax = zero
           do j = 1, n
              xmax = max( xmax, cabs2( x( j ) ) )
           end do
           xbnd = xmax
           if( notran ) then
              ! compute the growth in a * x = b.
              if( upper ) then
                 jfirst = n
                 jlast = 1
                 jinc = -1
              else
                 jfirst = 1
                 jlast = n
                 jinc = 1
              end if
              if( tscal/=one ) then
                 grow = zero
                 go to 60
              end if
              if( nounit ) then
                 ! a is non-unit triangular.
                 ! compute grow = 1/g(j) and xbnd = 1/m(j).
                 ! initially, g(0) = max{x(i), i=1,...,n}.
                 grow = half / max( xbnd, smlnum )
                 xbnd = grow
                 ip = jfirst*( jfirst+1 ) / 2
                 jlen = n
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 60
                    tjjs = ap( ip )
                    tjj = cabs1( tjjs )
                    if( tjj>=smlnum ) then
                       ! m(j) = g(j-1) / abs(a(j,j))
                       xbnd = min( xbnd, min( one, tjj )*grow )
                    else
                       ! m(j) could overflow, set xbnd to 0.
                       xbnd = zero
                    end if
                    if( tjj+cnorm( j )>=smlnum ) then
                       ! g(j) = g(j-1)*( 1 + cnorm(j) / abs(a(j,j)) )
                       grow = grow*( tjj / ( tjj+cnorm( j ) ) )
                    else
                       ! g(j) could overflow, set grow to 0.
                       grow = zero
                    end if
                    ip = ip + jinc*jlen
                    jlen = jlen - 1
                 end do
                 grow = xbnd
              else
                 ! a is unit triangular.
                 ! compute grow = 1/g(j), where g(0) = max{x(i), i=1,...,n}.
                 grow = min( one, half / max( xbnd, smlnum ) )
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 60
                    ! g(j) = g(j-1)*( 1 + cnorm(j) )
                    grow = grow*( one / ( one+cnorm( j ) ) )
                 end do
              end if
              60 continue
           else
              ! compute the growth in a**t * x = b  or  a**h * x = b.
              if( upper ) then
                 jfirst = 1
                 jlast = n
                 jinc = 1
              else
                 jfirst = n
                 jlast = 1
                 jinc = -1
              end if
              if( tscal/=one ) then
                 grow = zero
                 go to 90
              end if
              if( nounit ) then
                 ! a is non-unit triangular.
                 ! compute grow = 1/g(j) and xbnd = 1/m(j).
                 ! initially, m(0) = max{x(i), i=1,...,n}.
                 grow = half / max( xbnd, smlnum )
                 xbnd = grow
                 ip = jfirst*( jfirst+1 ) / 2
                 jlen = 1
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 90
                    ! g(j) = max( g(j-1), m(j-1)*( 1 + cnorm(j) ) )
                    xj = one + cnorm( j )
                    grow = min( grow, xbnd / xj )
                    tjjs = ap( ip )
                    tjj = cabs1( tjjs )
                    if( tjj>=smlnum ) then
                       ! m(j) = m(j-1)*( 1 + cnorm(j) ) / abs(a(j,j))
                       if( xj>tjj )xbnd = xbnd*( tjj / xj )
                    else
                       ! m(j) could overflow, set xbnd to 0.
                       xbnd = zero
                    end if
                    jlen = jlen + 1
                    ip = ip + jinc*jlen
                 end do
                 grow = min( grow, xbnd )
              else
                 ! a is unit triangular.
                 ! compute grow = 1/g(j), where g(0) = max{x(i), i=1,...,n}.
                 grow = min( one, half / max( xbnd, smlnum ) )
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 90
                    ! g(j) = ( 1 + cnorm(j) )*g(j-1)
                    xj = one + cnorm( j )
                    grow = grow / xj
                 end do
              end if
              90 continue
           end if
           if( ( grow*tscal )>smlnum ) then
              ! use the level 2 blas solve if the reciprocal of the bound on
              ! elements of x is not too small.
              call stdlib_ctpsv( uplo, trans, diag, n, ap, x, 1 )
           else
              ! use a level 1 blas solve, scaling intermediate results.
              if( xmax>bignum*half ) then
                 ! scale x so that its components are less than or equal to
                 ! bignum in absolute value.
                 scale = ( bignum*half ) / xmax
                 call stdlib_csscal( n, scale, x, 1 )
                 xmax = bignum
              else
                 xmax = xmax*two
              end if
              if( notran ) then
                 ! solve a * x = b
                 ip = jfirst*( jfirst+1 ) / 2
                 loop_110: do j = jfirst, jlast, jinc
                    ! compute x(j) = b(j) / a(j,j), scaling x if necessary.
                    xj = cabs1( x( j ) )
                    if( nounit ) then
                       tjjs = ap( ip )*tscal
                    else
                       tjjs = tscal
                       if( tscal==one )go to 105
                    end if
                       tjj = cabs1( tjjs )
                       if( tjj>smlnum ) then
                          ! abs(a(j,j)) > smlnum:
                          if( tjj<one ) then
                             if( xj>tjj*bignum ) then
                                ! scale x by 1/b(j).
                                rec = one / xj
                                call stdlib_csscal( n, rec, x, 1 )
                                scale = scale*rec
                                xmax = xmax*rec
                             end if
                          end if
                          x( j ) = stdlib_cladiv( x( j ), tjjs )
                          xj = cabs1( x( j ) )
                       else if( tjj>zero ) then
                          ! 0 < abs(a(j,j)) <= smlnum:
                          if( xj>tjj*bignum ) then
                             ! scale x by (1/abs(x(j)))*abs(a(j,j))*bignum
                             ! to avoid overflow when dividing by a(j,j).
                             rec = ( tjj*bignum ) / xj
                             if( cnorm( j )>one ) then
                                ! scale by 1/cnorm(j) to avoid overflow when
                                ! multiplying x(j) times column j.
                                rec = rec / cnorm( j )
                             end if
                             call stdlib_csscal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                          x( j ) = stdlib_cladiv( x( j ), tjjs )
                          xj = cabs1( x( j ) )
                       else
                          ! a(j,j) = 0:  set x(1:n) = 0, x(j) = 1, and
                          ! scale = 0, and compute a solution to a*x = 0.
                          do i = 1, n
                             x( i ) = zero
                          end do
                          x( j ) = one
                          xj = one
                          scale = zero
                          xmax = zero
                       end if
                       105 continue
                    ! scale x if necessary to avoid overflow when adding a
                    ! multiple of column j of a.
                    if( xj>one ) then
                       rec = one / xj
                       if( cnorm( j )>( bignum-xmax )*rec ) then
                          ! scale x by 1/(2*abs(x(j))).
                          rec = rec*half
                          call stdlib_csscal( n, rec, x, 1 )
                          scale = scale*rec
                       end if
                    else if( xj*cnorm( j )>( bignum-xmax ) ) then
                       ! scale x by 1/2.
                       call stdlib_csscal( n, half, x, 1 )
                       scale = scale*half
                    end if
                    if( upper ) then
                       if( j>1 ) then
                          ! compute the update
                             ! x(1:j-1) := x(1:j-1) - x(j) * a(1:j-1,j)
                          call stdlib_caxpy( j-1, -x( j )*tscal, ap( ip-j+1 ), 1, x,1 )
                          i = stdlib_icamax( j-1, x, 1 )
                          xmax = cabs1( x( i ) )
                       end if
                       ip = ip - j
                    else
                       if( j<n ) then
                          ! compute the update
                             ! x(j+1:n) := x(j+1:n) - x(j) * a(j+1:n,j)
                          call stdlib_caxpy( n-j, -x( j )*tscal, ap( ip+1 ), 1,x( j+1 ), 1 )
                                    
                          i = j + stdlib_icamax( n-j, x( j+1 ), 1 )
                          xmax = cabs1( x( i ) )
                       end if
                       ip = ip + n - j + 1
                    end if
                 end do loop_110
              else if( stdlib_lsame( trans, 'T' ) ) then
                 ! solve a**t * x = b
                 ip = jfirst*( jfirst+1 ) / 2
                 jlen = 1
                 loop_150: do j = jfirst, jlast, jinc
                    ! compute x(j) = b(j) - sum a(k,j)*x(k).
                                          ! k<>j
                    xj = cabs1( x( j ) )
                    uscal = tscal
                    rec = one / max( xmax, one )
                    if( cnorm( j )>( bignum-xj )*rec ) then
                       ! if x(j) could overflow, scale x by 1/(2*xmax).
                       rec = rec*half
                       if( nounit ) then
                          tjjs = ap( ip )*tscal
                       else
                          tjjs = tscal
                       end if
                          tjj = cabs1( tjjs )
                          if( tjj>one ) then
                             ! divide by a(j,j) when scaling x if a(j,j) > 1.
                             rec = min( one, rec*tjj )
                             uscal = stdlib_cladiv( uscal, tjjs )
                          end if
                       if( rec<one ) then
                          call stdlib_csscal( n, rec, x, 1 )
                          scale = scale*rec
                          xmax = xmax*rec
                       end if
                    end if
                    csumj = zero
                    if( uscal==cmplx( one,KIND=sp) ) then
                       ! if the scaling needed for a in the dot product is 1,
                       ! call stdlib_cdotu to perform the dot product.
                       if( upper ) then
                          csumj = stdlib_cdotu( j-1, ap( ip-j+1 ), 1, x, 1 )
                       else if( j<n ) then
                          csumj = stdlib_cdotu( n-j, ap( ip+1 ), 1, x( j+1 ), 1 )
                       end if
                    else
                       ! otherwise, use in-line code for the dot product.
                       if( upper ) then
                          do i = 1, j - 1
                             csumj = csumj + ( ap( ip-j+i )*uscal )*x( i )
                          end do
                       else if( j<n ) then
                          do i = 1, n - j
                             csumj = csumj + ( ap( ip+i )*uscal )*x( j+i )
                          end do
                       end if
                    end if
                    if( uscal==cmplx( tscal,KIND=sp) ) then
                       ! compute x(j) := ( x(j) - csumj ) / a(j,j) if 1/a(j,j)
                       ! was not used to scale the dotproduct.
                       x( j ) = x( j ) - csumj
                       xj = cabs1( x( j ) )
                       if( nounit ) then
                          ! compute x(j) = x(j) / a(j,j), scaling if necessary.
                          tjjs = ap( ip )*tscal
                       else
                          tjjs = tscal
                          if( tscal==one )go to 145
                       end if
                          tjj = cabs1( tjjs )
                          if( tjj>smlnum ) then
                             ! abs(a(j,j)) > smlnum:
                             if( tjj<one ) then
                                if( xj>tjj*bignum ) then
                                   ! scale x by 1/abs(x(j)).
                                   rec = one / xj
                                   call stdlib_csscal( n, rec, x, 1 )
                                   scale = scale*rec
                                   xmax = xmax*rec
                                end if
                             end if
                             x( j ) = stdlib_cladiv( x( j ), tjjs )
                          else if( tjj>zero ) then
                             ! 0 < abs(a(j,j)) <= smlnum:
                             if( xj>tjj*bignum ) then
                                ! scale x by (1/abs(x(j)))*abs(a(j,j))*bignum.
                                rec = ( tjj*bignum ) / xj
                                call stdlib_csscal( n, rec, x, 1 )
                                scale = scale*rec
                                xmax = xmax*rec
                             end if
                             x( j ) = stdlib_cladiv( x( j ), tjjs )
                          else
                             ! a(j,j) = 0:  set x(1:n) = 0, x(j) = 1, and
                             ! scale = 0 and compute a solution to a**t *x = 0.
                             do i = 1, n
                                x( i ) = zero
                             end do
                             x( j ) = one
                             scale = zero
                             xmax = zero
                          end if
                          145 continue
                    else
                       ! compute x(j) := x(j) / a(j,j) - csumj if the dot
                       ! product has already been divided by 1/a(j,j).
                       x( j ) = stdlib_cladiv( x( j ), tjjs ) - csumj
                    end if
                    xmax = max( xmax, cabs1( x( j ) ) )
                    jlen = jlen + 1
                    ip = ip + jinc*jlen
                 end do loop_150
              else
                 ! solve a**h * x = b
                 ip = jfirst*( jfirst+1 ) / 2
                 jlen = 1
                 loop_190: do j = jfirst, jlast, jinc
                    ! compute x(j) = b(j) - sum a(k,j)*x(k).
                                          ! k<>j
                    xj = cabs1( x( j ) )
                    uscal = tscal
                    rec = one / max( xmax, one )
                    if( cnorm( j )>( bignum-xj )*rec ) then
                       ! if x(j) could overflow, scale x by 1/(2*xmax).
                       rec = rec*half
                       if( nounit ) then
                          tjjs = conjg( ap( ip ) )*tscal
                       else
                          tjjs = tscal
                       end if
                          tjj = cabs1( tjjs )
                          if( tjj>one ) then
                             ! divide by a(j,j) when scaling x if a(j,j) > 1.
                             rec = min( one, rec*tjj )
                             uscal = stdlib_cladiv( uscal, tjjs )
                          end if
                       if( rec<one ) then
                          call stdlib_csscal( n, rec, x, 1 )
                          scale = scale*rec
                          xmax = xmax*rec
                       end if
                    end if
                    csumj = zero
                    if( uscal==cmplx( one,KIND=sp) ) then
                       ! if the scaling needed for a in the dot product is 1,
                       ! call stdlib_cdotc to perform the dot product.
                       if( upper ) then
                          csumj = stdlib_cdotc( j-1, ap( ip-j+1 ), 1, x, 1 )
                       else if( j<n ) then
                          csumj = stdlib_cdotc( n-j, ap( ip+1 ), 1, x( j+1 ), 1 )
                       end if
                    else
                       ! otherwise, use in-line code for the dot product.
                       if( upper ) then
                          do i = 1, j - 1
                             csumj = csumj + ( conjg( ap( ip-j+i ) )*uscal )*x( i )
                          end do
                       else if( j<n ) then
                          do i = 1, n - j
                             csumj = csumj + ( conjg( ap( ip+i ) )*uscal )*x( j+i )
                          end do
                       end if
                    end if
                    if( uscal==cmplx( tscal,KIND=sp) ) then
                       ! compute x(j) := ( x(j) - csumj ) / a(j,j) if 1/a(j,j)
                       ! was not used to scale the dotproduct.
                       x( j ) = x( j ) - csumj
                       xj = cabs1( x( j ) )
                       if( nounit ) then
                          ! compute x(j) = x(j) / a(j,j), scaling if necessary.
                          tjjs = conjg( ap( ip ) )*tscal
                       else
                          tjjs = tscal
                          if( tscal==one )go to 185
                       end if
                          tjj = cabs1( tjjs )
                          if( tjj>smlnum ) then
                             ! abs(a(j,j)) > smlnum:
                             if( tjj<one ) then
                                if( xj>tjj*bignum ) then
                                   ! scale x by 1/abs(x(j)).
                                   rec = one / xj
                                   call stdlib_csscal( n, rec, x, 1 )
                                   scale = scale*rec
                                   xmax = xmax*rec
                                end if
                             end if
                             x( j ) = stdlib_cladiv( x( j ), tjjs )
                          else if( tjj>zero ) then
                             ! 0 < abs(a(j,j)) <= smlnum:
                             if( xj>tjj*bignum ) then
                                ! scale x by (1/abs(x(j)))*abs(a(j,j))*bignum.
                                rec = ( tjj*bignum ) / xj
                                call stdlib_csscal( n, rec, x, 1 )
                                scale = scale*rec
                                xmax = xmax*rec
                             end if
                             x( j ) = stdlib_cladiv( x( j ), tjjs )
                          else
                             ! a(j,j) = 0:  set x(1:n) = 0, x(j) = 1, and
                             ! scale = 0 and compute a solution to a**h *x = 0.
                             do i = 1, n
                                x( i ) = zero
                             end do
                             x( j ) = one
                             scale = zero
                             xmax = zero
                          end if
                          185 continue
                    else
                       ! compute x(j) := x(j) / a(j,j) - csumj if the dot
                       ! product has already been divided by 1/a(j,j).
                       x( j ) = stdlib_cladiv( x( j ), tjjs ) - csumj
                    end if
                    xmax = max( xmax, cabs1( x( j ) ) )
                    jlen = jlen + 1
                    ip = ip + jinc*jlen
                 end do loop_190
              end if
              scale = scale / tscal
           end if
           ! scale the column norms by 1/tscal for return.
           if( tscal/=one ) then
              call stdlib_sscal( n, one / tscal, cnorm, 1 )
           end if
           return
     end subroutine stdlib_clatps


     pure subroutine stdlib_clatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
     !! CLATRD reduces NB rows and columns of a complex Hermitian matrix A to
     !! Hermitian tridiagonal form by a unitary similarity
     !! transformation Q**H * A * Q, and returns the matrices V and W which are
     !! needed to apply the transformation to the unreduced part of A.
     !! If UPLO = 'U', CLATRD reduces the last NB rows and columns of a
     !! matrix, of which the upper triangle is supplied;
     !! if UPLO = 'L', CLATRD reduces the first NB rows and columns of a
     !! matrix, of which the lower triangle is supplied.
     !! This is an auxiliary routine called by CHETRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           real(sp), intent(out) :: e(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), w(ldw,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, iw
           complex(sp) :: alpha
           ! Intrinsic Functions 
           intrinsic :: min,real
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 )return
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! reduce last nb columns of upper triangle
              loop_10: do i = n, n - nb + 1, -1
                 iw = i - n + nb
                 if( i<n ) then
                    ! update a(1:i,i)
                    a( i, i ) = real( a( i, i ),KIND=sp)
                    call stdlib_clacgv( n-i, w( i, iw+1 ), ldw )
                    call stdlib_cgemv( 'NO TRANSPOSE', i, n-i, -cone, a( 1, i+1 ),lda, w( i, iw+1 &
                              ), ldw, cone, a( 1, i ), 1 )
                    call stdlib_clacgv( n-i, w( i, iw+1 ), ldw )
                    call stdlib_clacgv( n-i, a( i, i+1 ), lda )
                    call stdlib_cgemv( 'NO TRANSPOSE', i, n-i, -cone, w( 1, iw+1 ),ldw, a( i, i+1 &
                              ), lda, cone, a( 1, i ), 1 )
                    call stdlib_clacgv( n-i, a( i, i+1 ), lda )
                    a( i, i ) = real( a( i, i ),KIND=sp)
                 end if
                 if( i>1 ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(1:i-2,i)
                    alpha = a( i-1, i )
                    call stdlib_clarfg( i-1, alpha, a( 1, i ), 1, tau( i-1 ) )
                    e( i-1 ) = real( alpha,KIND=sp)
                    a( i-1, i ) = cone
                    ! compute w(1:i-1,i)
                    call stdlib_chemv( 'UPPER', i-1, cone, a, lda, a( 1, i ), 1,czero, w( 1, iw ),&
                               1 )
                    if( i<n ) then
                       call stdlib_cgemv( 'CONJUGATE TRANSPOSE', i-1, n-i, cone,w( 1, iw+1 ), ldw,&
                                  a( 1, i ), 1, czero,w( i+1, iw ), 1 )
                       call stdlib_cgemv( 'NO TRANSPOSE', i-1, n-i, -cone,a( 1, i+1 ), lda, w( i+&
                                 1, iw ), 1, cone,w( 1, iw ), 1 )
                       call stdlib_cgemv( 'CONJUGATE TRANSPOSE', i-1, n-i, cone,a( 1, i+1 ), lda, &
                                 a( 1, i ), 1, czero,w( i+1, iw ), 1 )
                       call stdlib_cgemv( 'NO TRANSPOSE', i-1, n-i, -cone,w( 1, iw+1 ), ldw, w( i+&
                                 1, iw ), 1, cone,w( 1, iw ), 1 )
                    end if
                    call stdlib_cscal( i-1, tau( i-1 ), w( 1, iw ), 1 )
                    alpha = -chalf*tau( i-1 )*stdlib_cdotc( i-1, w( 1, iw ), 1,a( 1, i ), 1 )
                              
                    call stdlib_caxpy( i-1, alpha, a( 1, i ), 1, w( 1, iw ), 1 )
                 end if
              end do loop_10
           else
              ! reduce first nb columns of lower triangle
              loop_20: do i = 1, nb
                 ! update a(i:n,i)
                 a( i, i ) = real( a( i, i ),KIND=sp)
                 call stdlib_clacgv( i-1, w( i, 1 ), ldw )
                 call stdlib_cgemv( 'NO TRANSPOSE', n-i+1, i-1, -cone, a( i, 1 ),lda, w( i, 1 ), &
                           ldw, cone, a( i, i ), 1 )
                 call stdlib_clacgv( i-1, w( i, 1 ), ldw )
                 call stdlib_clacgv( i-1, a( i, 1 ), lda )
                 call stdlib_cgemv( 'NO TRANSPOSE', n-i+1, i-1, -cone, w( i, 1 ),ldw, a( i, 1 ), &
                           lda, cone, a( i, i ), 1 )
                 call stdlib_clacgv( i-1, a( i, 1 ), lda )
                 a( i, i ) = real( a( i, i ),KIND=sp)
                 if( i<n ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(i+2:n,i)
                    alpha = a( i+1, i )
                    call stdlib_clarfg( n-i, alpha, a( min( i+2, n ), i ), 1,tau( i ) )
                    e( i ) = real( alpha,KIND=sp)
                    a( i+1, i ) = cone
                    ! compute w(i+1:n,i)
                    call stdlib_chemv( 'LOWER', n-i, cone, a( i+1, i+1 ), lda,a( i+1, i ), 1, &
                              czero, w( i+1, i ), 1 )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-i, i-1, cone,w( i+1, 1 ), ldw, a( &
                              i+1, i ), 1, czero,w( 1, i ), 1 )
                    call stdlib_cgemv( 'NO TRANSPOSE', n-i, i-1, -cone, a( i+1, 1 ),lda, w( 1, i )&
                              , 1, cone, w( i+1, i ), 1 )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-i, i-1, cone,a( i+1, 1 ), lda, a( &
                              i+1, i ), 1, czero,w( 1, i ), 1 )
                    call stdlib_cgemv( 'NO TRANSPOSE', n-i, i-1, -cone, w( i+1, 1 ),ldw, w( 1, i )&
                              , 1, cone, w( i+1, i ), 1 )
                    call stdlib_cscal( n-i, tau( i ), w( i+1, i ), 1 )
                    alpha = -chalf*tau( i )*stdlib_cdotc( n-i, w( i+1, i ), 1,a( i+1, i ), 1 )
                              
                    call stdlib_caxpy( n-i, alpha, a( i+1, i ), 1, w( i+1, i ), 1 )
                 end if
              end do loop_20
           end if
           return
     end subroutine stdlib_clatrd


     pure subroutine stdlib_clatrs( uplo, trans, diag, normin, n, a, lda, x, scale,cnorm, info )
     !! CLATRS solves one of the triangular systems
     !! A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
     !! with scaling to prevent overflow.  Here A is an upper or lower
     !! triangular matrix, A**T denotes the transpose of A, A**H denotes the
     !! conjugate transpose of A, x and b are n-element vectors, and s is a
     !! scaling factor, usually less than or equal to 1, chosen so that the
     !! components of x will be less than the overflow threshold.  If the
     !! unscaled problem will not cause overflow, the Level 2 BLAS routine
     !! CTRSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
     !! then s is set to 0 and a non-trivial solution to A*x = 0 is returned.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, normin, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(out) :: scale
           ! Array Arguments 
           real(sp), intent(inout) :: cnorm(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: x(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notran, nounit, upper
           integer(ilp) :: i, imax, j, jfirst, jinc, jlast
           real(sp) :: bignum, grow, rec, smlnum, tjj, tmax, tscal, xbnd, xj, xmax
           complex(sp) :: csumj, tjjs, uscal, zdum
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,conjg,max,min,real
           ! Statement Functions 
           real(sp) :: cabs1, cabs2
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           cabs2( zdum ) = abs( real( zdum,KIND=sp) / 2. ) +abs( aimag( zdum ) / 2. )
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           notran = stdlib_lsame( trans, 'N' )
           nounit = stdlib_lsame( diag, 'N' )
           ! test the input parameters.
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( .not.stdlib_lsame( normin, 'Y' ) .and. .not.stdlib_lsame( normin, 'N' ) ) &
                     then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLATRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine machine dependent parameters to control overflow.
           smlnum = stdlib_slamch( 'SAFE MINIMUM' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = smlnum / stdlib_slamch( 'PRECISION' )
           bignum = one / smlnum
           scale = one
           if( stdlib_lsame( normin, 'N' ) ) then
              ! compute the 1-norm of each column, not including the diagonal.
              if( upper ) then
                 ! a is upper triangular.
                 do j = 1, n
                    cnorm( j ) = stdlib_scasum( j-1, a( 1, j ), 1 )
                 end do
              else
                 ! a is lower triangular.
                 do j = 1, n - 1
                    cnorm( j ) = stdlib_scasum( n-j, a( j+1, j ), 1 )
                 end do
                 cnorm( n ) = zero
              end if
           end if
           ! scale the column norms by tscal if the maximum element in cnorm is
           ! greater than bignum/2.
           imax = stdlib_isamax( n, cnorm, 1 )
           tmax = cnorm( imax )
           if( tmax<=bignum*half ) then
              tscal = one
           else
              tscal = half / ( smlnum*tmax )
              call stdlib_sscal( n, tscal, cnorm, 1 )
           end if
           ! compute a bound on the computed solution vector to see if the
           ! level 2 blas routine stdlib_ctrsv can be used.
           xmax = zero
           do j = 1, n
              xmax = max( xmax, cabs2( x( j ) ) )
           end do
           xbnd = xmax
           if( notran ) then
              ! compute the growth in a * x = b.
              if( upper ) then
                 jfirst = n
                 jlast = 1
                 jinc = -1
              else
                 jfirst = 1
                 jlast = n
                 jinc = 1
              end if
              if( tscal/=one ) then
                 grow = zero
                 go to 60
              end if
              if( nounit ) then
                 ! a is non-unit triangular.
                 ! compute grow = 1/g(j) and xbnd = 1/m(j).
                 ! initially, g(0) = max{x(i), i=1,...,n}.
                 grow = half / max( xbnd, smlnum )
                 xbnd = grow
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 60
                    tjjs = a( j, j )
                    tjj = cabs1( tjjs )
                    if( tjj>=smlnum ) then
                       ! m(j) = g(j-1) / abs(a(j,j))
                       xbnd = min( xbnd, min( one, tjj )*grow )
                    else
                       ! m(j) could overflow, set xbnd to 0.
                       xbnd = zero
                    end if
                    if( tjj+cnorm( j )>=smlnum ) then
                       ! g(j) = g(j-1)*( 1 + cnorm(j) / abs(a(j,j)) )
                       grow = grow*( tjj / ( tjj+cnorm( j ) ) )
                    else
                       ! g(j) could overflow, set grow to 0.
                       grow = zero
                    end if
                 end do
                 grow = xbnd
              else
                 ! a is unit triangular.
                 ! compute grow = 1/g(j), where g(0) = max{x(i), i=1,...,n}.
                 grow = min( one, half / max( xbnd, smlnum ) )
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 60
                    ! g(j) = g(j-1)*( 1 + cnorm(j) )
                    grow = grow*( one / ( one+cnorm( j ) ) )
                 end do
              end if
              60 continue
           else
              ! compute the growth in a**t * x = b  or  a**h * x = b.
              if( upper ) then
                 jfirst = 1
                 jlast = n
                 jinc = 1
              else
                 jfirst = n
                 jlast = 1
                 jinc = -1
              end if
              if( tscal/=one ) then
                 grow = zero
                 go to 90
              end if
              if( nounit ) then
                 ! a is non-unit triangular.
                 ! compute grow = 1/g(j) and xbnd = 1/m(j).
                 ! initially, m(0) = max{x(i), i=1,...,n}.
                 grow = half / max( xbnd, smlnum )
                 xbnd = grow
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 90
                    ! g(j) = max( g(j-1), m(j-1)*( 1 + cnorm(j) ) )
                    xj = one + cnorm( j )
                    grow = min( grow, xbnd / xj )
                    tjjs = a( j, j )
                    tjj = cabs1( tjjs )
                    if( tjj>=smlnum ) then
                       ! m(j) = m(j-1)*( 1 + cnorm(j) ) / abs(a(j,j))
                       if( xj>tjj )xbnd = xbnd*( tjj / xj )
                    else
                       ! m(j) could overflow, set xbnd to 0.
                       xbnd = zero
                    end if
                 end do
                 grow = min( grow, xbnd )
              else
                 ! a is unit triangular.
                 ! compute grow = 1/g(j), where g(0) = max{x(i), i=1,...,n}.
                 grow = min( one, half / max( xbnd, smlnum ) )
                 do j = jfirst, jlast, jinc
                    ! exit the loop if the growth factor is too small.
                    if( grow<=smlnum )go to 90
                    ! g(j) = ( 1 + cnorm(j) )*g(j-1)
                    xj = one + cnorm( j )
                    grow = grow / xj
                 end do
              end if
              90 continue
           end if
           if( ( grow*tscal )>smlnum ) then
              ! use the level 2 blas solve if the reciprocal of the bound on
              ! elements of x is not too small.
              call stdlib_ctrsv( uplo, trans, diag, n, a, lda, x, 1 )
           else
              ! use a level 1 blas solve, scaling intermediate results.
              if( xmax>bignum*half ) then
                 ! scale x so that its components are less than or equal to
                 ! bignum in absolute value.
                 scale = ( bignum*half ) / xmax
                 call stdlib_csscal( n, scale, x, 1 )
                 xmax = bignum
              else
                 xmax = xmax*two
              end if
              if( notran ) then
                 ! solve a * x = b
                 loop_110: do j = jfirst, jlast, jinc
                    ! compute x(j) = b(j) / a(j,j), scaling x if necessary.
                    xj = cabs1( x( j ) )
                    if( nounit ) then
                       tjjs = a( j, j )*tscal
                    else
                       tjjs = tscal
                       if( tscal==one )go to 105
                    end if
                       tjj = cabs1( tjjs )
                       if( tjj>smlnum ) then
                          ! abs(a(j,j)) > smlnum:
                          if( tjj<one ) then
                             if( xj>tjj*bignum ) then
                                ! scale x by 1/b(j).
                                rec = one / xj
                                call stdlib_csscal( n, rec, x, 1 )
                                scale = scale*rec
                                xmax = xmax*rec
                             end if
                          end if
                          x( j ) = stdlib_cladiv( x( j ), tjjs )
                          xj = cabs1( x( j ) )
                       else if( tjj>zero ) then
                          ! 0 < abs(a(j,j)) <= smlnum:
                          if( xj>tjj*bignum ) then
                             ! scale x by (1/abs(x(j)))*abs(a(j,j))*bignum
                             ! to avoid overflow when dividing by a(j,j).
                             rec = ( tjj*bignum ) / xj
                             if( cnorm( j )>one ) then
                                ! scale by 1/cnorm(j) to avoid overflow when
                                ! multiplying x(j) times column j.
                                rec = rec / cnorm( j )
                             end if
                             call stdlib_csscal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                          x( j ) = stdlib_cladiv( x( j ), tjjs )
                          xj = cabs1( x( j ) )
                       else
                          ! a(j,j) = 0:  set x(1:n) = 0, x(j) = 1, and
                          ! scale = 0, and compute a solution to a*x = 0.
                          do i = 1, n
                             x( i ) = zero
                          end do
                          x( j ) = one
                          xj = one
                          scale = zero
                          xmax = zero
                       end if
                       105 continue
                    ! scale x if necessary to avoid overflow when adding a
                    ! multiple of column j of a.
                    if( xj>one ) then
                       rec = one / xj
                       if( cnorm( j )>( bignum-xmax )*rec ) then
                          ! scale x by 1/(2*abs(x(j))).
                          rec = rec*half
                          call stdlib_csscal( n, rec, x, 1 )
                          scale = scale*rec
                       end if
                    else if( xj*cnorm( j )>( bignum-xmax ) ) then
                       ! scale x by 1/2.
                       call stdlib_csscal( n, half, x, 1 )
                       scale = scale*half
                    end if
                    if( upper ) then
                       if( j>1 ) then
                          ! compute the update
                             ! x(1:j-1) := x(1:j-1) - x(j) * a(1:j-1,j)
                          call stdlib_caxpy( j-1, -x( j )*tscal, a( 1, j ), 1, x,1 )
                          i = stdlib_icamax( j-1, x, 1 )
                          xmax = cabs1( x( i ) )
                       end if
                    else
                       if( j<n ) then
                          ! compute the update
                             ! x(j+1:n) := x(j+1:n) - x(j) * a(j+1:n,j)
                          call stdlib_caxpy( n-j, -x( j )*tscal, a( j+1, j ), 1,x( j+1 ), 1 )
                                    
                          i = j + stdlib_icamax( n-j, x( j+1 ), 1 )
                          xmax = cabs1( x( i ) )
                       end if
                    end if
                 end do loop_110
              else if( stdlib_lsame( trans, 'T' ) ) then
                 ! solve a**t * x = b
                 loop_150: do j = jfirst, jlast, jinc
                    ! compute x(j) = b(j) - sum a(k,j)*x(k).
                                          ! k<>j
                    xj = cabs1( x( j ) )
                    uscal = tscal
                    rec = one / max( xmax, one )
                    if( cnorm( j )>( bignum-xj )*rec ) then
                       ! if x(j) could overflow, scale x by 1/(2*xmax).
                       rec = rec*half
                       if( nounit ) then
                          tjjs = a( j, j )*tscal
                       else
                          tjjs = tscal
                       end if
                          tjj = cabs1( tjjs )
                          if( tjj>one ) then
                             ! divide by a(j,j) when scaling x if a(j,j) > 1.
                             rec = min( one, rec*tjj )
                             uscal = stdlib_cladiv( uscal, tjjs )
                          end if
                       if( rec<one ) then
                          call stdlib_csscal( n, rec, x, 1 )
                          scale = scale*rec
                          xmax = xmax*rec
                       end if
                    end if
                    csumj = zero
                    if( uscal==cmplx( one,KIND=sp) ) then
                       ! if the scaling needed for a in the dot product is 1,
                       ! call stdlib_cdotu to perform the dot product.
                       if( upper ) then
                          csumj = stdlib_cdotu( j-1, a( 1, j ), 1, x, 1 )
                       else if( j<n ) then
                          csumj = stdlib_cdotu( n-j, a( j+1, j ), 1, x( j+1 ), 1 )
                       end if
                    else
                       ! otherwise, use in-line code for the dot product.
                       if( upper ) then
                          do i = 1, j - 1
                             csumj = csumj + ( a( i, j )*uscal )*x( i )
                          end do
                       else if( j<n ) then
                          do i = j + 1, n
                             csumj = csumj + ( a( i, j )*uscal )*x( i )
                          end do
                       end if
                    end if
                    if( uscal==cmplx( tscal,KIND=sp) ) then
                       ! compute x(j) := ( x(j) - csumj ) / a(j,j) if 1/a(j,j)
                       ! was not used to scale the dotproduct.
                       x( j ) = x( j ) - csumj
                       xj = cabs1( x( j ) )
                       if( nounit ) then
                          tjjs = a( j, j )*tscal
                       else
                          tjjs = tscal
                          if( tscal==one )go to 145
                       end if
                          ! compute x(j) = x(j) / a(j,j), scaling if necessary.
                          tjj = cabs1( tjjs )
                          if( tjj>smlnum ) then
                             ! abs(a(j,j)) > smlnum:
                             if( tjj<one ) then
                                if( xj>tjj*bignum ) then
                                   ! scale x by 1/abs(x(j)).
                                   rec = one / xj
                                   call stdlib_csscal( n, rec, x, 1 )
                                   scale = scale*rec
                                   xmax = xmax*rec
                                end if
                             end if
                             x( j ) = stdlib_cladiv( x( j ), tjjs )
                          else if( tjj>zero ) then
                             ! 0 < abs(a(j,j)) <= smlnum:
                             if( xj>tjj*bignum ) then
                                ! scale x by (1/abs(x(j)))*abs(a(j,j))*bignum.
                                rec = ( tjj*bignum ) / xj
                                call stdlib_csscal( n, rec, x, 1 )
                                scale = scale*rec
                                xmax = xmax*rec
                             end if
                             x( j ) = stdlib_cladiv( x( j ), tjjs )
                          else
                             ! a(j,j) = 0:  set x(1:n) = 0, x(j) = 1, and
                             ! scale = 0 and compute a solution to a**t *x = 0.
                             do i = 1, n
                                x( i ) = zero
                             end do
                             x( j ) = one
                             scale = zero
                             xmax = zero
                          end if
                          145 continue
                    else
                       ! compute x(j) := x(j) / a(j,j) - csumj if the dot
                       ! product has already been divided by 1/a(j,j).
                       x( j ) = stdlib_cladiv( x( j ), tjjs ) - csumj
                    end if
                    xmax = max( xmax, cabs1( x( j ) ) )
                 end do loop_150
              else
                 ! solve a**h * x = b
                 loop_190: do j = jfirst, jlast, jinc
                    ! compute x(j) = b(j) - sum a(k,j)*x(k).
                                          ! k<>j
                    xj = cabs1( x( j ) )
                    uscal = tscal
                    rec = one / max( xmax, one )
                    if( cnorm( j )>( bignum-xj )*rec ) then
                       ! if x(j) could overflow, scale x by 1/(2*xmax).
                       rec = rec*half
                       if( nounit ) then
                          tjjs = conjg( a( j, j ) )*tscal
                       else
                          tjjs = tscal
                       end if
                          tjj = cabs1( tjjs )
                          if( tjj>one ) then
                             ! divide by a(j,j) when scaling x if a(j,j) > 1.
                             rec = min( one, rec*tjj )
                             uscal = stdlib_cladiv( uscal, tjjs )
                          end if
                       if( rec<one ) then
                          call stdlib_csscal( n, rec, x, 1 )
                          scale = scale*rec
                          xmax = xmax*rec
                       end if
                    end if
                    csumj = zero
                    if( uscal==cmplx( one,KIND=sp) ) then
                       ! if the scaling needed for a in the dot product is 1,
                       ! call stdlib_cdotc to perform the dot product.
                       if( upper ) then
                          csumj = stdlib_cdotc( j-1, a( 1, j ), 1, x, 1 )
                       else if( j<n ) then
                          csumj = stdlib_cdotc( n-j, a( j+1, j ), 1, x( j+1 ), 1 )
                       end if
                    else
                       ! otherwise, use in-line code for the dot product.
                       if( upper ) then
                          do i = 1, j - 1
                             csumj = csumj + ( conjg( a( i, j ) )*uscal )*x( i )
                          end do
                       else if( j<n ) then
                          do i = j + 1, n
                             csumj = csumj + ( conjg( a( i, j ) )*uscal )*x( i )
                          end do
                       end if
                    end if
                    if( uscal==cmplx( tscal,KIND=sp) ) then
                       ! compute x(j) := ( x(j) - csumj ) / a(j,j) if 1/a(j,j)
                       ! was not used to scale the dotproduct.
                       x( j ) = x( j ) - csumj
                       xj = cabs1( x( j ) )
                       if( nounit ) then
                          tjjs = conjg( a( j, j ) )*tscal
                       else
                          tjjs = tscal
                          if( tscal==one )go to 185
                       end if
                          ! compute x(j) = x(j) / a(j,j), scaling if necessary.
                          tjj = cabs1( tjjs )
                          if( tjj>smlnum ) then
                             ! abs(a(j,j)) > smlnum:
                             if( tjj<one ) then
                                if( xj>tjj*bignum ) then
                                   ! scale x by 1/abs(x(j)).
                                   rec = one / xj
                                   call stdlib_csscal( n, rec, x, 1 )
                                   scale = scale*rec
                                   xmax = xmax*rec
                                end if
                             end if
                             x( j ) = stdlib_cladiv( x( j ), tjjs )
                          else if( tjj>zero ) then
                             ! 0 < abs(a(j,j)) <= smlnum:
                             if( xj>tjj*bignum ) then
                                ! scale x by (1/abs(x(j)))*abs(a(j,j))*bignum.
                                rec = ( tjj*bignum ) / xj
                                call stdlib_csscal( n, rec, x, 1 )
                                scale = scale*rec
                                xmax = xmax*rec
                             end if
                             x( j ) = stdlib_cladiv( x( j ), tjjs )
                          else
                             ! a(j,j) = 0:  set x(1:n) = 0, x(j) = 1, and
                             ! scale = 0 and compute a solution to a**h *x = 0.
                             do i = 1, n
                                x( i ) = zero
                             end do
                             x( j ) = one
                             scale = zero
                             xmax = zero
                          end if
                          185 continue
                    else
                       ! compute x(j) := x(j) / a(j,j) - csumj if the dot
                       ! product has already been divided by 1/a(j,j).
                       x( j ) = stdlib_cladiv( x( j ), tjjs ) - csumj
                    end if
                    xmax = max( xmax, cabs1( x( j ) ) )
                 end do loop_190
              end if
              scale = scale / tscal
           end if
           ! scale the column norms by 1/tscal for return.
           if( tscal/=one ) then
              call stdlib_sscal( n, one / tscal, cnorm, 1 )
           end if
           return
     end subroutine stdlib_clatrs


     pure subroutine stdlib_clatrz( m, n, l, a, lda, tau, work )
     !! CLATRZ factors the M-by-(M+L) complex upper trapezoidal matrix
     !! [ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R  0 ) * Z by means
     !! of unitary transformations, where  Z is an (M+L)-by-(M+L) unitary
     !! matrix and, R and A1 are M-by-M upper triangular matrices.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: l, lda, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(sp) :: alpha
           ! Intrinsic Functions 
           intrinsic :: conjg
           ! Executable Statements 
           ! quick return if possible
           if( m==0 ) then
              return
           else if( m==n ) then
              do i = 1, n
                 tau( i ) = czero
              end do
              return
           end if
           do i = m, 1, -1
              ! generate elementary reflector h(i) to annihilate
              ! [ a(i,i) a(i,n-l+1:n) ]
              call stdlib_clacgv( l, a( i, n-l+1 ), lda )
              alpha = conjg( a( i, i ) )
              call stdlib_clarfg( l+1, alpha, a( i, n-l+1 ), lda, tau( i ) )
              tau( i ) = conjg( tau( i ) )
              ! apply h(i) to a(1:i-1,i:n) from the right
              call stdlib_clarz( 'RIGHT', i-1, n-i+1, l, a( i, n-l+1 ), lda,conjg( tau( i ) ), a( &
                        1, i ), lda, work )
              a( i, i ) = conjg( alpha )
           end do
           return
     end subroutine stdlib_clatrz


     pure recursive subroutine stdlib_claunhr_col_getrfnp2( m, n, a, lda, d, info )
     !! CLAUNHR_COL_GETRFNP2 computes the modified LU factorization without
     !! pivoting of a complex general M-by-N matrix A. The factorization has
     !! the form:
     !! A - S = L * U,
     !! where:
     !! S is a m-by-n diagonal sign matrix with the diagonal D, so that
     !! D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
     !! as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
     !! i-1 steps of Gaussian elimination. This means that the diagonal
     !! element at each step of "modified" Gaussian elimination is at
     !! least one in absolute value (so that division-by-zero not
     !! possible during the division by the diagonal element);
     !! L is a M-by-N lower triangular matrix with unit diagonal elements
     !! (lower trapezoidal if M > N);
     !! and U is a M-by-N upper triangular matrix
     !! (upper trapezoidal if M < N).
     !! This routine is an auxiliary routine used in the Householder
     !! reconstruction routine CUNHR_COL. In CUNHR_COL, this routine is
     !! applied to an M-by-N matrix A with orthonormal columns, where each
     !! element is bounded by one in absolute value. With the choice of
     !! the matrix S above, one can show that the diagonal element at each
     !! step of Gaussian elimination is the largest (in absolute value) in
     !! the column on or below the diagonal, so that no pivoting is required
     !! for numerical stability [1].
     !! For more details on the Householder reconstruction algorithm,
     !! including the modified LU factorization, see [1].
     !! This is the recursive version of the LU factorization algorithm.
     !! Denote A - S by B. The algorithm divides the matrix B into four
     !! submatrices:
     !! [  B11 | B12  ]  where B11 is n1 by n1,
     !! B = [ -----|----- ]        B21 is (m-n1) by n1,
     !! [  B21 | B22  ]        B12 is n1 by n2,
     !! B22 is (m-n1) by n2,
     !! with n1 = min(m,n)/2, n2 = n-n1.
     !! The subroutine calls itself to factor B11, solves for B21,
     !! solves for B12, updates B22, then calls itself to factor B22.
     !! For more details on the recursive LU algorithm, see [2].
     !! CLAUNHR_COL_GETRFNP2 is called to factorize a block by the blocked
     !! routine CLAUNHR_COL_GETRFNP, which uses blocked code calling
     !! Level 3 BLAS to update the submatrix. However, CLAUNHR_COL_GETRFNP2
     !! is self-sufficient and can be used without CLAUNHR_COL_GETRFNP.
     !! [1] "Reconstructing Householder vectors from tall-skinny QR",
     !! G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
     !! E. Solomonik, J. Parallel Distrib. Comput.,
     !! vol. 85, pp. 3-31, 2015.
     !! [2] "Recursion leads to automatic variable blocking for dense linear
     !! algebra algorithms", F. Gustavson, IBM J. of Res. and Dev.,
     !! vol. 41, no. 6, pp. 737-755, 1997.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: d(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           real(sp) :: sfmin
           integer(ilp) :: i, iinfo, n1, n2
           complex(sp) :: z
           ! Intrinsic Functions 
           intrinsic :: abs,real,cmplx,aimag,sign,max,min
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAUNHR_COL_GETRFNP2', -info )
              return
           end if
           ! quick return if possible
           if( min( m, n )==0 )return
           if ( m==1 ) then
              ! one row case, (also recursion termination case),
              ! use unblocked code
              ! transfer the sign
              d( 1 ) = cmplx( -sign( one, real( a( 1, 1 ),KIND=sp) ),KIND=sp)
              ! construct the row of u
              a( 1, 1 ) = a( 1, 1 ) - d( 1 )
           else if( n==1 ) then
              ! one column case, (also recursion termination case),
              ! use unblocked code
              ! transfer the sign
              d( 1 ) = cmplx( -sign( one, real( a( 1, 1 ),KIND=sp) ),KIND=sp)
              ! construct the row of u
              a( 1, 1 ) = a( 1, 1 ) - d( 1 )
              ! scale the elements 2:m of the column
              ! determine machine safe minimum
              sfmin = stdlib_slamch('S')
              ! construct the subdiagonal elements of l
              if( cabs1( a( 1, 1 ) ) >= sfmin ) then
                 call stdlib_cscal( m-1, cone / a( 1, 1 ), a( 2, 1 ), 1 )
              else
                 do i = 2, m
                    a( i, 1 ) = a( i, 1 ) / a( 1, 1 )
                 end do
              end if
           else
              ! divide the matrix b into four submatrices
              n1 = min( m, n ) / 2
              n2 = n-n1
              ! factor b11, recursive call
              call stdlib_claunhr_col_getrfnp2( n1, n1, a, lda, d, iinfo )
              ! solve for b21
              call stdlib_ctrsm( 'R', 'U', 'N', 'N', m-n1, n1, cone, a, lda,a( n1+1, 1 ), lda )
                        
              ! solve for b12
              call stdlib_ctrsm( 'L', 'L', 'N', 'U', n1, n2, cone, a, lda,a( 1, n1+1 ), lda )
                        
              ! update b22, i.e. compute the schur complement
              ! b22 := b22 - b21*b12
              call stdlib_cgemm( 'N', 'N', m-n1, n2, n1, -cone, a( n1+1, 1 ), lda,a( 1, n1+1 ), &
                        lda, cone, a( n1+1, n1+1 ), lda )
              ! factor b22, recursive call
              call stdlib_claunhr_col_getrfnp2( m-n1, n2, a( n1+1, n1+1 ), lda,d( n1+1 ), iinfo )
                        
           end if
           return
     end subroutine stdlib_claunhr_col_getrfnp2


     pure subroutine stdlib_clauu2( uplo, n, a, lda, info )
     !! CLAUU2 computes the product U * U**H or L**H * L, where the triangular
     !! factor U or L is stored in the upper or lower triangular part of
     !! the array A.
     !! If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
     !! overwriting the factor U in A.
     !! If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
     !! overwriting the factor L in A.
     !! This is the unblocked form of the algorithm, calling Level 2 BLAS.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           real(sp) :: aii
           ! Intrinsic Functions 
           intrinsic :: cmplx,max,real
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAUU2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! compute the product u * u**h.
              do i = 1, n
                 aii = real( a( i, i ),KIND=sp)
                 if( i<n ) then
                    a( i, i ) = aii*aii + real( stdlib_cdotc( n-i, a( i, i+1 ), lda,a( i, i+1 ), &
                              lda ),KIND=sp)
                    call stdlib_clacgv( n-i, a( i, i+1 ), lda )
                    call stdlib_cgemv( 'NO TRANSPOSE', i-1, n-i, cone, a( 1, i+1 ),lda, a( i, i+1 &
                              ), lda, cmplx( aii,KIND=sp),a( 1, i ), 1 )
                    call stdlib_clacgv( n-i, a( i, i+1 ), lda )
                 else
                    call stdlib_csscal( i, aii, a( 1, i ), 1 )
                 end if
              end do
           else
              ! compute the product l**h * l.
              do i = 1, n
                 aii = real( a( i, i ),KIND=sp)
                 if( i<n ) then
                    a( i, i ) = aii*aii + real( stdlib_cdotc( n-i, a( i+1, i ), 1,a( i+1, i ), 1 )&
                              ,KIND=sp)
                    call stdlib_clacgv( i-1, a( i, 1 ), lda )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-i, i-1, cone,a( i+1, 1 ), lda, a( &
                              i+1, i ), 1,cmplx( aii,KIND=sp), a( i, 1 ), lda )
                    call stdlib_clacgv( i-1, a( i, 1 ), lda )
                 else
                    call stdlib_csscal( i, aii, a( i, 1 ), lda )
                 end if
              end do
           end if
           return
     end subroutine stdlib_clauu2


     pure subroutine stdlib_clauum( uplo, n, a, lda, info )
     !! CLAUUM computes the product U * U**H or L**H * L, where the triangular
     !! factor U or L is stored in the upper or lower triangular part of
     !! the array A.
     !! If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
     !! overwriting the factor U in A.
     !! If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
     !! overwriting the factor L in A.
     !! This is the blocked form of the algorithm, calling Level 3 BLAS.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, ib, nb
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAUUM', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine the block size for this environment.
           nb = stdlib_ilaenv( 1, 'CLAUUM', uplo, n, -1, -1, -1 )
           if( nb<=1 .or. nb>=n ) then
              ! use unblocked code
              call stdlib_clauu2( uplo, n, a, lda, info )
           else
              ! use blocked code
              if( upper ) then
                 ! compute the product u * u**h.
                 do i = 1, n, nb
                    ib = min( nb, n-i+1 )
                    call stdlib_ctrmm( 'RIGHT', 'UPPER', 'CONJUGATE TRANSPOSE','NON-UNIT', i-1, &
                              ib, cone, a( i, i ), lda,a( 1, i ), lda )
                    call stdlib_clauu2( 'UPPER', ib, a( i, i ), lda, info )
                    if( i+ib<=n ) then
                       call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',i-1, ib, n-i-ib+1,&
                                  cone, a( 1, i+ib ),lda, a( i, i+ib ), lda, cone, a( 1, i ),lda )
                       call stdlib_cherk( 'UPPER', 'NO TRANSPOSE', ib, n-i-ib+1,one, a( i, i+ib ),&
                                  lda, one, a( i, i ),lda )
                    end if
                 end do
              else
                 ! compute the product l**h * l.
                 do i = 1, n, nb
                    ib = min( nb, n-i+1 )
                    call stdlib_ctrmm( 'LEFT', 'LOWER', 'CONJUGATE TRANSPOSE','NON-UNIT', ib, i-1,&
                               cone, a( i, i ), lda,a( i, 1 ), lda )
                    call stdlib_clauu2( 'LOWER', ib, a( i, i ), lda, info )
                    if( i+ib<=n ) then
                       call stdlib_cgemm( 'CONJUGATE TRANSPOSE', 'NO TRANSPOSE', ib,i-1, n-i-ib+1,&
                                  cone, a( i+ib, i ), lda,a( i+ib, 1 ), lda, cone, a( i, 1 ), lda )
                       call stdlib_cherk( 'LOWER', 'CONJUGATE TRANSPOSE', ib,n-i-ib+1, one, a( i+&
                                 ib, i ), lda, one,a( i, i ), lda )
                    end if
                 end do
              end if
           end if
           return
     end subroutine stdlib_clauum


     pure subroutine stdlib_cpbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
     !! CPBEQU computes row and column scalings intended to equilibrate a
     !! Hermitian positive definite band matrix A and reduce its condition
     !! number (with respect to the two-norm).  S contains the scale factors,
     !! S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
     !! elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
     !! choice of S puts the condition number of B within a factor N of the
     !! smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, n
           real(sp), intent(out) :: amax, scond
           ! Array Arguments 
           real(sp), intent(out) :: s(*)
           complex(sp), intent(in) :: ab(ldab,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j
           real(sp) :: smin
           ! Intrinsic Functions 
           intrinsic :: max,min,real,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( ldab<kd+1 ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPBEQU', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              scond = one
              amax = zero
              return
           end if
           if( upper ) then
              j = kd + 1
           else
              j = 1
           end if
           ! initialize smin and amax.
           s( 1 ) = real( ab( j, 1 ),KIND=sp)
           smin = s( 1 )
           amax = s( 1 )
           ! find the minimum and maximum diagonal elements.
           do i = 2, n
              s( i ) = real( ab( j, i ),KIND=sp)
              smin = min( smin, s( i ) )
              amax = max( amax, s( i ) )
           end do
           if( smin<=zero ) then
              ! find the first non-positive diagonal element and return.
              do i = 1, n
                 if( s( i )<=zero ) then
                    info = i
                    return
                 end if
              end do
           else
              ! set the scale factors to the reciprocals
              ! of the diagonal elements.
              do i = 1, n
                 s( i ) = one / sqrt( s( i ) )
              end do
              ! compute scond = min(s(i)) / max(s(i))
              scond = sqrt( smin ) / sqrt( amax )
           end if
           return
     end subroutine stdlib_cpbequ


     pure subroutine stdlib_cpbstf( uplo, n, kd, ab, ldab, info )
     !! CPBSTF computes a split Cholesky factorization of a complex
     !! Hermitian positive definite band matrix A.
     !! This routine is designed to be used in conjunction with CHBGST.
     !! The factorization has the form  A = S**H*S  where S is a band matrix
     !! of the same bandwidth as A and the following structure:
     !! S = ( U    )
     !! ( M  L )
     !! where U is upper triangular of order m = (n+kd)/2, and L is lower
     !! triangular of order n-m.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, n
           ! Array Arguments 
           complex(sp), intent(inout) :: ab(ldab,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, kld, km, m
           real(sp) :: ajj
           ! Intrinsic Functions 
           intrinsic :: max,min,real,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( ldab<kd+1 ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPBSTF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           kld = max( 1, ldab-1 )
           ! set the splitting point m.
           m = ( n+kd ) / 2
           if( upper ) then
              ! factorize a(m+1:n,m+1:n) as l**h*l, and update a(1:m,1:m).
              do j = n, m + 1, -1
                 ! compute s(j,j) and test for non-positive-definiteness.
                 ajj = real( ab( kd+1, j ),KIND=sp)
                 if( ajj<=zero ) then
                    ab( kd+1, j ) = ajj
                    go to 50
                 end if
                 ajj = sqrt( ajj )
                 ab( kd+1, j ) = ajj
                 km = min( j-1, kd )
                 ! compute elements j-km:j-1 of the j-th column and update the
                 ! the leading submatrix within the band.
                 call stdlib_csscal( km, one / ajj, ab( kd+1-km, j ), 1 )
                 call stdlib_cher( 'UPPER', km, -one, ab( kd+1-km, j ), 1,ab( kd+1, j-km ), kld )
                           
              end do
              ! factorize the updated submatrix a(1:m,1:m) as u**h*u.
              do j = 1, m
                 ! compute s(j,j) and test for non-positive-definiteness.
                 ajj = real( ab( kd+1, j ),KIND=sp)
                 if( ajj<=zero ) then
                    ab( kd+1, j ) = ajj
                    go to 50
                 end if
                 ajj = sqrt( ajj )
                 ab( kd+1, j ) = ajj
                 km = min( kd, m-j )
                 ! compute elements j+1:j+km of the j-th row and update the
                 ! trailing submatrix within the band.
                 if( km>0 ) then
                    call stdlib_csscal( km, one / ajj, ab( kd, j+1 ), kld )
                    call stdlib_clacgv( km, ab( kd, j+1 ), kld )
                    call stdlib_cher( 'UPPER', km, -one, ab( kd, j+1 ), kld,ab( kd+1, j+1 ), kld )
                              
                    call stdlib_clacgv( km, ab( kd, j+1 ), kld )
                 end if
              end do
           else
              ! factorize a(m+1:n,m+1:n) as l**h*l, and update a(1:m,1:m).
              do j = n, m + 1, -1
                 ! compute s(j,j) and test for non-positive-definiteness.
                 ajj = real( ab( 1, j ),KIND=sp)
                 if( ajj<=zero ) then
                    ab( 1, j ) = ajj
                    go to 50
                 end if
                 ajj = sqrt( ajj )
                 ab( 1, j ) = ajj
                 km = min( j-1, kd )
                 ! compute elements j-km:j-1 of the j-th row and update the
                 ! trailing submatrix within the band.
                 call stdlib_csscal( km, one / ajj, ab( km+1, j-km ), kld )
                 call stdlib_clacgv( km, ab( km+1, j-km ), kld )
                 call stdlib_cher( 'LOWER', km, -one, ab( km+1, j-km ), kld,ab( 1, j-km ), kld )
                           
                 call stdlib_clacgv( km, ab( km+1, j-km ), kld )
              end do
              ! factorize the updated submatrix a(1:m,1:m) as u**h*u.
              do j = 1, m
                 ! compute s(j,j) and test for non-positive-definiteness.
                 ajj = real( ab( 1, j ),KIND=sp)
                 if( ajj<=zero ) then
                    ab( 1, j ) = ajj
                    go to 50
                 end if
                 ajj = sqrt( ajj )
                 ab( 1, j ) = ajj
                 km = min( kd, m-j )
                 ! compute elements j+1:j+km of the j-th column and update the
                 ! trailing submatrix within the band.
                 if( km>0 ) then
                    call stdlib_csscal( km, one / ajj, ab( 2, j ), 1 )
                    call stdlib_cher( 'LOWER', km, -one, ab( 2, j ), 1,ab( 1, j+1 ), kld )
                 end if
              end do
           end if
           return
           50 continue
           info = j
           return
     end subroutine stdlib_cpbstf


     pure subroutine stdlib_cpbtf2( uplo, n, kd, ab, ldab, info )
     !! CPBTF2 computes the Cholesky factorization of a complex Hermitian
     !! positive definite band matrix A.
     !! The factorization has the form
     !! A = U**H * U ,  if UPLO = 'U', or
     !! A = L  * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix, U**H is the conjugate transpose
     !! of U, and L is lower triangular.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, n
           ! Array Arguments 
           complex(sp), intent(inout) :: ab(ldab,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, kld, kn
           real(sp) :: ajj
           ! Intrinsic Functions 
           intrinsic :: max,min,real,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( ldab<kd+1 ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPBTF2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           kld = max( 1, ldab-1 )
           if( upper ) then
              ! compute the cholesky factorization a = u**h * u.
              do j = 1, n
                 ! compute u(j,j) and test for non-positive-definiteness.
                 ajj = real( ab( kd+1, j ),KIND=sp)
                 if( ajj<=zero ) then
                    ab( kd+1, j ) = ajj
                    go to 30
                 end if
                 ajj = sqrt( ajj )
                 ab( kd+1, j ) = ajj
                 ! compute elements j+1:j+kn of row j and update the
                 ! trailing submatrix within the band.
                 kn = min( kd, n-j )
                 if( kn>0 ) then
                    call stdlib_csscal( kn, one / ajj, ab( kd, j+1 ), kld )
                    call stdlib_clacgv( kn, ab( kd, j+1 ), kld )
                    call stdlib_cher( 'UPPER', kn, -one, ab( kd, j+1 ), kld,ab( kd+1, j+1 ), kld )
                              
                    call stdlib_clacgv( kn, ab( kd, j+1 ), kld )
                 end if
              end do
           else
              ! compute the cholesky factorization a = l*l**h.
              do j = 1, n
                 ! compute l(j,j) and test for non-positive-definiteness.
                 ajj = real( ab( 1, j ),KIND=sp)
                 if( ajj<=zero ) then
                    ab( 1, j ) = ajj
                    go to 30
                 end if
                 ajj = sqrt( ajj )
                 ab( 1, j ) = ajj
                 ! compute elements j+1:j+kn of column j and update the
                 ! trailing submatrix within the band.
                 kn = min( kd, n-j )
                 if( kn>0 ) then
                    call stdlib_csscal( kn, one / ajj, ab( 2, j ), 1 )
                    call stdlib_cher( 'LOWER', kn, -one, ab( 2, j ), 1,ab( 1, j+1 ), kld )
                 end if
              end do
           end if
           return
           30 continue
           info = j
           return
     end subroutine stdlib_cpbtf2


     pure subroutine stdlib_cpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
     !! CPBTRS solves a system of linear equations A*X = B with a Hermitian
     !! positive definite band matrix A using the Cholesky factorization
     !! A = U**H*U or A = L*L**H computed by CPBTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldb, n, nrhs
           ! Array Arguments 
           complex(sp), intent(in) :: ab(ldab,*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldab<kd+1 ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPBTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b where a = u**h *u.
              do j = 1, nrhs
                 ! solve u**h *x = b, overwriting b with x.
                 call stdlib_ctbsv( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT', n,kd, ab, ldab, b(&
                            1, j ), 1 )
                 ! solve u*x = b, overwriting b with x.
                 call stdlib_ctbsv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n, kd, ab,ldab, b( 1, j )&
                           , 1 )
              end do
           else
              ! solve a*x = b where a = l*l**h.
              do j = 1, nrhs
                 ! solve l*x = b, overwriting b with x.
                 call stdlib_ctbsv( 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', n, kd, ab,ldab, b( 1, j )&
                           , 1 )
                 ! solve l**h *x = b, overwriting b with x.
                 call stdlib_ctbsv( 'LOWER', 'CONJUGATE TRANSPOSE', 'NON-UNIT', n,kd, ab, ldab, b(&
                            1, j ), 1 )
              end do
           end if
           return
     end subroutine stdlib_cpbtrs


     pure subroutine stdlib_cpoequ( n, a, lda, s, scond, amax, info )
     !! CPOEQU computes row and column scalings intended to equilibrate a
     !! Hermitian positive definite matrix A and reduce its condition number
     !! (with respect to the two-norm).  S contains the scale factors,
     !! S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
     !! elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
     !! choice of S puts the condition number of B within a factor N of the
     !! smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(out) :: amax, scond
           ! Array Arguments 
           real(sp), intent(out) :: s(*)
           complex(sp), intent(in) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(sp) :: smin
           ! Intrinsic Functions 
           intrinsic :: max,min,real,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( lda<max( 1, n ) ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPOEQU', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              scond = one
              amax = zero
              return
           end if
           ! find the minimum and maximum diagonal elements.
           s( 1 ) = real( a( 1, 1 ),KIND=sp)
           smin = s( 1 )
           amax = s( 1 )
           do i = 2, n
              s( i ) = real( a( i, i ),KIND=sp)
              smin = min( smin, s( i ) )
              amax = max( amax, s( i ) )
           end do
           if( smin<=zero ) then
              ! find the first non-positive diagonal element and return.
              do i = 1, n
                 if( s( i )<=zero ) then
                    info = i
                    return
                 end if
              end do
           else
              ! set the scale factors to the reciprocals
              ! of the diagonal elements.
              do i = 1, n
                 s( i ) = one / sqrt( s( i ) )
              end do
              ! compute scond = min(s(i)) / max(s(i))
              scond = sqrt( smin ) / sqrt( amax )
           end if
           return
     end subroutine stdlib_cpoequ


     pure subroutine stdlib_cpoequb( n, a, lda, s, scond, amax, info )
     !! CPOEQUB computes row and column scalings intended to equilibrate a
     !! Hermitian positive definite matrix A and reduce its condition number
     !! (with respect to the two-norm).  S contains the scale factors,
     !! S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
     !! elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
     !! choice of S puts the condition number of B within a factor N of the
     !! smallest possible condition number over all possible diagonal
     !! scalings.
     !! This routine differs from CPOEQU by restricting the scaling factors
     !! to a power of the radix.  Barring over- and underflow, scaling by
     !! these factors introduces no additional rounding errors.  However, the
     !! scaled diagonal entries are no longer approximately 1 but lie
     !! between sqrt(radix) and 1/sqrt(radix).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(out) :: amax, scond
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*)
           real(sp), intent(out) :: s(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(sp) :: smin, base, tmp
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt,log,int
           ! Executable Statements 
           ! test the input parameters.
           ! positive definite only performs 1 pass of equilibration.
           info = 0
           if( n<0 ) then
              info = -1
           else if( lda<max( 1, n ) ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPOEQUB', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 ) then
              scond = one
              amax = zero
              return
           end if
           base = stdlib_slamch( 'B' )
           tmp = -0.5_sp / log ( base )
           ! find the minimum and maximum diagonal elements.
           s( 1 ) = real( a( 1, 1 ),KIND=sp)
           smin = s( 1 )
           amax = s( 1 )
           do i = 2, n
              s( i ) = real( a( i, i ),KIND=sp)
              smin = min( smin, s( i ) )
              amax = max( amax, s( i ) )
           end do
           if( smin<=zero ) then
              ! find the first non-positive diagonal element and return.
              do i = 1, n
                 if( s( i )<=zero ) then
                    info = i
                    return
                 end if
              end do
           else
              ! set the scale factors to the reciprocals
              ! of the diagonal elements.
              do i = 1, n
                 s( i ) = base ** int( tmp * log( s( i ) ),KIND=ilp)
              end do
              ! compute scond = min(s(i)) / max(s(i)).
              scond = sqrt( smin ) / sqrt( amax )
           end if
           return
     end subroutine stdlib_cpoequb


     pure subroutine stdlib_cpotf2( uplo, n, a, lda, info )
     !! CPOTF2 computes the Cholesky factorization of a complex Hermitian
     !! positive definite matrix A.
     !! The factorization has the form
     !! A = U**H * U ,  if UPLO = 'U', or
     !! A = L  * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is lower triangular.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j
           real(sp) :: ajj
           ! Intrinsic Functions 
           intrinsic :: max,real,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPOTF2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! compute the cholesky factorization a = u**h *u.
              do j = 1, n
                 ! compute u(j,j) and test for non-positive-definiteness.
                 ajj = real( real( a( j, j ),KIND=sp) - stdlib_cdotc( j-1, a( 1, j ), 1,a( 1, j ),&
                            1 ),KIND=sp)
                 if( ajj<=zero.or.stdlib_sisnan( ajj ) ) then
                    a( j, j ) = ajj
                    go to 30
                 end if
                 ajj = sqrt( ajj )
                 a( j, j ) = ajj
                 ! compute elements j+1:n of row j.
                 if( j<n ) then
                    call stdlib_clacgv( j-1, a( 1, j ), 1 )
                    call stdlib_cgemv( 'TRANSPOSE', j-1, n-j, -cone, a( 1, j+1 ),lda, a( 1, j ), &
                              1, cone, a( j, j+1 ), lda )
                    call stdlib_clacgv( j-1, a( 1, j ), 1 )
                    call stdlib_csscal( n-j, one / ajj, a( j, j+1 ), lda )
                 end if
              end do
           else
              ! compute the cholesky factorization a = l*l**h.
              do j = 1, n
                 ! compute l(j,j) and test for non-positive-definiteness.
                 ajj = real( real( a( j, j ),KIND=sp) - stdlib_cdotc( j-1, a( j, 1 ), lda,a( j, 1 &
                           ), lda ),KIND=sp)
                 if( ajj<=zero.or.stdlib_sisnan( ajj ) ) then
                    a( j, j ) = ajj
                    go to 30
                 end if
                 ajj = sqrt( ajj )
                 a( j, j ) = ajj
                 ! compute elements j+1:n of column j.
                 if( j<n ) then
                    call stdlib_clacgv( j-1, a( j, 1 ), lda )
                    call stdlib_cgemv( 'NO TRANSPOSE', n-j, j-1, -cone, a( j+1, 1 ),lda, a( j, 1 )&
                              , lda, cone, a( j+1, j ), 1 )
                    call stdlib_clacgv( j-1, a( j, 1 ), lda )
                    call stdlib_csscal( n-j, one / ajj, a( j+1, j ), 1 )
                 end if
              end do
           end if
           go to 40
           30 continue
           info = j
           40 continue
           return
     end subroutine stdlib_cpotf2


     pure recursive subroutine stdlib_cpotrf2( uplo, n, a, lda, info )
     !! CPOTRF2 computes the Cholesky factorization of a Hermitian
     !! positive definite matrix A using the recursive algorithm.
     !! The factorization has the form
     !! A = U**H * U,  if UPLO = 'U', or
     !! A = L  * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is lower triangular.
     !! This is the recursive version of the algorithm. It divides
     !! the matrix into four submatrices:
     !! [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2
     !! A = [ -----|----- ]  with n1 = n/2
     !! [  A21 | A22  ]       n2 = n-n1
     !! The subroutine calls itself to factor A11. Update and scale A21
     !! or A12, update A22 then calls itself to factor A22.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: n1, n2, iinfo
           real(sp) :: ajj
           ! Intrinsic Functions 
           intrinsic :: max,real,sqrt
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPOTRF2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! n=1 case
           if( n==1 ) then
              ! test for non-positive-definiteness
              ajj = real( a( 1, 1 ),KIND=sp)
              if( ajj<=zero.or.stdlib_sisnan( ajj ) ) then
                 info = 1
                 return
              end if
              ! factor
              a( 1, 1 ) = sqrt( ajj )
           ! use recursive code
           else
              n1 = n/2
              n2 = n-n1
              ! factor a11
              call stdlib_cpotrf2( uplo, n1, a( 1, 1 ), lda, iinfo )
              if ( iinfo/=0 ) then
                 info = iinfo
                 return
              end if
              ! compute the cholesky factorization a = u**h*u
              if( upper ) then
                 ! update and scale a12
                 call stdlib_ctrsm( 'L', 'U', 'C', 'N', n1, n2, cone,a( 1, 1 ), lda, a( 1, n1+1 ),&
                            lda )
                 ! update and factor a22
                 call stdlib_cherk( uplo, 'C', n2, n1, -one, a( 1, n1+1 ), lda,one, a( n1+1, n1+1 &
                           ), lda )
                 call stdlib_cpotrf2( uplo, n2, a( n1+1, n1+1 ), lda, iinfo )
                 if ( iinfo/=0 ) then
                    info = iinfo + n1
                    return
                 end if
              ! compute the cholesky factorization a = l*l**h
              else
                 ! update and scale a21
                 call stdlib_ctrsm( 'R', 'L', 'C', 'N', n2, n1, cone,a( 1, 1 ), lda, a( n1+1, 1 ),&
                            lda )
                 ! update and factor a22
                 call stdlib_cherk( uplo, 'N', n2, n1, -one, a( n1+1, 1 ), lda,one, a( n1+1, n1+1 &
                           ), lda )
                 call stdlib_cpotrf2( uplo, n2, a( n1+1, n1+1 ), lda, iinfo )
                 if ( iinfo/=0 ) then
                    info = iinfo + n1
                    return
                 end if
              end if
           end if
           return
     end subroutine stdlib_cpotrf2


     pure subroutine stdlib_cpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
     !! CPOTRS solves a system of linear equations A*X = B with a Hermitian
     !! positive definite matrix A using the Cholesky factorization
     !! A = U**H*U or A = L*L**H computed by CPOTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPOTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b where a = u**h *u.
              ! solve u**h *x = b, overwriting b with x.
              call stdlib_ctrsm( 'LEFT', 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',n, nrhs, cone,&
                         a, lda, b, ldb )
              ! solve u*x = b, overwriting b with x.
              call stdlib_ctrsm( 'LEFT', 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n,nrhs, cone, a, &
                        lda, b, ldb )
           else
              ! solve a*x = b where a = l*l**h.
              ! solve l*x = b, overwriting b with x.
              call stdlib_ctrsm( 'LEFT', 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', n,nrhs, cone, a, &
                        lda, b, ldb )
              ! solve l**h *x = b, overwriting b with x.
              call stdlib_ctrsm( 'LEFT', 'LOWER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',n, nrhs, cone,&
                         a, lda, b, ldb )
           end if
           return
     end subroutine stdlib_cpotrs


     pure subroutine stdlib_cppequ( uplo, n, ap, s, scond, amax, info )
     !! CPPEQU computes row and column scalings intended to equilibrate a
     !! Hermitian positive definite matrix A in packed storage and reduce
     !! its condition number (with respect to the two-norm).  S contains the
     !! scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
     !! B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
     !! This choice of S puts the condition number of B within a factor N of
     !! the smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(sp), intent(out) :: amax, scond
           ! Array Arguments 
           real(sp), intent(out) :: s(*)
           complex(sp), intent(in) :: ap(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, jj
           real(sp) :: smin
           ! Intrinsic Functions 
           intrinsic :: max,min,real,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPPEQU', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              scond = one
              amax = zero
              return
           end if
           ! initialize smin and amax.
           s( 1 ) = real( ap( 1 ),KIND=sp)
           smin = s( 1 )
           amax = s( 1 )
           if( upper ) then
              ! uplo = 'u':  upper triangle of a is stored.
              ! find the minimum and maximum diagonal elements.
              jj = 1
              do i = 2, n
                 jj = jj + i
                 s( i ) = real( ap( jj ),KIND=sp)
                 smin = min( smin, s( i ) )
                 amax = max( amax, s( i ) )
              end do
           else
              ! uplo = 'l':  lower triangle of a is stored.
              ! find the minimum and maximum diagonal elements.
              jj = 1
              do i = 2, n
                 jj = jj + n - i + 2
                 s( i ) = real( ap( jj ),KIND=sp)
                 smin = min( smin, s( i ) )
                 amax = max( amax, s( i ) )
              end do
           end if
           if( smin<=zero ) then
              ! find the first non-positive diagonal element and return.
              do i = 1, n
                 if( s( i )<=zero ) then
                    info = i
                    return
                 end if
              end do
           else
              ! set the scale factors to the reciprocals
              ! of the diagonal elements.
              do i = 1, n
                 s( i ) = one / sqrt( s( i ) )
              end do
              ! compute scond = min(s(i)) / max(s(i))
              scond = sqrt( smin ) / sqrt( amax )
           end if
           return
     end subroutine stdlib_cppequ


     pure subroutine stdlib_cpptrf( uplo, n, ap, info )
     !! CPPTRF computes the Cholesky factorization of a complex Hermitian
     !! positive definite matrix A stored in packed format.
     !! The factorization has the form
     !! A = U**H * U,  if UPLO = 'U', or
     !! A = L  * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is lower triangular.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           complex(sp), intent(inout) :: ap(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, jc, jj
           real(sp) :: ajj
           ! Intrinsic Functions 
           intrinsic :: real,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPPTRF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! compute the cholesky factorization a = u**h * u.
              jj = 0
              do j = 1, n
                 jc = jj + 1
                 jj = jj + j
                 ! compute elements 1:j-1 of column j.
                 if( j>1 )call stdlib_ctpsv( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',j-1, ap, &
                           ap( jc ), 1 )
                 ! compute u(j,j) and test for non-positive-definiteness.
                 ajj = real( real( ap( jj ),KIND=sp) - stdlib_cdotc( j-1,ap( jc ), 1, ap( jc ), 1 &
                           ),KIND=sp)
                 if( ajj<=zero ) then
                    ap( jj ) = ajj
                    go to 30
                 end if
                 ap( jj ) = sqrt( ajj )
              end do
           else
              ! compute the cholesky factorization a = l * l**h.
              jj = 1
              do j = 1, n
                 ! compute l(j,j) and test for non-positive-definiteness.
                 ajj = real( ap( jj ),KIND=sp)
                 if( ajj<=zero ) then
                    ap( jj ) = ajj
                    go to 30
                 end if
                 ajj = sqrt( ajj )
                 ap( jj ) = ajj
                 ! compute elements j+1:n of column j and update the trailing
                 ! submatrix.
                 if( j<n ) then
                    call stdlib_csscal( n-j, one / ajj, ap( jj+1 ), 1 )
                    call stdlib_chpr( 'LOWER', n-j, -one, ap( jj+1 ), 1,ap( jj+n-j+1 ) )
                    jj = jj + n - j + 1
                 end if
              end do
           end if
           go to 40
           30 continue
           info = j
           40 continue
           return
     end subroutine stdlib_cpptrf


     pure subroutine stdlib_cpptrs( uplo, n, nrhs, ap, b, ldb, info )
     !! CPPTRS solves a system of linear equations A*X = B with a Hermitian
     !! positive definite matrix A in packed storage using the Cholesky
     !! factorization A = U**H*U or A = L*L**H computed by CPPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           complex(sp), intent(in) :: ap(*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPPTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b where a = u**h * u.
              do i = 1, nrhs
                 ! solve u**h *x = b, overwriting b with x.
                 call stdlib_ctpsv( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT', n,ap, b( 1, i ), &
                           1 )
                 ! solve u*x = b, overwriting b with x.
                 call stdlib_ctpsv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n, ap,b( 1, i ), 1 )
                           
              end do
           else
              ! solve a*x = b where a = l * l**h.
              do i = 1, nrhs
                 ! solve l*y = b, overwriting b with x.
                 call stdlib_ctpsv( 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', n, ap,b( 1, i ), 1 )
                           
                 ! solve l**h *x = y, overwriting b with x.
                 call stdlib_ctpsv( 'LOWER', 'CONJUGATE TRANSPOSE', 'NON-UNIT', n,ap, b( 1, i ), &
                           1 )
              end do
           end if
           return
     end subroutine stdlib_cpptrs


     pure subroutine stdlib_cpstf2( uplo, n, a, lda, piv, rank, tol, work, info )
     !! CPSTF2 computes the Cholesky factorization with complete
     !! pivoting of a complex Hermitian positive semidefinite matrix A.
     !! The factorization has the form
     !! P**T * A * P = U**H * U ,  if UPLO = 'U',
     !! P**T * A * P = L  * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is lower triangular, and
     !! P is stored as vector PIV.
     !! This algorithm does not attempt to check that A is positive
     !! semidefinite. This version of the algorithm calls level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(sp), intent(in) :: tol
           integer(ilp), intent(out) :: info, rank
           integer(ilp), intent(in) :: lda, n
           character, intent(in) :: uplo
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: work(2*n)
           integer(ilp), intent(out) :: piv(n)
        ! =====================================================================
           
           
           ! Local Scalars 
           complex(sp) :: ctemp
           real(sp) :: ajj, sstop, stemp
           integer(ilp) :: i, itemp, j, pvt
           logical(lk) :: upper
           ! Intrinsic Functions 
           intrinsic :: conjg,max,real,sqrt
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPSTF2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! initialize piv
           do i = 1, n
              piv( i ) = i
           end do
           ! compute stopping value
           do i = 1, n
              work( i ) = real( a( i, i ),KIND=sp)
           end do
           pvt = maxloc( work( 1:n ), 1 )
           ajj = real( a( pvt, pvt ),KIND=sp)
           if( ajj<=zero.or.stdlib_sisnan( ajj ) ) then
              rank = 0
              info = 1
              go to 200
           end if
           ! compute stopping value if not supplied
           if( tol<zero ) then
              sstop = n * stdlib_slamch( 'EPSILON' ) * ajj
           else
              sstop = tol
           end if
           ! set first chalf of work to zero, holds dot products
           do i = 1, n
              work( i ) = 0
           end do
           if( upper ) then
              ! compute the cholesky factorization p**t * a * p = u**h * u
              loop_150: do j = 1, n
              ! find pivot, test for exit, else swap rows and columns
              ! update dot products, compute possible pivots which are
              ! stored in the second chalf of work
                 do i = j, n
                    if( j>1 ) then
                       work( i ) = work( i ) +real( conjg( a( j-1, i ) )*a( j-1, i ),KIND=sp)
                                 
                    end if
                    work( n+i ) = real( a( i, i ),KIND=sp) - work( i )
                 end do
                 if( j>1 ) then
                    itemp = maxloc( work( (n+j):(2*n) ), 1 )
                    pvt = itemp + j - 1
                    ajj = work( n+pvt )
                    if( ajj<=sstop.or.stdlib_sisnan( ajj ) ) then
                       a( j, j ) = ajj
                       go to 190
                    end if
                 end if
                 if( j/=pvt ) then
                    ! pivot ok, so can now swap pivot rows and columns
                    a( pvt, pvt ) = a( j, j )
                    call stdlib_cswap( j-1, a( 1, j ), 1, a( 1, pvt ), 1 )
                    if( pvt<n )call stdlib_cswap( n-pvt, a( j, pvt+1 ), lda,a( pvt, pvt+1 ), lda )
                              
                    do i = j + 1, pvt - 1
                       ctemp = conjg( a( j, i ) )
                       a( j, i ) = conjg( a( i, pvt ) )
                       a( i, pvt ) = ctemp
                    end do
                    a( j, pvt ) = conjg( a( j, pvt ) )
                    ! swap dot products and piv
                    stemp = work( j )
                    work( j ) = work( pvt )
                    work( pvt ) = stemp
                    itemp = piv( pvt )
                    piv( pvt ) = piv( j )
                    piv( j ) = itemp
                 end if
                 ajj = sqrt( ajj )
                 a( j, j ) = ajj
                 ! compute elements j+1:n of row j
                 if( j<n ) then
                    call stdlib_clacgv( j-1, a( 1, j ), 1 )
                    call stdlib_cgemv( 'TRANS', j-1, n-j, -cone, a( 1, j+1 ), lda,a( 1, j ), 1, &
                              cone, a( j, j+1 ), lda )
                    call stdlib_clacgv( j-1, a( 1, j ), 1 )
                    call stdlib_csscal( n-j, one / ajj, a( j, j+1 ), lda )
                 end if
              end do loop_150
           else
              ! compute the cholesky factorization p**t * a * p = l * l**h
              loop_180: do j = 1, n
              ! find pivot, test for exit, else swap rows and columns
              ! update dot products, compute possible pivots which are
              ! stored in the second chalf of work
                 do i = j, n
                    if( j>1 ) then
                       work( i ) = work( i ) +real( conjg( a( i, j-1 ) )*a( i, j-1 ),KIND=sp)
                                 
                    end if
                    work( n+i ) = real( a( i, i ),KIND=sp) - work( i )
                 end do
                 if( j>1 ) then
                    itemp = maxloc( work( (n+j):(2*n) ), 1 )
                    pvt = itemp + j - 1
                    ajj = work( n+pvt )
                    if( ajj<=sstop.or.stdlib_sisnan( ajj ) ) then
                       a( j, j ) = ajj
                       go to 190
                    end if
                 end if
                 if( j/=pvt ) then
                    ! pivot ok, so can now swap pivot rows and columns
                    a( pvt, pvt ) = a( j, j )
                    call stdlib_cswap( j-1, a( j, 1 ), lda, a( pvt, 1 ), lda )
                    if( pvt<n )call stdlib_cswap( n-pvt, a( pvt+1, j ), 1, a( pvt+1, pvt ),1 )
                              
                    do i = j + 1, pvt - 1
                       ctemp = conjg( a( i, j ) )
                       a( i, j ) = conjg( a( pvt, i ) )
                       a( pvt, i ) = ctemp
                    end do
                    a( pvt, j ) = conjg( a( pvt, j ) )
                    ! swap dot products and piv
                    stemp = work( j )
                    work( j ) = work( pvt )
                    work( pvt ) = stemp
                    itemp = piv( pvt )
                    piv( pvt ) = piv( j )
                    piv( j ) = itemp
                 end if
                 ajj = sqrt( ajj )
                 a( j, j ) = ajj
                 ! compute elements j+1:n of column j
                 if( j<n ) then
                    call stdlib_clacgv( j-1, a( j, 1 ), lda )
                    call stdlib_cgemv( 'NO TRANS', n-j, j-1, -cone, a( j+1, 1 ),lda, a( j, 1 ), &
                              lda, cone, a( j+1, j ), 1 )
                    call stdlib_clacgv( j-1, a( j, 1 ), lda )
                    call stdlib_csscal( n-j, one / ajj, a( j+1, j ), 1 )
                 end if
              end do loop_180
           end if
           ! ran to completion, a has full rank
           rank = n
           go to 200
           190 continue
           ! rank is number of steps completed.  set info = 1 to signal
           ! that the factorization cannot be used to solve a system.
           rank = j - 1
           info = 1
           200 continue
           return
     end subroutine stdlib_cpstf2


     pure subroutine stdlib_cpstrf( uplo, n, a, lda, piv, rank, tol, work, info )
     !! CPSTRF computes the Cholesky factorization with complete
     !! pivoting of a complex Hermitian positive semidefinite matrix A.
     !! The factorization has the form
     !! P**T * A * P = U**H * U ,  if UPLO = 'U',
     !! P**T * A * P = L  * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is lower triangular, and
     !! P is stored as vector PIV.
     !! This algorithm does not attempt to check that A is positive
     !! semidefinite. This version of the algorithm calls level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(sp), intent(in) :: tol
           integer(ilp), intent(out) :: info, rank
           integer(ilp), intent(in) :: lda, n
           character, intent(in) :: uplo
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: work(2*n)
           integer(ilp), intent(out) :: piv(n)
        ! =====================================================================
           
           
           ! Local Scalars 
           complex(sp) :: ctemp
           real(sp) :: ajj, sstop, stemp
           integer(ilp) :: i, itemp, j, jb, k, nb, pvt
           logical(lk) :: upper
           ! Intrinsic Functions 
           intrinsic :: conjg,max,min,real,sqrt,maxloc
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPSTRF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get block size
           nb = stdlib_ilaenv( 1, 'CPOTRF', uplo, n, -1, -1, -1 )
           if( nb<=1 .or. nb>=n ) then
              ! use unblocked code
              call stdlib_cpstf2( uplo, n, a( 1, 1 ), lda, piv, rank, tol, work,info )
              go to 230
           else
           ! initialize piv
              do i = 1, n
                 piv( i ) = i
              end do
           ! compute stopping value
              do i = 1, n
                 work( i ) = real( a( i, i ),KIND=sp)
              end do
              pvt = maxloc( work( 1:n ), 1 )
              ajj = real( a( pvt, pvt ),KIND=sp)
              if( ajj<=zero.or.stdlib_sisnan( ajj ) ) then
                 rank = 0
                 info = 1
                 go to 230
              end if
           ! compute stopping value if not supplied
              if( tol<zero ) then
                 sstop = n * stdlib_slamch( 'EPSILON' ) * ajj
              else
                 sstop = tol
              end if
              if( upper ) then
                 ! compute the cholesky factorization p**t * a * p = u**h * u
                 loop_160: do k = 1, n, nb
                    ! account for last block not being nb wide
                    jb = min( nb, n-k+1 )
                    ! set relevant part of first chalf of work to zero,
                    ! holds dot products
                    do i = k, n
                       work( i ) = 0
                    end do
                    loop_150: do j = k, k + jb - 1
                    ! find pivot, test for exit, else swap rows and columns
                    ! update dot products, compute possible pivots which are
                    ! stored in the second chalf of work
                       do i = j, n
                          if( j>k ) then
                             work( i ) = work( i ) +real( conjg( a( j-1, i ) )*a( j-1, i ),&
                                       KIND=sp)
                          end if
                          work( n+i ) = real( a( i, i ),KIND=sp) - work( i )
                       end do
                       if( j>1 ) then
                          itemp = maxloc( work( (n+j):(2*n) ), 1 )
                          pvt = itemp + j - 1
                          ajj = work( n+pvt )
                          if( ajj<=sstop.or.stdlib_sisnan( ajj ) ) then
                             a( j, j ) = ajj
                             go to 220
                          end if
                       end if
                       if( j/=pvt ) then
                          ! pivot ok, so can now swap pivot rows and columns
                          a( pvt, pvt ) = a( j, j )
                          call stdlib_cswap( j-1, a( 1, j ), 1, a( 1, pvt ), 1 )
                          if( pvt<n )call stdlib_cswap( n-pvt, a( j, pvt+1 ), lda,a( pvt, pvt+1 ),&
                                     lda )
                          do i = j + 1, pvt - 1
                             ctemp = conjg( a( j, i ) )
                             a( j, i ) = conjg( a( i, pvt ) )
                             a( i, pvt ) = ctemp
                          end do
                          a( j, pvt ) = conjg( a( j, pvt ) )
                          ! swap dot products and piv
                          stemp = work( j )
                          work( j ) = work( pvt )
                          work( pvt ) = stemp
                          itemp = piv( pvt )
                          piv( pvt ) = piv( j )
                          piv( j ) = itemp
                       end if
                       ajj = sqrt( ajj )
                       a( j, j ) = ajj
                       ! compute elements j+1:n of row j.
                       if( j<n ) then
                          call stdlib_clacgv( j-1, a( 1, j ), 1 )
                          call stdlib_cgemv( 'TRANS', j-k, n-j, -cone, a( k, j+1 ),lda, a( k, j ),&
                                     1, cone, a( j, j+1 ),lda )
                          call stdlib_clacgv( j-1, a( 1, j ), 1 )
                          call stdlib_csscal( n-j, one / ajj, a( j, j+1 ), lda )
                       end if
                    end do loop_150
                    ! update trailing matrix, j already incremented
                    if( k+jb<=n ) then
                       call stdlib_cherk( 'UPPER', 'CONJ TRANS', n-j+1, jb, -one,a( k, j ), lda, &
                                 one, a( j, j ), lda )
                    end if
                 end do loop_160
              else
              ! compute the cholesky factorization p**t * a * p = l * l**h
                 loop_210: do k = 1, n, nb
                    ! account for last block not being nb wide
                    jb = min( nb, n-k+1 )
                    ! set relevant part of first chalf of work to zero,
                    ! holds dot products
                    do i = k, n
                       work( i ) = 0
                    end do
                    loop_200: do j = k, k + jb - 1
                    ! find pivot, test for exit, else swap rows and columns
                    ! update dot products, compute possible pivots which are
                    ! stored in the second chalf of work
                       do i = j, n
                          if( j>k ) then
                             work( i ) = work( i ) +real( conjg( a( i, j-1 ) )*a( i, j-1 ),&
                                       KIND=sp)
                          end if
                          work( n+i ) = real( a( i, i ),KIND=sp) - work( i )
                       end do
                       if( j>1 ) then
                          itemp = maxloc( work( (n+j):(2*n) ), 1 )
                          pvt = itemp + j - 1
                          ajj = work( n+pvt )
                          if( ajj<=sstop.or.stdlib_sisnan( ajj ) ) then
                             a( j, j ) = ajj
                             go to 220
                          end if
                       end if
                       if( j/=pvt ) then
                          ! pivot ok, so can now swap pivot rows and columns
                          a( pvt, pvt ) = a( j, j )
                          call stdlib_cswap( j-1, a( j, 1 ), lda, a( pvt, 1 ), lda )
                          if( pvt<n )call stdlib_cswap( n-pvt, a( pvt+1, j ), 1,a( pvt+1, pvt ), &
                                    1 )
                          do i = j + 1, pvt - 1
                             ctemp = conjg( a( i, j ) )
                             a( i, j ) = conjg( a( pvt, i ) )
                             a( pvt, i ) = ctemp
                          end do
                          a( pvt, j ) = conjg( a( pvt, j ) )
                          ! swap dot products and piv
                          stemp = work( j )
                          work( j ) = work( pvt )
                          work( pvt ) = stemp
                          itemp = piv( pvt )
                          piv( pvt ) = piv( j )
                          piv( j ) = itemp
                       end if
                       ajj = sqrt( ajj )
                       a( j, j ) = ajj
                       ! compute elements j+1:n of column j.
                       if( j<n ) then
                          call stdlib_clacgv( j-1, a( j, 1 ), lda )
                          call stdlib_cgemv( 'NO TRANS', n-j, j-k, -cone,a( j+1, k ), lda, a( j, &
                                    k ), lda, cone,a( j+1, j ), 1 )
                          call stdlib_clacgv( j-1, a( j, 1 ), lda )
                          call stdlib_csscal( n-j, one / ajj, a( j+1, j ), 1 )
                       end if
                    end do loop_200
                    ! update trailing matrix, j already incremented
                    if( k+jb<=n ) then
                       call stdlib_cherk( 'LOWER', 'NO TRANS', n-j+1, jb, -one,a( j, k ), lda, &
                                 one, a( j, j ), lda )
                    end if
                 end do loop_210
              end if
           end if
           ! ran to completion, a has full rank
           rank = n
           go to 230
           220 continue
           ! rank is the number of steps completed.  set info = 1 to signal
           ! that the factorization cannot be used to solve a system.
           rank = j - 1
           info = 1
           230 continue
           return
     end subroutine stdlib_cpstrf


     pure subroutine stdlib_cptcon( n, d, e, anorm, rcond, rwork, info )
     !! CPTCON computes the reciprocal of the condition number (in the
     !! 1-norm) of a complex Hermitian positive definite tridiagonal matrix
     !! using the factorization A = L*D*L**H or A = U**H*D*U computed by
     !! CPTTRF.
     !! Norm(inv(A)) is computed by a direct method, and the reciprocal of
     !! the condition number is computed as
     !! RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           real(sp), intent(in) :: d(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(in) :: e(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, ix
           real(sp) :: ainvnm
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
           ! test the input arguments.
           info = 0
           if( n<0 ) then
              info = -1
           else if( anorm<zero ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPTCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm==zero ) then
              return
           end if
           ! check that d(1:n) is positive.
           do i = 1, n
              if( d( i )<=zero )return
           end do
           ! solve m(a) * x = e, where m(a) = (m(i,j)) is given by
              ! m(i,j) =  abs(a(i,j)), i = j,
              ! m(i,j) = -abs(a(i,j)), i .ne. j,
           ! and e = [ 1, 1, ..., 1 ]**t.  note m(a) = m(l)*d*m(l)**h.
           ! solve m(l) * x = e.
           rwork( 1 ) = one
           do i = 2, n
              rwork( i ) = one + rwork( i-1 )*abs( e( i-1 ) )
           end do
           ! solve d * m(l)**h * x = b.
           rwork( n ) = rwork( n ) / d( n )
           do i = n - 1, 1, -1
              rwork( i ) = rwork( i ) / d( i ) + rwork( i+1 )*abs( e( i ) )
           end do
           ! compute ainvnm = max(x(i)), 1<=i<=n.
           ix = stdlib_isamax( n, rwork, 1 )
           ainvnm = abs( rwork( ix ) )
           ! compute the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_cptcon


     pure subroutine stdlib_cpttrf( n, d, e, info )
     !! CPTTRF computes the L*D*L**H factorization of a complex Hermitian
     !! positive definite tridiagonal matrix A.  The factorization may also
     !! be regarded as having the form A = U**H *D*U.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(sp), intent(inout) :: d(*)
           complex(sp), intent(inout) :: e(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, i4
           real(sp) :: eii, eir, f, g
           ! Intrinsic Functions 
           intrinsic :: aimag,cmplx,mod,real
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
              call stdlib_xerbla( 'CPTTRF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! compute the l*d*l**h (or u**h *d*u) factorization of a.
           i4 = mod( n-1, 4 )
           do i = 1, i4
              if( d( i )<=zero ) then
                 info = i
                 go to 20
              end if
              eir = real( e( i ),KIND=sp)
              eii = aimag( e( i ) )
              f = eir / d( i )
              g = eii / d( i )
              e( i ) = cmplx( f, g,KIND=sp)
              d( i+1 ) = d( i+1 ) - f*eir - g*eii
           end do
           loop_110: do i = i4+1, n - 4, 4
              ! drop out of the loop if d(i) <= 0: the matrix is not positive
              ! definite.
              if( d( i )<=zero ) then
                 info = i
                 go to 20
              end if
              ! solve for e(i) and d(i+1).
              eir = real( e( i ),KIND=sp)
              eii = aimag( e( i ) )
              f = eir / d( i )
              g = eii / d( i )
              e( i ) = cmplx( f, g,KIND=sp)
              d( i+1 ) = d( i+1 ) - f*eir - g*eii
              if( d( i+1 )<=zero ) then
                 info = i+1
                 go to 20
              end if
              ! solve for e(i+1) and d(i+2).
              eir = real( e( i+1 ),KIND=sp)
              eii = aimag( e( i+1 ) )
              f = eir / d( i+1 )
              g = eii / d( i+1 )
              e( i+1 ) = cmplx( f, g,KIND=sp)
              d( i+2 ) = d( i+2 ) - f*eir - g*eii
              if( d( i+2 )<=zero ) then
                 info = i+2
                 go to 20
              end if
              ! solve for e(i+2) and d(i+3).
              eir = real( e( i+2 ),KIND=sp)
              eii = aimag( e( i+2 ) )
              f = eir / d( i+2 )
              g = eii / d( i+2 )
              e( i+2 ) = cmplx( f, g,KIND=sp)
              d( i+3 ) = d( i+3 ) - f*eir - g*eii
              if( d( i+3 )<=zero ) then
                 info = i+3
                 go to 20
              end if
              ! solve for e(i+3) and d(i+4).
              eir = real( e( i+3 ),KIND=sp)
              eii = aimag( e( i+3 ) )
              f = eir / d( i+3 )
              g = eii / d( i+3 )
              e( i+3 ) = cmplx( f, g,KIND=sp)
              d( i+4 ) = d( i+4 ) - f*eir - g*eii
           end do loop_110
           ! check d(n) for positive definiteness.
           if( d( n )<=zero )info = n
           20 continue
           return
     end subroutine stdlib_cpttrf


     pure subroutine stdlib_cptts2( iuplo, n, nrhs, d, e, b, ldb )
     !! CPTTS2 solves a tridiagonal system of the form
     !! A * X = B
     !! using the factorization A = U**H*D*U or A = L*D*L**H computed by CPTTRF.
     !! D is a diagonal matrix specified in the vector D, U (or L) is a unit
     !! bidiagonal matrix whose superdiagonal (subdiagonal) is specified in
     !! the vector E, and X and B are N by NRHS matrices.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: iuplo, ldb, n, nrhs
           ! Array Arguments 
           real(sp), intent(in) :: d(*)
           complex(sp), intent(inout) :: b(ldb,*)
           complex(sp), intent(in) :: e(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           ! Intrinsic Functions 
           intrinsic :: conjg
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 ) then
              if( n==1 )call stdlib_csscal( nrhs, 1. / d( 1 ), b, ldb )
              return
           end if
           if( iuplo==1 ) then
              ! solve a * x = b using the factorization a = u**h *d*u,
              ! overwriting each right hand side vector with its solution.
              if( nrhs<=2 ) then
                 j = 1
                 5 continue
                 ! solve u**h * x = b.
                 do i = 2, n
                    b( i, j ) = b( i, j ) - b( i-1, j )*conjg( e( i-1 ) )
                 end do
                 ! solve d * u * x = b.
                 do i = 1, n
                    b( i, j ) = b( i, j ) / d( i )
                 end do
                 do i = n - 1, 1, -1
                    b( i, j ) = b( i, j ) - b( i+1, j )*e( i )
                 end do
                 if( j<nrhs ) then
                    j = j + 1
                    go to 5
                 end if
              else
                 do j = 1, nrhs
                    ! solve u**h * x = b.
                    do i = 2, n
                       b( i, j ) = b( i, j ) - b( i-1, j )*conjg( e( i-1 ) )
                    end do
                    ! solve d * u * x = b.
                    b( n, j ) = b( n, j ) / d( n )
                    do i = n - 1, 1, -1
                       b( i, j ) = b( i, j ) / d( i ) - b( i+1, j )*e( i )
                    end do
                 end do
              end if
           else
              ! solve a * x = b using the factorization a = l*d*l**h,
              ! overwriting each right hand side vector with its solution.
              if( nrhs<=2 ) then
                 j = 1
                 65 continue
                 ! solve l * x = b.
                 do i = 2, n
                    b( i, j ) = b( i, j ) - b( i-1, j )*e( i-1 )
                 end do
                 ! solve d * l**h * x = b.
                 do i = 1, n
                    b( i, j ) = b( i, j ) / d( i )
                 end do
                 do i = n - 1, 1, -1
                    b( i, j ) = b( i, j ) - b( i+1, j )*conjg( e( i ) )
                 end do
                 if( j<nrhs ) then
                    j = j + 1
                    go to 65
                 end if
              else
                 do j = 1, nrhs
                    ! solve l * x = b.
                    do i = 2, n
                       b( i, j ) = b( i, j ) - b( i-1, j )*e( i-1 )
                    end do
                    ! solve d * l**h * x = b.
                    b( n, j ) = b( n, j ) / d( n )
                    do i = n - 1, 1, -1
                       b( i, j ) = b( i, j ) / d( i ) -b( i+1, j )*conjg( e( i ) )
                    end do
                 end do
              end if
           end if
           return
     end subroutine stdlib_cptts2


     pure subroutine stdlib_crot( n, cx, incx, cy, incy, c, s )
     !! CROT applies a plane rotation, where the cos (C) is real and the
     !! sin (S) is complex, and the vectors CX and CY are complex.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, incy, n
           real(sp), intent(in) :: c
           complex(sp), intent(in) :: s
           ! Array Arguments 
           complex(sp), intent(inout) :: cx(*), cy(*)
       ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ix, iy
           complex(sp) :: stemp
           ! Intrinsic Functions 
           intrinsic :: conjg
           ! Executable Statements 
           if( n<=0 )return
           if( incx==1 .and. incy==1 )go to 20
           ! code for unequal increments or equal increments not equal to 1
           ix = 1
           iy = 1
           if( incx<0 )ix = ( -n+1 )*incx + 1
           if( incy<0 )iy = ( -n+1 )*incy + 1
           do i = 1, n
              stemp = c*cx( ix ) + s*cy( iy )
              cy( iy ) = c*cy( iy ) - conjg( s )*cx( ix )
              cx( ix ) = stemp
              ix = ix + incx
              iy = iy + incy
           end do
           return
           ! code for both increments equal to 1
           20 continue
           do i = 1, n
              stemp = c*cx( i ) + s*cy( i )
              cy( i ) = c*cy( i ) - conjg( s )*cx( i )
              cx( i ) = stemp
           end do
           return
     end subroutine stdlib_crot


     pure subroutine stdlib_cspmv( uplo, n, alpha, ap, x, incx, beta, y, incy )
     !! CSPMV performs the matrix-vector operation
     !! y := alpha*A*x + beta*y,
     !! where alpha and beta are scalars, x and y are n element vectors and
     !! A is an n by n symmetric matrix, supplied in packed form.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: incx, incy, n
           complex(sp), intent(in) :: alpha, beta
           ! Array Arguments 
           complex(sp), intent(in) :: ap(*), x(*)
           complex(sp), intent(inout) :: y(*)
       ! =====================================================================
           
           
           ! Local Scalars 
           integer(ilp) :: i, info, ix, iy, j, jx, jy, k, kk, kx, ky
           complex(sp) :: temp1, temp2
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = 1
           else if( n<0 ) then
              info = 2
           else if( incx==0 ) then
              info = 6
           else if( incy==0 ) then
              info = 9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPMV ', info )
              return
           end if
           ! quick return if possible.
           if( ( n==0 ) .or. ( ( alpha==czero ) .and. ( beta==cone ) ) )return
           ! set up the start points in  x  and  y.
           if( incx>0 ) then
              kx = 1
           else
              kx = 1 - ( n-1 )*incx
           end if
           if( incy>0 ) then
              ky = 1
           else
              ky = 1 - ( n-1 )*incy
           end if
           ! start the operations. in this version the elements of the array ap
           ! are accessed sequentially with cone pass through ap.
           ! first form  y := beta*y.
           if( beta/=cone ) then
              if( incy==1 ) then
                 if( beta==czero ) then
                    do i = 1, n
                       y( i ) = czero
                    end do
                 else
                    do i = 1, n
                       y( i ) = beta*y( i )
                    end do
                 end if
              else
                 iy = ky
                 if( beta==czero ) then
                    do i = 1, n
                       y( iy ) = czero
                       iy = iy + incy
                    end do
                 else
                    do i = 1, n
                       y( iy ) = beta*y( iy )
                       iy = iy + incy
                    end do
                 end if
              end if
           end if
           if( alpha==czero )return
           kk = 1
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! form  y  when ap contains the upper triangle.
              if( ( incx==1 ) .and. ( incy==1 ) ) then
                 do j = 1, n
                    temp1 = alpha*x( j )
                    temp2 = czero
                    k = kk
                    do i = 1, j - 1
                       y( i ) = y( i ) + temp1*ap( k )
                       temp2 = temp2 + ap( k )*x( i )
                       k = k + 1
                    end do
                    y( j ) = y( j ) + temp1*ap( kk+j-1 ) + alpha*temp2
                    kk = kk + j
                 end do
              else
                 jx = kx
                 jy = ky
                 do j = 1, n
                    temp1 = alpha*x( jx )
                    temp2 = czero
                    ix = kx
                    iy = ky
                    do k = kk, kk + j - 2
                       y( iy ) = y( iy ) + temp1*ap( k )
                       temp2 = temp2 + ap( k )*x( ix )
                       ix = ix + incx
                       iy = iy + incy
                    end do
                    y( jy ) = y( jy ) + temp1*ap( kk+j-1 ) + alpha*temp2
                    jx = jx + incx
                    jy = jy + incy
                    kk = kk + j
                 end do
              end if
           else
              ! form  y  when ap contains the lower triangle.
              if( ( incx==1 ) .and. ( incy==1 ) ) then
                 do j = 1, n
                    temp1 = alpha*x( j )
                    temp2 = czero
                    y( j ) = y( j ) + temp1*ap( kk )
                    k = kk + 1
                    do i = j + 1, n
                       y( i ) = y( i ) + temp1*ap( k )
                       temp2 = temp2 + ap( k )*x( i )
                       k = k + 1
                    end do
                    y( j ) = y( j ) + alpha*temp2
                    kk = kk + ( n-j+1 )
                 end do
              else
                 jx = kx
                 jy = ky
                 do j = 1, n
                    temp1 = alpha*x( jx )
                    temp2 = czero
                    y( jy ) = y( jy ) + temp1*ap( kk )
                    ix = jx
                    iy = jy
                    do k = kk + 1, kk + n - j
                       ix = ix + incx
                       iy = iy + incy
                       y( iy ) = y( iy ) + temp1*ap( k )
                       temp2 = temp2 + ap( k )*x( ix )
                    end do
                    y( jy ) = y( jy ) + alpha*temp2
                    jx = jx + incx
                    jy = jy + incy
                    kk = kk + ( n-j+1 )
                 end do
              end if
           end if
           return
     end subroutine stdlib_cspmv


     pure subroutine stdlib_cspr( uplo, n, alpha, x, incx, ap )
     !! CSPR performs the symmetric rank 1 operation
     !! A := alpha*x*x**H + A,
     !! where alpha is a complex scalar, x is an n element vector and A is an
     !! n by n symmetric matrix, supplied in packed form.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: incx, n
           complex(sp), intent(in) :: alpha
           ! Array Arguments 
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(in) :: x(*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, info, ix, j, jx, k, kk, kx
           complex(sp) :: temp
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = 1
           else if( n<0 ) then
              info = 2
           else if( incx==0 ) then
              info = 5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPR  ', info )
              return
           end if
           ! quick return if possible.
           if( ( n==0 ) .or. ( alpha==czero ) )return
           ! set the start point in x if the increment is not unity.
           if( incx<=0 ) then
              kx = 1 - ( n-1 )*incx
           else if( incx/=1 ) then
              kx = 1
           end if
           ! start the operations. in this version the elements of the array ap
           ! are accessed sequentially with cone pass through ap.
           kk = 1
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! form  a  when upper triangle is stored in ap.
              if( incx==1 ) then
                 do j = 1, n
                    if( x( j )/=czero ) then
                       temp = alpha*x( j )
                       k = kk
                       do i = 1, j - 1
                          ap( k ) = ap( k ) + x( i )*temp
                          k = k + 1
                       end do
                       ap( kk+j-1 ) = ap( kk+j-1 ) + x( j )*temp
                    else
                       ap( kk+j-1 ) = ap( kk+j-1 )
                    end if
                    kk = kk + j
                 end do
              else
                 jx = kx
                 do j = 1, n
                    if( x( jx )/=czero ) then
                       temp = alpha*x( jx )
                       ix = kx
                       do k = kk, kk + j - 2
                          ap( k ) = ap( k ) + x( ix )*temp
                          ix = ix + incx
                       end do
                       ap( kk+j-1 ) = ap( kk+j-1 ) + x( jx )*temp
                    else
                       ap( kk+j-1 ) = ap( kk+j-1 )
                    end if
                    jx = jx + incx
                    kk = kk + j
                 end do
              end if
           else
              ! form  a  when lower triangle is stored in ap.
              if( incx==1 ) then
                 do j = 1, n
                    if( x( j )/=czero ) then
                       temp = alpha*x( j )
                       ap( kk ) = ap( kk ) + temp*x( j )
                       k = kk + 1
                       do i = j + 1, n
                          ap( k ) = ap( k ) + x( i )*temp
                          k = k + 1
                       end do
                    else
                       ap( kk ) = ap( kk )
                    end if
                    kk = kk + n - j + 1
                 end do
              else
                 jx = kx
                 do j = 1, n
                    if( x( jx )/=czero ) then
                       temp = alpha*x( jx )
                       ap( kk ) = ap( kk ) + temp*x( jx )
                       ix = jx
                       do k = kk + 1, kk + n - j
                          ix = ix + incx
                          ap( k ) = ap( k ) + x( ix )*temp
                       end do
                    else
                       ap( kk ) = ap( kk )
                    end if
                    jx = jx + incx
                    kk = kk + n - j + 1
                 end do
              end if
           end if
           return
     end subroutine stdlib_cspr


     pure subroutine stdlib_csptrf( uplo, n, ap, ipiv, info )
     !! CSPTRF computes the factorization of a complex symmetric matrix A
     !! stored in packed format using the Bunch-Kaufman diagonal pivoting
     !! method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: ap(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kc, kk, knc, kp, kpc, kstep, kx, npp
           real(sp) :: absakk, alpha, colmax, rowmax
           complex(sp) :: d11, d12, d21, d22, r1, t, wk, wkm1, wkp1, zdum
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real,sqrt
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPTRF', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              kc = ( n-1 )*n / 2 + 1
              10 continue
              knc = kc
              ! if k < 1, exit from loop
              if( k<1 )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( ap( kc+k-1 ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, ap( kc ), 1 )
                 colmax = cabs1( ap( kc+imax-1 ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    rowmax = zero
                    jmax = imax
                    kx = imax*( imax+1 ) / 2 + imax
                    do j = imax + 1, k
                       if( cabs1( ap( kx ) )>rowmax ) then
                          rowmax = cabs1( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + j
                    end do
                    kpc = ( imax-1 )*imax / 2 + 1
                    if( imax>1 ) then
                       jmax = stdlib_icamax( imax-1, ap( kpc ), 1 )
                       rowmax = max( rowmax, cabs1( ap( kpc+jmax-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( ap( kpc+imax-1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kstep==2 )knc = knc - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_cswap( kp-1, ap( knc ), 1, ap( kpc ), 1 )
                    kx = kpc + kp - 1
                    do j = kp + 1, kk - 1
                       kx = kx + j - 1
                       t = ap( knc+j-1 )
                       ap( knc+j-1 ) = ap( kx )
                       ap( kx ) = t
                    end do
                    t = ap( knc+kk-1 )
                    ap( knc+kk-1 ) = ap( kpc+kp-1 )
                    ap( kpc+kp-1 ) = t
                    if( kstep==2 ) then
                       t = ap( kc+k-2 )
                       ap( kc+k-2 ) = ap( kc+kp-1 )
                       ap( kc+kp-1 ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**t = a - w(k)*1/d(k)*w(k)**t
                    r1 = cone / ap( kc+k-1 )
                    call stdlib_cspr( uplo, k-1, -r1, ap( kc ), 1, ap )
                    ! store u(k) in column k
                    call stdlib_cscal( k-1, r1, ap( kc ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**t
                    if( k>2 ) then
                       d12 = ap( k-1+( k-1 )*k / 2 )
                       d22 = ap( k-1+( k-2 )*( k-1 ) / 2 ) / d12
                       d11 = ap( k+( k-1 )*k / 2 ) / d12
                       t = cone / ( d11*d22-cone )
                       d12 = t / d12
                       do j = k - 2, 1, -1
                          wkm1 = d12*( d11*ap( j+( k-2 )*( k-1 ) / 2 )-ap( j+( k-1 )*k / 2 ) )
                                    
                          wk = d12*( d22*ap( j+( k-1 )*k / 2 )-ap( j+( k-2 )*( k-1 ) / 2 ) )
                                    
                          do i = j, 1, -1
                             ap( i+( j-1 )*j / 2 ) = ap( i+( j-1 )*j / 2 ) -ap( i+( k-1 )*k / 2 )&
                                       *wk -ap( i+( k-2 )*( k-1 ) / 2 )*wkm1
                          end do
                          ap( j+( k-1 )*k / 2 ) = wk
                          ap( j+( k-2 )*( k-1 ) / 2 ) = wkm1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              kc = knc - k
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              kc = 1
              npp = n*( n+1 ) / 2
              60 continue
              knc = kc
              ! if k > n, exit from loop
              if( k>n )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( ap( kc ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, ap( kc+1 ), 1 )
                 colmax = cabs1( ap( kc+imax-k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    rowmax = zero
                    kx = kc + imax - k
                    do j = k, imax - 1
                       if( cabs1( ap( kx ) )>rowmax ) then
                          rowmax = cabs1( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + n - j
                    end do
                    kpc = npp - ( n-imax+1 )*( n-imax+2 ) / 2 + 1
                    if( imax<n ) then
                       jmax = imax + stdlib_icamax( n-imax, ap( kpc+1 ), 1 )
                       rowmax = max( rowmax, cabs1( ap( kpc+jmax-imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( ap( kpc ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kstep==2 )knc = knc + n - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_cswap( n-kp, ap( knc+kp-kk+1 ), 1, ap( kpc+1 ),1 )
                              
                    kx = knc + kp - kk
                    do j = kk + 1, kp - 1
                       kx = kx + n - j + 1
                       t = ap( knc+j-kk )
                       ap( knc+j-kk ) = ap( kx )
                       ap( kx ) = t
                    end do
                    t = ap( knc )
                    ap( knc ) = ap( kpc )
                    ap( kpc ) = t
                    if( kstep==2 ) then
                       t = ap( kc+1 )
                       ap( kc+1 ) = ap( kc+kp-k )
                       ap( kc+kp-k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**t = a - w(k)*(1/d(k))*w(k)**t
                       r1 = cone / ap( kc )
                       call stdlib_cspr( uplo, n-k, -r1, ap( kc+1 ), 1,ap( kc+n-k+1 ) )
                       ! store l(k) in column k
                       call stdlib_cscal( n-k, r1, ap( kc+1 ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**t
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**t
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d21 = ap( k+1+( k-1 )*( 2*n-k ) / 2 )
                       d11 = ap( k+1+k*( 2*n-k-1 ) / 2 ) / d21
                       d22 = ap( k+( k-1 )*( 2*n-k ) / 2 ) / d21
                       t = cone / ( d11*d22-cone )
                       d21 = t / d21
                       do j = k + 2, n
                          wk = d21*( d11*ap( j+( k-1 )*( 2*n-k ) / 2 )-ap( j+k*( 2*n-k-1 ) / 2 ) )
                                    
                          wkp1 = d21*( d22*ap( j+k*( 2*n-k-1 ) / 2 )-ap( j+( k-1 )*( 2*n-k ) / 2 )&
                                     )
                          do i = j, n
                             ap( i+( j-1 )*( 2*n-j ) / 2 ) = ap( i+( j-1 )*( 2*n-j ) / 2 ) - ap( &
                                       i+( k-1 )*( 2*n-k ) /2 )*wk - ap( i+k*( 2*n-k-1 ) / 2 )*wkp1
                          end do
                          ap( j+( k-1 )*( 2*n-k ) / 2 ) = wk
                          ap( j+k*( 2*n-k-1 ) / 2 ) = wkp1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              kc = knc + n - k + 2
              go to 60
           end if
           110 continue
           return
     end subroutine stdlib_csptrf


     pure subroutine stdlib_csptri( uplo, n, ap, ipiv, work, info )
     !! CSPTRI computes the inverse of a complex symmetric indefinite matrix
     !! A in packed storage using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by CSPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kcnext, kp, kpc, kstep, kx, npp
           complex(sp) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              kp = n*( n+1 ) / 2
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. ap( kp )==czero )return
                 kp = kp - info
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              kp = 1
              do info = 1, n
                 if( ipiv( info )>0 .and. ap( kp )==czero )return
                 kp = kp + n - info + 1
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              kcnext = kc + k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc+k-1 ) = cone / ap( kc+k-1 )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_cspmv( uplo, k-1, -cone, ap, work, 1, czero, ap( kc ),1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -stdlib_cdotu( k-1, work, 1, ap( kc ), 1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = ap( kcnext+k-1 )
                 ak = ap( kc+k-1 ) / t
                 akp1 = ap( kcnext+k ) / t
                 akkp1 = ap( kcnext+k-1 ) / t
                 d = t*( ak*akp1-cone )
                 ap( kc+k-1 ) = akp1 / d
                 ap( kcnext+k ) = ak / d
                 ap( kcnext+k-1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_cspmv( uplo, k-1, -cone, ap, work, 1, czero, ap( kc ),1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -stdlib_cdotu( k-1, work, 1, ap( kc ), 1 )
                    ap( kcnext+k-1 ) = ap( kcnext+k-1 ) -stdlib_cdotu( k-1, ap( kc ), 1, ap( &
                              kcnext ),1 )
                    call stdlib_ccopy( k-1, ap( kcnext ), 1, work, 1 )
                    call stdlib_cspmv( uplo, k-1, -cone, ap, work, 1, czero,ap( kcnext ), 1 )
                              
                    ap( kcnext+k ) = ap( kcnext+k ) -stdlib_cdotu( k-1, work, 1, ap( kcnext ), 1 )
                              
                 end if
                 kstep = 2
                 kcnext = kcnext + k + 1
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kpc = ( kp-1 )*kp / 2 + 1
                 call stdlib_cswap( kp-1, ap( kc ), 1, ap( kpc ), 1 )
                 kx = kpc + kp - 1
                 do j = kp + 1, k - 1
                    kx = kx + j - 1
                    temp = ap( kc+j-1 )
                    ap( kc+j-1 ) = ap( kx )
                    ap( kx ) = temp
                 end do
                 temp = ap( kc+k-1 )
                 ap( kc+k-1 ) = ap( kpc+kp-1 )
                 ap( kpc+kp-1 ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc+k+k-1 )
                    ap( kc+k+k-1 ) = ap( kc+k+kp-1 )
                    ap( kc+k+kp-1 ) = temp
                 end if
              end if
              k = k + kstep
              kc = kcnext
              go to 30
              50 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              npp = n*( n+1 ) / 2
              k = n
              kc = npp
              60 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 80
              kcnext = kc - ( n-k+2 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc ) = cone / ap( kc )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_cspmv( uplo, n-k, -cone, ap( kc+n-k+1 ), work, 1,czero, ap( kc+1 )&
                              , 1 )
                    ap( kc ) = ap( kc ) - stdlib_cdotu( n-k, work, 1, ap( kc+1 ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = ap( kcnext+1 )
                 ak = ap( kcnext ) / t
                 akp1 = ap( kc ) / t
                 akkp1 = ap( kcnext+1 ) / t
                 d = t*( ak*akp1-cone )
                 ap( kcnext ) = akp1 / d
                 ap( kc ) = ak / d
                 ap( kcnext+1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_cspmv( uplo, n-k, -cone, ap( kc+( n-k+1 ) ), work, 1,czero, ap( &
                              kc+1 ), 1 )
                    ap( kc ) = ap( kc ) - stdlib_cdotu( n-k, work, 1, ap( kc+1 ),1 )
                    ap( kcnext+1 ) = ap( kcnext+1 ) -stdlib_cdotu( n-k, ap( kc+1 ), 1,ap( kcnext+&
                              2 ), 1 )
                    call stdlib_ccopy( n-k, ap( kcnext+2 ), 1, work, 1 )
                    call stdlib_cspmv( uplo, n-k, -cone, ap( kc+( n-k+1 ) ), work, 1,czero, ap( &
                              kcnext+2 ), 1 )
                    ap( kcnext ) = ap( kcnext ) -stdlib_cdotu( n-k, work, 1, ap( kcnext+2 ), 1 )
                              
                 end if
                 kstep = 2
                 kcnext = kcnext - ( n-k+3 )
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kpc = npp - ( n-kp+1 )*( n-kp+2 ) / 2 + 1
                 if( kp<n )call stdlib_cswap( n-kp, ap( kc+kp-k+1 ), 1, ap( kpc+1 ), 1 )
                 kx = kc + kp - k
                 do j = k + 1, kp - 1
                    kx = kx + n - j + 1
                    temp = ap( kc+j-k )
                    ap( kc+j-k ) = ap( kx )
                    ap( kx ) = temp
                 end do
                 temp = ap( kc )
                 ap( kc ) = ap( kpc )
                 ap( kpc ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc-n+k-1 )
                    ap( kc-n+k-1 ) = ap( kc-n+kp-1 )
                    ap( kc-n+kp-1 ) = temp
                 end if
              end if
              k = k - kstep
              kc = kcnext
              go to 60
              80 continue
           end if
           return
     end subroutine stdlib_csptri


     pure subroutine stdlib_csptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! CSPTRS solves a system of linear equations A*X = B with a complex
     !! symmetric matrix A stored in packed format using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by CSPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: ap(*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kp
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              kc = kc - k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_cgeru( k-1, nrhs, -cone, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_cscal( nrhs, cone / ap( kc+k-1 ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_cgeru( k-2, nrhs, -cone, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 call stdlib_cgeru( k-2, nrhs, -cone, ap( kc-( k-1 ) ), 1,b( k-1, 1 ), ldb, b( 1, &
                           1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+k-2 )
                 akm1 = ap( kc-1 ) / akm1k
                 ak = ap( kc+k-1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc - k + 1
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb, ap( kc ),1, cone, b( k,&
                            1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + k
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb, ap( kc ),1, cone, b( k,&
                            1 ), ldb )
                 call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb,ap( kc+k ), 1, cone, b( &
                           k+1, 1 ), ldb )
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + 2*k + 1
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgeru( n-k, nrhs, -cone, ap( kc+1 ), 1, b( k, 1 ),ldb, b( k+&
                           1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_cscal( nrhs, cone / ap( kc ), b( k, 1 ), ldb )
                 kc = kc + n - k + 1
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_cgeru( n-k-1, nrhs, -cone, ap( kc+2 ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_cgeru( n-k-1, nrhs, -cone, ap( kc+n-k+2 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+1 )
                 akm1 = ap( kc ) / akm1k
                 ak = ap( kc+n-k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc + 2*( n-k ) + 1
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              kc = kc - ( n-k+1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, ap( &
                           kc+1 ), 1, cone, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, ap( kc+1 ),&
                               1, cone, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, ap( kc-( n-&
                              k ) ), 1, cone, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc - ( n-k+2 )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_csptrs


     pure subroutine stdlib_csrscl( n, sa, sx, incx )
     !! CSRSCL multiplies an n-element complex vector x by the real scalar
     !! 1/a.  This is done without overflow or underflow as long as
     !! the final result x/a does not overflow or underflow.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, n
           real(sp), intent(in) :: sa
           ! Array Arguments 
           complex(sp), intent(inout) :: sx(*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: done
           real(sp) :: bignum, cden, cden1, cnum, cnum1, mul, smlnum
           ! Intrinsic Functions 
           intrinsic :: abs
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 )return
           ! get machine parameters
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           ! initialize the denominator to sa and the numerator to 1.
           cden = sa
           cnum = one
           10 continue
           cden1 = cden*smlnum
           cnum1 = cnum / bignum
           if( abs( cden1 )>abs( cnum ) .and. cnum/=zero ) then
              ! pre-multiply x by smlnum if cden is large compared to cnum.
              mul = smlnum
              done = .false.
              cden = cden1
           else if( abs( cnum1 )>abs( cden ) ) then
              ! pre-multiply x by bignum if cden is small compared to cnum.
              mul = bignum
              done = .false.
              cnum = cnum1
           else
              ! multiply x by cnum / cden and return.
              mul = cnum / cden
              done = .true.
           end if
           ! scale the vector x by mul
           call stdlib_csscal( n, mul, sx, incx )
           if( .not.done )go to 10
           return
     end subroutine stdlib_csrscl


     pure subroutine stdlib_cstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
     !! CSTEIN computes the eigenvectors of a real symmetric tridiagonal
     !! matrix T corresponding to specified eigenvalues, using inverse
     !! iteration.
     !! The maximum number of iterations allowed for each eigenvector is
     !! specified by an internal parameter MAXITS (currently set to 5).
     !! Although the eigenvectors are real, they are stored in a complex
     !! array, which may be passed to CUNMTR or CUPMTR for back
     !! transformation to the eigenvectors of a complex Hermitian matrix
     !! which was reduced to tridiagonal form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, m, n
           ! Array Arguments 
           integer(ilp), intent(in) :: iblock(*), isplit(*)
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(in) :: d(*), e(*), w(*)
           real(sp), intent(out) :: work(*)
           complex(sp), intent(out) :: z(ldz,*)
       ! =====================================================================
           ! Parameters 
           real(sp), parameter :: odm3 = 1.0e-3_sp
           real(sp), parameter :: odm1 = 1.0e-1_sp
           integer(ilp), parameter :: maxits = 5
           integer(ilp), parameter :: extra = 2
           
           
           
           ! Local Scalars 
           integer(ilp) :: b1, blksiz, bn, gpind, i, iinfo, indrv1, indrv2, indrv3, indrv4, &
                     indrv5, its, j, j1, jblk, jmax, jr, nblk, nrmchk
           real(sp) :: ctr, eps, eps1, nrm, onenrm, ortol, pertol, scl, sep, stpcrt, tol, xj, &
                     xjm
           ! Local Arrays 
           integer(ilp) :: iseed(4)
           ! Intrinsic Functions 
           intrinsic :: abs,cmplx,max,real,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           do i = 1, m
              ifail( i ) = 0
           end do
           if( n<0 ) then
              info = -1
           else if( m<0 .or. m>n ) then
              info = -4
           else if( ldz<max( 1, n ) ) then
              info = -9
           else
              do j = 2, m
                 if( iblock( j )<iblock( j-1 ) ) then
                    info = -6
                    go to 30
                 end if
                 if( iblock( j )==iblock( j-1 ) .and. w( j )<w( j-1 ) )then
                    info = -5
                    go to 30
                 end if
              end do
              30 continue
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSTEIN', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. m==0 ) then
              return
           else if( n==1 ) then
              z( 1, 1 ) = cone
              return
           end if
           ! get machine constants.
           eps = stdlib_slamch( 'PRECISION' )
           ! initialize seed for random number generator stdlib_slarnv.
           do i = 1, 4
              iseed( i ) = 1
           end do
           ! initialize pointers.
           indrv1 = 0
           indrv2 = indrv1 + n
           indrv3 = indrv2 + n
           indrv4 = indrv3 + n
           indrv5 = indrv4 + n
           ! compute eigenvectors of matrix blocks.
           j1 = 1
           loop_180: do nblk = 1, iblock( m )
              ! find starting and ending indices of block nblk.
              if( nblk==1 ) then
                 b1 = 1
              else
                 b1 = isplit( nblk-1 ) + 1
              end if
              bn = isplit( nblk )
              blksiz = bn - b1 + 1
              if( blksiz==1 )go to 60
              gpind = j1
              ! compute reorthogonalization criterion and stopping criterion.
              onenrm = abs( d( b1 ) ) + abs( e( b1 ) )
              onenrm = max( onenrm, abs( d( bn ) )+abs( e( bn-1 ) ) )
              do i = b1 + 1, bn - 1
                 onenrm = max( onenrm, abs( d( i ) )+abs( e( i-1 ) )+abs( e( i ) ) )
              end do
              ortol = odm3*onenrm
              stpcrt = sqrt( odm1 / blksiz )
              ! loop through eigenvalues of block nblk.
              60 continue
              jblk = 0
              loop_170: do j = j1, m
                 if( iblock( j )/=nblk ) then
                    j1 = j
                    cycle loop_180
                 end if
                 jblk = jblk + 1
                 xj = w( j )
                 ! skip all the work if the block size is one.
                 if( blksiz==1 ) then
                    work( indrv1+1 ) = one
                    go to 140
                 end if
                 ! if eigenvalues j and j-1 are too close, add a relatively
                 ! small perturbation.
                 if( jblk>1 ) then
                    eps1 = abs( eps*xj )
                    pertol = ten*eps1
                    sep = xj - xjm
                    if( sep<pertol )xj = xjm + pertol
                 end if
                 its = 0
                 nrmchk = 0
                 ! get random starting vector.
                 call stdlib_slarnv( 2, iseed, blksiz, work( indrv1+1 ) )
                 ! copy the matrix t so it won't be destroyed in factorization.
                 call stdlib_scopy( blksiz, d( b1 ), 1, work( indrv4+1 ), 1 )
                 call stdlib_scopy( blksiz-1, e( b1 ), 1, work( indrv2+2 ), 1 )
                 call stdlib_scopy( blksiz-1, e( b1 ), 1, work( indrv3+1 ), 1 )
                 ! compute lu factors with partial pivoting  ( pt = lu )
                 tol = zero
                 call stdlib_slagtf( blksiz, work( indrv4+1 ), xj, work( indrv2+2 ),work( indrv3+&
                           1 ), tol, work( indrv5+1 ), iwork,iinfo )
                 ! update iteration count.
                 70 continue
                 its = its + 1
                 if( its>maxits )go to 120
                 ! normalize and scale the righthand side vector pb.
                 jmax = stdlib_isamax( blksiz, work( indrv1+1 ), 1 )
                 scl = blksiz*onenrm*max( eps,abs( work( indrv4+blksiz ) ) ) /abs( work( indrv1+&
                           jmax ) )
                 call stdlib_sscal( blksiz, scl, work( indrv1+1 ), 1 )
                 ! solve the system lu = pb.
                 call stdlib_slagts( -1, blksiz, work( indrv4+1 ), work( indrv2+2 ),work( indrv3+&
                           1 ), work( indrv5+1 ), iwork,work( indrv1+1 ), tol, iinfo )
                 ! reorthogonalize by modified gram-schmidt if eigenvalues are
                 ! close enough.
                 if( jblk==1 )go to 110
                 if( abs( xj-xjm )>ortol )gpind = j
                 if( gpind/=j ) then
                    do i = gpind, j - 1
                       ctr = zero
                       do jr = 1, blksiz
                          ctr = ctr + work( indrv1+jr )*real( z( b1-1+jr, i ),KIND=sp)
                       end do
                       do jr = 1, blksiz
                          work( indrv1+jr ) = work( indrv1+jr ) -ctr*real( z( b1-1+jr, i ),&
                                    KIND=sp)
                       end do
                    end do
                 end if
                 ! check the infinity norm of the iterate.
                 110 continue
                 jmax = stdlib_isamax( blksiz, work( indrv1+1 ), 1 )
                 nrm = abs( work( indrv1+jmax ) )
                 ! continue for additional iterations after norm reaches
                 ! stopping criterion.
                 if( nrm<stpcrt )go to 70
                 nrmchk = nrmchk + 1
                 if( nrmchk<extra+1 )go to 70
                 go to 130
                 ! if stopping criterion was not satisfied, update info and
                 ! store eigenvector number in array ifail.
                 120 continue
                 info = info + 1
                 ifail( info ) = j
                 ! accept iterate as jth eigenvector.
                 130 continue
                 scl = one / stdlib_snrm2( blksiz, work( indrv1+1 ), 1 )
                 jmax = stdlib_isamax( blksiz, work( indrv1+1 ), 1 )
                 if( work( indrv1+jmax )<zero )scl = -scl
                 call stdlib_sscal( blksiz, scl, work( indrv1+1 ), 1 )
                 140 continue
                 do i = 1, n
                    z( i, j ) = czero
                 end do
                 do i = 1, blksiz
                    z( b1+i-1, j ) = cmplx( work( indrv1+i ), zero,KIND=sp)
                 end do
                 ! save the shift to check eigenvalue spacing at next
                 ! iteration.
                 xjm = xj
              end do loop_170
           end do loop_180
           return
     end subroutine stdlib_cstein


     pure subroutine stdlib_csteqr( compz, n, d, e, z, ldz, work, info )
     !! CSTEQR computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric tridiagonal matrix using the implicit QL or QR method.
     !! The eigenvectors of a full or band complex Hermitian matrix can also
     !! be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
     !! matrix to tridiagonal form.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 30
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, icompz, ii, iscale, j, jtot, k, l, l1, lend, lendm1, lendp1, lendsv,&
                      lm1, lsv, m, mm, mm1, nm1, nmaxit
           real(sp) :: anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2, s, safmax, safmin, ssfmax, &
                     ssfmin, tst
           ! Intrinsic Functions 
           intrinsic :: abs,max,sign,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or. ( icompz>0 .and. ldz<max( 1,n ) ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSTEQR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz==2 )z( 1, 1 ) = cone
              return
           end if
           ! determine the unit roundoff and over/underflow thresholds.
           eps = stdlib_slamch( 'E' )
           eps2 = eps**2
           safmin = stdlib_slamch( 'S' )
           safmax = one / safmin
           ssfmax = sqrt( safmax ) / three
           ssfmin = sqrt( safmin ) / eps2
           ! compute the eigenvalues and eigenvectors of the tridiagonal
           ! matrix.
           if( icompz==2 )call stdlib_claset( 'FULL', n, n, czero, cone, z, ldz )
           nmaxit = n*maxit
           jtot = 0
           ! determine where the matrix splits and choose ql or qr iteration
           ! for each block, according to whether top or bottom diagonal
           ! element is smaller.
           l1 = 1
           nm1 = n - 1
           10 continue
           if( l1>n )go to 160
           if( l1>1 )e( l1-1 ) = zero
           if( l1<=nm1 ) then
              do m = l1, nm1
                 tst = abs( e( m ) )
                 if( tst==zero )go to 30
                 if( tst<=( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+1 ) ) ) )*eps ) then
                    e( m ) = zero
                    go to 30
                 end if
              end do
           end if
           m = n
           30 continue
           l = l1
           lsv = l
           lend = m
           lendsv = lend
           l1 = m + 1
           if( lend==l )go to 10
           ! scale submatrix in rows and columns l to lend
           anorm = stdlib_slanst( 'I', lend-l+1, d( l ), e( l ) )
           iscale = 0
           if( anorm==zero )go to 10
           if( anorm>ssfmax ) then
              iscale = 1
              call stdlib_slascl( 'G', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,info )
              call stdlib_slascl( 'G', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,info )
           else if( anorm<ssfmin ) then
              iscale = 2
              call stdlib_slascl( 'G', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,info )
              call stdlib_slascl( 'G', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,info )
           end if
           ! choose between ql and qr iteration
           if( abs( d( lend ) )<abs( d( l ) ) ) then
              lend = lsv
              l = lendsv
           end if
           if( lend>l ) then
              ! ql iteration
              ! look for small subdiagonal element.
              40 continue
              if( l/=lend ) then
                 lendm1 = lend - 1
                 do m = l, lendm1
                    tst = abs( e( m ) )**2
                    if( tst<=( eps2*abs( d( m ) ) )*abs( d( m+1 ) )+safmin )go to 60
                 end do
              end if
              m = lend
              60 continue
              if( m<lend )e( m ) = zero
              p = d( l )
              if( m==l )go to 80
              ! if remaining matrix is 2-by-2, use stdlib_slae2 or stdlib_slaev2
              ! to compute its eigensystem.
              if( m==l+1 ) then
                 if( icompz>0 ) then
                    call stdlib_slaev2( d( l ), e( l ), d( l+1 ), rt1, rt2, c, s )
                    work( l ) = c
                    work( n-1+l ) = s
                    call stdlib_clasr( 'R', 'V', 'B', n, 2, work( l ),work( n-1+l ), z( 1, l ), &
                              ldz )
                 else
                    call stdlib_slae2( d( l ), e( l ), d( l+1 ), rt1, rt2 )
                 end if
                 d( l ) = rt1
                 d( l+1 ) = rt2
                 e( l ) = zero
                 l = l + 2
                 if( l<=lend )go to 40
                 go to 140
              end if
              if( jtot==nmaxit )go to 140
              jtot = jtot + 1
              ! form shift.
              g = ( d( l+1 )-p ) / ( two*e( l ) )
              r = stdlib_slapy2( g, one )
              g = d( m ) - p + ( e( l ) / ( g+sign( r, g ) ) )
              s = one
              c = one
              p = zero
              ! inner loop
              mm1 = m - 1
              do i = mm1, l, -1
                 f = s*e( i )
                 b = c*e( i )
                 call stdlib_slartg( g, f, c, s, r )
                 if( i/=m-1 )e( i+1 ) = r
                 g = d( i+1 ) - p
                 r = ( d( i )-g )*s + two*c*b
                 p = s*r
                 d( i+1 ) = g + p
                 g = c*r - b
                 ! if eigenvectors are desired, then save rotations.
                 if( icompz>0 ) then
                    work( i ) = c
                    work( n-1+i ) = -s
                 end if
              end do
              ! if eigenvectors are desired, then apply saved rotations.
              if( icompz>0 ) then
                 mm = m - l + 1
                 call stdlib_clasr( 'R', 'V', 'B', n, mm, work( l ), work( n-1+l ),z( 1, l ), ldz &
                           )
              end if
              d( l ) = d( l ) - p
              e( l ) = g
              go to 40
              ! eigenvalue found.
              80 continue
              d( l ) = p
              l = l + 1
              if( l<=lend )go to 40
              go to 140
           else
              ! qr iteration
              ! look for small superdiagonal element.
              90 continue
              if( l/=lend ) then
                 lendp1 = lend + 1
                 do m = l, lendp1, -1
                    tst = abs( e( m-1 ) )**2
                    if( tst<=( eps2*abs( d( m ) ) )*abs( d( m-1 ) )+safmin )go to 110
                 end do
              end if
              m = lend
              110 continue
              if( m>lend )e( m-1 ) = zero
              p = d( l )
              if( m==l )go to 130
              ! if remaining matrix is 2-by-2, use stdlib_slae2 or stdlib_slaev2
              ! to compute its eigensystem.
              if( m==l-1 ) then
                 if( icompz>0 ) then
                    call stdlib_slaev2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2, c, s )
                    work( m ) = c
                    work( n-1+m ) = s
                    call stdlib_clasr( 'R', 'V', 'F', n, 2, work( m ),work( n-1+m ), z( 1, l-1 ), &
                              ldz )
                 else
                    call stdlib_slae2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2 )
                 end if
                 d( l-1 ) = rt1
                 d( l ) = rt2
                 e( l-1 ) = zero
                 l = l - 2
                 if( l>=lend )go to 90
                 go to 140
              end if
              if( jtot==nmaxit )go to 140
              jtot = jtot + 1
              ! form shift.
              g = ( d( l-1 )-p ) / ( two*e( l-1 ) )
              r = stdlib_slapy2( g, one )
              g = d( m ) - p + ( e( l-1 ) / ( g+sign( r, g ) ) )
              s = one
              c = one
              p = zero
              ! inner loop
              lm1 = l - 1
              do i = m, lm1
                 f = s*e( i )
                 b = c*e( i )
                 call stdlib_slartg( g, f, c, s, r )
                 if( i/=m )e( i-1 ) = r
                 g = d( i ) - p
                 r = ( d( i+1 )-g )*s + two*c*b
                 p = s*r
                 d( i ) = g + p
                 g = c*r - b
                 ! if eigenvectors are desired, then save rotations.
                 if( icompz>0 ) then
                    work( i ) = c
                    work( n-1+i ) = s
                 end if
              end do
              ! if eigenvectors are desired, then apply saved rotations.
              if( icompz>0 ) then
                 mm = l - m + 1
                 call stdlib_clasr( 'R', 'V', 'F', n, mm, work( m ), work( n-1+m ),z( 1, m ), ldz &
                           )
              end if
              d( l ) = d( l ) - p
              e( lm1 ) = g
              go to 90
              ! eigenvalue found.
              130 continue
              d( l ) = p
              l = l - 1
              if( l>=lend )go to 90
              go to 140
           end if
           ! undo scaling if necessary
           140 continue
           if( iscale==1 ) then
              call stdlib_slascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,d( lsv ), n, info )
                        
              call stdlib_slascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv, 1, e( lsv ),n, info )
                        
           else if( iscale==2 ) then
              call stdlib_slascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,d( lsv ), n, info )
                        
              call stdlib_slascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv, 1, e( lsv ),n, info )
                        
           end if
           ! check for no convergence to an eigenvalue after a total
           ! of n*maxit iterations.
           if( jtot==nmaxit ) then
              do i = 1, n - 1
                 if( e( i )/=zero )info = info + 1
              end do
              return
           end if
           go to 10
           ! order eigenvalues and eigenvectors.
           160 continue
           if( icompz==0 ) then
              ! use quick sort
              call stdlib_slasrt( 'I', n, d, info )
           else
              ! use selection sort to minimize swaps of eigenvectors
              do ii = 2, n
                 i = ii - 1
                 k = i
                 p = d( i )
                 do j = ii, n
                    if( d( j )<p ) then
                       k = j
                       p = d( j )
                    end if
                 end do
                 if( k/=i ) then
                    d( k ) = d( i )
                    d( i ) = p
                    call stdlib_cswap( n, z( 1, i ), 1, z( 1, k ), 1 )
                 end if
              end do
           end if
           return
     end subroutine stdlib_csteqr


     pure subroutine stdlib_csyconv( uplo, way, n, a, lda, ipiv, e, info )
     !! CSYCONV convert A given by TRF into L and D and vice-versa.
     !! Get Non-diag elements of D (returned in workspace) and
     !! apply or reverse permutation done in TRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip, j
           complex(sp) :: temp
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYCONV', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
            ! a is upper
            ! convert a (a is upper)
              ! convert value
              if ( convert ) then
                 i=n
                 e(1)=czero
                 do while ( i > 1 )
                    if( ipiv(i) < 0 ) then
                       e(i)=a(i-1,i)
                       e(i-1)=czero
                       a(i-1,i)=czero
                       i=i-1
                    else
                       e(i)=czero
                    endif
                    i=i-1
                 end do
              ! convert permutations
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0) then
                    ip=ipiv(i)
                    if( i < n) then
                       do j= i+1,n
                         temp=a(ip,j)
                         a(ip,j)=a(i,j)
                         a(i,j)=temp
                       end do
                    endif
                 else
                   ip=-ipiv(i)
                    if( i < n) then
                  do j= i+1,n
                      temp=a(ip,j)
                      a(ip,j)=a(i-1,j)
                      a(i-1,j)=temp
                  end do
                     endif
                     i=i-1
                endif
                i=i-1
             end do
              else
            ! revert a (a is upper)
              ! revert permutations
                 i=1
                 do while ( i <= n )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if( i < n) then
                       do j= i+1,n
                         temp=a(ip,j)
                         a(ip,j)=a(i,j)
                         a(i,j)=temp
                       end do
                       endif
                    else
                      ip=-ipiv(i)
                      i=i+1
                      if( i < n) then
                         do j= i+1,n
                            temp=a(ip,j)
                            a(ip,j)=a(i-1,j)
                            a(i-1,j)=temp
                         end do
                      endif
                    endif
                    i=i+1
                 end do
              ! revert value
                 i=n
                 do while ( i > 1 )
                    if( ipiv(i) < 0 ) then
                       a(i-1,i)=e(i)
                       i=i-1
                    endif
                    i=i-1
                 end do
              end if
           else
            ! a is lower
              if ( convert ) then
            ! convert a (a is lower)
              ! convert value
                 i=1
                 e(n)=czero
                 do while ( i <= n )
                    if( i<n .and. ipiv(i) < 0 ) then
                       e(i)=a(i+1,i)
                       e(i+1)=czero
                       a(i+1,i)=czero
                       i=i+1
                    else
                       e(i)=czero
                    endif
                    i=i+1
                 end do
              ! convert permutations
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                    ip=ipiv(i)
                    if (i > 1) then
                    do j= 1,i-1
                      temp=a(ip,j)
                      a(ip,j)=a(i,j)
                      a(i,j)=temp
                    end do
                    endif
                 else
                   ip=-ipiv(i)
                   if (i > 1) then
                   do j= 1,i-1
                      temp=a(ip,j)
                      a(ip,j)=a(i+1,j)
                      a(i+1,j)=temp
                   end do
                   endif
                   i=i+1
                endif
                i=i+1
             end do
              else
            ! revert a (a is lower)
              ! revert permutations
                 i=n
                 do while ( i >= 1 )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(i,j)
                             a(i,j)=a(ip,j)
                             a(ip,j)=temp
                          end do
                       endif
                    else
                       ip=-ipiv(i)
                       i=i-1
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(i+1,j)
                             a(i+1,j)=a(ip,j)
                             a(ip,j)=temp
                          end do
                       endif
                    endif
                    i=i-1
                 end do
              ! revert value
                 i=1
                 do while ( i <= n-1 )
                    if( ipiv(i) < 0 ) then
                       a(i+1,i)=e(i)
                       i=i+1
                    endif
                    i=i+1
                 end do
              end if
           end if
           return
     end subroutine stdlib_csyconv


     pure subroutine stdlib_csyconvf( uplo, way, n, a, lda, e, ipiv, info )
     !! If parameter WAY = 'C':
     !! CSYCONVF converts the factorization output format used in
     !! CSYTRF provided on entry in parameter A into the factorization
     !! output format used in CSYTRF_RK (or CSYTRF_BK) that is stored
     !! on exit in parameters A and E. It also converts in place details of
     !! the intechanges stored in IPIV from the format used in CSYTRF into
     !! the format used in CSYTRF_RK (or CSYTRF_BK).
     !! If parameter WAY = 'R':
     !! CSYCONVF performs the conversion in reverse direction, i.e.
     !! converts the factorization output format used in CSYTRF_RK
     !! (or CSYTRF_BK) provided on entry in parameters A and E into
     !! the factorization output format used in CSYTRF that is stored
     !! on exit in parameter A. It also converts in place details of
     !! the intechanges stored in IPIV from the format used in CSYTRF_RK
     !! (or CSYTRF_BK) into the format used in CSYTRF.
     !! CSYCONVF can also convert in Hermitian matrix case, i.e. between
     !! formats used in CHETRF and CHETRF_RK (or CHETRF_BK).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYCONVF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! begin a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 ! assign superdiagonal entries of d to array e and czero out
                 ! corresponding entries in input storage a
                 i = n
                 e( 1 ) = czero
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       e( i ) = a( i-1, i )
                       e( i-1 ) = czero
                       a( i-1, i ) = czero
                       i = i - 1
                    else
                       e( i ) = czero
                    end if
                    i = i - 1
                 end do
                 ! convert permutations and ipiv
                 ! apply permutations to submatrices of upper part of a
                 ! in factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_cswap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i) in a(1:i,n-i:n)
                       ip = -ipiv( i )
                       if( i<n ) then
                          if( ip/=(i-1) ) then
                             call stdlib_cswap( n-i, a( i-1, i+1 ), lda,a( ip, i+1 ), lda )
                                       
                          end if
                       end if
                       ! convert ipiv
                       ! there is no interchnge of rows i and and ipiv(i),
                       ! so this should be reflected in ipiv format for
                       ! *sytrf_rk ( or *sytrf_bk)
                       ipiv( i ) = i
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations and ipiv
                 ! apply permutations to submatrices of upper part of a
                 ! in reverse factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_cswap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i) in a(1:i,n-i:n)
                       i = i + 1
                       ip = -ipiv( i )
                       if( i<n ) then
                          if( ip/=(i-1) ) then
                             call stdlib_cswap( n-i, a( ip, i+1 ), lda,a( i-1, i+1 ), lda )
                                       
                          end if
                       end if
                       ! convert ipiv
                       ! there is cone interchange of rows i-1 and ipiv(i-1),
                       ! so this should be recorded in two consecutive entries
                       ! in ipiv format for *sytrf
                       ipiv( i ) = ipiv( i-1 )
                    end if
                    i = i + 1
                 end do
                 ! revert value
                 ! assign superdiagonal entries of d from array e to
                 ! superdiagonal entries of a.
                 i = n
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       a( i-1, i ) = e( i )
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              ! end a is upper
              end if
           else
              ! begin a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 ! assign subdiagonal entries of d to array e and czero out
                 ! corresponding entries in input storage a
                 i = 1
                 e( n ) = czero
                 do while ( i<=n )
                    if( i<n .and. ipiv(i)<0 ) then
                       e( i ) = a( i+1, i )
                       e( i+1 ) = czero
                       a( i+1, i ) = czero
                       i = i + 1
                    else
                       e( i ) = czero
                    end if
                    i = i + 1
                 end do
                 ! convert permutations and ipiv
                 ! apply permutations to submatrices of lower part of a
                 ! in factorization order where k increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_cswap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i) in a(i:n,1:i-1)
                       ip = -ipiv( i )
                       if ( i>1 ) then
                          if( ip/=(i+1) ) then
                             call stdlib_cswap( i-1, a( i+1, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                       ! convert ipiv
                       ! there is no interchnge of rows i and and ipiv(i),
                       ! so this should be reflected in ipiv format for
                       ! *sytrf_rk ( or *sytrf_bk)
                       ipiv( i ) = i
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations and ipiv
                 ! apply permutations to submatrices of lower part of a
                 ! in reverse factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_cswap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i) in a(i:n,1:i-1)
                       i = i - 1
                       ip = -ipiv( i )
                       if ( i>1 ) then
                          if( ip/=(i+1) ) then
                             call stdlib_cswap( i-1, a( ip, 1 ), lda,a( i+1, 1 ), lda )
                          end if
                       end if
                       ! convert ipiv
                       ! there is cone interchange of rows i+1 and ipiv(i+1),
                       ! so this should be recorded in consecutive entries
                       ! in ipiv format for *sytrf
                       ipiv( i ) = ipiv( i+1 )
                    end if
                    i = i - 1
                 end do
                 ! revert value
                 ! assign subdiagonal entries of d from array e to
                 ! subgiagonal entries of a.
                 i = 1
                 do while ( i<=n-1 )
                    if( ipiv( i )<0 ) then
                       a( i + 1, i ) = e( i )
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              end if
              ! end a is lower
           end if
           return
     end subroutine stdlib_csyconvf


     pure subroutine stdlib_csyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
     !! If parameter WAY = 'C':
     !! CSYCONVF_ROOK converts the factorization output format used in
     !! CSYTRF_ROOK provided on entry in parameter A into the factorization
     !! output format used in CSYTRF_RK (or CSYTRF_BK) that is stored
     !! on exit in parameters A and E. IPIV format for CSYTRF_ROOK and
     !! CSYTRF_RK (or CSYTRF_BK) is the same and is not converted.
     !! If parameter WAY = 'R':
     !! CSYCONVF_ROOK performs the conversion in reverse direction, i.e.
     !! converts the factorization output format used in CSYTRF_RK
     !! (or CSYTRF_BK) provided on entry in parameters A and E into
     !! the factorization output format used in CSYTRF_ROOK that is stored
     !! on exit in parameter A. IPIV format for CSYTRF_ROOK and
     !! CSYTRF_RK (or CSYTRF_BK) is the same and is not converted.
     !! CSYCONVF_ROOK can also convert in Hermitian matrix case, i.e. between
     !! formats used in CHETRF_ROOK and CHETRF_RK (or CHETRF_BK).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip, ip2
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYCONVF_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! begin a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 ! assign superdiagonal entries of d to array e and czero out
                 ! corresponding entries in input storage a
                 i = n
                 e( 1 ) = czero
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       e( i ) = a( i-1, i )
                       e( i-1 ) = czero
                       a( i-1, i ) = czero
                       i = i - 1
                    else
                       e( i ) = czero
                    end if
                    i = i - 1
                 end do
                 ! convert permutations
                 ! apply permutations to submatrices of upper part of a
                 ! in factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_cswap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i and ipiv(i) and i-1 and ipiv(i-1)
                       ! in a(1:i,n-i:n)
                       ip = -ipiv( i )
                       ip2 = -ipiv( i-1 )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_cswap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                          if( ip2/=(i-1) ) then
                             call stdlib_cswap( n-i, a( i-1, i+1 ), lda,a( ip2, i+1 ), lda )
                                       
                          end if
                       end if
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations
                 ! apply permutations to submatrices of upper part of a
                 ! in reverse factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_cswap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i-1) and i and ipiv(i)
                       ! in a(1:i,n-i:n)
                       i = i + 1
                       ip = -ipiv( i )
                       ip2 = -ipiv( i-1 )
                       if( i<n ) then
                          if( ip2/=(i-1) ) then
                             call stdlib_cswap( n-i, a( ip2, i+1 ), lda,a( i-1, i+1 ), lda )
                                       
                          end if
                          if( ip/=i ) then
                             call stdlib_cswap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    end if
                    i = i + 1
                 end do
                 ! revert value
                 ! assign superdiagonal entries of d from array e to
                 ! superdiagonal entries of a.
                 i = n
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       a( i-1, i ) = e( i )
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              ! end a is upper
              end if
           else
              ! begin a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 ! assign subdiagonal entries of d to array e and czero out
                 ! corresponding entries in input storage a
                 i = 1
                 e( n ) = czero
                 do while ( i<=n )
                    if( i<n .and. ipiv(i)<0 ) then
                       e( i ) = a( i+1, i )
                       e( i+1 ) = czero
                       a( i+1, i ) = czero
                       i = i + 1
                    else
                       e( i ) = czero
                    end if
                    i = i + 1
                 end do
                 ! convert permutations
                 ! apply permutations to submatrices of lower part of a
                 ! in factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_cswap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i and ipiv(i) and i+1 and ipiv(i+1)
                       ! in a(i:n,1:i-1)
                       ip = -ipiv( i )
                       ip2 = -ipiv( i+1 )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_cswap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                          if( ip2/=(i+1) ) then
                             call stdlib_cswap( i-1, a( i+1, 1 ), lda,a( ip2, 1 ), lda )
                          end if
                       end if
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations
                 ! apply permutations to submatrices of lower part of a
                 ! in reverse factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_cswap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i+1) and i and ipiv(i)
                       ! in a(i:n,1:i-1)
                       i = i - 1
                       ip = -ipiv( i )
                       ip2 = -ipiv( i+1 )
                       if ( i>1 ) then
                          if( ip2/=(i+1) ) then
                             call stdlib_cswap( i-1, a( ip2, 1 ), lda,a( i+1, 1 ), lda )
                          end if
                          if( ip/=i ) then
                             call stdlib_cswap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    end if
                    i = i - 1
                 end do
                 ! revert value
                 ! assign subdiagonal entries of d from array e to
                 ! subgiagonal entries of a.
                 i = 1
                 do while ( i<=n-1 )
                    if( ipiv( i )<0 ) then
                       a( i + 1, i ) = e( i )
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              end if
              ! end a is lower
           end if
           return
     end subroutine stdlib_csyconvf_rook


     pure subroutine stdlib_csyequb( uplo, n, a, lda, s, scond, amax, work, info )
     !! CSYEQUB computes row and column scalings intended to equilibrate a
     !! symmetric matrix A (with respect to the Euclidean norm) and reduce
     !! its condition number. The scale factors S are computed by the BIN
     !! algorithm (see references) so that the scaled matrix B with elements
     !! B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
     !! the smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(out) :: amax, scond
           character, intent(in) :: uplo
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(out) :: s(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: max_iter = 100
           
           
           ! Local Scalars 
           integer(ilp) :: i, j, iter
           real(sp) :: avg, std, tol, c0, c1, c2, t, u, si, d, base, smin, smax, smlnum, bignum, &
                     scale, sumsq
           logical(lk) :: up
           complex(sp) :: zdum
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,int,log,max,min,real,sqrt
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if ( .not. ( stdlib_lsame( uplo, 'U' ) .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -1
           else if ( n < 0 ) then
              info = -2
           else if ( lda < max( 1, n ) ) then
              info = -4
           end if
           if ( info /= 0 ) then
              call stdlib_xerbla( 'CSYEQUB', -info )
              return
           end if
           up = stdlib_lsame( uplo, 'U' )
           amax = zero
           ! quick return if possible.
           if ( n == 0 ) then
              scond = one
              return
           end if
           do i = 1, n
              s( i ) = zero
           end do
           amax = zero
           if ( up ) then
              do j = 1, n
                 do i = 1, j-1
                    s( i ) = max( s( i ), cabs1( a( i, j ) ) )
                    s( j ) = max( s( j ), cabs1( a( i, j ) ) )
                    amax = max( amax, cabs1( a( i, j ) ) )
                 end do
                 s( j ) = max( s( j ), cabs1( a( j, j ) ) )
                 amax = max( amax, cabs1( a( j, j ) ) )
              end do
           else
              do j = 1, n
                 s( j ) = max( s( j ), cabs1( a( j, j ) ) )
                 amax = max( amax, cabs1( a( j, j ) ) )
                 do i = j+1, n
                    s( i ) = max( s( i ), cabs1( a( i, j ) ) )
                    s( j ) = max( s( j ), cabs1( a( i, j ) ) )
                    amax = max( amax, cabs1( a( i, j ) ) )
                 end do
              end do
           end if
           do j = 1, n
              s( j ) = 1.0_sp / s( j )
           end do
           tol = one / sqrt( 2.0_sp * n )
           do iter = 1, max_iter
              scale = zero
              sumsq = zero
              ! beta = |a|s
              do i = 1, n
                  work( i ) = zero
              end do
              if ( up ) then
                 do j = 1, n
                    do i = 1, j-1
                       work( i ) = work( i ) + cabs1( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + cabs1( a( i, j ) ) * s( i )
                    end do
                    work( j ) = work( j ) + cabs1( a( j, j ) ) * s( j )
                 end do
              else
                 do j = 1, n
                    work( j ) = work( j ) + cabs1( a( j, j ) ) * s( j )
                    do i = j+1, n
                       work( i ) = work( i ) + cabs1( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + cabs1( a( i, j ) ) * s( i )
                    end do
                 end do
              end if
              ! avg = s^t beta / n
              avg = zero
              do i = 1, n
                 avg = avg + real( s( i )*work( i ),KIND=sp)
              end do
              avg = avg / n
              std = zero
              do i = n+1, 2*n
                 work( i ) = s( i-n ) * work( i-n ) - avg
              end do
              call stdlib_classq( n, work( n+1 ), 1, scale, sumsq )
              std = scale * sqrt( sumsq / n )
              if ( std < tol * avg ) goto 999
              do i = 1, n
                 t = cabs1( a( i, i ) )
                 si = s( i )
                 c2 = ( n-1 ) * t
                 c1 = real( n-2,KIND=sp) * ( real( work( i ),KIND=sp) - t*si )
                 c0 = -(t*si)*si + 2 * real( work( i ),KIND=sp) * si - n*avg
                 d = c1*c1 - 4*c0*c2
                 if ( d <= 0 ) then
                    info = -1
                    return
                 end if
                 si = -2*c0 / ( c1 + sqrt( d ) )
                 d = si - s( i )
                 u = zero
                 if ( up ) then
                    do j = 1, i
                       t = cabs1( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = cabs1( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 else
                    do j = 1, i
                       t = cabs1( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = cabs1( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 end if
                 avg = avg + ( u + real( work( i ),KIND=sp) ) * d / n
                 s( i ) = si
              end do
           end do
           999 continue
           smlnum = stdlib_slamch( 'SAFEMIN' )
           bignum = one / smlnum
           smin = bignum
           smax = zero
           t = one / sqrt( avg )
           base = stdlib_slamch( 'B' )
           u = one / log( base )
           do i = 1, n
              s( i ) = base ** int( u * log( s( i ) * t ),KIND=ilp)
              smin = min( smin, s( i ) )
              smax = max( smax, s( i ) )
           end do
           scond = max( smin, smlnum ) / min( smax, bignum )
     end subroutine stdlib_csyequb


     pure subroutine stdlib_csymv( uplo, n, alpha, a, lda, x, incx, beta, y, incy )
     !! CSYMV performs the matrix-vector  operation
     !! y := alpha*A*x + beta*y,
     !! where alpha and beta are scalars, x and y are n element vectors and
     !! A is an n by n symmetric matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: incx, incy, lda, n
           complex(sp), intent(in) :: alpha, beta
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), x(*)
           complex(sp), intent(inout) :: y(*)
       ! =====================================================================
           
           
           ! Local Scalars 
           integer(ilp) :: i, info, ix, iy, j, jx, jy, kx, ky
           complex(sp) :: temp1, temp2
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = 1
           else if( n<0 ) then
              info = 2
           else if( lda<max( 1, n ) ) then
              info = 5
           else if( incx==0 ) then
              info = 7
           else if( incy==0 ) then
              info = 10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYMV ', info )
              return
           end if
           ! quick return if possible.
           if( ( n==0 ) .or. ( ( alpha==czero ) .and. ( beta==cone ) ) )return
           ! set up the start points in  x  and  y.
           if( incx>0 ) then
              kx = 1
           else
              kx = 1 - ( n-1 )*incx
           end if
           if( incy>0 ) then
              ky = 1
           else
              ky = 1 - ( n-1 )*incy
           end if
           ! start the operations. in this version the elements of a are
           ! accessed sequentially with cone pass through the triangular part
           ! of a.
           ! first form  y := beta*y.
           if( beta/=cone ) then
              if( incy==1 ) then
                 if( beta==czero ) then
                    do i = 1, n
                       y( i ) = czero
                    end do
                 else
                    do i = 1, n
                       y( i ) = beta*y( i )
                    end do
                 end if
              else
                 iy = ky
                 if( beta==czero ) then
                    do i = 1, n
                       y( iy ) = czero
                       iy = iy + incy
                    end do
                 else
                    do i = 1, n
                       y( iy ) = beta*y( iy )
                       iy = iy + incy
                    end do
                 end if
              end if
           end if
           if( alpha==czero )return
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! form  y  when a is stored in upper triangle.
              if( ( incx==1 ) .and. ( incy==1 ) ) then
                 do j = 1, n
                    temp1 = alpha*x( j )
                    temp2 = czero
                    do i = 1, j - 1
                       y( i ) = y( i ) + temp1*a( i, j )
                       temp2 = temp2 + a( i, j )*x( i )
                    end do
                    y( j ) = y( j ) + temp1*a( j, j ) + alpha*temp2
                 end do
              else
                 jx = kx
                 jy = ky
                 do j = 1, n
                    temp1 = alpha*x( jx )
                    temp2 = czero
                    ix = kx
                    iy = ky
                    do i = 1, j - 1
                       y( iy ) = y( iy ) + temp1*a( i, j )
                       temp2 = temp2 + a( i, j )*x( ix )
                       ix = ix + incx
                       iy = iy + incy
                    end do
                    y( jy ) = y( jy ) + temp1*a( j, j ) + alpha*temp2
                    jx = jx + incx
                    jy = jy + incy
                 end do
              end if
           else
              ! form  y  when a is stored in lower triangle.
              if( ( incx==1 ) .and. ( incy==1 ) ) then
                 do j = 1, n
                    temp1 = alpha*x( j )
                    temp2 = czero
                    y( j ) = y( j ) + temp1*a( j, j )
                    do i = j + 1, n
                       y( i ) = y( i ) + temp1*a( i, j )
                       temp2 = temp2 + a( i, j )*x( i )
                    end do
                    y( j ) = y( j ) + alpha*temp2
                 end do
              else
                 jx = kx
                 jy = ky
                 do j = 1, n
                    temp1 = alpha*x( jx )
                    temp2 = czero
                    y( jy ) = y( jy ) + temp1*a( j, j )
                    ix = jx
                    iy = jy
                    do i = j + 1, n
                       ix = ix + incx
                       iy = iy + incy
                       y( iy ) = y( iy ) + temp1*a( i, j )
                       temp2 = temp2 + a( i, j )*x( ix )
                    end do
                    y( jy ) = y( jy ) + alpha*temp2
                    jx = jx + incx
                    jy = jy + incy
                 end do
              end if
           end if
           return
     end subroutine stdlib_csymv


     pure subroutine stdlib_csyr( uplo, n, alpha, x, incx, a, lda )
     !! CSYR performs the symmetric rank 1 operation
     !! A := alpha*x*x**H + A,
     !! where alpha is a complex scalar, x is an n element vector and A is an
     !! n by n symmetric matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: incx, lda, n
           complex(sp), intent(in) :: alpha
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: x(*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, info, ix, j, jx, kx
           complex(sp) :: temp
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = 1
           else if( n<0 ) then
              info = 2
           else if( incx==0 ) then
              info = 5
           else if( lda<max( 1, n ) ) then
              info = 7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYR  ', info )
              return
           end if
           ! quick return if possible.
           if( ( n==0 ) .or. ( alpha==czero ) )return
           ! set the start point in x if the increment is not unity.
           if( incx<=0 ) then
              kx = 1 - ( n-1 )*incx
           else if( incx/=1 ) then
              kx = 1
           end if
           ! start the operations. in this version the elements of a are
           ! accessed sequentially with cone pass through the triangular part
           ! of a.
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! form  a  when a is stored in upper triangle.
              if( incx==1 ) then
                 do j = 1, n
                    if( x( j )/=czero ) then
                       temp = alpha*x( j )
                       do i = 1, j
                          a( i, j ) = a( i, j ) + x( i )*temp
                       end do
                    end if
                 end do
              else
                 jx = kx
                 do j = 1, n
                    if( x( jx )/=czero ) then
                       temp = alpha*x( jx )
                       ix = kx
                       do i = 1, j
                          a( i, j ) = a( i, j ) + x( ix )*temp
                          ix = ix + incx
                       end do
                    end if
                    jx = jx + incx
                 end do
              end if
           else
              ! form  a  when a is stored in lower triangle.
              if( incx==1 ) then
                 do j = 1, n
                    if( x( j )/=czero ) then
                       temp = alpha*x( j )
                       do i = j, n
                          a( i, j ) = a( i, j ) + x( i )*temp
                       end do
                    end if
                 end do
              else
                 jx = kx
                 do j = 1, n
                    if( x( jx )/=czero ) then
                       temp = alpha*x( jx )
                       ix = jx
                       do i = j, n
                          a( i, j ) = a( i, j ) + x( ix )*temp
                          ix = ix + incx
                       end do
                    end if
                    jx = jx + incx
                 end do
              end if
           end if
           return
     end subroutine stdlib_csyr


     pure subroutine stdlib_csyswapr( uplo, n, a, lda, i1, i2)
     !! CSYSWAPR applies an elementary permutation on the rows and the columns of
     !! a symmetric matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: i1, i2, lda, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,n)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           complex(sp) :: tmp
           ! Executable Statements 
           upper = stdlib_lsame( uplo, 'U' )
           if (upper) then
               ! upper
               ! first swap
                ! - swap column i1 and i2 from i1 to i1-1
              call stdlib_cswap( i1-1, a(1,i1), 1, a(1,i2), 1 )
                ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap row i1 from i1+1 to i2-1 with col i2 from i1+1 to i2-1
              tmp=a(i1,i1)
              a(i1,i1)=a(i2,i2)
              a(i2,i2)=tmp
              do i=1,i2-i1-1
                 tmp=a(i1,i1+i)
                 a(i1,i1+i)=a(i1+i,i2)
                 a(i1+i,i2)=tmp
              end do
                ! third swap
                ! - swap row i1 and i2 from i2+1 to n
              do i=i2+1,n
                 tmp=a(i1,i)
                 a(i1,i)=a(i2,i)
                 a(i2,i)=tmp
              end do
             else
               ! lower
               ! first swap
                ! - swap row i1 and i2 from i1 to i1-1
              call stdlib_cswap ( i1-1, a(i1,1), lda, a(i2,1), lda )
               ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap col i1 from i1+1 to i2-1 with row i2 from i1+1 to i2-1
               tmp=a(i1,i1)
               a(i1,i1)=a(i2,i2)
               a(i2,i2)=tmp
               do i=1,i2-i1-1
                  tmp=a(i1+i,i1)
                  a(i1+i,i1)=a(i2,i1+i)
                  a(i2,i1+i)=tmp
               end do
               ! third swap
                ! - swap col i1 and i2 from i2+1 to n
               do i=i2+1,n
                  tmp=a(i,i1)
                  a(i,i1)=a(i,i2)
                  a(i,i2)=tmp
               end do
           endif
     end subroutine stdlib_csyswapr


     pure subroutine stdlib_csytf2( uplo, n, a, lda, ipiv, info )
     !! CSYTF2 computes the factorization of a complex symmetric matrix A
     !! using the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**T is the transpose of U, and D is symmetric and
     !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kk, kp, kstep
           real(sp) :: absakk, alpha, colmax, rowmax
           complex(sp) :: d11, d12, d21, d22, r1, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real,sqrt
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTF2', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero .or. stdlib_sisnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_icamax( k-imax, a( imax, imax+1 ), lda )
                    rowmax = cabs1( a( imax, jmax ) )
                    if( imax>1 ) then
                       jmax = stdlib_icamax( imax-1, a( 1, imax ), 1 )
                       rowmax = max( rowmax, cabs1( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( a( imax, imax ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_cswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    call stdlib_cswap( kk-kp-1, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**t = a - w(k)*1/d(k)*w(k)**t
                    r1 = cone / a( k, k )
                    call stdlib_csyr( uplo, k-1, -r1, a( 1, k ), 1, a, lda )
                    ! store u(k) in column k
                    call stdlib_cscal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**t
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = cone / ( d11*d22-cone )
                       d12 = t / d12
                       do j = k - 2, 1, -1
                          wkm1 = d12*( d11*a( j, k-1 )-a( j, k ) )
                          wk = d12*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - a( i, k )*wk -a( i, k-1 )*wkm1
                          end do
                          a( j, k ) = wk
                          a( j, k-1 ) = wkm1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero .or. stdlib_sisnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_icamax( imax-k, a( imax, k ), lda )
                    rowmax = cabs1( a( imax, jmax ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_icamax( n-imax, a( imax+1, imax ), 1 )
                       rowmax = max( rowmax, cabs1( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( a( imax, imax ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    call stdlib_cswap( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**t = a - w(k)*(1/d(k))*w(k)**t
                       r1 = cone / a( k, k )
                       call stdlib_csyr( uplo, n-k, -r1, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                 
                       ! store l(k) in column k
                       call stdlib_cscal( n-k, r1, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k)
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**t
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**t
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       d21 = t / d21
                       do j = k + 2, n
                          wk = d21*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = d21*( d22*a( j, k+1 )-a( j, k ) )
                          do i = j, n
                             a( i, j ) = a( i, j ) - a( i, k )*wk -a( i, k+1 )*wkp1
                          end do
                          a( j, k ) = wk
                          a( j, k+1 ) = wkp1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_csytf2


     pure subroutine stdlib_csytf2_rk( uplo, n, a, lda, e, ipiv, info )
     !! CSYTF2_RK computes the factorization of a complex symmetric matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: e(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: upper, done
           integer(ilp) :: i, imax, j, jmax, itemp, k, kk, kp, kstep, p, ii
           real(sp) :: absakk, alpha, colmax, rowmax, stemp, sfmin
           complex(sp) :: d11, d12, d21, d22, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt,aimag,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTF2_RK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = czero
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 34
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = czero
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange,
                    ! use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_icamax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_icamax( imax-1, a( 1, imax ), 1 )
                          stemp = cabs1( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( cabs1( a( imax, imax ) )<alpha*rowmax ))then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the leading
                    ! submatrix a(1:k,1:k) if we have a 2-by-2 pivot
                    if( p>1 )call stdlib_cswap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    if( p<(k-1) )call stdlib_cswap( k-p-1, a( p+1, k ), 1, a( p, p+1 ),lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_cswap( n-k, a( k, k+1 ), lda, a( p, k+1 ), lda )
                 end if
                 ! second swap
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    if( ( kk>1 ) .and. ( kp<(kk-1) ) )call stdlib_cswap( kk-kp-1, a( kp+1, kk ), &
                              1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_cswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = cone / a( k, k )
                          call stdlib_csyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_cscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_csyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = cone / ( d11*d22-cone )
                       do j = k - 2, 1, -1
                          wkm1 = t*( d11*a( j, k-1 )-a( j, k ) )
                          wk = t*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - (a( i, k ) / d12 )*wk -( a( i, k-1 ) / d12 )&
                                       *wkm1
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d12
                          a( j, k-1 ) = wkm1 / d12
                       end do
                    end if
                    ! copy superdiagonal elements of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    e( k ) = a( k-1, k )
                    e( k-1 ) = czero
                    a( k-1, k ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              34 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = czero
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 64
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ! set e( k ) to zero
                 if( k<n )e( k ) = czero
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_icamax( imax-k, a( imax, k ), lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_icamax( n-imax, a( imax+1, imax ),1 )
                          stemp = cabs1( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( cabs1( a( imax, imax ) )<alpha*rowmax ))then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 42
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the trailing
                    ! submatrix a(k:n,k:n) if we have a 2-by-2 pivot
                    if( p<n )call stdlib_cswap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    if( p>(k+1) )call stdlib_cswap( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_cswap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                 end if
                 ! second swap
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    if( ( kk<n ) .and. ( kp>(kk+1) ) )call stdlib_cswap( kp-kk-1, a( kk+1, kk ), &
                              1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_cswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                    ! perform a rank-1 update of a(k+1:n,k+1:n) and
                    ! store l(k) in column k
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = cone / a( k, k )
                          call stdlib_csyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_cscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_csyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = t*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = t*( d22*a( j, k+1 )-a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) - ( a( i, k ) / d21 )*wk -( a( i, k+1 ) / d21 )&
                                       *wkp1
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d21
                          a( j, k+1 ) = wkp1 / d21
                       end do
                    end if
                    ! copy subdiagonal elements of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    e( k ) = a( k+1, k )
                    e( k+1 ) = czero
                    a( k+1, k ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
              64 continue
           end if
           return
     end subroutine stdlib_csytf2_rk


     pure subroutine stdlib_csytf2_rook( uplo, n, a, lda, ipiv, info )
     !! CSYTF2_ROOK computes the factorization of a complex symmetric matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**T is the transpose of U, and D is symmetric and
     !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: upper, done
           integer(ilp) :: i, imax, j, jmax, itemp, k, kk, kp, kstep, p, ii
           real(sp) :: absakk, alpha, colmax, rowmax, stemp, sfmin
           complex(sp) :: d11, d12, d21, d22, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           intrinsic :: abs,max,sqrt,aimag,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTF2_ROOK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange,
                    ! use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_icamax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_icamax( imax-1, a( 1, imax ), 1 )
                          stemp = cabs1( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! cabs1( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( cabs1(a( imax, imax ))<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the leading
                    ! submatrix a(1:k,1:k) if we have a 2-by-2 pivot
                    if( p>1 )call stdlib_cswap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    if( p<(k-1) )call stdlib_cswap( k-p-1, a( p+1, k ), 1, a( p, p+1 ),lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                 end if
                 ! second swap
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    if( ( kk>1 ) .and. ( kp<(kk-1) ) )call stdlib_cswap( kk-kp-1, a( kp+1, kk ), &
                              1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = cone / a( k, k )
                          call stdlib_csyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_cscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_csyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = cone / ( d11*d22-cone )
                       do j = k - 2, 1, -1
                          wkm1 = t*( d11*a( j, k-1 )-a( j, k ) )
                          wk = t*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - (a( i, k ) / d12 )*wk -( a( i, k-1 ) / d12 )&
                                       *wkm1
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d12
                          a( j, k-1 ) = wkm1 / d12
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_icamax( imax-k, a( imax, k ), lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_icamax( n-imax, a( imax+1, imax ),1 )
                          stemp = cabs1( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! cabs1( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( cabs1(a( imax, imax ))<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 42
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the trailing
                    ! submatrix a(k:n,k:n) if we have a 2-by-2 pivot
                    if( p<n )call stdlib_cswap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    if( p>(k+1) )call stdlib_cswap( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                 end if
                 ! second swap
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    if( ( kk<n ) .and. ( kp>(kk+1) ) )call stdlib_cswap( kp-kk-1, a( kk+1, kk ), &
                              1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                    ! perform a rank-1 update of a(k+1:n,k+1:n) and
                    ! store l(k) in column k
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = cone / a( k, k )
                          call stdlib_csyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_cscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_csyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = t*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = t*( d22*a( j, k+1 )-a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) - ( a( i, k ) / d21 )*wk -( a( i, k+1 ) / d21 )&
                                       *wkp1
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d21
                          a( j, k+1 ) = wkp1 / d21
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_csytf2_rook


     pure subroutine stdlib_csytrf( uplo, n, a, lda, ipiv, work, lwork, info )
     !! CSYTRF computes the factorization of a complex symmetric matrix A
     !! using the Bunch-Kaufman diagonal pivoting method.  The form of the
     !! factorization is
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'CSYTRF', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRF', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CSYTRF', uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clasyf;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_clasyf( uplo, k, nb, kb, a, lda, ipiv, work, n, iinfo )
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_csytf2( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clasyf;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_clasyf( uplo, n-k+1, nb, kb, a( k, k ), lda, ipiv( k ),work, n, &
                           iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_csytf2( uplo, n-k+1, a( k, k ), lda, ipiv( k ), iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csytrf


     pure subroutine stdlib_csytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
     !! CSYTRF_RK computes the factorization of a complex symmetric matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, ip, iws, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'CSYTRF_RK', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRF_RK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CSYTRF_RK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clasyf_rk;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 15
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_clasyf_rk( uplo, k, nb, kb, a, lda, e,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_csytf2_rk( uplo, k, a, lda, e, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k-kb+1:k and apply row permutations to the
              ! last k+1 colunms k+1:n after that block
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k<n ) then
                 do i = k, ( k - kb + 1 ), -1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_cswap( n-k, a( i, k+1 ), lda,a( ip, k+1 ), lda )
                    end if
                 end do
              end if
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
              ! this label is the exit from main loop over k decreasing
              ! from n to 1 in steps of kb
              15 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clasyf_rk;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 35
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_clasyf_rk( uplo, n-k+1, nb, kb, a( k, k ), lda, e( k ),ipiv( k ), &
                           work, ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_csytf2_rk( uplo, n-k+1, a( k, k ), lda, e( k ),ipiv( k ), iinfo )
                           
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do i = k, k + kb - 1
                 if( ipiv( i )>0 ) then
                    ipiv( i ) = ipiv( i ) + k - 1
                 else
                    ipiv( i ) = ipiv( i ) - k + 1
                 end if
              end do
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k:k+kb-1 and apply row permutations to the
              ! first k-1 colunms 1:k-1 before that block
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k>1 ) then
                 do i = k, ( k + kb - 1 ), 1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_cswap( k-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                    end if
                 end do
              end if
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
              ! this label is the exit from main loop over k increasing
              ! from 1 to n in steps of kb
              35 continue
           ! end lower
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csytrf_rk


     pure subroutine stdlib_csytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
     !! CSYTRF_ROOK computes the factorization of a complex symmetric matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
     !! The form of the factorization is
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'CSYTRF_ROOK', uplo, n, -1, -1, -1 )
              lwkopt = max( 1, n*nb )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRF_ROOK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CSYTRF_ROOK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clasyf_rook;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_clasyf_rook( uplo, k, nb, kb, a, lda,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_csytf2_rook( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clasyf_rook;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_clasyf_rook( uplo, n-k+1, nb, kb, a( k, k ), lda,ipiv( k ), work, &
                           ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_csytf2_rook( uplo, n-k+1, a( k, k ), lda, ipiv( k ),iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csytrf_rook


     pure subroutine stdlib_csytri( uplo, n, a, lda, ipiv, work, info )
     !! CSYTRI computes the inverse of a complex symmetric indefinite matrix
     !! A using the factorization A = U*D*U**T or A = L*D*L**T computed by
     !! CSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kp, kstep
           complex(sp) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 40
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = cone / a( k, k )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_csymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_cdotu( k-1, work, 1, a( 1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = a( k, k+1 )
                 ak = a( k, k ) / t
                 akp1 = a( k+1, k+1 ) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-cone )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_csymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_cdotu( k-1, work, 1, a( 1, k ),1 )
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_cdotu( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_ccopy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_csymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -stdlib_cdotu( k-1, work, 1, a( 1, k+1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 call stdlib_cswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                 call stdlib_cswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
              end if
              k = k + kstep
              go to 30
              40 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              50 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 60
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = cone / a( k, k )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_csymv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_cdotu( n-k, work, 1, a( k+1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = a( k, k-1 )
                 ak = a( k-1, k-1 ) / t
                 akp1 = a( k, k ) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-cone )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_csymv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_cdotu( n-k, work, 1, a( k+1, k ),1 )
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_cdotu( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 &
                              )
                    call stdlib_ccopy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_csymv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+&
                              1, k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -stdlib_cdotu( n-k, work, 1, a( k+1, k-1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 if( kp<n )call stdlib_cswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                 call stdlib_cswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
              end if
              k = k - kstep
              go to 50
              60 continue
           end if
           return
     end subroutine stdlib_csytri


     pure subroutine stdlib_csytri_rook( uplo, n, a, lda, ipiv, work, info )
     !! CSYTRI_ROOK computes the inverse of a complex symmetric
     !! matrix A using the factorization A = U*D*U**T or A = L*D*L**T
     !! computed by CSYTRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kp, kstep
           complex(sp) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRI_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 40
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = cone / a( k, k )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_csymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_cdotu( k-1, work, 1, a( 1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = a( k, k+1 )
                 ak = a( k, k ) / t
                 akp1 = a( k+1, k+1 ) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-cone )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_csymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_cdotu( k-1, work, 1, a( 1, k ),1 )
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_cdotu( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_ccopy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_csymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -stdlib_cdotu( k-1, work, 1, a( 1, k+1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_cswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k+1 with -ipiv(k) and
                 ! -ipiv(k+1)in the leading submatrix a(1:k+1,1:k+1)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_cswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
                 k = k + 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_cswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k + 1
              go to 30
              40 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              50 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 60
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = cone / a( k, k )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_csymv( uplo, n-k,-cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+1,&
                               k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_cdotu( n-k, work, 1, a( k+1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = a( k, k-1 )
                 ak = a( k-1, k-1 ) / t
                 akp1 = a( k, k ) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-cone )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_csymv( uplo, n-k,-cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+1,&
                               k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_cdotu( n-k, work, 1, a( k+1, k ),1 )
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_cdotu( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 &
                              )
                    call stdlib_ccopy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_csymv( uplo, n-k,-cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+1,&
                               k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -stdlib_cdotu( n-k, work, 1, a( k+1, k-1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_cswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k-1 with -ipiv(k) and
                 ! -ipiv(k-1) in the trailing submatrix a(k-1:n,k-1:n)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_cswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
                 k = k - 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_cswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k - 1
              go to 50
              60 continue
           end if
           return
     end subroutine stdlib_csytri_rook


     pure subroutine stdlib_csytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
     !! CSYTRS solves a system of linear equations A*X = B with a complex
     !! symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by CSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_cgeru( k-1, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_cscal( nrhs, cone / a( k, k ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_cgeru( k-2, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 call stdlib_cgeru( k-2, nrhs, -cone, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ), &
                           ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb, a( 1, k ),1, cone, b( &
                           k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb, a( 1, k ),1, cone, b( &
                           k, 1 ), ldb )
                 call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb,a( 1, k+1 ), 1, cone, b(&
                            k+1, 1 ), ldb )
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgeru( n-k, nrhs, -cone, a( k+1, k ), 1, b( k, 1 ),ldb, b( &
                           k+1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_cscal( nrhs, cone / a( k, k ), b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_cgeru( n-k-1, nrhs, -cone, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_cgeru( n-k-1, nrhs, -cone, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / akm1k
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+&
                           1, k ), 1, cone, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+1, k )&
                              , 1, cone, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+1, k-&
                              1 ), 1, cone, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_csytrs


     pure subroutine stdlib_csytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
     !! CSYTRS2 solves a system of linear equations A*X = B with a complex
     !! symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by CSYTRF and converted by CSYCONV.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, j, k, kp
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRS2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! convert a
           call stdlib_csyconv( uplo, 'C', n, a, lda, ipiv, work, iinfo )
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
             ! p**t * b
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp==-ipiv( k-1 ) )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb &
                           )
                 k=k-2
              end if
             end do
        ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
             call stdlib_ctrsm('L','U','N','U',n,nrhs,cone,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0 ) then
                   call stdlib_cscal( nrhs, cone / a( i, i ), b( i, 1 ), ldb )
                 elseif ( i > 1) then
                    if ( ipiv(i-1) == ipiv(i) ) then
                       akm1k = work(i)
                       akm1 = a( i-1, i-1 ) / akm1k
                       ak = a( i, i ) / akm1k
                       denom = akm1*ak - cone
                       do j = 1, nrhs
                          bkm1 = b( i-1, j ) / akm1k
                          bk = b( i, j ) / akm1k
                          b( i-1, j ) = ( ak*bkm1-bk ) / denom
                          b( i, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                    i = i - 1
                    endif
                 endif
                 i = i - 1
              end do
            ! compute (u**t \ b) -> b   [ u**t \ (d \ (u \p**t * b) ) ]
              call stdlib_ctrsm('L','U','T','U',n,nrhs,cone,a,lda,b,ldb)
             ! p * b  [ p * (u**t \ (d \ (u \p**t * b) )) ]
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k < n .and. kp==-ipiv( k+1 ) )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp,&
                            1 ), ldb )
                 k=k+2
              endif
             end do
           else
              ! solve a*x = b, where a = l*d*l**t.
             ! p**t * b
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k+1).
                 kp = -ipiv( k+1 )
                 if( kp==-ipiv( k ) )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                           
                 k=k+2
              endif
             end do
        ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
             call stdlib_ctrsm('L','L','N','U',n,nrhs,cone,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                   call stdlib_cscal( nrhs, cone / a( i, i ), b( i, 1 ), ldb )
                 else
                       akm1k = work(i)
                       akm1 = a( i, i ) / akm1k
                       ak = a( i+1, i+1 ) / akm1k
                       denom = akm1*ak - cone
                       do j = 1, nrhs
                          bkm1 = b( i, j ) / akm1k
                          bk = b( i+1, j ) / akm1k
                          b( i, j ) = ( ak*bkm1-bk ) / denom
                          b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                       i = i + 1
                 endif
                 i = i + 1
              end do
        ! compute (l**t \ b) -> b   [ l**t \ (d \ (l \p**t * b) ) ]
             call stdlib_ctrsm('L','L','T','U',n,nrhs,cone,a,lda,b,ldb)
             ! p * b  [ p * (l**t \ (d \ (l \p**t * b) )) ]
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k>1 .and. kp==-ipiv( k-1 ) )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, &
                           1 ), ldb )
                 k=k-2
              endif
             end do
           end if
           ! revert a
           call stdlib_csyconv( uplo, 'R', n, a, lda, ipiv, work, iinfo )
           return
     end subroutine stdlib_csytrs2


     pure subroutine stdlib_csytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
     !! CSYTRS_3 solves a system of linear equations A * X = B with a complex
     !! symmetric matrix A using the factorization computed
     !! by CSYTRF_RK or CSYTRF_BK:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This algorithm is using Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*), e(*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j, k, kp
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRS_3', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! begin upper
              ! solve a*x = b, where a = u*d*u**t.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
              call stdlib_ctrsm( 'L', 'U', 'N', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i = n
              do while ( i>=1 )
                 if( ipiv( i )>0 ) then
                    call stdlib_cscal( nrhs, cone / a( i, i ), b( i, 1 ), ldb )
                 else if ( i>1 ) then
                    akm1k = e( i )
                    akm1 = a( i-1, i-1 ) / akm1k
                    ak = a( i, i ) / akm1k
                    denom = akm1*ak - cone
                    do j = 1, nrhs
                       bkm1 = b( i-1, j ) / akm1k
                       bk = b( i, j ) / akm1k
                       b( i-1, j ) = ( ak*bkm1-bk ) / denom
                       b( i, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i - 1
                 end if
                 i = i - 1
              end do
              ! compute (u**t \ b) -> b   [ u**t \ (d \ (u \p**t * b) ) ]
              call stdlib_ctrsm( 'L', 'U', 'T', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! p * b  [ p * (u**t \ (d \ (u \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
           else
              ! begin lower
              ! solve a*x = b, where a = l*d*l**t.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
              call stdlib_ctrsm( 'L', 'L', 'N', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i = 1
              do while ( i<=n )
                 if( ipiv( i )>0 ) then
                    call stdlib_cscal( nrhs, cone / a( i, i ), b( i, 1 ), ldb )
                 else if( i<n ) then
                    akm1k = e( i )
                    akm1 = a( i, i ) / akm1k
                    ak = a( i+1, i+1 ) / akm1k
                    denom = akm1*ak - cone
                    do  j = 1, nrhs
                       bkm1 = b( i, j ) / akm1k
                       bk = b( i+1, j ) / akm1k
                       b( i, j ) = ( ak*bkm1-bk ) / denom
                       b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i + 1
                 end if
                 i = i + 1
              end do
              ! compute (l**t \ b) -> b   [ l**t \ (d \ (l \p**t * b) ) ]
              call stdlib_ctrsm('L', 'L', 'T', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! p * b  [ p * (l**t \ (d \ (l \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! end lower
           end if
           return
     end subroutine stdlib_csytrs_3


     pure subroutine stdlib_csytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
     !! CSYTRS_AA solves a system of linear equations A*X = B with a complex
     !! symmetric matrix A using the factorization A = U**T*T*U or
     !! A = L*T*L**T computed by CSYTRF_AA.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, nrhs, lda, ldb, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           logical(lk) :: lquery, upper
           integer(ilp) :: k, kp, lwkopt
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 1, 3*n-2 ) .and. .not.lquery ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRS_AA', -info )
              return
           else if( lquery ) then
              lwkopt = (3*n-2)
              work( 1 ) = lwkopt
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u**t*t*u.
              ! 1) forward substitution with u**t
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute u**t \ b -> b    [ (u**t \p**t * b) ]
                 call stdlib_ctrsm( 'L', 'U', 'T', 'U', n-1, nrhs, cone, a( 1, 2 ),lda, b( 2, 1 ),&
                            ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (u**t \p**t * b) ]
              call stdlib_clacpy( 'F', 1, n, a( 1, 1 ), lda+1, work( n ), 1)
              if( n>1 ) then
                 call stdlib_clacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 1 ), 1 )
                 call stdlib_clacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 2*n ), 1 )
              end if
              call stdlib_cgtsv( n, nrhs, work( 1 ), work( n ), work( 2*n ), b, ldb,info )
              ! 3) backward substitution with u
              if( n>1 ) then
                 ! compute u \ b -> b   [ u \ (t \ (u**t \p**t * b) ) ]
                 call stdlib_ctrsm( 'L', 'U', 'N', 'U', n-1, nrhs, cone, a( 1, 2 ),lda, b( 2, 1 ),&
                            ldb)
                 ! pivot, p * b -> b  [ p * (u**t \ (t \ (u \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           else
              ! solve a*x = b, where a = l*t*l**t.
              ! 1) forward substitution with l
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute l \ b -> b    [ (l \p**t * b) ]
                 call stdlib_ctrsm( 'L', 'L', 'N', 'U', n-1, nrhs, cone, a( 2, 1 ),lda, b( 2, 1 ),&
                            ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (l \p**t * b) ]
              call stdlib_clacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1)
              if( n>1 ) then
                 call stdlib_clacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 1 ), 1 )
                 call stdlib_clacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 2*n ), 1 )
              end if
              call stdlib_cgtsv( n, nrhs, work( 1 ), work(n), work( 2*n ), b, ldb,info)
              ! 3) backward substitution with l**t
              if( n>1 ) then
                 ! compute (l**t \ b) -> b   [ l**t \ (t \ (l \p**t * b) ) ]
                 call stdlib_ctrsm( 'L', 'L', 'T', 'U', n-1, nrhs, cone, a( 2, 1 ),lda, b( 2, 1 ),&
                            ldb)
                 ! pivot, p * b -> b  [ p * (l**t \ (t \ (l \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           end if
           return
     end subroutine stdlib_csytrs_aa


     pure subroutine stdlib_csytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
     !! CSYTRS_ROOK solves a system of linear equations A*X = B with
     !! a complex symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by CSYTRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRS_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_cgeru( k-1, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_cscal( nrhs, cone / a( k, k ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k) then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k>2 ) then
                    call stdlib_cgeru( k-2, nrhs,-cone, a( 1, k ), 1, b( k, 1 ),ldb, b( 1, 1 ), &
                              ldb )
                    call stdlib_cgeru( k-2, nrhs,-cone, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 )&
                              , ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 )call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), 1, &
                           cone, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), 1, cone, &
                              b( k, 1 ), ldb )
                    call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k+1 ), 1, cone,&
                               b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k) then k+1 and -ipiv(k+1).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgeru( n-k, nrhs, -cone, a( k+1, k ), 1, b( k, 1 ),ldb, b( &
                           k+1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_cscal( nrhs, cone / a( k, k ), b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k) then k+1 and -ipiv(k+1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_cgeru( n-k-1, nrhs,-cone, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_cgeru( n-k-1, nrhs,-cone, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( k+&
                              2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / akm1k
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+&
                           1, k ), 1, cone, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+1, k )&
                              , 1, cone, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+1, k-&
                              1 ), 1, cone, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k) then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_csytrs_rook


     pure subroutine stdlib_ctbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, x, ldx, ferr,&
     !! CTBRFS provides error bounds and backward error estimates for the
     !! solution to a system of linear equations with a triangular band
     !! coefficient matrix.
     !! The solution matrix X must be computed by CTBTRS or some other
     !! means before entering this routine.  CTBRFS does not do iterative
     !! refinement because doing so cannot improve the backward error.
                berr, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldb, ldx, n, nrhs
           ! Array Arguments 
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: ab(ldab,*), b(ldb,*), x(ldx,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: notran, nounit, upper
           character :: transn, transt
           integer(ilp) :: i, j, k, kase, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,min,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           notran = stdlib_lsame( trans, 'N' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( kd<0 ) then
              info = -5
           else if( nrhs<0 ) then
              info = -6
           else if( ldab<kd+1 ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTBRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           if( notran ) then
              transn = 'N'
              transt = 'C'
           else
              transn = 'C'
              transt = 'N'
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = kd + 2
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_250: do j = 1, nrhs
              ! compute residual r = b - op(a) * x,
              ! where op(a) = a, a**t, or a**h, depending on trans.
              call stdlib_ccopy( n, x( 1, j ), 1, work, 1 )
              call stdlib_ctbmv( uplo, trans, diag, n, kd, ab, ldab, work, 1 )
              call stdlib_caxpy( n, -cone, b( 1, j ), 1, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(op(a))*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              if( notran ) then
                 ! compute abs(a)*abs(x) + abs(b).
                 if( upper ) then
                    if( nounit ) then
                       do k = 1, n
                          xk = cabs1( x( k, j ) )
                          do i = max( 1, k-kd ), k
                             rwork( i ) = rwork( i ) +cabs1( ab( kd+1+i-k, k ) )*xk
                          end do
                       end do
                    else
                       do k = 1, n
                          xk = cabs1( x( k, j ) )
                          do i = max( 1, k-kd ), k - 1
                             rwork( i ) = rwork( i ) +cabs1( ab( kd+1+i-k, k ) )*xk
                          end do
                          rwork( k ) = rwork( k ) + xk
                       end do
                    end if
                 else
                    if( nounit ) then
                       do k = 1, n
                          xk = cabs1( x( k, j ) )
                          do i = k, min( n, k+kd )
                             rwork( i ) = rwork( i ) +cabs1( ab( 1+i-k, k ) )*xk
                          end do
                       end do
                    else
                       do k = 1, n
                          xk = cabs1( x( k, j ) )
                          do i = k + 1, min( n, k+kd )
                             rwork( i ) = rwork( i ) +cabs1( ab( 1+i-k, k ) )*xk
                          end do
                          rwork( k ) = rwork( k ) + xk
                       end do
                    end if
                 end if
              else
                 ! compute abs(a**h)*abs(x) + abs(b).
                 if( upper ) then
                    if( nounit ) then
                       do k = 1, n
                          s = zero
                          do i = max( 1, k-kd ), k
                             s = s + cabs1( ab( kd+1+i-k, k ) )*cabs1( x( i, j ) )
                          end do
                          rwork( k ) = rwork( k ) + s
                       end do
                    else
                       do k = 1, n
                          s = cabs1( x( k, j ) )
                          do i = max( 1, k-kd ), k - 1
                             s = s + cabs1( ab( kd+1+i-k, k ) )*cabs1( x( i, j ) )
                          end do
                          rwork( k ) = rwork( k ) + s
                       end do
                    end if
                 else
                    if( nounit ) then
                       do k = 1, n
                          s = zero
                          do i = k, min( n, k+kd )
                             s = s + cabs1( ab( 1+i-k, k ) )*cabs1( x( i, j ) )
                          end do
                          rwork( k ) = rwork( k ) + s
                       end do
                    else
                       do k = 1, n
                          s = cabs1( x( k, j ) )
                          do i = k + 1, min( n, k+kd )
                             s = s + cabs1( ab( 1+i-k, k ) )*cabs1( x( i, j ) )
                          end do
                          rwork( k ) = rwork( k ) + s
                       end do
                    end if
                 end if
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(op(a)))*
                 ! ( abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(op(a)) is the inverse of op(a)
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(op(a))*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(op(a))*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(op(a)) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              210 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(op(a)**h).
                    call stdlib_ctbsv( uplo, transt, diag, n, kd, ab, ldab, work,1 )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else
                    ! multiply by inv(op(a))*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_ctbsv( uplo, transn, diag, n, kd, ab, ldab, work,1 )
                 end if
                 go to 210
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_250
           return
     end subroutine stdlib_ctbrfs


     pure subroutine stdlib_ctbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, info )
     !! CTBTRS solves a triangular system of the form
     !! A * X = B,  A**T * X = B,  or  A**H * X = B,
     !! where A is a triangular band matrix of order N, and B is an
     !! N-by-NRHS matrix.  A check is made to verify that A is nonsingular.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldb, n, nrhs
           ! Array Arguments 
           complex(sp), intent(in) :: ab(ldab,*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit, upper
           integer(ilp) :: j
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nounit = stdlib_lsame( diag, 'N' )
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) .and. &
                     .not.stdlib_lsame( trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( kd<0 ) then
              info = -5
           else if( nrhs<0 ) then
              info = -6
           else if( ldab<kd+1 ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTBTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check for singularity.
           if( nounit ) then
              if( upper ) then
                 do info = 1, n
                    if( ab( kd+1, info )==czero )return
                 end do
              else
                 do info = 1, n
                    if( ab( 1, info )==czero )return
                 end do
              end if
           end if
           info = 0
           ! solve a * x = b,  a**t * x = b,  or  a**h * x = b.
           do j = 1, nrhs
              call stdlib_ctbsv( uplo, trans, diag, n, kd, ab, ldab, b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_ctbtrs


     pure subroutine stdlib_ctfsm( transr, side, uplo, trans, diag, m, n, alpha, a,b, ldb )
     !! Level 3 BLAS like routine for A in RFP Format.
     !! CTFSM solves the matrix equation
     !! op( A )*X = alpha*B  or  X*op( A ) = alpha*B
     !! where alpha is a scalar, X and B are m by n matrices, A is a unit, or
     !! non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
     !! op( A ) = A   or   op( A ) = A**H.
     !! A is in Rectangular Full Packed (RFP) Format.
     !! The matrix X is overwritten on B.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, diag, side, trans, uplo
           integer(ilp), intent(in) :: ldb, m, n
           complex(sp), intent(in) :: alpha
           ! Array Arguments 
           complex(sp), intent(in) :: a(0:*)
           complex(sp), intent(inout) :: b(0:ldb-1,0:*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lower, lside, misodd, nisodd, normaltransr, notrans
           integer(ilp) :: m1, m2, n1, n2, k, info, i, j
           ! Intrinsic Functions 
           intrinsic :: max,mod
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lside = stdlib_lsame( side, 'L' )
           lower = stdlib_lsame( uplo, 'L' )
           notrans = stdlib_lsame( trans, 'N' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'C' ) ) then
              info = -1
           else if( .not.lside .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -2
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -3
           else if( .not.notrans .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -4
           else if( .not.stdlib_lsame( diag, 'N' ) .and. .not.stdlib_lsame( diag, 'U' ) )&
                     then
              info = -5
           else if( m<0 ) then
              info = -6
           else if( n<0 ) then
              info = -7
           else if( ldb<max( 1, m ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTFSM ', -info )
              return
           end if
           ! quick return when ( (n==0).or.(m==0) )
           if( ( m==0 ) .or. ( n==0 ) )return
           ! quick return when alpha==(0e+0_sp,0e+0_sp)
           if( alpha==czero ) then
              do j = 0, n - 1
                 do i = 0, m - 1
                    b( i, j ) = czero
                 end do
              end do
              return
           end if
           if( lside ) then
              ! side = 'l'
              ! a is m-by-m.
              ! if m is odd, set nisodd = .true., and m1 and m2.
              ! if m is even, nisodd = .false., and m.
              if( mod( m, 2 )==0 ) then
                 misodd = .false.
                 k = m / 2
              else
                 misodd = .true.
                 if( lower ) then
                    m2 = m / 2
                    m1 = m - m2
                 else
                    m1 = m / 2
                    m2 = m - m1
                 end if
              end if
              if( misodd ) then
                 ! side = 'l' and n is odd
                 if( normaltransr ) then
                    ! side = 'l', n is odd, and transr = 'n'
                    if( lower ) then
                       ! side  ='l', n is odd, transr = 'n', and uplo = 'l'
                       if( notrans ) then
                          ! side  ='l', n is odd, transr = 'n', uplo = 'l', and
                          ! trans = 'n'
                          if( m==1 ) then
                             call stdlib_ctrsm( 'L', 'L', 'N', diag, m1, n, alpha,a, m, b, ldb )
                                       
                          else
                             call stdlib_ctrsm( 'L', 'L', 'N', diag, m1, n, alpha,a( 0 ), m, b, &
                                       ldb )
                             call stdlib_cgemm( 'N', 'N', m2, n, m1, -cone, a( m1 ),m, b, ldb, &
                                       alpha, b( m1, 0 ), ldb )
                             call stdlib_ctrsm( 'L', 'U', 'C', diag, m2, n, cone,a( m ), m, b( m1,&
                                        0 ), ldb )
                          end if
                       else
                          ! side  ='l', n is odd, transr = 'n', uplo = 'l', and
                          ! trans = 'c'
                          if( m==1 ) then
                             call stdlib_ctrsm( 'L', 'L', 'C', diag, m1, n, alpha,a( 0 ), m, b, &
                                       ldb )
                          else
                             call stdlib_ctrsm( 'L', 'U', 'N', diag, m2, n, alpha,a( m ), m, b( &
                                       m1, 0 ), ldb )
                             call stdlib_cgemm( 'C', 'N', m1, n, m2, -cone, a( m1 ),m, b( m1, 0 ),&
                                        ldb, alpha, b, ldb )
                             call stdlib_ctrsm( 'L', 'L', 'C', diag, m1, n, cone,a( 0 ), m, b, &
                                       ldb )
                          end if
                       end if
                    else
                       ! side  ='l', n is odd, transr = 'n', and uplo = 'u'
                       if( .not.notrans ) then
                          ! side  ='l', n is odd, transr = 'n', uplo = 'u', and
                          ! trans = 'n'
                          call stdlib_ctrsm( 'L', 'L', 'N', diag, m1, n, alpha,a( m2 ), m, b, ldb &
                                    )
                          call stdlib_cgemm( 'C', 'N', m2, n, m1, -cone, a( 0 ), m,b, ldb, alpha, &
                                    b( m1, 0 ), ldb )
                          call stdlib_ctrsm( 'L', 'U', 'C', diag, m2, n, cone,a( m1 ), m, b( m1, &
                                    0 ), ldb )
                       else
                          ! side  ='l', n is odd, transr = 'n', uplo = 'u', and
                          ! trans = 'c'
                          call stdlib_ctrsm( 'L', 'U', 'N', diag, m2, n, alpha,a( m1 ), m, b( m1, &
                                    0 ), ldb )
                          call stdlib_cgemm( 'N', 'N', m1, n, m2, -cone, a( 0 ), m,b( m1, 0 ), &
                                    ldb, alpha, b, ldb )
                          call stdlib_ctrsm( 'L', 'L', 'C', diag, m1, n, cone,a( m2 ), m, b, ldb )
                                    
                       end if
                    end if
                 else
                    ! side = 'l', n is odd, and transr = 'c'
                    if( lower ) then
                       ! side  ='l', n is odd, transr = 'c', and uplo = 'l'
                       if( notrans ) then
                          ! side  ='l', n is odd, transr = 'c', uplo = 'l', and
                          ! trans = 'n'
                          if( m==1 ) then
                             call stdlib_ctrsm( 'L', 'U', 'C', diag, m1, n, alpha,a( 0 ), m1, b, &
                                       ldb )
                          else
                             call stdlib_ctrsm( 'L', 'U', 'C', diag, m1, n, alpha,a( 0 ), m1, b, &
                                       ldb )
                             call stdlib_cgemm( 'C', 'N', m2, n, m1, -cone,a( m1*m1 ), m1, b, ldb,&
                                        alpha,b( m1, 0 ), ldb )
                             call stdlib_ctrsm( 'L', 'L', 'N', diag, m2, n, cone,a( 1 ), m1, b( &
                                       m1, 0 ), ldb )
                          end if
                       else
                          ! side  ='l', n is odd, transr = 'c', uplo = 'l', and
                          ! trans = 'c'
                          if( m==1 ) then
                             call stdlib_ctrsm( 'L', 'U', 'N', diag, m1, n, alpha,a( 0 ), m1, b, &
                                       ldb )
                          else
                             call stdlib_ctrsm( 'L', 'L', 'C', diag, m2, n, alpha,a( 1 ), m1, b( &
                                       m1, 0 ), ldb )
                             call stdlib_cgemm( 'N', 'N', m1, n, m2, -cone,a( m1*m1 ), m1, b( m1, &
                                       0 ), ldb,alpha, b, ldb )
                             call stdlib_ctrsm( 'L', 'U', 'N', diag, m1, n, cone,a( 0 ), m1, b, &
                                       ldb )
                          end if
                       end if
                    else
                       ! side  ='l', n is odd, transr = 'c', and uplo = 'u'
                       if( .not.notrans ) then
                          ! side  ='l', n is odd, transr = 'c', uplo = 'u', and
                          ! trans = 'n'
                          call stdlib_ctrsm( 'L', 'U', 'C', diag, m1, n, alpha,a( m2*m2 ), m2, b, &
                                    ldb )
                          call stdlib_cgemm( 'N', 'N', m2, n, m1, -cone, a( 0 ), m2,b, ldb, alpha,&
                                     b( m1, 0 ), ldb )
                          call stdlib_ctrsm( 'L', 'L', 'N', diag, m2, n, cone,a( m1*m2 ), m2, b( &
                                    m1, 0 ), ldb )
                       else
                          ! side  ='l', n is odd, transr = 'c', uplo = 'u', and
                          ! trans = 'c'
                          call stdlib_ctrsm( 'L', 'L', 'C', diag, m2, n, alpha,a( m1*m2 ), m2, b( &
                                    m1, 0 ), ldb )
                          call stdlib_cgemm( 'C', 'N', m1, n, m2, -cone, a( 0 ), m2,b( m1, 0 ), &
                                    ldb, alpha, b, ldb )
                          call stdlib_ctrsm( 'L', 'U', 'N', diag, m1, n, cone,a( m2*m2 ), m2, b, &
                                    ldb )
                       end if
                    end if
                 end if
              else
                 ! side = 'l' and n is even
                 if( normaltransr ) then
                    ! side = 'l', n is even, and transr = 'n'
                    if( lower ) then
                       ! side  ='l', n is even, transr = 'n', and uplo = 'l'
                       if( notrans ) then
                          ! side  ='l', n is even, transr = 'n', uplo = 'l',
                          ! and trans = 'n'
                          call stdlib_ctrsm( 'L', 'L', 'N', diag, k, n, alpha,a( 1 ), m+1, b, ldb &
                                    )
                          call stdlib_cgemm( 'N', 'N', k, n, k, -cone, a( k+1 ),m+1, b, ldb, &
                                    alpha, b( k, 0 ), ldb )
                          call stdlib_ctrsm( 'L', 'U', 'C', diag, k, n, cone,a( 0 ), m+1, b( k, 0 &
                                    ), ldb )
                       else
                          ! side  ='l', n is even, transr = 'n', uplo = 'l',
                          ! and trans = 'c'
                          call stdlib_ctrsm( 'L', 'U', 'N', diag, k, n, alpha,a( 0 ), m+1, b( k, &
                                    0 ), ldb )
                          call stdlib_cgemm( 'C', 'N', k, n, k, -cone, a( k+1 ),m+1, b( k, 0 ), &
                                    ldb, alpha, b, ldb )
                          call stdlib_ctrsm( 'L', 'L', 'C', diag, k, n, cone,a( 1 ), m+1, b, ldb )
                                    
                       end if
                    else
                       ! side  ='l', n is even, transr = 'n', and uplo = 'u'
                       if( .not.notrans ) then
                          ! side  ='l', n is even, transr = 'n', uplo = 'u',
                          ! and trans = 'n'
                          call stdlib_ctrsm( 'L', 'L', 'N', diag, k, n, alpha,a( k+1 ), m+1, b, &
                                    ldb )
                          call stdlib_cgemm( 'C', 'N', k, n, k, -cone, a( 0 ), m+1,b, ldb, alpha, &
                                    b( k, 0 ), ldb )
                          call stdlib_ctrsm( 'L', 'U', 'C', diag, k, n, cone,a( k ), m+1, b( k, 0 &
                                    ), ldb )
                       else
                          ! side  ='l', n is even, transr = 'n', uplo = 'u',
                          ! and trans = 'c'
                          call stdlib_ctrsm( 'L', 'U', 'N', diag, k, n, alpha,a( k ), m+1, b( k, &
                                    0 ), ldb )
                          call stdlib_cgemm( 'N', 'N', k, n, k, -cone, a( 0 ), m+1,b( k, 0 ), ldb,&
                                     alpha, b, ldb )
                          call stdlib_ctrsm( 'L', 'L', 'C', diag, k, n, cone,a( k+1 ), m+1, b, &
                                    ldb )
                       end if
                    end if
                 else
                    ! side = 'l', n is even, and transr = 'c'
                    if( lower ) then
                       ! side  ='l', n is even, transr = 'c', and uplo = 'l'
                       if( notrans ) then
                          ! side  ='l', n is even, transr = 'c', uplo = 'l',
                          ! and trans = 'n'
                          call stdlib_ctrsm( 'L', 'U', 'C', diag, k, n, alpha,a( k ), k, b, ldb )
                                    
                          call stdlib_cgemm( 'C', 'N', k, n, k, -cone,a( k*( k+1 ) ), k, b, ldb, &
                                    alpha,b( k, 0 ), ldb )
                          call stdlib_ctrsm( 'L', 'L', 'N', diag, k, n, cone,a( 0 ), k, b( k, 0 ),&
                                     ldb )
                       else
                          ! side  ='l', n is even, transr = 'c', uplo = 'l',
                          ! and trans = 'c'
                          call stdlib_ctrsm( 'L', 'L', 'C', diag, k, n, alpha,a( 0 ), k, b( k, 0 )&
                                    , ldb )
                          call stdlib_cgemm( 'N', 'N', k, n, k, -cone,a( k*( k+1 ) ), k, b( k, 0 )&
                                    , ldb,alpha, b, ldb )
                          call stdlib_ctrsm( 'L', 'U', 'N', diag, k, n, cone,a( k ), k, b, ldb )
                                    
                       end if
                    else
                       ! side  ='l', n is even, transr = 'c', and uplo = 'u'
                       if( .not.notrans ) then
                          ! side  ='l', n is even, transr = 'c', uplo = 'u',
                          ! and trans = 'n'
                          call stdlib_ctrsm( 'L', 'U', 'C', diag, k, n, alpha,a( k*( k+1 ) ), k, &
                                    b, ldb )
                          call stdlib_cgemm( 'N', 'N', k, n, k, -cone, a( 0 ), k, b,ldb, alpha, b(&
                                     k, 0 ), ldb )
                          call stdlib_ctrsm( 'L', 'L', 'N', diag, k, n, cone,a( k*k ), k, b( k, 0 &
                                    ), ldb )
                       else
                          ! side  ='l', n is even, transr = 'c', uplo = 'u',
                          ! and trans = 'c'
                          call stdlib_ctrsm( 'L', 'L', 'C', diag, k, n, alpha,a( k*k ), k, b( k, &
                                    0 ), ldb )
                          call stdlib_cgemm( 'C', 'N', k, n, k, -cone, a( 0 ), k,b( k, 0 ), ldb, &
                                    alpha, b, ldb )
                          call stdlib_ctrsm( 'L', 'U', 'N', diag, k, n, cone,a( k*( k+1 ) ), k, b,&
                                     ldb )
                       end if
                    end if
                 end if
              end if
           else
              ! side = 'r'
              ! a is n-by-n.
              ! if n is odd, set nisodd = .true., and n1 and n2.
              ! if n is even, nisodd = .false., and k.
              if( mod( n, 2 )==0 ) then
                 nisodd = .false.
                 k = n / 2
              else
                 nisodd = .true.
                 if( lower ) then
                    n2 = n / 2
                    n1 = n - n2
                 else
                    n1 = n / 2
                    n2 = n - n1
                 end if
              end if
              if( nisodd ) then
                 ! side = 'r' and n is odd
                 if( normaltransr ) then
                    ! side = 'r', n is odd, and transr = 'n'
                    if( lower ) then
                       ! side  ='r', n is odd, transr = 'n', and uplo = 'l'
                       if( notrans ) then
                          ! side  ='r', n is odd, transr = 'n', uplo = 'l', and
                          ! trans = 'n'
                          call stdlib_ctrsm( 'R', 'U', 'C', diag, m, n2, alpha,a( n ), n, b( 0, &
                                    n1 ), ldb )
                          call stdlib_cgemm( 'N', 'N', m, n1, n2, -cone, b( 0, n1 ),ldb, a( n1 ), &
                                    n, alpha, b( 0, 0 ),ldb )
                          call stdlib_ctrsm( 'R', 'L', 'N', diag, m, n1, cone,a( 0 ), n, b( 0, 0 )&
                                    , ldb )
                       else
                          ! side  ='r', n is odd, transr = 'n', uplo = 'l', and
                          ! trans = 'c'
                          call stdlib_ctrsm( 'R', 'L', 'C', diag, m, n1, alpha,a( 0 ), n, b( 0, 0 &
                                    ), ldb )
                          call stdlib_cgemm( 'N', 'C', m, n2, n1, -cone, b( 0, 0 ),ldb, a( n1 ), &
                                    n, alpha, b( 0, n1 ),ldb )
                          call stdlib_ctrsm( 'R', 'U', 'N', diag, m, n2, cone,a( n ), n, b( 0, n1 &
                                    ), ldb )
                       end if
                    else
                       ! side  ='r', n is odd, transr = 'n', and uplo = 'u'
                       if( notrans ) then
                          ! side  ='r', n is odd, transr = 'n', uplo = 'u', and
                          ! trans = 'n'
                          call stdlib_ctrsm( 'R', 'L', 'C', diag, m, n1, alpha,a( n2 ), n, b( 0, &
                                    0 ), ldb )
                          call stdlib_cgemm( 'N', 'N', m, n2, n1, -cone, b( 0, 0 ),ldb, a( 0 ), n,&
                                     alpha, b( 0, n1 ),ldb )
                          call stdlib_ctrsm( 'R', 'U', 'N', diag, m, n2, cone,a( n1 ), n, b( 0, &
                                    n1 ), ldb )
                       else
                          ! side  ='r', n is odd, transr = 'n', uplo = 'u', and
                          ! trans = 'c'
                          call stdlib_ctrsm( 'R', 'U', 'C', diag, m, n2, alpha,a( n1 ), n, b( 0, &
                                    n1 ), ldb )
                          call stdlib_cgemm( 'N', 'C', m, n1, n2, -cone, b( 0, n1 ),ldb, a( 0 ), &
                                    n, alpha, b( 0, 0 ), ldb )
                          call stdlib_ctrsm( 'R', 'L', 'N', diag, m, n1, cone,a( n2 ), n, b( 0, 0 &
                                    ), ldb )
                       end if
                    end if
                 else
                    ! side = 'r', n is odd, and transr = 'c'
                    if( lower ) then
                       ! side  ='r', n is odd, transr = 'c', and uplo = 'l'
                       if( notrans ) then
                          ! side  ='r', n is odd, transr = 'c', uplo = 'l', and
                          ! trans = 'n'
                          call stdlib_ctrsm( 'R', 'L', 'N', diag, m, n2, alpha,a( 1 ), n1, b( 0, &
                                    n1 ), ldb )
                          call stdlib_cgemm( 'N', 'C', m, n1, n2, -cone, b( 0, n1 ),ldb, a( n1*n1 &
                                    ), n1, alpha, b( 0, 0 ),ldb )
                          call stdlib_ctrsm( 'R', 'U', 'C', diag, m, n1, cone,a( 0 ), n1, b( 0, 0 &
                                    ), ldb )
                       else
                          ! side  ='r', n is odd, transr = 'c', uplo = 'l', and
                          ! trans = 'c'
                          call stdlib_ctrsm( 'R', 'U', 'N', diag, m, n1, alpha,a( 0 ), n1, b( 0, &
                                    0 ), ldb )
                          call stdlib_cgemm( 'N', 'N', m, n2, n1, -cone, b( 0, 0 ),ldb, a( n1*n1 )&
                                    , n1, alpha, b( 0, n1 ),ldb )
                          call stdlib_ctrsm( 'R', 'L', 'C', diag, m, n2, cone,a( 1 ), n1, b( 0, &
                                    n1 ), ldb )
                       end if
                    else
                       ! side  ='r', n is odd, transr = 'c', and uplo = 'u'
                       if( notrans ) then
                          ! side  ='r', n is odd, transr = 'c', uplo = 'u', and
                          ! trans = 'n'
                          call stdlib_ctrsm( 'R', 'U', 'N', diag, m, n1, alpha,a( n2*n2 ), n2, b( &
                                    0, 0 ), ldb )
                          call stdlib_cgemm( 'N', 'C', m, n2, n1, -cone, b( 0, 0 ),ldb, a( 0 ), &
                                    n2, alpha, b( 0, n1 ),ldb )
                          call stdlib_ctrsm( 'R', 'L', 'C', diag, m, n2, cone,a( n1*n2 ), n2, b( &
                                    0, n1 ), ldb )
                       else
                          ! side  ='r', n is odd, transr = 'c', uplo = 'u', and
                          ! trans = 'c'
                          call stdlib_ctrsm( 'R', 'L', 'N', diag, m, n2, alpha,a( n1*n2 ), n2, b( &
                                    0, n1 ), ldb )
                          call stdlib_cgemm( 'N', 'N', m, n1, n2, -cone, b( 0, n1 ),ldb, a( 0 ), &
                                    n2, alpha, b( 0, 0 ),ldb )
                          call stdlib_ctrsm( 'R', 'U', 'C', diag, m, n1, cone,a( n2*n2 ), n2, b( &
                                    0, 0 ), ldb )
                       end if
                    end if
                 end if
              else
                 ! side = 'r' and n is even
                 if( normaltransr ) then
                    ! side = 'r', n is even, and transr = 'n'
                    if( lower ) then
                       ! side  ='r', n is even, transr = 'n', and uplo = 'l'
                       if( notrans ) then
                          ! side  ='r', n is even, transr = 'n', uplo = 'l',
                          ! and trans = 'n'
                          call stdlib_ctrsm( 'R', 'U', 'C', diag, m, k, alpha,a( 0 ), n+1, b( 0, &
                                    k ), ldb )
                          call stdlib_cgemm( 'N', 'N', m, k, k, -cone, b( 0, k ),ldb, a( k+1 ), n+&
                                    1, alpha, b( 0, 0 ),ldb )
                          call stdlib_ctrsm( 'R', 'L', 'N', diag, m, k, cone,a( 1 ), n+1, b( 0, 0 &
                                    ), ldb )
                       else
                          ! side  ='r', n is even, transr = 'n', uplo = 'l',
                          ! and trans = 'c'
                          call stdlib_ctrsm( 'R', 'L', 'C', diag, m, k, alpha,a( 1 ), n+1, b( 0, &
                                    0 ), ldb )
                          call stdlib_cgemm( 'N', 'C', m, k, k, -cone, b( 0, 0 ),ldb, a( k+1 ), n+&
                                    1, alpha, b( 0, k ),ldb )
                          call stdlib_ctrsm( 'R', 'U', 'N', diag, m, k, cone,a( 0 ), n+1, b( 0, k &
                                    ), ldb )
                       end if
                    else
                       ! side  ='r', n is even, transr = 'n', and uplo = 'u'
                       if( notrans ) then
                          ! side  ='r', n is even, transr = 'n', uplo = 'u',
                          ! and trans = 'n'
                          call stdlib_ctrsm( 'R', 'L', 'C', diag, m, k, alpha,a( k+1 ), n+1, b( 0,&
                                     0 ), ldb )
                          call stdlib_cgemm( 'N', 'N', m, k, k, -cone, b( 0, 0 ),ldb, a( 0 ), n+1,&
                                     alpha, b( 0, k ),ldb )
                          call stdlib_ctrsm( 'R', 'U', 'N', diag, m, k, cone,a( k ), n+1, b( 0, k &
                                    ), ldb )
                       else
                          ! side  ='r', n is even, transr = 'n', uplo = 'u',
                          ! and trans = 'c'
                          call stdlib_ctrsm( 'R', 'U', 'C', diag, m, k, alpha,a( k ), n+1, b( 0, &
                                    k ), ldb )
                          call stdlib_cgemm( 'N', 'C', m, k, k, -cone, b( 0, k ),ldb, a( 0 ), n+1,&
                                     alpha, b( 0, 0 ),ldb )
                          call stdlib_ctrsm( 'R', 'L', 'N', diag, m, k, cone,a( k+1 ), n+1, b( 0, &
                                    0 ), ldb )
                       end if
                    end if
                 else
                    ! side = 'r', n is even, and transr = 'c'
                    if( lower ) then
                       ! side  ='r', n is even, transr = 'c', and uplo = 'l'
                       if( notrans ) then
                          ! side  ='r', n is even, transr = 'c', uplo = 'l',
                          ! and trans = 'n'
                          call stdlib_ctrsm( 'R', 'L', 'N', diag, m, k, alpha,a( 0 ), k, b( 0, k )&
                                    , ldb )
                          call stdlib_cgemm( 'N', 'C', m, k, k, -cone, b( 0, k ),ldb, a( ( k+1 )&
                                    *k ), k, alpha,b( 0, 0 ), ldb )
                          call stdlib_ctrsm( 'R', 'U', 'C', diag, m, k, cone,a( k ), k, b( 0, 0 ),&
                                     ldb )
                       else
                          ! side  ='r', n is even, transr = 'c', uplo = 'l',
                          ! and trans = 'c'
                          call stdlib_ctrsm( 'R', 'U', 'N', diag, m, k, alpha,a( k ), k, b( 0, 0 )&
                                    , ldb )
                          call stdlib_cgemm( 'N', 'N', m, k, k, -cone, b( 0, 0 ),ldb, a( ( k+1 )&
                                    *k ), k, alpha,b( 0, k ), ldb )
                          call stdlib_ctrsm( 'R', 'L', 'C', diag, m, k, cone,a( 0 ), k, b( 0, k ),&
                                     ldb )
                       end if
                    else
                       ! side  ='r', n is even, transr = 'c', and uplo = 'u'
                       if( notrans ) then
                          ! side  ='r', n is even, transr = 'c', uplo = 'u',
                          ! and trans = 'n'
                          call stdlib_ctrsm( 'R', 'U', 'N', diag, m, k, alpha,a( ( k+1 )*k ), k, &
                                    b( 0, 0 ), ldb )
                          call stdlib_cgemm( 'N', 'C', m, k, k, -cone, b( 0, 0 ),ldb, a( 0 ), k, &
                                    alpha, b( 0, k ), ldb )
                          call stdlib_ctrsm( 'R', 'L', 'C', diag, m, k, cone,a( k*k ), k, b( 0, k &
                                    ), ldb )
                       else
                          ! side  ='r', n is even, transr = 'c', uplo = 'u',
                          ! and trans = 'c'
                          call stdlib_ctrsm( 'R', 'L', 'N', diag, m, k, alpha,a( k*k ), k, b( 0, &
                                    k ), ldb )
                          call stdlib_cgemm( 'N', 'N', m, k, k, -cone, b( 0, k ),ldb, a( 0 ), k, &
                                    alpha, b( 0, 0 ), ldb )
                          call stdlib_ctrsm( 'R', 'U', 'C', diag, m, k, cone,a( ( k+1 )*k ), k, b(&
                                     0, 0 ), ldb )
                       end if
                    end if
                 end if
              end if
           end if
           return
     end subroutine stdlib_ctfsm


     pure subroutine stdlib_ctfttp( transr, uplo, n, arf, ap, info )
     !! CTFTTP copies a triangular matrix A from rectangular full packed
     !! format (TF) to standard packed format (TP).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           complex(sp), intent(out) :: ap(0:*)
           complex(sp), intent(in) :: arf(0:*)
        ! =====================================================================
           ! Parameters 
           ! Local Scalars 
           logical(lk) :: lower, nisodd, normaltransr
           integer(ilp) :: n1, n2, k, nt
           integer(ilp) :: i, j, ij
           integer(ilp) :: ijp, jp, lda, js
           ! Intrinsic Functions 
           intrinsic :: conjg
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'C' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTFTTP', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( normaltransr ) then
                 ap( 0 ) = arf( 0 )
              else
                 ap( 0 ) = conjg( arf( 0 ) )
              end if
              return
           end if
           ! size of array arf(0:nt-1)
           nt = n*( n+1 ) / 2
           ! set n1 and n2 depending on lower
           if( lower ) then
              n2 = n / 2
              n1 = n - n2
           else
              n1 = n / 2
              n2 = n - n1
           end if
           ! if n is odd, set nisodd = .true.
           ! if n is even, set k = n/2 and nisodd = .false.
           ! set lda of arf^c; arf^c is (0:(n+1)/2-1,0:n-noe)
           ! where noe = 0 if n is even, noe = 1 if n is odd
           if( mod( n, 2 )==0 ) then
              k = n / 2
              nisodd = .false.
              lda = n + 1
           else
              nisodd = .true.
              lda = n
           end if
           ! arf^c has lda rows and n+1-noe cols
           if( .not.normaltransr )lda = ( n+1 ) / 2
           ! start execution: there are eight cases
           if( nisodd ) then
              ! n is odd
              if( normaltransr ) then
                 ! n is odd and transr = 'n'
                 if( lower ) then
                   ! srpa for lower, normal and n is odd ( a(0:n-1,0:n1-1) )
                   ! t1 -> a(0,0), t2 -> a(0,1), s -> a(n1,0)
                   ! t1 -> a(0), t2 -> a(n), s -> a(n1); lda = n
                    ijp = 0
                    jp = 0
                    do j = 0, n2
                       do i = j, n - 1
                          ij = i + jp
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                       jp = jp + lda
                    end do
                    do i = 0, n2 - 1
                       do j = 1 + i, n2
                          ij = i + j*lda
                          ap( ijp ) = conjg( arf( ij ) )
                          ijp = ijp + 1
                       end do
                    end do
                 else
                   ! srpa for upper, normal and n is odd ( a(0:n-1,0:n2-1)
                   ! t1 -> a(n1+1,0), t2 -> a(n1,0), s -> a(0,0)
                   ! t1 -> a(n2), t2 -> a(n1), s -> a(0)
                    ijp = 0
                    do j = 0, n1 - 1
                       ij = n2 + j
                       do i = 0, j
                          ap( ijp ) = conjg( arf( ij ) )
                          ijp = ijp + 1
                          ij = ij + lda
                       end do
                    end do
                    js = 0
                    do j = n1, n - 1
                       ij = js
                       do ij = js, js + j
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                       js = js + lda
                    end do
                 end if
              else
                 ! n is odd and transr = 'c'
                 if( lower ) then
                    ! srpa for lower, transpose and n is odd
                    ! t1 -> a(0,0) , t2 -> a(1,0) , s -> a(0,n1)
                    ! t1 -> a(0+0) , t2 -> a(1+0) , s -> a(0+n1*n1); lda=n1
                    ijp = 0
                    do i = 0, n2
                       do ij = i*( lda+1 ), n*lda - 1, lda
                          ap( ijp ) = conjg( arf( ij ) )
                          ijp = ijp + 1
                       end do
                    end do
                    js = 1
                    do j = 0, n2 - 1
                       do ij = js, js + n2 - j - 1
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                       js = js + lda + 1
                    end do
                 else
                    ! srpa for upper, transpose and n is odd
                    ! t1 -> a(0,n1+1), t2 -> a(0,n1), s -> a(0,0)
                    ! t1 -> a(n2*n2), t2 -> a(n1*n2), s -> a(0); lda = n2
                    ijp = 0
                    js = n2*lda
                    do j = 0, n1 - 1
                       do ij = js, js + j
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                       js = js + lda
                    end do
                    do i = 0, n1
                       do ij = i, i + ( n1+i )*lda, lda
                          ap( ijp ) = conjg( arf( ij ) )
                          ijp = ijp + 1
                       end do
                    end do
                 end if
              end if
           else
              ! n is even
              if( normaltransr ) then
                 ! n is even and transr = 'n'
                 if( lower ) then
                    ! srpa for lower, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(1,0), t2 -> a(0,0), s -> a(k+1,0)
                    ! t1 -> a(1), t2 -> a(0), s -> a(k+1)
                    ijp = 0
                    jp = 0
                    do j = 0, k - 1
                       do i = j, n - 1
                          ij = 1 + i + jp
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                       jp = jp + lda
                    end do
                    do i = 0, k - 1
                       do j = i, k - 1
                          ij = i + j*lda
                          ap( ijp ) = conjg( arf( ij ) )
                          ijp = ijp + 1
                       end do
                    end do
                 else
                    ! srpa for upper, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(k+1,0) ,  t2 -> a(k,0),   s -> a(0,0)
                    ! t1 -> a(k+1), t2 -> a(k), s -> a(0)
                    ijp = 0
                    do j = 0, k - 1
                       ij = k + 1 + j
                       do i = 0, j
                          ap( ijp ) = conjg( arf( ij ) )
                          ijp = ijp + 1
                          ij = ij + lda
                       end do
                    end do
                    js = 0
                    do j = k, n - 1
                       ij = js
                       do ij = js, js + j
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                       js = js + lda
                    end do
                 end if
              else
                 ! n is even and transr = 'c'
                 if( lower ) then
                    ! srpa for lower, transpose and n is even (see paper)
                    ! t1 -> b(0,1), t2 -> b(0,0), s -> b(0,k+1)
                    ! t1 -> a(0+k), t2 -> a(0+0), s -> a(0+k*(k+1)); lda=k
                    ijp = 0
                    do i = 0, k - 1
                       do ij = i + ( i+1 )*lda, ( n+1 )*lda - 1, lda
                          ap( ijp ) = conjg( arf( ij ) )
                          ijp = ijp + 1
                       end do
                    end do
                    js = 0
                    do j = 0, k - 1
                       do ij = js, js + k - j - 1
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                       js = js + lda + 1
                    end do
                 else
                    ! srpa for upper, transpose and n is even (see paper)
                    ! t1 -> b(0,k+1),     t2 -> b(0,k),   s -> b(0,0)
                    ! t1 -> a(0+k*(k+1)), t2 -> a(0+k*k), s -> a(0+0)); lda=k
                    ijp = 0
                    js = ( k+1 )*lda
                    do j = 0, k - 1
                       do ij = js, js + j
                          ap( ijp ) = arf( ij )
                          ijp = ijp + 1
                       end do
                       js = js + lda
                    end do
                    do i = 0, k - 1
                       do ij = i, i + ( k+i )*lda, lda
                          ap( ijp ) = conjg( arf( ij ) )
                          ijp = ijp + 1
                       end do
                    end do
                 end if
              end if
           end if
           return
     end subroutine stdlib_ctfttp


     pure subroutine stdlib_ctfttr( transr, uplo, n, arf, a, lda, info )
     !! CTFTTR copies a triangular matrix A from rectangular full packed
     !! format (TF) to standard full format (TR).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n, lda
           ! Array Arguments 
           complex(sp), intent(out) :: a(0:lda-1,0:*)
           complex(sp), intent(in) :: arf(0:*)
        ! =====================================================================
           ! Parameters 
           ! Local Scalars 
           logical(lk) :: lower, nisodd, normaltransr
           integer(ilp) :: n1, n2, k, nt, nx2, np1x2
           integer(ilp) :: i, j, l, ij
           ! Intrinsic Functions 
           intrinsic :: conjg,max,mod
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'C' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTFTTR', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 ) then
              if( n==1 ) then
                 if( normaltransr ) then
                    a( 0, 0 ) = arf( 0 )
                 else
                    a( 0, 0 ) = conjg( arf( 0 ) )
                 end if
              end if
              return
           end if
           ! size of array arf(1:2,0:nt-1)
           nt = n*( n+1 ) / 2
           ! set n1 and n2 depending on lower: for n even n1=n2=k
           if( lower ) then
              n2 = n / 2
              n1 = n - n2
           else
              n1 = n / 2
              n2 = n - n1
           end if
           ! if n is odd, set nisodd = .true., lda=n+1 and a is (n+1)--by--k2.
           ! if n is even, set k = n/2 and nisodd = .false., lda=n and a is
           ! n--by--(n+1)/2.
           if( mod( n, 2 )==0 ) then
              k = n / 2
              nisodd = .false.
              if( .not.lower )np1x2 = n + n + 2
           else
              nisodd = .true.
              if( .not.lower )nx2 = n + n
           end if
           if( nisodd ) then
              ! n is odd
              if( normaltransr ) then
                 ! n is odd and transr = 'n'
                 if( lower ) then
                   ! srpa for lower, normal and n is odd ( a(0:n-1,0:n1-1) )
                   ! t1 -> a(0,0), t2 -> a(0,1), s -> a(n1,0)
                   ! t1 -> a(0), t2 -> a(n), s -> a(n1); lda=n
                    ij = 0
                    do j = 0, n2
                       do i = n1, n2 + j
                          a( n2+j, i ) = conjg( arf( ij ) )
                          ij = ij + 1
                       end do
                       do i = j, n - 1
                          a( i, j ) = arf( ij )
                          ij = ij + 1
                       end do
                    end do
                 else
                   ! srpa for upper, normal and n is odd ( a(0:n-1,0:n2-1)
                   ! t1 -> a(n1+1,0), t2 -> a(n1,0), s -> a(0,0)
                   ! t1 -> a(n2), t2 -> a(n1), s -> a(0); lda=n
                    ij = nt - n
                    do j = n - 1, n1, -1
                       do i = 0, j
                          a( i, j ) = arf( ij )
                          ij = ij + 1
                       end do
                       do l = j - n1, n1 - 1
                          a( j-n1, l ) = conjg( arf( ij ) )
                          ij = ij + 1
                       end do
                       ij = ij - nx2
                    end do
                 end if
              else
                 ! n is odd and transr = 'c'
                 if( lower ) then
                    ! srpa for lower, transpose and n is odd
                    ! t1 -> a(0,0) , t2 -> a(1,0) , s -> a(0,n1)
                    ! t1 -> a(0+0) , t2 -> a(1+0) , s -> a(0+n1*n1); lda=n1
                    ij = 0
                    do j = 0, n2 - 1
                       do i = 0, j
                          a( j, i ) = conjg( arf( ij ) )
                          ij = ij + 1
                       end do
                       do i = n1 + j, n - 1
                          a( i, n1+j ) = arf( ij )
                          ij = ij + 1
                       end do
                    end do
                    do j = n2, n - 1
                       do i = 0, n1 - 1
                          a( j, i ) = conjg( arf( ij ) )
                          ij = ij + 1
                       end do
                    end do
                 else
                    ! srpa for upper, transpose and n is odd
                    ! t1 -> a(0,n1+1), t2 -> a(0,n1), s -> a(0,0)
                    ! t1 -> a(n2*n2), t2 -> a(n1*n2), s -> a(0); lda = n2
                    ij = 0
                    do j = 0, n1
                       do i = n1, n - 1
                          a( j, i ) = conjg( arf( ij ) )
                          ij = ij + 1
                       end do
                    end do
                    do j = 0, n1 - 1
                       do i = 0, j
                          a( i, j ) = arf( ij )
                          ij = ij + 1
                       end do
                       do l = n2 + j, n - 1
                          a( n2+j, l ) = conjg( arf( ij ) )
                          ij = ij + 1
                       end do
                    end do
                 end if
              end if
           else
              ! n is even
              if( normaltransr ) then
                 ! n is even and transr = 'n'
                 if( lower ) then
                    ! srpa for lower, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(1,0), t2 -> a(0,0), s -> a(k+1,0)
                    ! t1 -> a(1), t2 -> a(0), s -> a(k+1); lda=n+1
                    ij = 0
                    do j = 0, k - 1
                       do i = k, k + j
                          a( k+j, i ) = conjg( arf( ij ) )
                          ij = ij + 1
                       end do
                       do i = j, n - 1
                          a( i, j ) = arf( ij )
                          ij = ij + 1
                       end do
                    end do
                 else
                    ! srpa for upper, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(k+1,0) ,  t2 -> a(k,0),   s -> a(0,0)
                    ! t1 -> a(k+1), t2 -> a(k), s -> a(0); lda=n+1
                    ij = nt - n - 1
                    do j = n - 1, k, -1
                       do i = 0, j
                          a( i, j ) = arf( ij )
                          ij = ij + 1
                       end do
                       do l = j - k, k - 1
                          a( j-k, l ) = conjg( arf( ij ) )
                          ij = ij + 1
                       end do
                       ij = ij - np1x2
                    end do
                 end if
              else
                 ! n is even and transr = 'c'
                 if( lower ) then
                    ! srpa for lower, transpose and n is even (see paper, a=b)
                    ! t1 -> a(0,1) , t2 -> a(0,0) , s -> a(0,k+1) :
                    ! t1 -> a(0+k) , t2 -> a(0+0) , s -> a(0+k*(k+1)); lda=k
                    ij = 0
                    j = k
                    do i = k, n - 1
                       a( i, j ) = arf( ij )
                       ij = ij + 1
                    end do
                    do j = 0, k - 2
                       do i = 0, j
                          a( j, i ) = conjg( arf( ij ) )
                          ij = ij + 1
                       end do
                       do i = k + 1 + j, n - 1
                          a( i, k+1+j ) = arf( ij )
                          ij = ij + 1
                       end do
                    end do
                    do j = k - 1, n - 1
                       do i = 0, k - 1
                          a( j, i ) = conjg( arf( ij ) )
                          ij = ij + 1
                       end do
                    end do
                 else
                    ! srpa for upper, transpose and n is even (see paper, a=b)
                    ! t1 -> a(0,k+1) , t2 -> a(0,k) , s -> a(0,0)
                    ! t1 -> a(0+k*(k+1)) , t2 -> a(0+k*k) , s -> a(0+0)); lda=k
                    ij = 0
                    do j = 0, k
                       do i = k, n - 1
                          a( j, i ) = conjg( arf( ij ) )
                          ij = ij + 1
                       end do
                    end do
                    do j = 0, k - 2
                       do i = 0, j
                          a( i, j ) = arf( ij )
                          ij = ij + 1
                       end do
                       do l = k + 1 + j, n - 1
                          a( k+1+j, l ) = conjg( arf( ij ) )
                          ij = ij + 1
                       end do
                    end do
                    ! note that here j = k-1
                    do i = 0, j
                       a( i, j ) = arf( ij )
                       ij = ij + 1
                    end do
                 end if
              end if
           end if
           return
     end subroutine stdlib_ctfttr


     pure subroutine stdlib_ctgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
     !! CTGEVC computes some or all of the right and/or left eigenvectors of
     !! a pair of complex matrices (S,P), where S and P are upper triangular.
     !! Matrix pairs of this type are produced by the generalized Schur
     !! factorization of a complex matrix pair (A,B):
     !! A = Q*S*Z**H,  B = Q*P*Z**H
     !! as computed by CGGHRD + CHGEQZ.
     !! The right eigenvector x and the left eigenvector y of (S,P)
     !! corresponding to an eigenvalue w are defined by:
     !! S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
     !! where y**H denotes the conjugate tranpose of y.
     !! The eigenvalues are not input to this routine, but are computed
     !! directly from the diagonal elements of S and P.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of (S,P), or the products Z*X and/or Q*Y,
     !! where Z and Q are input matrices.
     !! If Q and Z are the unitary factors from the generalized Schur
     !! factorization of a matrix pair (A,B), then Z*X and Q*Y
     !! are the matrices of right and left eigenvectors of (A,B).
               mm, m, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(in) :: p(ldp,*), s(lds,*)
           complex(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: compl, compr, ilall, ilback, ilbbad, ilcomp, lsa, lsb
           integer(ilp) :: i, ibeg, ieig, iend, ihwmny, im, iside, isrc, j, je, jr
           real(sp) :: acoefa, acoeff, anorm, ascale, bcoefa, big, bignum, bnorm, bscale, dmin, &
                     safmin, sbeta, scale, small, temp, ulp, xmax
           complex(sp) :: bcoeff, ca, cb, d, salpha, sum, suma, sumb, x
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,conjg,max,min,real
           ! Statement Functions 
           real(sp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=sp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode and test the input parameters
           if( stdlib_lsame( howmny, 'A' ) ) then
              ihwmny = 1
              ilall = .true.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'S' ) ) then
              ihwmny = 2
              ilall = .false.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'B' ) ) then
              ihwmny = 3
              ilall = .true.
              ilback = .true.
           else
              ihwmny = -1
           end if
           if( stdlib_lsame( side, 'R' ) ) then
              iside = 1
              compl = .false.
              compr = .true.
           else if( stdlib_lsame( side, 'L' ) ) then
              iside = 2
              compl = .true.
              compr = .false.
           else if( stdlib_lsame( side, 'B' ) ) then
              iside = 3
              compl = .true.
              compr = .true.
           else
              iside = -1
           end if
           info = 0
           if( iside<0 ) then
              info = -1
           else if( ihwmny<0 ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lds<max( 1, n ) ) then
              info = -6
           else if( ldp<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGEVC', -info )
              return
           end if
           ! count the number of eigenvectors
           if( .not.ilall ) then
              im = 0
              do j = 1, n
                 if( select( j ) )im = im + 1
              end do
           else
              im = n
           end if
           ! check diagonal of b
           ilbbad = .false.
           do j = 1, n
              if( aimag( p( j, j ) )/=zero )ilbbad = .true.
           end do
           if( ilbbad ) then
              info = -7
           else if( compl .and. ldvl<n .or. ldvl<1 ) then
              info = -10
           else if( compr .and. ldvr<n .or. ldvr<1 ) then
              info = -12
           else if( mm<im ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGEVC', -info )
              return
           end if
           ! quick return if possible
           m = im
           if( n==0 )return
           ! machine constants
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           big = one / safmin
           call stdlib_slabad( safmin, big )
           ulp = stdlib_slamch( 'EPSILON' )*stdlib_slamch( 'BASE' )
           small = safmin*n / ulp
           big = one / small
           bignum = one / ( safmin*n )
           ! compute the 1-norm of each column of the strictly upper triangular
           ! part of a and b to check for possible overflow in the triangular
           ! solver.
           anorm = abs1( s( 1, 1 ) )
           bnorm = abs1( p( 1, 1 ) )
           rwork( 1 ) = zero
           rwork( n+1 ) = zero
           do j = 2, n
              rwork( j ) = zero
              rwork( n+j ) = zero
              do i = 1, j - 1
                 rwork( j ) = rwork( j ) + abs1( s( i, j ) )
                 rwork( n+j ) = rwork( n+j ) + abs1( p( i, j ) )
              end do
              anorm = max( anorm, rwork( j )+abs1( s( j, j ) ) )
              bnorm = max( bnorm, rwork( n+j )+abs1( p( j, j ) ) )
           end do
           ascale = one / max( anorm, safmin )
           bscale = one / max( bnorm, safmin )
           ! left eigenvectors
           if( compl ) then
              ieig = 0
              ! main loop over eigenvalues
              loop_140: do je = 1, n
                 if( ilall ) then
                    ilcomp = .true.
                 else
                    ilcomp = select( je )
                 end if
                 if( ilcomp ) then
                    ieig = ieig + 1
                    if( abs1( s( je, je ) )<=safmin .and.abs( real( p( je, je ),KIND=sp) )&
                              <=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       do jr = 1, n
                          vl( jr, ieig ) = czero
                       end do
                       vl( ieig, ieig ) = cone
                       cycle loop_140
                    end if
                    ! non-singular eigenvalue:
                    ! compute coefficients  a  and  b  in
                         ! h
                       ! y  ( a a - b b ) = 0
                    temp = one / max( abs1( s( je, je ) )*ascale,abs( real( p( je, je ),KIND=sp) )&
                              *bscale, safmin )
                    salpha = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*real( p( je, je ),KIND=sp) )*bscale
                    acoeff = sbeta*ascale
                    bcoeff = salpha*bscale
                    ! scale to avoid underflow
                    lsa = abs( sbeta )>=safmin .and. abs( acoeff )<small
                    lsb = abs1( salpha )>=safmin .and. abs1( bcoeff )<small
                    scale = one
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs1( salpha ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoeff ),abs1( bcoeff ) ) &
                                 ) )
                       if( lsa ) then
                          acoeff = ascale*( scale*sbeta )
                       else
                          acoeff = scale*acoeff
                       end if
                       if( lsb ) then
                          bcoeff = bscale*( scale*salpha )
                       else
                          bcoeff = scale*bcoeff
                       end if
                    end if
                    acoefa = abs( acoeff )
                    bcoefa = abs1( bcoeff )
                    xmax = one
                    do jr = 1, n
                       work( jr ) = czero
                    end do
                    work( je ) = cone
                    dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                                                    ! h
                    ! triangular solve of  (a a - b b)  y = 0
                                            ! h
                    ! (rowwise in  (a a - b b) , or columnwise in a a - b b)
                    loop_100: do j = je + 1, n
                       ! compute
                             ! j-1
                       ! sum = sum  conjg( a*s(k,j) - b*p(k,j) )*x(k)
                             ! k=je
                       ! (scale if necessary)
                       temp = one / xmax
                       if( acoefa*rwork( j )+bcoefa*rwork( n+j )>bignum*temp ) then
                          do jr = je, j - 1
                             work( jr ) = temp*work( jr )
                          end do
                          xmax = one
                       end if
                       suma = czero
                       sumb = czero
                       do jr = je, j - 1
                          suma = suma + conjg( s( jr, j ) )*work( jr )
                          sumb = sumb + conjg( p( jr, j ) )*work( jr )
                       end do
                       sum = acoeff*suma - conjg( bcoeff )*sumb
                       ! form x(j) = - sum / conjg( a*s(j,j) - b*p(j,j) )
                       ! with scaling and perturbation of the denominator
                       d = conjg( acoeff*s( j, j )-bcoeff*p( j, j ) )
                       if( abs1( d )<=dmin )d = cmplx( dmin,KIND=sp)
                       if( abs1( d )<one ) then
                          if( abs1( sum )>=bignum*abs1( d ) ) then
                             temp = one / abs1( sum )
                             do jr = je, j - 1
                                work( jr ) = temp*work( jr )
                             end do
                             xmax = temp*xmax
                             sum = temp*sum
                          end if
                       end if
                       work( j ) = stdlib_cladiv( -sum, d )
                       xmax = max( xmax, abs1( work( j ) ) )
                    end do loop_100
                    ! back transform eigenvector if howmny='b'.
                    if( ilback ) then
                       call stdlib_cgemv( 'N', n, n+1-je, cone, vl( 1, je ), ldvl,work( je ), 1, &
                                 czero, work( n+1 ), 1 )
                       isrc = 2
                       ibeg = 1
                    else
                       isrc = 1
                       ibeg = je
                    end if
                    ! copy and scale eigenvector into column of vl
                    xmax = zero
                    do jr = ibeg, n
                       xmax = max( xmax, abs1( work( ( isrc-1 )*n+jr ) ) )
                    end do
                    if( xmax>safmin ) then
                       temp = one / xmax
                       do jr = ibeg, n
                          vl( jr, ieig ) = temp*work( ( isrc-1 )*n+jr )
                       end do
                    else
                       ibeg = n + 1
                    end if
                    do jr = 1, ibeg - 1
                       vl( jr, ieig ) = czero
                    end do
                 end if
              end do loop_140
           end if
           ! right eigenvectors
           if( compr ) then
              ieig = im + 1
              ! main loop over eigenvalues
              loop_250: do je = n, 1, -1
                 if( ilall ) then
                    ilcomp = .true.
                 else
                    ilcomp = select( je )
                 end if
                 if( ilcomp ) then
                    ieig = ieig - 1
                    if( abs1( s( je, je ) )<=safmin .and.abs( real( p( je, je ),KIND=sp) )&
                              <=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       do jr = 1, n
                          vr( jr, ieig ) = czero
                       end do
                       vr( ieig, ieig ) = cone
                       cycle loop_250
                    end if
                    ! non-singular eigenvalue:
                    ! compute coefficients  a  and  b  in
                    ! ( a a - b b ) x  = 0
                    temp = one / max( abs1( s( je, je ) )*ascale,abs( real( p( je, je ),KIND=sp) )&
                              *bscale, safmin )
                    salpha = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*real( p( je, je ),KIND=sp) )*bscale
                    acoeff = sbeta*ascale
                    bcoeff = salpha*bscale
                    ! scale to avoid underflow
                    lsa = abs( sbeta )>=safmin .and. abs( acoeff )<small
                    lsb = abs1( salpha )>=safmin .and. abs1( bcoeff )<small
                    scale = one
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs1( salpha ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoeff ),abs1( bcoeff ) ) &
                                 ) )
                       if( lsa ) then
                          acoeff = ascale*( scale*sbeta )
                       else
                          acoeff = scale*acoeff
                       end if
                       if( lsb ) then
                          bcoeff = bscale*( scale*salpha )
                       else
                          bcoeff = scale*bcoeff
                       end if
                    end if
                    acoefa = abs( acoeff )
                    bcoefa = abs1( bcoeff )
                    xmax = one
                    do jr = 1, n
                       work( jr ) = czero
                    end do
                    work( je ) = cone
                    dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                    ! triangular solve of  (a a - b b) x = 0  (columnwise)
                    ! work(1:j-1) contains sums w,
                    ! work(j+1:je) contains x
                    do jr = 1, je - 1
                       work( jr ) = acoeff*s( jr, je ) - bcoeff*p( jr, je )
                    end do
                    work( je ) = cone
                    loop_210: do j = je - 1, 1, -1
                       ! form x(j) := - w(j) / d
                       ! with scaling and perturbation of the denominator
                       d = acoeff*s( j, j ) - bcoeff*p( j, j )
                       if( abs1( d )<=dmin )d = cmplx( dmin,KIND=sp)
                       if( abs1( d )<one ) then
                          if( abs1( work( j ) )>=bignum*abs1( d ) ) then
                             temp = one / abs1( work( j ) )
                             do jr = 1, je
                                work( jr ) = temp*work( jr )
                             end do
                          end if
                       end if
                       work( j ) = stdlib_cladiv( -work( j ), d )
                       if( j>1 ) then
                          ! w = w + x(j)*(a s(*,j) - b p(*,j) ) with scaling
                          if( abs1( work( j ) )>one ) then
                             temp = one / abs1( work( j ) )
                             if( acoefa*rwork( j )+bcoefa*rwork( n+j )>=bignum*temp ) then
                                do jr = 1, je
                                   work( jr ) = temp*work( jr )
                                end do
                             end if
                          end if
                          ca = acoeff*work( j )
                          cb = bcoeff*work( j )
                          do jr = 1, j - 1
                             work( jr ) = work( jr ) + ca*s( jr, j ) -cb*p( jr, j )
                          end do
                       end if
                    end do loop_210
                    ! back transform eigenvector if howmny='b'.
                    if( ilback ) then
                       call stdlib_cgemv( 'N', n, je, cone, vr, ldvr, work, 1,czero, work( n+1 ), &
                                 1 )
                       isrc = 2
                       iend = n
                    else
                       isrc = 1
                       iend = je
                    end if
                    ! copy and scale eigenvector into column of vr
                    xmax = zero
                    do jr = 1, iend
                       xmax = max( xmax, abs1( work( ( isrc-1 )*n+jr ) ) )
                    end do
                    if( xmax>safmin ) then
                       temp = one / xmax
                       do jr = 1, iend
                          vr( jr, ieig ) = temp*work( ( isrc-1 )*n+jr )
                       end do
                    else
                       iend = 0
                    end if
                    do jr = iend + 1, n
                       vr( jr, ieig ) = czero
                    end do
                 end if
              end do loop_250
           end if
           return
     end subroutine stdlib_ctgevc


     pure subroutine stdlib_ctgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, info )
     !! CTGEX2 swaps adjacent diagonal 1 by 1 blocks (A11,B11) and (A22,B22)
     !! in an upper triangular matrix pair (A, B) by an unitary equivalence
     !! transformation.
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
     !! Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, lda, ldb, ldq, ldz, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: twenty = 2.0e+1_sp
           integer(ilp), parameter :: ldst = 2
           logical(lk), parameter :: wands = .true.
           
           
           
           
           ! Local Scalars 
           logical(lk) :: strong, weak
           integer(ilp) :: i, m
           real(sp) :: cq, cz, eps, sa, sb, scale, smlnum, sum, thresha, threshb
           complex(sp) :: cdum, f, g, sq, sz
           ! Local Arrays 
           complex(sp) :: s(ldst,ldst), t(ldst,ldst), work(8)
           ! Intrinsic Functions 
           intrinsic :: abs,conjg,max,real,sqrt
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=1 )return
           m = ldst
           weak = .false.
           strong = .false.
           ! make a local copy of selected block in (a, b)
           call stdlib_clacpy( 'FULL', m, m, a( j1, j1 ), lda, s, ldst )
           call stdlib_clacpy( 'FULL', m, m, b( j1, j1 ), ldb, t, ldst )
           ! compute the threshold for testing the acceptance of swapping.
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           scale = real( czero,KIND=sp)
           sum = real( cone,KIND=sp)
           call stdlib_clacpy( 'FULL', m, m, s, ldst, work, m )
           call stdlib_clacpy( 'FULL', m, m, t, ldst, work( m*m+1 ), m )
           call stdlib_classq( m*m, work, 1, scale, sum )
           sa = scale*sqrt( sum )
           scale = real( czero,KIND=sp)
           sum = real( cone,KIND=sp)
           call stdlib_classq( m*m, work(m*m+1), 1, scale, sum )
           sb = scale*sqrt( sum )
           ! thres has been changed from
              ! thresh = max( ten*eps*sa, smlnum )
           ! to
              ! thresh = max( twenty*eps*sa, smlnum )
           ! on 04/01/10.
           ! "bug" reported by ondra kamenik, confirmed by julie langou, fixed by
           ! jim demmel and guillaume revy. see forum post 1783.
           thresha = max( twenty*eps*sa, smlnum )
           threshb = max( twenty*eps*sb, smlnum )
           ! compute unitary ql and rq that swap 1-by-1 and 1-by-1 blocks
           ! using givens rotations and perform the swap tentatively.
           f = s( 2, 2 )*t( 1, 1 ) - t( 2, 2 )*s( 1, 1 )
           g = s( 2, 2 )*t( 1, 2 ) - t( 2, 2 )*s( 1, 2 )
           sa = abs( s( 2, 2 ) ) * abs( t( 1, 1 ) )
           sb = abs( s( 1, 1 ) ) * abs( t( 2, 2 ) )
           call stdlib_clartg( g, f, cz, sz, cdum )
           sz = -sz
           call stdlib_crot( 2, s( 1, 1 ), 1, s( 1, 2 ), 1, cz, conjg( sz ) )
           call stdlib_crot( 2, t( 1, 1 ), 1, t( 1, 2 ), 1, cz, conjg( sz ) )
           if( sa>=sb ) then
              call stdlib_clartg( s( 1, 1 ), s( 2, 1 ), cq, sq, cdum )
           else
              call stdlib_clartg( t( 1, 1 ), t( 2, 1 ), cq, sq, cdum )
           end if
           call stdlib_crot( 2, s( 1, 1 ), ldst, s( 2, 1 ), ldst, cq, sq )
           call stdlib_crot( 2, t( 1, 1 ), ldst, t( 2, 1 ), ldst, cq, sq )
           ! weak stability test: |s21| <= o(eps f-norm((a)))
                                ! and  |t21| <= o(eps f-norm((b)))
           weak = abs( s( 2, 1 ) )<=thresha .and.abs( t( 2, 1 ) )<=threshb
           if( .not.weak )go to 20
           if( wands ) then
              ! strong stability test:
                 ! f-norm((a-ql**h*s*qr, b-ql**h*t*qr)) <= o(eps*f-norm((a, b)))
              call stdlib_clacpy( 'FULL', m, m, s, ldst, work, m )
              call stdlib_clacpy( 'FULL', m, m, t, ldst, work( m*m+1 ), m )
              call stdlib_crot( 2, work, 1, work( 3 ), 1, cz, -conjg( sz ) )
              call stdlib_crot( 2, work( 5 ), 1, work( 7 ), 1, cz, -conjg( sz ) )
              call stdlib_crot( 2, work, 2, work( 2 ), 2, cq, -sq )
              call stdlib_crot( 2, work( 5 ), 2, work( 6 ), 2, cq, -sq )
              do i = 1, 2
                 work( i ) = work( i ) - a( j1+i-1, j1 )
                 work( i+2 ) = work( i+2 ) - a( j1+i-1, j1+1 )
                 work( i+4 ) = work( i+4 ) - b( j1+i-1, j1 )
                 work( i+6 ) = work( i+6 ) - b( j1+i-1, j1+1 )
              end do
              scale = real( czero,KIND=sp)
              sum = real( cone,KIND=sp)
              call stdlib_classq( m*m, work, 1, scale, sum )
              sa = scale*sqrt( sum )
              scale = real( czero,KIND=sp)
              sum = real( cone,KIND=sp)
              call stdlib_classq( m*m, work(m*m+1), 1, scale, sum )
              sb = scale*sqrt( sum )
              strong = sa<=thresha .and. sb<=threshb
              if( .not.strong )go to 20
           end if
           ! if the swap is accepted ("weakly" and "strongly"), apply the
           ! equivalence transformations to the original matrix pair (a,b)
           call stdlib_crot( j1+1, a( 1, j1 ), 1, a( 1, j1+1 ), 1, cz, conjg( sz ) )
           call stdlib_crot( j1+1, b( 1, j1 ), 1, b( 1, j1+1 ), 1, cz, conjg( sz ) )
           call stdlib_crot( n-j1+1, a( j1, j1 ), lda, a( j1+1, j1 ), lda, cq, sq )
           call stdlib_crot( n-j1+1, b( j1, j1 ), ldb, b( j1+1, j1 ), ldb, cq, sq )
           ! set  n1 by n2 (2,1) blocks to 0
           a( j1+1, j1 ) = czero
           b( j1+1, j1 ) = czero
           ! accumulate transformations into q and z if requested.
           if( wantz )call stdlib_crot( n, z( 1, j1 ), 1, z( 1, j1+1 ), 1, cz, conjg( sz ) )
                     
           if( wantq )call stdlib_crot( n, q( 1, j1 ), 1, q( 1, j1+1 ), 1, cq, conjg( sq ) )
                     
           ! exit with info = 0 if swap was successfully performed.
           return
           ! exit with info = 1 if swap was rejected.
           20 continue
           info = 1
           return
     end subroutine stdlib_ctgex2


     pure subroutine stdlib_ctgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
     !! CTGEXC reorders the generalized Schur decomposition of a complex
     !! matrix pair (A,B), using an unitary equivalence transformation
     !! (A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with
     !! row index IFST is moved to row ILST.
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
     !! Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ifst, lda, ldb, ldq, ldz, n
           integer(ilp), intent(inout) :: ilst
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: here
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! decode and test input arguments.
           info = 0
           if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldq<1 .or. wantq .and. ( ldq<max( 1, n ) ) ) then
              info = -9
           else if( ldz<1 .or. wantz .and. ( ldz<max( 1, n ) ) ) then
              info = -11
           else if( ifst<1 .or. ifst>n ) then
              info = -12
           else if( ilst<1 .or. ilst>n ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGEXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           if( ifst==ilst )return
           if( ifst<ilst ) then
              here = ifst
              10 continue
              ! swap with next one below
              call stdlib_ctgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz,here, info )
                        
              if( info/=0 ) then
                 ilst = here
                 return
              end if
              here = here + 1
              if( here<ilst )go to 10
              here = here - 1
           else
              here = ifst - 1
              20 continue
              ! swap with next one above
              call stdlib_ctgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz,here, info )
                        
              if( info/=0 ) then
                 ilst = here
                 return
              end if
              here = here - 1
              if( here>=ilst )go to 20
              here = here + 1
           end if
           ilst = here
           return
     end subroutine stdlib_ctgexc


     pure subroutine stdlib_ctplqt2( m, n, l, a, lda, b, ldb, t, ldt, info )
     !! CTPLQT2 computes a LQ a factorization of a complex "triangular-pentagonal"
     !! matrix C, which is composed of a triangular block A and pentagonal block B,
     !! using the compact WY representation for Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldt, n, m, l
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: t(ldt,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, p, mp, np
           complex(sp) :: alpha
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( l<0 .or. l>min(m,n) ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, m ) ) then
              info = -7
           else if( ldt<max( 1, m ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTPLQT2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. m==0 ) return
           do i = 1, m
              ! generate elementary reflector h(i) to annihilate b(i,:)
              p = n-l+min( l, i )
              call stdlib_clarfg( p+1, a( i, i ), b( i, 1 ), ldb, t( 1, i ) )
              t(1,i)=conjg(t(1,i))
              if( i<m ) then
                 do j = 1, p
                    b( i, j ) = conjg(b(i,j))
                 end do
                 ! w(m-i:1) := c(i+1:m,i:n) * c(i,i:n) [use w = t(m,:)]
                 do j = 1, m-i
                    t( m, j ) = (a( i+j, i ))
                 end do
                 call stdlib_cgemv( 'N', m-i, p, cone, b( i+1, 1 ), ldb,b( i, 1 ), ldb, cone, t( &
                           m, 1 ), ldt )
                 ! c(i+1:m,i:n) = c(i+1:m,i:n) + alpha * c(i,i:n)*w(m-1:1)^h
                 alpha = -(t( 1, i ))
                 do j = 1, m-i
                    a( i+j, i ) = a( i+j, i ) + alpha*(t( m, j ))
                 end do
                 call stdlib_cgerc( m-i, p, (alpha),  t( m, 1 ), ldt,b( i, 1 ), ldb, b( i+1, 1 ), &
                           ldb )
                 do j = 1, p
                    b( i, j ) = conjg(b(i,j))
                 end do
              end if
           end do
           do i = 2, m
              ! t(i,1:i-1) := c(i:i-1,1:n)**h * (alpha * c(i,i:n))
              alpha = -(t( 1, i ))
              do j = 1, i-1
                 t( i, j ) = czero
              end do
              p = min( i-1, l )
              np = min( n-l+1, n )
              mp = min( p+1, m )
              do j = 1, n-l+p
                b(i,j)=conjg(b(i,j))
              end do
              ! triangular part of b2
              do j = 1, p
                 t( i, j ) = (alpha*b( i, n-l+j ))
              end do
              call stdlib_ctrmv( 'L', 'N', 'N', p, b( 1, np ), ldb,t( i, 1 ), ldt )
              ! rectangular part of b2
              call stdlib_cgemv( 'N', i-1-p, l,  alpha, b( mp, np ), ldb,b( i, np ), ldb, czero, &
                        t( i,mp ), ldt )
              ! b1
              call stdlib_cgemv( 'N', i-1, n-l, alpha, b, ldb, b( i, 1 ), ldb,cone, t( i, 1 ), &
                        ldt )
              ! t(1:i-1,i) := t(1:i-1,1:i-1) * t(i,1:i-1)
              do j = 1, i-1
                 t(i,j)=conjg(t(i,j))
              end do
              call stdlib_ctrmv( 'L', 'C', 'N', i-1, t, ldt, t( i, 1 ), ldt )
              do j = 1, i-1
                 t(i,j)=conjg(t(i,j))
              end do
              do j = 1, n-l+p
                 b(i,j)=conjg(b(i,j))
              end do
              ! t(i,i) = tau(i)
              t( i, i ) = t( 1, i )
              t( 1, i ) = czero
           end do
           do i=1,m
              do j= i+1,m
                 t(i,j)=(t(j,i))
                 t(j,i)=czero
              end do
           end do
     end subroutine stdlib_ctplqt2


     pure subroutine stdlib_ctpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
     !! CTPQRT2 computes a QR factorization of a complex "triangular-pentagonal"
     !! matrix C, which is composed of a triangular block A and pentagonal block B,
     !! using the compact WY representation for Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldt, n, m, l
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: t(ldt,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, p, mp, np
           complex(sp) :: alpha
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( l<0 .or. l>min(m,n) ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, m ) ) then
              info = -7
           else if( ldt<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTPQRT2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. m==0 ) return
           do i = 1, n
              ! generate elementary reflector h(i) to annihilate b(:,i)
              p = m-l+min( l, i )
              call stdlib_clarfg( p+1, a( i, i ), b( 1, i ), 1, t( i, 1 ) )
              if( i<n ) then
                 ! w(1:n-i) := c(i:m,i+1:n)**h * c(i:m,i) [use w = t(:,n)]
                 do j = 1, n-i
                    t( j, n ) = conjg(a( i, i+j ))
                 end do
                 call stdlib_cgemv( 'C', p, n-i, cone, b( 1, i+1 ), ldb,b( 1, i ), 1, cone, t( 1, &
                           n ), 1 )
                 ! c(i:m,i+1:n) = c(i:m,i+1:n) + alpha*c(i:m,i)*w(1:n-1)**h
                 alpha = -conjg(t( i, 1 ))
                 do j = 1, n-i
                    a( i, i+j ) = a( i, i+j ) + alpha*conjg(t( j, n ))
                 end do
                 call stdlib_cgerc( p, n-i, alpha, b( 1, i ), 1,t( 1, n ), 1, b( 1, i+1 ), ldb )
                           
              end if
           end do
           do i = 2, n
              ! t(1:i-1,i) := c(i:m,1:i-1)**h * (alpha * c(i:m,i))
              alpha = -t( i, 1 )
              do j = 1, i-1
                 t( j, i ) = czero
              end do
              p = min( i-1, l )
              mp = min( m-l+1, m )
              np = min( p+1, n )
              ! triangular part of b2
              do j = 1, p
                 t( j, i ) = alpha*b( m-l+j, i )
              end do
              call stdlib_ctrmv( 'U', 'C', 'N', p, b( mp, 1 ), ldb,t( 1, i ), 1 )
              ! rectangular part of b2
              call stdlib_cgemv( 'C', l, i-1-p, alpha, b( mp, np ), ldb,b( mp, i ), 1, czero, t( &
                        np, i ), 1 )
              ! b1
              call stdlib_cgemv( 'C', m-l, i-1, alpha, b, ldb, b( 1, i ), 1,cone, t( 1, i ), 1 )
                        
              ! t(1:i-1,i) := t(1:i-1,1:i-1) * t(1:i-1,i)
              call stdlib_ctrmv( 'U', 'N', 'N', i-1, t, ldt, t( 1, i ), 1 )
              ! t(i,i) = tau(i)
              t( i, i ) = t( i, 1 )
              t( i, 1 ) = czero
           end do
     end subroutine stdlib_ctpqrt2


     pure subroutine stdlib_ctprfb( side, trans, direct, storev, m, n, k, l,v, ldv, t, ldt, a, &
     !! CTPRFB applies a complex "triangular-pentagonal" block reflector H or its
     !! conjugate transpose H**H to a complex matrix C, which is composed of two
     !! blocks A and B, either from the left or right.
               lda, b, ldb, work, ldwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: direct, side, storev, trans
           integer(ilp), intent(in) :: k, l, lda, ldb, ldt, ldv, ldwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(in) :: t(ldt,*), v(ldv,*)
           complex(sp), intent(out) :: work(ldwork,*)
        ! ==========================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, mp, np, kp
           logical(lk) :: left, forward, column, right, backward, row
           ! Intrinsic Functions 
           intrinsic :: conjg
           ! Executable Statements 
           ! quick return if possible
           if( m<=0 .or. n<=0 .or. k<=0 .or. l<0 ) return
           if( stdlib_lsame( storev, 'C' ) ) then
              column = .true.
              row = .false.
           else if ( stdlib_lsame( storev, 'R' ) ) then
              column = .false.
              row = .true.
           else
              column = .false.
              row = .false.
           end if
           if( stdlib_lsame( side, 'L' ) ) then
              left = .true.
              right = .false.
           else if( stdlib_lsame( side, 'R' ) ) then
              left = .false.
              right = .true.
           else
              left = .false.
              right = .false.
           end if
           if( stdlib_lsame( direct, 'F' ) ) then
              forward = .true.
              backward = .false.
           else if( stdlib_lsame( direct, 'B' ) ) then
              forward = .false.
              backward = .true.
           else
              forward = .false.
              backward = .false.
           end if
       ! ---------------------------------------------------------------------------
           if( column .and. forward .and. left  ) then
       ! ---------------------------------------------------------------------------
              ! let  w =  [ i ]    (k-by-k)
                        ! [ v ]    (m-by-k)
              ! form  h c  or  h**h c  where  c = [ a ]  (k-by-n)
                                                ! [ b ]  (m-by-n)
              ! h = i - w t w**h          or  h**h = i - w t**h w**h
              ! a = a -   t (a + v**h b)  or  a = a -   t**h (a + v**h b)
              ! b = b - v t (a + v**h b)  or  b = b - v t**h (a + v**h b)
       ! ---------------------------------------------------------------------------
              mp = min( m-l+1, m )
              kp = min( l+1, k )
              do j = 1, n
                 do i = 1, l
                    work( i, j ) = b( m-l+i, j )
                 end do
              end do
              call stdlib_ctrmm( 'L', 'U', 'C', 'N', l, n, cone, v( mp, 1 ), ldv,work, ldwork )
                        
              call stdlib_cgemm( 'C', 'N', l, n, m-l, cone, v, ldv, b, ldb,cone, work, ldwork )
                        
              call stdlib_cgemm( 'C', 'N', k-l, n, m, cone, v( 1, kp ), ldv,b, ldb, czero, work( &
                        kp, 1 ), ldwork )
              do j = 1, n
                 do i = 1, k
                    work( i, j ) = work( i, j ) + a( i, j )
                 end do
              end do
              call stdlib_ctrmm( 'L', 'U', trans, 'N', k, n, cone, t, ldt,work, ldwork )
              do j = 1, n
                 do i = 1, k
                    a( i, j ) = a( i, j ) - work( i, j )
                 end do
              end do
              call stdlib_cgemm( 'N', 'N', m-l, n, k, -cone, v, ldv, work, ldwork,cone, b, ldb )
                        
              call stdlib_cgemm( 'N', 'N', l, n, k-l, -cone, v( mp, kp ), ldv,work( kp, 1 ), &
                        ldwork, cone, b( mp, 1 ),  ldb )
              call stdlib_ctrmm( 'L', 'U', 'N', 'N', l, n, cone, v( mp, 1 ), ldv,work, ldwork )
                        
              do j = 1, n
                 do i = 1, l
                    b( m-l+i, j ) = b( m-l+i, j ) - work( i, j )
                 end do
              end do
       ! ---------------------------------------------------------------------------
           else if( column .and. forward .and. right ) then
       ! ---------------------------------------------------------------------------
              ! let  w =  [ i ]    (k-by-k)
                        ! [ v ]    (n-by-k)
              ! form  c h or  c h**h  where  c = [ a b ] (a is m-by-k, b is m-by-n)
              ! h = i - w t w**h          or  h**h = i - w t**h w**h
              ! a = a - (a + b v) t      or  a = a - (a + b v) t**h
              ! b = b - (a + b v) t v**h  or  b = b - (a + b v) t**h v**h
       ! ---------------------------------------------------------------------------
              np = min( n-l+1, n )
              kp = min( l+1, k )
              do j = 1, l
                 do i = 1, m
                    work( i, j ) = b( i, n-l+j )
                 end do
              end do
              call stdlib_ctrmm( 'R', 'U', 'N', 'N', m, l, cone, v( np, 1 ), ldv,work, ldwork )
                        
              call stdlib_cgemm( 'N', 'N', m, l, n-l, cone, b, ldb,v, ldv, cone, work, ldwork )
                        
              call stdlib_cgemm( 'N', 'N', m, k-l, n, cone, b, ldb,v( 1, kp ), ldv, czero, work( &
                        1, kp ), ldwork )
              do j = 1, k
                 do i = 1, m
                    work( i, j ) = work( i, j ) + a( i, j )
                 end do
              end do
              call stdlib_ctrmm( 'R', 'U', trans, 'N', m, k, cone, t, ldt,work, ldwork )
              do j = 1, k
                 do i = 1, m
                    a( i, j ) = a( i, j ) - work( i, j )
                 end do
              end do
              call stdlib_cgemm( 'N', 'C', m, n-l, k, -cone, work, ldwork,v, ldv, cone, b, ldb )
                        
              call stdlib_cgemm( 'N', 'C', m, l, k-l, -cone, work( 1, kp ), ldwork,v( np, kp ), &
                        ldv, cone, b( 1, np ), ldb )
              call stdlib_ctrmm( 'R', 'U', 'C', 'N', m, l, cone, v( np, 1 ), ldv,work, ldwork )
                        
              do j = 1, l
                 do i = 1, m
                    b( i, n-l+j ) = b( i, n-l+j ) - work( i, j )
                 end do
              end do
       ! ---------------------------------------------------------------------------
           else if( column .and. backward .and. left ) then
       ! ---------------------------------------------------------------------------
              ! let  w =  [ v ]    (m-by-k)
                        ! [ i ]    (k-by-k)
              ! form  h c  or  h**h c  where  c = [ b ]  (m-by-n)
                                                ! [ a ]  (k-by-n)
              ! h = i - w t w**h          or  h**h = i - w t**h w**h
              ! a = a -   t (a + v**h b)  or  a = a -   t**h (a + v**h b)
              ! b = b - v t (a + v**h b)  or  b = b - v t**h (a + v**h b)
       ! ---------------------------------------------------------------------------
              mp = min( l+1, m )
              kp = min( k-l+1, k )
              do j = 1, n
                 do i = 1, l
                    work( k-l+i, j ) = b( i, j )
                 end do
              end do
              call stdlib_ctrmm( 'L', 'L', 'C', 'N', l, n, cone, v( 1, kp ), ldv,work( kp, 1 ), &
                        ldwork )
              call stdlib_cgemm( 'C', 'N', l, n, m-l, cone, v( mp, kp ), ldv,b( mp, 1 ), ldb, &
                        cone, work( kp, 1 ), ldwork )
              call stdlib_cgemm( 'C', 'N', k-l, n, m, cone, v, ldv,b, ldb, czero, work, ldwork )
                        
              do j = 1, n
                 do i = 1, k
                    work( i, j ) = work( i, j ) + a( i, j )
                 end do
              end do
              call stdlib_ctrmm( 'L', 'L', trans, 'N', k, n, cone, t, ldt,work, ldwork )
              do j = 1, n
                 do i = 1, k
                    a( i, j ) = a( i, j ) - work( i, j )
                 end do
              end do
              call stdlib_cgemm( 'N', 'N', m-l, n, k, -cone, v( mp, 1 ), ldv,work, ldwork, cone, &
                        b( mp, 1 ), ldb )
              call stdlib_cgemm( 'N', 'N', l, n, k-l, -cone, v, ldv,work, ldwork, cone, b,  ldb )
                        
              call stdlib_ctrmm( 'L', 'L', 'N', 'N', l, n, cone, v( 1, kp ), ldv,work( kp, 1 ), &
                        ldwork )
              do j = 1, n
                 do i = 1, l
                    b( i, j ) = b( i, j ) - work( k-l+i, j )
                 end do
              end do
       ! ---------------------------------------------------------------------------
           else if( column .and. backward .and. right ) then
       ! ---------------------------------------------------------------------------
              ! let  w =  [ v ]    (n-by-k)
                        ! [ i ]    (k-by-k)
              ! form  c h  or  c h**h  where  c = [ b a ] (b is m-by-n, a is m-by-k)
              ! h = i - w t w**h          or  h**h = i - w t**h w**h
              ! a = a - (a + b v) t      or  a = a - (a + b v) t**h
              ! b = b - (a + b v) t v**h  or  b = b - (a + b v) t**h v**h
       ! ---------------------------------------------------------------------------
              np = min( l+1, n )
              kp = min( k-l+1, k )
              do j = 1, l
                 do i = 1, m
                    work( i, k-l+j ) = b( i, j )
                 end do
              end do
              call stdlib_ctrmm( 'R', 'L', 'N', 'N', m, l, cone, v( 1, kp ), ldv,work( 1, kp ), &
                        ldwork )
              call stdlib_cgemm( 'N', 'N', m, l, n-l, cone, b( 1, np ), ldb,v( np, kp ), ldv, &
                        cone, work( 1, kp ), ldwork )
              call stdlib_cgemm( 'N', 'N', m, k-l, n, cone, b, ldb,v, ldv, czero, work, ldwork )
                        
              do j = 1, k
                 do i = 1, m
                    work( i, j ) = work( i, j ) + a( i, j )
                 end do
              end do
              call stdlib_ctrmm( 'R', 'L', trans, 'N', m, k, cone, t, ldt,work, ldwork )
              do j = 1, k
                 do i = 1, m
                    a( i, j ) = a( i, j ) - work( i, j )
                 end do
              end do
              call stdlib_cgemm( 'N', 'C', m, n-l, k, -cone, work, ldwork,v( np, 1 ), ldv, cone, &
                        b( 1, np ), ldb )
              call stdlib_cgemm( 'N', 'C', m, l, k-l, -cone, work, ldwork,v, ldv, cone, b, ldb )
                        
              call stdlib_ctrmm( 'R', 'L', 'C', 'N', m, l, cone, v( 1, kp ), ldv,work( 1, kp ), &
                        ldwork )
              do j = 1, l
                 do i = 1, m
                    b( i, j ) = b( i, j ) - work( i, k-l+j )
                 end do
              end do
       ! ---------------------------------------------------------------------------
           else if( row .and. forward .and. left ) then
       ! ---------------------------------------------------------------------------
              ! let  w =  [ i v ] ( i is k-by-k, v is k-by-m )
              ! form  h c  or  h**h c  where  c = [ a ]  (k-by-n)
                                                ! [ b ]  (m-by-n)
              ! h = i - w**h t w          or  h**h = i - w**h t**h w
              ! a = a -     t (a + v b)  or  a = a -     t**h (a + v b)
              ! b = b - v**h t (a + v b)  or  b = b - v**h t**h (a + v b)
       ! ---------------------------------------------------------------------------
              mp = min( m-l+1, m )
              kp = min( l+1, k )
              do j = 1, n
                 do i = 1, l
                    work( i, j ) = b( m-l+i, j )
                 end do
              end do
              call stdlib_ctrmm( 'L', 'L', 'N', 'N', l, n, cone, v( 1, mp ), ldv,work, ldb )
                        
              call stdlib_cgemm( 'N', 'N', l, n, m-l, cone, v, ldv,b, ldb,cone, work, ldwork )
                        
              call stdlib_cgemm( 'N', 'N', k-l, n, m, cone, v( kp, 1 ), ldv,b, ldb, czero, work( &
                        kp, 1 ), ldwork )
              do j = 1, n
                 do i = 1, k
                    work( i, j ) = work( i, j ) + a( i, j )
                 end do
              end do
              call stdlib_ctrmm( 'L', 'U', trans, 'N', k, n, cone, t, ldt,work, ldwork )
              do j = 1, n
                 do i = 1, k
                    a( i, j ) = a( i, j ) - work( i, j )
                 end do
              end do
              call stdlib_cgemm( 'C', 'N', m-l, n, k, -cone, v, ldv, work, ldwork,cone, b, ldb )
                        
              call stdlib_cgemm( 'C', 'N', l, n, k-l, -cone, v( kp, mp ), ldv,work( kp, 1 ), &
                        ldwork, cone, b( mp, 1 ), ldb )
              call stdlib_ctrmm( 'L', 'L', 'C', 'N', l, n, cone, v( 1, mp ), ldv,work, ldwork )
                        
              do j = 1, n
                 do i = 1, l
                    b( m-l+i, j ) = b( m-l+i, j ) - work( i, j )
                 end do
              end do
       ! ---------------------------------------------------------------------------
           else if( row .and. forward .and. right ) then
       ! ---------------------------------------------------------------------------
              ! let  w =  [ i v ] ( i is k-by-k, v is k-by-n )
              ! form  c h  or  c h**h  where  c = [ a b ] (a is m-by-k, b is m-by-n)
              ! h = i - w**h t w            or  h**h = i - w**h t**h w
              ! a = a - (a + b v**h) t      or  a = a - (a + b v**h) t**h
              ! b = b - (a + b v**h) t v    or  b = b - (a + b v**h) t**h v
       ! ---------------------------------------------------------------------------
              np = min( n-l+1, n )
              kp = min( l+1, k )
              do j = 1, l
                 do i = 1, m
                    work( i, j ) = b( i, n-l+j )
                 end do
              end do
              call stdlib_ctrmm( 'R', 'L', 'C', 'N', m, l, cone, v( 1, np ), ldv,work, ldwork )
                        
              call stdlib_cgemm( 'N', 'C', m, l, n-l, cone, b, ldb, v, ldv,cone, work, ldwork )
                        
              call stdlib_cgemm( 'N', 'C', m, k-l, n, cone, b, ldb,v( kp, 1 ), ldv, czero, work( &
                        1, kp ), ldwork )
              do j = 1, k
                 do i = 1, m
                    work( i, j ) = work( i, j ) + a( i, j )
                 end do
              end do
              call stdlib_ctrmm( 'R', 'U', trans, 'N', m, k, cone, t, ldt,work, ldwork )
              do j = 1, k
                 do i = 1, m
                    a( i, j ) = a( i, j ) - work( i, j )
                 end do
              end do
              call stdlib_cgemm( 'N', 'N', m, n-l, k, -cone, work, ldwork,v, ldv, cone, b, ldb )
                        
              call stdlib_cgemm( 'N', 'N', m, l, k-l, -cone, work( 1, kp ), ldwork,v( kp, np ), &
                        ldv, cone, b( 1, np ), ldb )
              call stdlib_ctrmm( 'R', 'L', 'N', 'N', m, l, cone, v( 1, np ), ldv,work, ldwork )
                        
              do j = 1, l
                 do i = 1, m
                    b( i, n-l+j ) = b( i, n-l+j ) - work( i, j )
                 end do
              end do
       ! ---------------------------------------------------------------------------
           else if( row .and. backward .and. left ) then
       ! ---------------------------------------------------------------------------
              ! let  w =  [ v i ] ( i is k-by-k, v is k-by-m )
              ! form  h c  or  h**h c  where  c = [ b ]  (m-by-n)
                                                ! [ a ]  (k-by-n)
              ! h = i - w**h t w          or  h**h = i - w**h t**h w
              ! a = a -     t (a + v b)  or  a = a -     t**h (a + v b)
              ! b = b - v**h t (a + v b)  or  b = b - v**h t**h (a + v b)
       ! ---------------------------------------------------------------------------
              mp = min( l+1, m )
              kp = min( k-l+1, k )
              do j = 1, n
                 do i = 1, l
                    work( k-l+i, j ) = b( i, j )
                 end do
              end do
              call stdlib_ctrmm( 'L', 'U', 'N', 'N', l, n, cone, v( kp, 1 ), ldv,work( kp, 1 ), &
                        ldwork )
              call stdlib_cgemm( 'N', 'N', l, n, m-l, cone, v( kp, mp ), ldv,b( mp, 1 ), ldb, &
                        cone, work( kp, 1 ), ldwork )
              call stdlib_cgemm( 'N', 'N', k-l, n, m, cone, v, ldv, b, ldb,czero, work, ldwork )
                        
              do j = 1, n
                 do i = 1, k
                    work( i, j ) = work( i, j ) + a( i, j )
                 end do
              end do
              call stdlib_ctrmm( 'L', 'L ', trans, 'N', k, n, cone, t, ldt,work, ldwork )
              do j = 1, n
                 do i = 1, k
                    a( i, j ) = a( i, j ) - work( i, j )
                 end do
              end do
              call stdlib_cgemm( 'C', 'N', m-l, n, k, -cone, v( 1, mp ), ldv,work, ldwork, cone, &
                        b( mp, 1 ), ldb )
              call stdlib_cgemm( 'C', 'N', l, n, k-l, -cone, v, ldv,work, ldwork, cone, b, ldb )
                        
              call stdlib_ctrmm( 'L', 'U', 'C', 'N', l, n, cone, v( kp, 1 ), ldv,work( kp, 1 ), &
                        ldwork )
              do j = 1, n
                 do i = 1, l
                    b( i, j ) = b( i, j ) - work( k-l+i, j )
                 end do
              end do
       ! ---------------------------------------------------------------------------
           else if( row .and. backward .and. right ) then
       ! ---------------------------------------------------------------------------
              ! let  w =  [ v i ] ( i is k-by-k, v is k-by-n )
              ! form  c h  or  c h**h  where  c = [ b a ] (a is m-by-k, b is m-by-n)
              ! h = i - w**h t w            or  h**h = i - w**h t**h w
              ! a = a - (a + b v**h) t      or  a = a - (a + b v**h) t**h
              ! b = b - (a + b v**h) t v    or  b = b - (a + b v**h) t**h v
       ! ---------------------------------------------------------------------------
              np = min( l+1, n )
              kp = min( k-l+1, k )
              do j = 1, l
                 do i = 1, m
                    work( i, k-l+j ) = b( i, j )
                 end do
              end do
              call stdlib_ctrmm( 'R', 'U', 'C', 'N', m, l, cone, v( kp, 1 ), ldv,work( 1, kp ), &
                        ldwork )
              call stdlib_cgemm( 'N', 'C', m, l, n-l, cone, b( 1, np ), ldb,v( kp, np ), ldv, &
                        cone, work( 1, kp ), ldwork )
              call stdlib_cgemm( 'N', 'C', m, k-l, n, cone, b, ldb, v, ldv,czero, work, ldwork )
                        
              do j = 1, k
                 do i = 1, m
                    work( i, j ) = work( i, j ) + a( i, j )
                 end do
              end do
              call stdlib_ctrmm( 'R', 'L', trans, 'N', m, k, cone, t, ldt,work, ldwork )
              do j = 1, k
                 do i = 1, m
                    a( i, j ) = a( i, j ) - work( i, j )
                 end do
              end do
              call stdlib_cgemm( 'N', 'N', m, n-l, k, -cone, work, ldwork,v( 1, np ), ldv, cone, &
                        b( 1, np ), ldb )
              call stdlib_cgemm( 'N', 'N', m, l, k-l , -cone, work, ldwork,v, ldv, cone, b, ldb )
                        
              call stdlib_ctrmm( 'R', 'U', 'N', 'N', m, l, cone, v( kp, 1 ), ldv,work( 1, kp ), &
                        ldwork )
              do j = 1, l
                 do i = 1, m
                    b( i, j ) = b( i, j ) - work( i, k-l+j )
                 end do
              end do
           end if
           return
     end subroutine stdlib_ctprfb


     pure subroutine stdlib_ctprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,ferr, berr, &
     !! CTPRFS provides error bounds and backward error estimates for the
     !! solution to a system of linear equations with a triangular packed
     !! coefficient matrix.
     !! The solution matrix X must be computed by CTPTRS or some other
     !! means before entering this routine.  CTPRFS does not do iterative
     !! refinement because doing so cannot improve the backward error.
               work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: ap(*), b(ldb,*), x(ldx,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: notran, nounit, upper
           character :: transn, transt
           integer(ilp) :: i, j, k, kase, kc, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           notran = stdlib_lsame( trans, 'N' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( nrhs<0 ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( ldx<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTPRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           if( notran ) then
              transn = 'N'
              transt = 'C'
           else
              transn = 'C'
              transt = 'N'
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_250: do j = 1, nrhs
              ! compute residual r = b - op(a) * x,
              ! where op(a) = a, a**t, or a**h, depending on trans.
              call stdlib_ccopy( n, x( 1, j ), 1, work, 1 )
              call stdlib_ctpmv( uplo, trans, diag, n, ap, work, 1 )
              call stdlib_caxpy( n, -cone, b( 1, j ), 1, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(op(a))*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              if( notran ) then
                 ! compute abs(a)*abs(x) + abs(b).
                 if( upper ) then
                    kc = 1
                    if( nounit ) then
                       do k = 1, n
                          xk = cabs1( x( k, j ) )
                          do i = 1, k
                             rwork( i ) = rwork( i ) +cabs1( ap( kc+i-1 ) )*xk
                          end do
                          kc = kc + k
                       end do
                    else
                       do k = 1, n
                          xk = cabs1( x( k, j ) )
                          do i = 1, k - 1
                             rwork( i ) = rwork( i ) +cabs1( ap( kc+i-1 ) )*xk
                          end do
                          rwork( k ) = rwork( k ) + xk
                          kc = kc + k
                       end do
                    end if
                 else
                    kc = 1
                    if( nounit ) then
                       do k = 1, n
                          xk = cabs1( x( k, j ) )
                          do i = k, n
                             rwork( i ) = rwork( i ) +cabs1( ap( kc+i-k ) )*xk
                          end do
                          kc = kc + n - k + 1
                       end do
                    else
                       do k = 1, n
                          xk = cabs1( x( k, j ) )
                          do i = k + 1, n
                             rwork( i ) = rwork( i ) +cabs1( ap( kc+i-k ) )*xk
                          end do
                          rwork( k ) = rwork( k ) + xk
                          kc = kc + n - k + 1
                       end do
                    end if
                 end if
              else
                 ! compute abs(a**h)*abs(x) + abs(b).
                 if( upper ) then
                    kc = 1
                    if( nounit ) then
                       do k = 1, n
                          s = zero
                          do i = 1, k
                             s = s + cabs1( ap( kc+i-1 ) )*cabs1( x( i, j ) )
                          end do
                          rwork( k ) = rwork( k ) + s
                          kc = kc + k
                       end do
                    else
                       do k = 1, n
                          s = cabs1( x( k, j ) )
                          do i = 1, k - 1
                             s = s + cabs1( ap( kc+i-1 ) )*cabs1( x( i, j ) )
                          end do
                          rwork( k ) = rwork( k ) + s
                          kc = kc + k
                       end do
                    end if
                 else
                    kc = 1
                    if( nounit ) then
                       do k = 1, n
                          s = zero
                          do i = k, n
                             s = s + cabs1( ap( kc+i-k ) )*cabs1( x( i, j ) )
                          end do
                          rwork( k ) = rwork( k ) + s
                          kc = kc + n - k + 1
                       end do
                    else
                       do k = 1, n
                          s = cabs1( x( k, j ) )
                          do i = k + 1, n
                             s = s + cabs1( ap( kc+i-k ) )*cabs1( x( i, j ) )
                          end do
                          rwork( k ) = rwork( k ) + s
                          kc = kc + n - k + 1
                       end do
                    end if
                 end if
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(op(a)))*
                 ! ( abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(op(a)) is the inverse of op(a)
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(op(a))*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(op(a))*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(op(a)) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              210 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(op(a)**h).
                    call stdlib_ctpsv( uplo, transt, diag, n, ap, work, 1 )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else
                    ! multiply by inv(op(a))*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_ctpsv( uplo, transn, diag, n, ap, work, 1 )
                 end if
                 go to 210
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_250
           return
     end subroutine stdlib_ctprfs


     pure subroutine stdlib_ctptri( uplo, diag, n, ap, info )
     !! CTPTRI computes the inverse of a complex upper or lower triangular
     !! matrix A stored in packed format.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           complex(sp), intent(inout) :: ap(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit, upper
           integer(ilp) :: j, jc, jclast, jj
           complex(sp) :: ajj
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTPTRI', -info )
              return
           end if
           ! check for singularity if non-unit.
           if( nounit ) then
              if( upper ) then
                 jj = 0
                 do info = 1, n
                    jj = jj + info
                    if( ap( jj )==czero )return
                 end do
              else
                 jj = 1
                 do info = 1, n
                    if( ap( jj )==czero )return
                    jj = jj + n - info + 1
                 end do
              end if
              info = 0
           end if
           if( upper ) then
              ! compute inverse of upper triangular matrix.
              jc = 1
              do j = 1, n
                 if( nounit ) then
                    ap( jc+j-1 ) = cone / ap( jc+j-1 )
                    ajj = -ap( jc+j-1 )
                 else
                    ajj = -cone
                 end if
                 ! compute elements 1:j-1 of j-th column.
                 call stdlib_ctpmv( 'UPPER', 'NO TRANSPOSE', diag, j-1, ap,ap( jc ), 1 )
                 call stdlib_cscal( j-1, ajj, ap( jc ), 1 )
                 jc = jc + j
              end do
           else
              ! compute inverse of lower triangular matrix.
              jc = n*( n+1 ) / 2
              do j = n, 1, -1
                 if( nounit ) then
                    ap( jc ) = cone / ap( jc )
                    ajj = -ap( jc )
                 else
                    ajj = -cone
                 end if
                 if( j<n ) then
                    ! compute elements j+1:n of j-th column.
                    call stdlib_ctpmv( 'LOWER', 'NO TRANSPOSE', diag, n-j,ap( jclast ), ap( jc+1 )&
                              , 1 )
                    call stdlib_cscal( n-j, ajj, ap( jc+1 ), 1 )
                 end if
                 jclast = jc
                 jc = jc - n + j - 2
              end do
           end if
           return
     end subroutine stdlib_ctptri


     pure subroutine stdlib_ctptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
     !! CTPTRS solves a triangular system of the form
     !! A * X = B,  A**T * X = B,  or  A**H * X = B,
     !! where A is a triangular matrix of order N stored in packed format,
     !! and B is an N-by-NRHS matrix.  A check is made to verify that A is
     !! nonsingular.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           complex(sp), intent(in) :: ap(*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit, upper
           integer(ilp) :: j, jc
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) .and. &
                     .not.stdlib_lsame( trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( nrhs<0 ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTPTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check for singularity.
           if( nounit ) then
              if( upper ) then
                 jc = 1
                 do info = 1, n
                    if( ap( jc+info-1 )==czero )return
                    jc = jc + info
                 end do
              else
                 jc = 1
                 do info = 1, n
                    if( ap( jc )==czero )return
                    jc = jc + n - info + 1
                 end do
              end if
           end if
           info = 0
           ! solve  a * x = b,  a**t * x = b,  or  a**h * x = b.
           do j = 1, nrhs
              call stdlib_ctpsv( uplo, trans, diag, n, ap, b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_ctptrs


     pure subroutine stdlib_ctpttf( transr, uplo, n, ap, arf, info )
     !! CTPTTF copies a triangular matrix A from standard packed format (TP)
     !! to rectangular full packed format (TF).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           complex(sp), intent(in) :: ap(0:*)
           complex(sp), intent(out) :: arf(0:*)
        ! =====================================================================
           ! Parameters 
           ! Local Scalars 
           logical(lk) :: lower, nisodd, normaltransr
           integer(ilp) :: n1, n2, k, nt
           integer(ilp) :: i, j, ij
           integer(ilp) :: ijp, jp, lda, js
           ! Intrinsic Functions 
           intrinsic :: conjg,mod
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'C' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTPTTF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( normaltransr ) then
                 arf( 0 ) = ap( 0 )
              else
                 arf( 0 ) = conjg( ap( 0 ) )
              end if
              return
           end if
           ! size of array arf(0:nt-1)
           nt = n*( n+1 ) / 2
           ! set n1 and n2 depending on lower
           if( lower ) then
              n2 = n / 2
              n1 = n - n2
           else
              n1 = n / 2
              n2 = n - n1
           end if
           ! if n is odd, set nisodd = .true.
           ! if n is even, set k = n/2 and nisodd = .false.
           ! set lda of arf^c; arf^c is (0:(n+1)/2-1,0:n-noe)
           ! where noe = 0 if n is even, noe = 1 if n is odd
           if( mod( n, 2 )==0 ) then
              k = n / 2
              nisodd = .false.
              lda = n + 1
           else
              nisodd = .true.
              lda = n
           end if
           ! arf^c has lda rows and n+1-noe cols
           if( .not.normaltransr )lda = ( n+1 ) / 2
           ! start execution: there are eight cases
           if( nisodd ) then
              ! n is odd
              if( normaltransr ) then
                 ! n is odd and transr = 'n'
                 if( lower ) then
                   ! srpa for lower, normal and n is odd ( a(0:n-1,0:n1-1) )
                   ! t1 -> a(0,0), t2 -> a(0,1), s -> a(n1,0)
                   ! t1 -> a(0), t2 -> a(n), s -> a(n1); lda = n
                    ijp = 0
                    jp = 0
                    do j = 0, n2
                       do i = j, n - 1
                          ij = i + jp
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                       jp = jp + lda
                    end do
                    do i = 0, n2 - 1
                       do j = 1 + i, n2
                          ij = i + j*lda
                          arf( ij ) = conjg( ap( ijp ) )
                          ijp = ijp + 1
                       end do
                    end do
                 else
                   ! srpa for upper, normal and n is odd ( a(0:n-1,0:n2-1)
                   ! t1 -> a(n1+1,0), t2 -> a(n1,0), s -> a(0,0)
                   ! t1 -> a(n2), t2 -> a(n1), s -> a(0)
                    ijp = 0
                    do j = 0, n1 - 1
                       ij = n2 + j
                       do i = 0, j
                          arf( ij ) = conjg( ap( ijp ) )
                          ijp = ijp + 1
                          ij = ij + lda
                       end do
                    end do
                    js = 0
                    do j = n1, n - 1
                       ij = js
                       do ij = js, js + j
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                       js = js + lda
                    end do
                 end if
              else
                 ! n is odd and transr = 'c'
                 if( lower ) then
                    ! srpa for lower, transpose and n is odd
                    ! t1 -> a(0,0) , t2 -> a(1,0) , s -> a(0,n1)
                    ! t1 -> a(0+0) , t2 -> a(1+0) , s -> a(0+n1*n1); lda=n1
                    ijp = 0
                    do i = 0, n2
                       do ij = i*( lda+1 ), n*lda - 1, lda
                          arf( ij ) = conjg( ap( ijp ) )
                          ijp = ijp + 1
                       end do
                    end do
                    js = 1
                    do j = 0, n2 - 1
                       do ij = js, js + n2 - j - 1
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                       js = js + lda + 1
                    end do
                 else
                    ! srpa for upper, transpose and n is odd
                    ! t1 -> a(0,n1+1), t2 -> a(0,n1), s -> a(0,0)
                    ! t1 -> a(n2*n2), t2 -> a(n1*n2), s -> a(0); lda = n2
                    ijp = 0
                    js = n2*lda
                    do j = 0, n1 - 1
                       do ij = js, js + j
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                       js = js + lda
                    end do
                    do i = 0, n1
                       do ij = i, i + ( n1+i )*lda, lda
                          arf( ij ) = conjg( ap( ijp ) )
                          ijp = ijp + 1
                       end do
                    end do
                 end if
              end if
           else
              ! n is even
              if( normaltransr ) then
                 ! n is even and transr = 'n'
                 if( lower ) then
                    ! srpa for lower, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(1,0), t2 -> a(0,0), s -> a(k+1,0)
                    ! t1 -> a(1), t2 -> a(0), s -> a(k+1)
                    ijp = 0
                    jp = 0
                    do j = 0, k - 1
                       do i = j, n - 1
                          ij = 1 + i + jp
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                       jp = jp + lda
                    end do
                    do i = 0, k - 1
                       do j = i, k - 1
                          ij = i + j*lda
                          arf( ij ) = conjg( ap( ijp ) )
                          ijp = ijp + 1
                       end do
                    end do
                 else
                    ! srpa for upper, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(k+1,0) ,  t2 -> a(k,0),   s -> a(0,0)
                    ! t1 -> a(k+1), t2 -> a(k), s -> a(0)
                    ijp = 0
                    do j = 0, k - 1
                       ij = k + 1 + j
                       do i = 0, j
                          arf( ij ) = conjg( ap( ijp ) )
                          ijp = ijp + 1
                          ij = ij + lda
                       end do
                    end do
                    js = 0
                    do j = k, n - 1
                       ij = js
                       do ij = js, js + j
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                       js = js + lda
                    end do
                 end if
              else
                 ! n is even and transr = 'c'
                 if( lower ) then
                    ! srpa for lower, transpose and n is even (see paper)
                    ! t1 -> b(0,1), t2 -> b(0,0), s -> b(0,k+1)
                    ! t1 -> a(0+k), t2 -> a(0+0), s -> a(0+k*(k+1)); lda=k
                    ijp = 0
                    do i = 0, k - 1
                       do ij = i + ( i+1 )*lda, ( n+1 )*lda - 1, lda
                          arf( ij ) = conjg( ap( ijp ) )
                          ijp = ijp + 1
                       end do
                    end do
                    js = 0
                    do j = 0, k - 1
                       do ij = js, js + k - j - 1
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                       js = js + lda + 1
                    end do
                 else
                    ! srpa for upper, transpose and n is even (see paper)
                    ! t1 -> b(0,k+1),     t2 -> b(0,k),   s -> b(0,0)
                    ! t1 -> a(0+k*(k+1)), t2 -> a(0+k*k), s -> a(0+0)); lda=k
                    ijp = 0
                    js = ( k+1 )*lda
                    do j = 0, k - 1
                       do ij = js, js + j
                          arf( ij ) = ap( ijp )
                          ijp = ijp + 1
                       end do
                       js = js + lda
                    end do
                    do i = 0, k - 1
                       do ij = i, i + ( k+i )*lda, lda
                          arf( ij ) = conjg( ap( ijp ) )
                          ijp = ijp + 1
                       end do
                    end do
                 end if
              end if
           end if
           return
     end subroutine stdlib_ctpttf


     pure subroutine stdlib_ctpttr( uplo, n, ap, a, lda, info )
     !! CTPTTR copies a triangular matrix A from standard packed format (TP)
     !! to standard full format (TR).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n, lda
           ! Array Arguments 
           complex(sp), intent(out) :: a(lda,*)
           complex(sp), intent(in) :: ap(*)
        ! =====================================================================
           ! Parameters 
           ! Local Scalars 
           logical(lk) :: lower
           integer(ilp) :: i, j, k
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTPTTR', -info )
              return
           end if
           if( lower ) then
              k = 0
              do j = 1, n
                 do i = j, n
                    k = k + 1
                    a( i, j ) = ap( k )
                 end do
              end do
           else
              k = 0
              do j = 1, n
                 do i = 1, j
                    k = k + 1
                    a( i, j ) = ap( k )
                 end do
              end do
           end if
           return
     end subroutine stdlib_ctpttr


     pure subroutine stdlib_ctrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! CTREVC computes some or all of the right and/or left eigenvectors of
     !! a complex upper triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix.  If Q is the unitary factor that reduces a matrix A to
     !! Schur form T, then Q*X and Q*Y are the matrices of right and left
     !! eigenvectors of A.
               work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           complex(sp), parameter :: cmzero = (0.0e+0_sp,0.0e+0_sp)
           complex(sp), parameter :: cmone = (1.0e+0_sp,0.0e+0_sp)
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, over, rightv, somev
           integer(ilp) :: i, ii, is, j, k, ki
           real(sp) :: ovfl, remax, scale, smin, smlnum, ulp, unfl
           complex(sp) :: cdum
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,conjg,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           allv = stdlib_lsame( howmny, 'A' )
           over = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           if( somev ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTREVC', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set the constants to control overflow.
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_slabad( unfl, ovfl )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ! store the diagonal elements of t in working array work.
           do i = 1, n
              work( i+n ) = t( i, i )
           end do
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           rwork( 1 ) = zero
           do j = 2, n
              rwork( j ) = stdlib_scasum( j-1, t( 1, j ), 1 )
           end do
           if( rightv ) then
              ! compute right eigenvectors.
              is = m
              loop_80: do ki = n, 1, -1
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_80
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 work( 1 ) = cmone
                 ! form right-hand side.
                 do k = 1, ki - 1
                    work( k ) = -t( k, ki )
                 end do
                 ! solve the triangular system:
                    ! (t(1:ki-1,1:ki-1) - t(ki,ki))*x = scale*work.
                 do k = 1, ki - 1
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki>1 ) then
                    call stdlib_clatrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', 'Y',ki-1, t, ldt, &
                              work( 1 ), scale, rwork,info )
                    work( ki ) = scale
                 end if
                 ! copy the vector x or q*x to vr and normalize.
                 if( .not.over ) then
                    call stdlib_ccopy( ki, work( 1 ), 1, vr( 1, is ), 1 )
                    ii = stdlib_icamax( ki, vr( 1, is ), 1 )
                    remax = one / cabs1( vr( ii, is ) )
                    call stdlib_csscal( ki, remax, vr( 1, is ), 1 )
                    do k = ki + 1, n
                       vr( k, is ) = cmzero
                    end do
                 else
                    if( ki>1 )call stdlib_cgemv( 'N', n, ki-1, cmone, vr, ldvr, work( 1 ),1, &
                              cmplx( scale,KIND=sp), vr( 1, ki ), 1 )
                    ii = stdlib_icamax( n, vr( 1, ki ), 1 )
                    remax = one / cabs1( vr( ii, ki ) )
                    call stdlib_csscal( n, remax, vr( 1, ki ), 1 )
                 end if
                 ! set back the original diagonal elements of t.
                 do k = 1, ki - 1
                    t( k, k ) = work( k+n )
                 end do
                 is = is - 1
              end do loop_80
           end if
           if( leftv ) then
              ! compute left eigenvectors.
              is = 1
              loop_130: do ki = 1, n
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_130
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 work( n ) = cmone
                 ! form right-hand side.
                 do k = ki + 1, n
                    work( k ) = -conjg( t( ki, k ) )
                 end do
                 ! solve the triangular system:
                    ! (t(ki+1:n,ki+1:n) - t(ki,ki))**h*x = scale*work.
                 do k = ki + 1, n
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki<n ) then
                    call stdlib_clatrs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT','Y', n-ki, t( &
                              ki+1, ki+1 ), ldt,work( ki+1 ), scale, rwork, info )
                    work( ki ) = scale
                 end if
                 ! copy the vector x or q*x to vl and normalize.
                 if( .not.over ) then
                    call stdlib_ccopy( n-ki+1, work( ki ), 1, vl( ki, is ), 1 )
                    ii = stdlib_icamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                    remax = one / cabs1( vl( ii, is ) )
                    call stdlib_csscal( n-ki+1, remax, vl( ki, is ), 1 )
                    do k = 1, ki - 1
                       vl( k, is ) = cmzero
                    end do
                 else
                    if( ki<n )call stdlib_cgemv( 'N', n, n-ki, cmone, vl( 1, ki+1 ), ldvl,work( &
                              ki+1 ), 1, cmplx( scale,KIND=sp),vl( 1, ki ), 1 )
                    ii = stdlib_icamax( n, vl( 1, ki ), 1 )
                    remax = one / cabs1( vl( ii, ki ) )
                    call stdlib_csscal( n, remax, vl( 1, ki ), 1 )
                 end if
                 ! set back the original diagonal elements of t.
                 do k = ki + 1, n
                    t( k, k ) = work( k+n )
                 end do
                 is = is + 1
              end do loop_130
           end if
           return
     end subroutine stdlib_ctrevc


     pure subroutine stdlib_ctrevc3( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! CTREVC3 computes some or all of the right and/or left eigenvectors of
     !! a complex upper triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix. If Q is the unitary factor that reduces a matrix A to
     !! Schur form T, then Q*X and Q*Y are the matrices of right and left
     !! eigenvectors of A.
     !! This uses a Level 3 BLAS version of the back transformation.
               work, lwork, rwork, lrwork, info)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, lwork, lrwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmin = 8
           integer(ilp), parameter :: nbmax = 128
           
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, lquery, over, rightv, somev
           integer(ilp) :: i, ii, is, j, k, ki, iv, maxwrk, nb
           real(sp) :: ovfl, remax, scale, smin, smlnum, ulp, unfl
           complex(sp) :: cdum
           ! Intrinsic Functions 
           intrinsic :: abs,real,cmplx,conjg,aimag,max
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           bothv  = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv  = stdlib_lsame( side, 'L' ) .or. bothv
           allv  = stdlib_lsame( howmny, 'A' )
           over  = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           if( somev ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           nb = stdlib_ilaenv( 1, 'CTREVC', side // howmny, n, -1, -1, -1 )
           maxwrk = n + 2*n*nb
           work(1) = maxwrk
           rwork(1) = n
           lquery = ( lwork==-1 .or. lrwork==-1 )
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -11
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -14
           else if ( lrwork<max( 1, n ) .and. .not.lquery ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTREVC3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! use blocked version of back-transformation if sufficient workspace.
           ! zero-out the workspace to avoid potential nan propagation.
           if( over .and. lwork >= n + 2*n*nbmin ) then
              nb = (lwork - n) / (2*n)
              nb = min( nb, nbmax )
              call stdlib_claset( 'F', n, 1+2*nb, czero, czero, work, n )
           else
              nb = 1
           end if
           ! set the constants to control overflow.
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_slabad( unfl, ovfl )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ! store the diagonal elements of t in working array work.
           do i = 1, n
              work( i ) = t( i, i )
           end do
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           rwork( 1 ) = zero
           do j = 2, n
              rwork( j ) = stdlib_scasum( j-1, t( 1, j ), 1 )
           end do
           if( rightv ) then
              ! ============================================================
              ! compute right eigenvectors.
              ! iv is index of column in current block.
              ! non-blocked version always uses iv=nb=1;
              ! blocked     version starts with iv=nb, goes down to 1.
              ! (note the "0-th" column is used to store the original diagonal.)
              iv = nb
              is = m
              loop_80: do ki = n, 1, -1
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_80
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 ! --------------------------------------------------------
                 ! complex right eigenvector
                 work( ki + iv*n ) = cone
                 ! form right-hand side.
                 do k = 1, ki - 1
                    work( k + iv*n ) = -t( k, ki )
                 end do
                 ! solve upper triangular system:
                 ! [ t(1:ki-1,1:ki-1) - t(ki,ki) ]*x = scale*work.
                 do k = 1, ki - 1
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki>1 ) then
                    call stdlib_clatrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', 'Y',ki-1, t, ldt, &
                              work( 1 + iv*n ), scale,rwork, info )
                    work( ki + iv*n ) = scale
                 end if
                 ! copy the vector x or q*x to vr and normalize.
                 if( .not.over ) then
                    ! ------------------------------
                    ! no back-transform: copy x to vr and normalize.
                    call stdlib_ccopy( ki, work( 1 + iv*n ), 1, vr( 1, is ), 1 )
                    ii = stdlib_icamax( ki, vr( 1, is ), 1 )
                    remax = one / cabs1( vr( ii, is ) )
                    call stdlib_csscal( ki, remax, vr( 1, is ), 1 )
                    do k = ki + 1, n
                       vr( k, is ) = czero
                    end do
                 else if( nb==1 ) then
                    ! ------------------------------
                    ! version 1: back-transform each vector with gemv, q*x.
                    if( ki>1 )call stdlib_cgemv( 'N', n, ki-1, cone, vr, ldvr,work( 1 + iv*n ), 1,&
                               cmplx( scale,KIND=sp),vr( 1, ki ), 1 )
                    ii = stdlib_icamax( n, vr( 1, ki ), 1 )
                    remax = one / cabs1( vr( ii, ki ) )
                    call stdlib_csscal( n, remax, vr( 1, ki ), 1 )
                 else
                    ! ------------------------------
                    ! version 2: back-transform block of vectors with gemm
                    ! zero out below vector
                    do k = ki + 1, n
                       work( k + iv*n ) = czero
                    end do
                    ! columns iv:nb of work are valid vectors.
                    ! when the number of vectors stored reaches nb,
                    ! or if this was last vector, do the gemm
                    if( (iv==1) .or. (ki==1) ) then
                       call stdlib_cgemm( 'N', 'N', n, nb-iv+1, ki+nb-iv, cone,vr, ldvr,work( 1 + &
                                 (iv)*n    ), n,czero,work( 1 + (nb+iv)*n ), n )
                       ! normalize vectors
                       do k = iv, nb
                          ii = stdlib_icamax( n, work( 1 + (nb+k)*n ), 1 )
                          remax = one / cabs1( work( ii + (nb+k)*n ) )
                          call stdlib_csscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_clacpy( 'F', n, nb-iv+1,work( 1 + (nb+iv)*n ), n,vr( 1, ki ), &
                                 ldvr )
                       iv = nb
                    else
                       iv = iv - 1
                    end if
                 end if
                 ! restore the original diagonal elements of t.
                 do k = 1, ki - 1
                    t( k, k ) = work( k )
                 end do
                 is = is - 1
              end do loop_80
           end if
           if( leftv ) then
              ! ============================================================
              ! compute left eigenvectors.
              ! iv is index of column in current block.
              ! non-blocked version always uses iv=1;
              ! blocked     version starts with iv=1, goes up to nb.
              ! (note the "0-th" column is used to store the original diagonal.)
              iv = 1
              is = 1
              loop_130: do ki = 1, n
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_130
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 ! --------------------------------------------------------
                 ! complex left eigenvector
                 work( ki + iv*n ) = cone
                 ! form right-hand side.
                 do k = ki + 1, n
                    work( k + iv*n ) = -conjg( t( ki, k ) )
                 end do
                 ! solve conjugate-transposed triangular system:
                 ! [ t(ki+1:n,ki+1:n) - t(ki,ki) ]**h * x = scale*work.
                 do k = ki + 1, n
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki<n ) then
                    call stdlib_clatrs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT','Y', n-ki, t( &
                              ki+1, ki+1 ), ldt,work( ki+1 + iv*n ), scale, rwork, info )
                    work( ki + iv*n ) = scale
                 end if
                 ! copy the vector x or q*x to vl and normalize.
                 if( .not.over ) then
                    ! ------------------------------
                    ! no back-transform: copy x to vl and normalize.
                    call stdlib_ccopy( n-ki+1, work( ki + iv*n ), 1, vl(ki,is), 1 )
                    ii = stdlib_icamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                    remax = one / cabs1( vl( ii, is ) )
                    call stdlib_csscal( n-ki+1, remax, vl( ki, is ), 1 )
                    do k = 1, ki - 1
                       vl( k, is ) = czero
                    end do
                 else if( nb==1 ) then
                    ! ------------------------------
                    ! version 1: back-transform each vector with gemv, q*x.
                    if( ki<n )call stdlib_cgemv( 'N', n, n-ki, cone, vl( 1, ki+1 ), ldvl,work( ki+&
                              1 + iv*n ), 1, cmplx( scale,KIND=sp),vl( 1, ki ), 1 )
                    ii = stdlib_icamax( n, vl( 1, ki ), 1 )
                    remax = one / cabs1( vl( ii, ki ) )
                    call stdlib_csscal( n, remax, vl( 1, ki ), 1 )
                 else
                    ! ------------------------------
                    ! version 2: back-transform block of vectors with gemm
                    ! zero out above vector
                    ! could go from ki-nv+1 to ki-1
                    do k = 1, ki - 1
                       work( k + iv*n ) = czero
                    end do
                    ! columns 1:iv of work are valid vectors.
                    ! when the number of vectors stored reaches nb,
                    ! or if this was last vector, do the gemm
                    if( (iv==nb) .or. (ki==n) ) then
                       call stdlib_cgemm( 'N', 'N', n, iv, n-ki+iv, cone,vl( 1, ki-iv+1 ), ldvl,&
                                 work( ki-iv+1 + (1)*n ), n,czero,work( 1 + (nb+1)*n ), n )
                       ! normalize vectors
                       do k = 1, iv
                          ii = stdlib_icamax( n, work( 1 + (nb+k)*n ), 1 )
                          remax = one / cabs1( work( ii + (nb+k)*n ) )
                          call stdlib_csscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_clacpy( 'F', n, iv,work( 1 + (nb+1)*n ), n,vl( 1, ki-iv+1 ), &
                                 ldvl )
                       iv = 1
                    else
                       iv = iv + 1
                    end if
                 end if
                 ! restore the original diagonal elements of t.
                 do k = ki + 1, n
                    t( k, k ) = work( k )
                 end do
                 is = is + 1
              end do loop_130
           end if
           return
     end subroutine stdlib_ctrevc3


     pure subroutine stdlib_ctrexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
     !! CTREXC reorders the Schur factorization of a complex matrix
     !! A = Q*T*Q**H, so that the diagonal element of T with row index IFST
     !! is moved to row ILST.
     !! The Schur form T is reordered by a unitary similarity transformation
     !! Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
     !! postmultplying it with Z.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compq
           integer(ilp), intent(in) :: ifst, ilst, ldq, ldt, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: q(ldq,*), t(ldt,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: wantq
           integer(ilp) :: k, m1, m2, m3
           real(sp) :: cs
           complex(sp) :: sn, t11, t22, temp
           ! Intrinsic Functions 
           intrinsic :: conjg,max
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           wantq = stdlib_lsame( compq, 'V' )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldt<max( 1, n ) ) then
              info = -4
           else if( ldq<1 .or. ( wantq .and. ldq<max( 1, n ) ) ) then
              info = -6
           else if(( ifst<1 .or. ifst>n ).and.( n>0 )) then
              info = -7
           else if(( ilst<1 .or. ilst>n ).and.( n>0 )) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTREXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 .or. ifst==ilst )return
           if( ifst<ilst ) then
              ! move the ifst-th diagonal element forward down the diagonal.
              m1 = 0
              m2 = -1
              m3 = 1
           else
              ! move the ifst-th diagonal element backward up the diagonal.
              m1 = -1
              m2 = 0
              m3 = -1
           end if
           do k = ifst + m1, ilst + m2, m3
              ! interchange the k-th and (k+1)-th diagonal elements.
              t11 = t( k, k )
              t22 = t( k+1, k+1 )
              ! determine the transformation to perform the interchange.
              call stdlib_clartg( t( k, k+1 ), t22-t11, cs, sn, temp )
              ! apply transformation to the matrix t.
              if( k+2<=n )call stdlib_crot( n-k-1, t( k, k+2 ), ldt, t( k+1, k+2 ), ldt, cs,sn )
                        
              call stdlib_crot( k-1, t( 1, k ), 1, t( 1, k+1 ), 1, cs, conjg( sn ) )
              t( k, k ) = t22
              t( k+1, k+1 ) = t11
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_crot( n, q( 1, k ), 1, q( 1, k+1 ), 1, cs,conjg( sn ) )
              end if
           end do
           return
     end subroutine stdlib_ctrexc


     pure subroutine stdlib_ctrrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,ldx, ferr, berr,&
     !! CTRRFS provides error bounds and backward error estimates for the
     !! solution to a system of linear equations with a triangular
     !! coefficient matrix.
     !! The solution matrix X must be computed by CTRTRS or some other
     !! means before entering this routine.  CTRRFS does not do iterative
     !! refinement because doing so cannot improve the backward error.
                work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldx, n, nrhs
           ! Array Arguments 
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: a(lda,*), b(ldb,*), x(ldx,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: notran, nounit, upper
           character :: transn, transt
           integer(ilp) :: i, j, k, kase, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           notran = stdlib_lsame( trans, 'N' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( nrhs<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTRRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           if( notran ) then
              transn = 'N'
              transt = 'C'
           else
              transn = 'C'
              transt = 'N'
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_250: do j = 1, nrhs
              ! compute residual r = b - op(a) * x,
              ! where op(a) = a, a**t, or a**h, depending on trans.
              call stdlib_ccopy( n, x( 1, j ), 1, work, 1 )
              call stdlib_ctrmv( uplo, trans, diag, n, a, lda, work, 1 )
              call stdlib_caxpy( n, -cone, b( 1, j ), 1, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(op(a))*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              if( notran ) then
                 ! compute abs(a)*abs(x) + abs(b).
                 if( upper ) then
                    if( nounit ) then
                       do k = 1, n
                          xk = cabs1( x( k, j ) )
                          do i = 1, k
                             rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                          end do
                       end do
                    else
                       do k = 1, n
                          xk = cabs1( x( k, j ) )
                          do i = 1, k - 1
                             rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                          end do
                          rwork( k ) = rwork( k ) + xk
                       end do
                    end if
                 else
                    if( nounit ) then
                       do k = 1, n
                          xk = cabs1( x( k, j ) )
                          do i = k, n
                             rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                          end do
                       end do
                    else
                       do k = 1, n
                          xk = cabs1( x( k, j ) )
                          do i = k + 1, n
                             rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                          end do
                          rwork( k ) = rwork( k ) + xk
                       end do
                    end if
                 end if
              else
                 ! compute abs(a**h)*abs(x) + abs(b).
                 if( upper ) then
                    if( nounit ) then
                       do k = 1, n
                          s = zero
                          do i = 1, k
                             s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                          end do
                          rwork( k ) = rwork( k ) + s
                       end do
                    else
                       do k = 1, n
                          s = cabs1( x( k, j ) )
                          do i = 1, k - 1
                             s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                          end do
                          rwork( k ) = rwork( k ) + s
                       end do
                    end if
                 else
                    if( nounit ) then
                       do k = 1, n
                          s = zero
                          do i = k, n
                             s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                          end do
                          rwork( k ) = rwork( k ) + s
                       end do
                    else
                       do k = 1, n
                          s = cabs1( x( k, j ) )
                          do i = k + 1, n
                             s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                          end do
                          rwork( k ) = rwork( k ) + s
                       end do
                    end if
                 end if
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(op(a)))*
                 ! ( abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(op(a)) is the inverse of op(a)
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(op(a))*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(op(a))*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(op(a)) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              210 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(op(a)**h).
                    call stdlib_ctrsv( uplo, transt, diag, n, a, lda, work, 1 )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else
                    ! multiply by inv(op(a))*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_ctrsv( uplo, transn, diag, n, a, lda, work, 1 )
                 end if
                 go to 210
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_250
           return
     end subroutine stdlib_ctrrfs


     pure subroutine stdlib_ctrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm,&
     !! CTRSNA estimates reciprocal condition numbers for specified
     !! eigenvalues and/or right eigenvectors of a complex upper triangular
     !! matrix T (or of any matrix Q*T*Q**H with Q unitary).
                m, work, ldwork, rwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(sp), intent(out) :: rwork(*), s(*), sep(*)
           complex(sp), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(ldwork,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: somcon, wantbh, wants, wantsp
           character :: normin
           integer(ilp) :: i, ierr, ix, j, k, kase, ks
           real(sp) :: bignum, eps, est, lnrm, rnrm, scale, smlnum, xnorm
           complex(sp) :: cdum, prod
           ! Local Arrays 
           integer(ilp) :: isave(3)
           complex(sp) :: dummy(1)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           ! set m to the number of eigenpairs for which condition numbers are
           ! to be computed.
           if( somcon ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           if( .not.wants .and. .not.wantsp ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( wants .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( wants .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -13
           else if( ldwork<1 .or. ( wantsp .and. ldwork<n ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTRSNA', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( somcon ) then
                 if( .not.select( 1 ) )return
              end if
              if( wants )s( 1 ) = one
              if( wantsp )sep( 1 ) = abs( t( 1, 1 ) )
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           ks = 1
           loop_50: do k = 1, n
              if( somcon ) then
                 if( .not.select( k ) )cycle loop_50
              end if
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 prod = stdlib_cdotc( n, vr( 1, ks ), 1, vl( 1, ks ), 1 )
                 rnrm = stdlib_scnrm2( n, vr( 1, ks ), 1 )
                 lnrm = stdlib_scnrm2( n, vl( 1, ks ), 1 )
                 s( ks ) = abs( prod ) / ( rnrm*lnrm )
              end if
              if( wantsp ) then
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvector.
                 ! copy the matrix t to the array work and swap the k-th
                 ! diagonal element to the (1,1) position.
                 call stdlib_clacpy( 'FULL', n, n, t, ldt, work, ldwork )
                 call stdlib_ctrexc( 'NO Q', n, work, ldwork, dummy, 1, k, 1, ierr )
                 ! form  c = t22 - lambda*i in work(2:n,2:n).
                 do i = 2, n
                    work( i, i ) = work( i, i ) - work( 1, 1 )
                 end do
                 ! estimate a lower bound for the 1-norm of inv(c**h). the 1st
                 ! and (n+1)th columns of work are used to store work vectors.
                 sep( ks ) = zero
                 est = zero
                 kase = 0
                 normin = 'N'
                 30 continue
                 call stdlib_clacn2( n-1, work( 1, n+1 ), work, est, kase, isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve c**h*x = scale*b
                       call stdlib_clatrs( 'UPPER', 'CONJUGATE TRANSPOSE','NONUNIT', normin, n-1, &
                                 work( 2, 2 ),ldwork, work, scale, rwork, ierr )
                    else
                       ! solve c*x = scale*b
                       call stdlib_clatrs( 'UPPER', 'NO TRANSPOSE', 'NONUNIT',normin, n-1, work( &
                                 2, 2 ), ldwork, work,scale, rwork, ierr )
                    end if
                    normin = 'Y'
                    if( scale/=one ) then
                       ! multiply by 1/scale if doing so will not cause
                       ! overflow.
                       ix = stdlib_icamax( n-1, work, 1 )
                       xnorm = cabs1( work( ix, 1 ) )
                       if( scale<xnorm*smlnum .or. scale==zero )go to 40
                       call stdlib_csrscl( n, scale, work, 1 )
                    end if
                    go to 30
                 end if
                 sep( ks ) = one / max( est, smlnum )
              end if
              40 continue
              ks = ks + 1
           end do loop_50
           return
     end subroutine stdlib_ctrsna


     pure subroutine stdlib_ctrti2( uplo, diag, n, a, lda, info )
     !! CTRTI2 computes the inverse of a complex upper or lower triangular
     !! matrix.
     !! This is the Level 2 BLAS version of the algorithm.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit, upper
           integer(ilp) :: j
           complex(sp) :: ajj
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTRTI2', -info )
              return
           end if
           if( upper ) then
              ! compute inverse of upper triangular matrix.
              do j = 1, n
                 if( nounit ) then
                    a( j, j ) = cone / a( j, j )
                    ajj = -a( j, j )
                 else
                    ajj = -cone
                 end if
                 ! compute elements 1:j-1 of j-th column.
                 call stdlib_ctrmv( 'UPPER', 'NO TRANSPOSE', diag, j-1, a, lda,a( 1, j ), 1 )
                           
                 call stdlib_cscal( j-1, ajj, a( 1, j ), 1 )
              end do
           else
              ! compute inverse of lower triangular matrix.
              do j = n, 1, -1
                 if( nounit ) then
                    a( j, j ) = cone / a( j, j )
                    ajj = -a( j, j )
                 else
                    ajj = -cone
                 end if
                 if( j<n ) then
                    ! compute elements j+1:n of j-th column.
                    call stdlib_ctrmv( 'LOWER', 'NO TRANSPOSE', diag, n-j,a( j+1, j+1 ), lda, a( &
                              j+1, j ), 1 )
                    call stdlib_cscal( n-j, ajj, a( j+1, j ), 1 )
                 end if
              end do
           end if
           return
     end subroutine stdlib_ctrti2


     pure subroutine stdlib_ctrtri( uplo, diag, n, a, lda, info )
     !! CTRTRI computes the inverse of a complex upper or lower triangular
     !! matrix A.
     !! This is the Level 3 BLAS version of the algorithm.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit, upper
           integer(ilp) :: j, jb, nb, nn
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTRTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check for singularity if non-unit.
           if( nounit ) then
              do info = 1, n
                 if( a( info, info )==czero )return
              end do
              info = 0
           end if
           ! determine the block size for this environment.
           nb = stdlib_ilaenv( 1, 'CTRTRI', uplo // diag, n, -1, -1, -1 )
           if( nb<=1 .or. nb>=n ) then
              ! use unblocked code
              call stdlib_ctrti2( uplo, diag, n, a, lda, info )
           else
              ! use blocked code
              if( upper ) then
                 ! compute inverse of upper triangular matrix
                 do j = 1, n, nb
                    jb = min( nb, n-j+1 )
                    ! compute rows 1:j-1 of current block column
                    call stdlib_ctrmm( 'LEFT', 'UPPER', 'NO TRANSPOSE', diag, j-1,jb, cone, a, &
                              lda, a( 1, j ), lda )
                    call stdlib_ctrsm( 'RIGHT', 'UPPER', 'NO TRANSPOSE', diag, j-1,jb, -cone, a( &
                              j, j ), lda, a( 1, j ), lda )
                    ! compute inverse of current diagonal block
                    call stdlib_ctrti2( 'UPPER', diag, jb, a( j, j ), lda, info )
                 end do
              else
                 ! compute inverse of lower triangular matrix
                 nn = ( ( n-1 ) / nb )*nb + 1
                 do j = nn, 1, -nb
                    jb = min( nb, n-j+1 )
                    if( j+jb<=n ) then
                       ! compute rows j+jb:n of current block column
                       call stdlib_ctrmm( 'LEFT', 'LOWER', 'NO TRANSPOSE', diag,n-j-jb+1, jb, &
                                 cone, a( j+jb, j+jb ), lda,a( j+jb, j ), lda )
                       call stdlib_ctrsm( 'RIGHT', 'LOWER', 'NO TRANSPOSE', diag,n-j-jb+1, jb, -&
                                 cone, a( j, j ), lda,a( j+jb, j ), lda )
                    end if
                    ! compute inverse of current diagonal block
                    call stdlib_ctrti2( 'LOWER', diag, jb, a( j, j ), lda, info )
                 end do
              end if
           end if
           return
     end subroutine stdlib_ctrtri


     pure subroutine stdlib_ctrtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,info )
     !! CTRTRS solves a triangular system of the form
     !! A * X = B,  A**T * X = B,  or  A**H * X = B,
     !! where A is a triangular matrix of order N, and B is an N-by-NRHS
     !! matrix.  A check is made to verify that A is nonsingular.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) .and. &
                     .not.stdlib_lsame( trans, 'C' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( nrhs<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTRTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check for singularity.
           if( nounit ) then
              do info = 1, n
                 if( a( info, info )==czero )return
              end do
           end if
           info = 0
           ! solve a * x = b,  a**t * x = b,  or  a**h * x = b.
           call stdlib_ctrsm( 'LEFT', uplo, trans, diag, n, nrhs, cone, a, lda, b,ldb )
           return
     end subroutine stdlib_ctrtrs


     pure subroutine stdlib_ctrttf( transr, uplo, n, a, lda, arf, info )
     !! CTRTTF copies a triangular matrix A from standard full format (TR)
     !! to rectangular full packed format (TF) .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n, lda
           ! Array Arguments 
           complex(sp), intent(in) :: a(0:lda-1,0:*)
           complex(sp), intent(out) :: arf(0:*)
        ! =====================================================================
           ! Parameters 
           ! Local Scalars 
           logical(lk) :: lower, nisodd, normaltransr
           integer(ilp) :: i, ij, j, k, l, n1, n2, nt, nx2, np1x2
           ! Intrinsic Functions 
           intrinsic :: conjg,max,mod
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'C' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTRTTF', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 ) then
              if( n==1 ) then
                 if( normaltransr ) then
                    arf( 0 ) = a( 0, 0 )
                 else
                    arf( 0 ) = conjg( a( 0, 0 ) )
                 end if
              end if
              return
           end if
           ! size of array arf(1:2,0:nt-1)
           nt = n*( n+1 ) / 2
           ! set n1 and n2 depending on lower: for n even n1=n2=k
           if( lower ) then
              n2 = n / 2
              n1 = n - n2
           else
              n1 = n / 2
              n2 = n - n1
           end if
           ! if n is odd, set nisodd = .true., lda=n+1 and a is (n+1)--by--k2.
           ! if n is even, set k = n/2 and nisodd = .false., lda=n and a is
           ! n--by--(n+1)/2.
           if( mod( n, 2 )==0 ) then
              k = n / 2
              nisodd = .false.
              if( .not.lower )np1x2 = n + n + 2
           else
              nisodd = .true.
              if( .not.lower )nx2 = n + n
           end if
           if( nisodd ) then
              ! n is odd
              if( normaltransr ) then
                 ! n is odd and transr = 'n'
                 if( lower ) then
                   ! srpa for lower, normal and n is odd ( a(0:n-1,0:n1-1) )
                   ! t1 -> a(0,0), t2 -> a(0,1), s -> a(n1,0)
                   ! t1 -> a(0), t2 -> a(n), s -> a(n1); lda=n
                    ij = 0
                    do j = 0, n2
                       do i = n1, n2 + j
                          arf( ij ) = conjg( a( n2+j, i ) )
                          ij = ij + 1
                       end do
                       do i = j, n - 1
                          arf( ij ) = a( i, j )
                          ij = ij + 1
                       end do
                    end do
                 else
                   ! srpa for upper, normal and n is odd ( a(0:n-1,0:n2-1)
                   ! t1 -> a(n1+1,0), t2 -> a(n1,0), s -> a(0,0)
                   ! t1 -> a(n2), t2 -> a(n1), s -> a(0); lda=n
                    ij = nt - n
                    do j = n - 1, n1, -1
                       do i = 0, j
                          arf( ij ) = a( i, j )
                          ij = ij + 1
                       end do
                       do l = j - n1, n1 - 1
                          arf( ij ) = conjg( a( j-n1, l ) )
                          ij = ij + 1
                       end do
                       ij = ij - nx2
                    end do
                 end if
              else
                 ! n is odd and transr = 'c'
                 if( lower ) then
                    ! srpa for lower, transpose and n is odd
                    ! t1 -> a(0,0) , t2 -> a(1,0) , s -> a(0,n1)
                    ! t1 -> a(0+0) , t2 -> a(1+0) , s -> a(0+n1*n1); lda=n1
                    ij = 0
                    do j = 0, n2 - 1
                       do i = 0, j
                          arf( ij ) = conjg( a( j, i ) )
                          ij = ij + 1
                       end do
                       do i = n1 + j, n - 1
                          arf( ij ) = a( i, n1+j )
                          ij = ij + 1
                       end do
                    end do
                    do j = n2, n - 1
                       do i = 0, n1 - 1
                          arf( ij ) = conjg( a( j, i ) )
                          ij = ij + 1
                       end do
                    end do
                 else
                    ! srpa for upper, transpose and n is odd
                    ! t1 -> a(0,n1+1), t2 -> a(0,n1), s -> a(0,0)
                    ! t1 -> a(n2*n2), t2 -> a(n1*n2), s -> a(0); lda=n2
                    ij = 0
                    do j = 0, n1
                       do i = n1, n - 1
                          arf( ij ) = conjg( a( j, i ) )
                          ij = ij + 1
                       end do
                    end do
                    do j = 0, n1 - 1
                       do i = 0, j
                          arf( ij ) = a( i, j )
                          ij = ij + 1
                       end do
                       do l = n2 + j, n - 1
                          arf( ij ) = conjg( a( n2+j, l ) )
                          ij = ij + 1
                       end do
                    end do
                 end if
              end if
           else
              ! n is even
              if( normaltransr ) then
                 ! n is even and transr = 'n'
                 if( lower ) then
                    ! srpa for lower, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(1,0), t2 -> a(0,0), s -> a(k+1,0)
                    ! t1 -> a(1), t2 -> a(0), s -> a(k+1); lda=n+1
                    ij = 0
                    do j = 0, k - 1
                       do i = k, k + j
                          arf( ij ) = conjg( a( k+j, i ) )
                          ij = ij + 1
                       end do
                       do i = j, n - 1
                          arf( ij ) = a( i, j )
                          ij = ij + 1
                       end do
                    end do
                 else
                    ! srpa for upper, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(k+1,0) ,  t2 -> a(k,0),   s -> a(0,0)
                    ! t1 -> a(k+1), t2 -> a(k), s -> a(0); lda=n+1
                    ij = nt - n - 1
                    do j = n - 1, k, -1
                       do i = 0, j
                          arf( ij ) = a( i, j )
                          ij = ij + 1
                       end do
                       do l = j - k, k - 1
                          arf( ij ) = conjg( a( j-k, l ) )
                          ij = ij + 1
                       end do
                       ij = ij - np1x2
                    end do
                 end if
              else
                 ! n is even and transr = 'c'
                 if( lower ) then
                    ! srpa for lower, transpose and n is even (see paper, a=b)
                    ! t1 -> a(0,1) , t2 -> a(0,0) , s -> a(0,k+1) :
                    ! t1 -> a(0+k) , t2 -> a(0+0) , s -> a(0+k*(k+1)); lda=k
                    ij = 0
                    j = k
                    do i = k, n - 1
                       arf( ij ) = a( i, j )
                       ij = ij + 1
                    end do
                    do j = 0, k - 2
                       do i = 0, j
                          arf( ij ) = conjg( a( j, i ) )
                          ij = ij + 1
                       end do
                       do i = k + 1 + j, n - 1
                          arf( ij ) = a( i, k+1+j )
                          ij = ij + 1
                       end do
                    end do
                    do j = k - 1, n - 1
                       do i = 0, k - 1
                          arf( ij ) = conjg( a( j, i ) )
                          ij = ij + 1
                       end do
                    end do
                 else
                    ! srpa for upper, transpose and n is even (see paper, a=b)
                    ! t1 -> a(0,k+1) , t2 -> a(0,k) , s -> a(0,0)
                    ! t1 -> a(0+k*(k+1)) , t2 -> a(0+k*k) , s -> a(0+0)); lda=k
                    ij = 0
                    do j = 0, k
                       do i = k, n - 1
                          arf( ij ) = conjg( a( j, i ) )
                          ij = ij + 1
                       end do
                    end do
                    do j = 0, k - 2
                       do i = 0, j
                          arf( ij ) = a( i, j )
                          ij = ij + 1
                       end do
                       do l = k + 1 + j, n - 1
                          arf( ij ) = conjg( a( k+1+j, l ) )
                          ij = ij + 1
                       end do
                    end do
                    ! note that here j = k-1
                    do i = 0, j
                       arf( ij ) = a( i, j )
                       ij = ij + 1
                    end do
                 end if
              end if
           end if
           return
     end subroutine stdlib_ctrttf


     pure subroutine stdlib_ctrttp( uplo, n, a, lda, ap, info )
     !! CTRTTP copies a triangular matrix A from full format (TR) to standard
     !! packed format (TP).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n, lda
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: ap(*)
        ! =====================================================================
           ! Parameters 
           ! Local Scalars 
           logical(lk) :: lower
           integer(ilp) :: i, j, k
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTRTTP', -info )
              return
           end if
           if( lower ) then
              k = 0
              do j = 1, n
                 do i = j, n
                    k = k + 1
                    ap( k ) = a( i, j )
                 end do
              end do
           else
              k = 0
              do j = 1, n
                 do i = 1, j
                    k = k + 1
                    ap( k ) = a( i, j )
                 end do
              end do
           end if
           return
     end subroutine stdlib_ctrttp


     pure subroutine stdlib_ctzrzf( m, n, a, lda, tau, work, lwork, info )
     !! CTZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
     !! to upper triangular form by means of unitary transformations.
     !! The upper trapezoidal matrix A is factored as
     !! A = ( R  0 ) * Z,
     !! where Z is an N-by-N unitary matrix and R is an M-by-M upper
     !! triangular matrix.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iws, ki, kk, ldwork, lwkmin, lwkopt, m1, mu, nb, nbmin, &
                     nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<m ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info==0 ) then
              if( m==0 .or. m==n ) then
                 lwkopt = 1
                 lwkmin = 1
              else
                 ! determine the block size.
                 nb = stdlib_ilaenv( 1, 'CGERQF', ' ', m, n, -1, -1 )
                 lwkopt = m*nb
                 lwkmin = max( 1, m )
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -7
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTZRZF', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 ) then
              return
           else if( m==n ) then
              do i = 1, n
                 tau( i ) = czero
              end do
              return
           end if
           nbmin = 2
           nx = 1
           iws = m
           if( nb>1 .and. nb<m ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'CGERQF', ' ', m, n, -1, -1 ) )
              if( nx<m ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = m
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'CGERQF', ' ', m, n, -1,-1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<m .and. nx<m ) then
              ! use blocked code initially.
              ! the last kk rows are handled by the block method.
              m1 = min( m+1, n )
              ki = ( ( m-nx-1 ) / nb )*nb
              kk = min( m, ki+nb )
              do i = m - kk + ki + 1, m - kk + 1, -nb
                 ib = min( m-i+1, nb )
                 ! compute the tz factorization of the current block
                 ! a(i:i+ib-1,i:n)
                 call stdlib_clatrz( ib, n-i+1, n-m, a( i, i ), lda, tau( i ),work )
                 if( i>1 ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i+ib-1) . . . h(i+1) h(i)
                    call stdlib_clarzt( 'BACKWARD', 'ROWWISE', n-m, ib, a( i, m1 ),lda, tau( i ), &
                              work, ldwork )
                    ! apply h to a(1:i-1,i:n) from the right
                    call stdlib_clarzb( 'RIGHT', 'NO TRANSPOSE', 'BACKWARD','ROWWISE', i-1, n-i+1,&
                     ib, n-m, a( i, m1 ),lda, work, ldwork, a( 1, i ), lda,work( ib+1 ), ldwork )
                               
                 end if
              end do
              mu = i + nb - 1
           else
              mu = m
           end if
           ! use unblocked code to factor the last or only block
           if( mu>0 )call stdlib_clatrz( mu, n, n-m, a, lda, tau, work )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_ctzrzf


     subroutine stdlib_cunbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
     !! CUNBDB simultaneously bidiagonalizes the blocks of an M-by-M
     !! partitioned unitary matrix X:
     !! [ B11 | B12 0  0 ]
     !! [ X11 | X12 ]   [ P1 |    ] [  0  |  0 -I  0 ] [ Q1 |    ]**H
     !! X = [-----------] = [---------] [----------------] [---------]   .
     !! [ X21 | X22 ]   [    | P2 ] [ B21 | B22 0  0 ] [    | Q2 ]
     !! [  0  |  0  0  I ]
     !! X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
     !! not the case, then X must be transposed and/or permuted. This can be
     !! done in constant time using the TRANS and SIGNS options. See CUNCSD
     !! for details.)
     !! The unitary matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
     !! (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
     !! represented implicitly by Householder vectors.
     !! B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
     !! implicitly by angles THETA, PHI.
               ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: signs, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldx11, ldx12, ldx21, ldx22, lwork, m, p, q
           ! Array Arguments 
           real(sp), intent(out) :: phi(*), theta(*)
           complex(sp), intent(out) :: taup1(*), taup2(*), tauq1(*), tauq2(*), work(*)
           complex(sp), intent(inout) :: x11(ldx11,*), x12(ldx12,*), x21(ldx21,*), x22(ldx22,*)
                     
        ! ====================================================================
           ! Parameters 
           real(sp), parameter :: realone = 1.0_sp
           
           
           ! Local Scalars 
           logical(lk) :: colmajor, lquery
           integer(ilp) :: i, lworkmin, lworkopt
           real(sp) :: z1, z2, z3, z4
           ! Intrinsic Functions
           intrinsic :: atan2,cos,max,min,sin
           intrinsic :: cmplx,conjg
           ! Executable Statements 
           ! test input arguments
           info = 0
           colmajor = .not. stdlib_lsame( trans, 'T' )
           if( .not. stdlib_lsame( signs, 'O' ) ) then
              z1 = realone
              z2 = realone
              z3 = realone
              z4 = realone
           else
              z1 = realone
              z2 = -realone
              z3 = realone
              z4 = -realone
           end if
           lquery = lwork == -1
           if( m < 0 ) then
              info = -3
           else if( p < 0 .or. p > m ) then
              info = -4
           else if( q < 0 .or. q > p .or. q > m-p .or.q > m-q ) then
              info = -5
           else if( colmajor .and. ldx11 < max( 1, p ) ) then
              info = -7
           else if( .not.colmajor .and. ldx11 < max( 1, q ) ) then
              info = -7
           else if( colmajor .and. ldx12 < max( 1, p ) ) then
              info = -9
           else if( .not.colmajor .and. ldx12 < max( 1, m-q ) ) then
              info = -9
           else if( colmajor .and. ldx21 < max( 1, m-p ) ) then
              info = -11
           else if( .not.colmajor .and. ldx21 < max( 1, q ) ) then
              info = -11
           else if( colmajor .and. ldx22 < max( 1, m-p ) ) then
              info = -13
           else if( .not.colmajor .and. ldx22 < max( 1, m-q ) ) then
              info = -13
           end if
           ! compute workspace
           if( info == 0 ) then
              lworkopt = m - q
              lworkmin = m - q
              work(1) = lworkopt
              if( lwork < lworkmin .and. .not. lquery ) then
                 info = -21
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'XORBDB', -info )
              return
           else if( lquery ) then
              return
           end if
           ! handle column-major and row-major separately
           if( colmajor ) then
              ! reduce columns 1, ..., q of x11, x12, x21, and x22
              do i = 1, q
                 if( i == 1 ) then
                    call stdlib_cscal( p-i+1, cmplx( z1, 0.0_sp,KIND=sp), x11(i,i), 1 )
                 else
                    call stdlib_cscal( p-i+1, cmplx( z1*cos(phi(i-1)), 0.0_sp,KIND=sp),x11(i,i), &
                              1 )
                    call stdlib_caxpy( p-i+1, cmplx( -z1*z3*z4*sin(phi(i-1)),0.0_sp,KIND=sp), x12(&
                              i,i-1), 1, x11(i,i), 1 )
                 end if
                 if( i == 1 ) then
                    call stdlib_cscal( m-p-i+1, cmplx( z2, 0.0_sp,KIND=sp), x21(i,i), 1 )
                 else
                    call stdlib_cscal( m-p-i+1, cmplx( z2*cos(phi(i-1)), 0.0_sp,KIND=sp),x21(i,i),&
                               1 )
                    call stdlib_caxpy( m-p-i+1, cmplx( -z2*z3*z4*sin(phi(i-1)),0.0_sp,KIND=sp), &
                              x22(i,i-1), 1, x21(i,i), 1 )
                 end if
                 theta(i) = atan2( stdlib_scnrm2( m-p-i+1, x21(i,i), 1 ),stdlib_scnrm2( p-i+1, &
                           x11(i,i), 1 ) )
                 if( p > i ) then
                    call stdlib_clarfgp( p-i+1, x11(i,i), x11(i+1,i), 1, taup1(i) )
                 else if ( p == i ) then
                    call stdlib_clarfgp( p-i+1, x11(i,i), x11(i,i), 1, taup1(i) )
                 end if
                 x11(i,i) = cone
                 if ( m-p > i ) then
                    call stdlib_clarfgp( m-p-i+1, x21(i,i), x21(i+1,i), 1,taup2(i) )
                 else if ( m-p == i ) then
                    call stdlib_clarfgp( m-p-i+1, x21(i,i), x21(i,i), 1,taup2(i) )
                 end if
                 x21(i,i) = cone
                 if ( q > i ) then
                    call stdlib_clarf( 'L', p-i+1, q-i, x11(i,i), 1,conjg(taup1(i)), x11(i,i+1), &
                              ldx11, work )
                    call stdlib_clarf( 'L', m-p-i+1, q-i, x21(i,i), 1,conjg(taup2(i)), x21(i,i+1),&
                               ldx21, work )
                 end if
                 if ( m-q+1 > i ) then
                    call stdlib_clarf( 'L', p-i+1, m-q-i+1, x11(i,i), 1,conjg(taup1(i)), x12(i,i),&
                               ldx12, work )
                    call stdlib_clarf( 'L', m-p-i+1, m-q-i+1, x21(i,i), 1,conjg(taup2(i)), x22(i,&
                              i), ldx22, work )
                 end if
                 if( i < q ) then
                    call stdlib_cscal( q-i, cmplx( -z1*z3*sin(theta(i)), 0.0_sp,KIND=sp),x11(i,i+&
                              1), ldx11 )
                    call stdlib_caxpy( q-i, cmplx( z2*z3*cos(theta(i)), 0.0_sp,KIND=sp),x21(i,i+1)&
                              , ldx21, x11(i,i+1), ldx11 )
                 end if
                 call stdlib_cscal( m-q-i+1, cmplx( -z1*z4*sin(theta(i)), 0.0_sp,KIND=sp),x12(i,i)&
                           , ldx12 )
                 call stdlib_caxpy( m-q-i+1, cmplx( z2*z4*cos(theta(i)), 0.0_sp,KIND=sp),x22(i,i),&
                            ldx22, x12(i,i), ldx12 )
                 if( i < q )phi(i) = atan2( stdlib_scnrm2( q-i, x11(i,i+1), ldx11 ),stdlib_scnrm2(&
                            m-q-i+1, x12(i,i), ldx12 ) )
                 if( i < q ) then
                    call stdlib_clacgv( q-i, x11(i,i+1), ldx11 )
                    if ( i == q-1 ) then
                       call stdlib_clarfgp( q-i, x11(i,i+1), x11(i,i+1), ldx11,tauq1(i) )
                    else
                       call stdlib_clarfgp( q-i, x11(i,i+1), x11(i,i+2), ldx11,tauq1(i) )
                    end if
                    x11(i,i+1) = cone
                 end if
                 if ( m-q+1 > i ) then
                    call stdlib_clacgv( m-q-i+1, x12(i,i), ldx12 )
                    if ( m-q == i ) then
                       call stdlib_clarfgp( m-q-i+1, x12(i,i), x12(i,i), ldx12,tauq2(i) )
                    else
                       call stdlib_clarfgp( m-q-i+1, x12(i,i), x12(i,i+1), ldx12,tauq2(i) )
                                 
                    end if
                 end if
                 x12(i,i) = cone
                 if( i < q ) then
                    call stdlib_clarf( 'R', p-i, q-i, x11(i,i+1), ldx11, tauq1(i),x11(i+1,i+1), &
                              ldx11, work )
                    call stdlib_clarf( 'R', m-p-i, q-i, x11(i,i+1), ldx11, tauq1(i),x21(i+1,i+1), &
                              ldx21, work )
                 end if
                 if ( p > i ) then
                    call stdlib_clarf( 'R', p-i, m-q-i+1, x12(i,i), ldx12, tauq2(i),x12(i+1,i), &
                              ldx12, work )
                 end if
                 if ( m-p > i ) then
                    call stdlib_clarf( 'R', m-p-i, m-q-i+1, x12(i,i), ldx12,tauq2(i), x22(i+1,i), &
                              ldx22, work )
                 end if
                 if( i < q )call stdlib_clacgv( q-i, x11(i,i+1), ldx11 )
                 call stdlib_clacgv( m-q-i+1, x12(i,i), ldx12 )
              end do
              ! reduce columns q + 1, ..., p of x12, x22
              do i = q + 1, p
                 call stdlib_cscal( m-q-i+1, cmplx( -z1*z4, 0.0_sp,KIND=sp), x12(i,i),ldx12 )
                           
                 call stdlib_clacgv( m-q-i+1, x12(i,i), ldx12 )
                 if ( i >= m-q ) then
                    call stdlib_clarfgp( m-q-i+1, x12(i,i), x12(i,i), ldx12,tauq2(i) )
                 else
                    call stdlib_clarfgp( m-q-i+1, x12(i,i), x12(i,i+1), ldx12,tauq2(i) )
                 end if
                 x12(i,i) = cone
                 if ( p > i ) then
                    call stdlib_clarf( 'R', p-i, m-q-i+1, x12(i,i), ldx12, tauq2(i),x12(i+1,i), &
                              ldx12, work )
                 end if
                 if( m-p-q >= 1 )call stdlib_clarf( 'R', m-p-q, m-q-i+1, x12(i,i), ldx12,tauq2(i),&
                            x22(q+1,i), ldx22, work )
                 call stdlib_clacgv( m-q-i+1, x12(i,i), ldx12 )
              end do
              ! reduce columns p + 1, ..., m - q of x12, x22
              do i = 1, m - p - q
                 call stdlib_cscal( m-p-q-i+1, cmplx( z2*z4, 0.0_sp,KIND=sp),x22(q+i,p+i), ldx22 )
                           
                 call stdlib_clacgv( m-p-q-i+1, x22(q+i,p+i), ldx22 )
                 call stdlib_clarfgp( m-p-q-i+1, x22(q+i,p+i), x22(q+i,p+i+1),ldx22, tauq2(p+i) )
                           
                 x22(q+i,p+i) = cone
                 call stdlib_clarf( 'R', m-p-q-i, m-p-q-i+1, x22(q+i,p+i), ldx22,tauq2(p+i), x22(&
                           q+i+1,p+i), ldx22, work )
                 call stdlib_clacgv( m-p-q-i+1, x22(q+i,p+i), ldx22 )
              end do
           else
              ! reduce columns 1, ..., q of x11, x12, x21, x22
              do i = 1, q
                 if( i == 1 ) then
                    call stdlib_cscal( p-i+1, cmplx( z1, 0.0_sp,KIND=sp), x11(i,i),ldx11 )
                 else
                    call stdlib_cscal( p-i+1, cmplx( z1*cos(phi(i-1)), 0.0_sp,KIND=sp),x11(i,i), &
                              ldx11 )
                    call stdlib_caxpy( p-i+1, cmplx( -z1*z3*z4*sin(phi(i-1)),0.0_sp,KIND=sp), x12(&
                              i-1,i), ldx12, x11(i,i), ldx11 )
                 end if
                 if( i == 1 ) then
                    call stdlib_cscal( m-p-i+1, cmplx( z2, 0.0_sp,KIND=sp), x21(i,i),ldx21 )
                              
                 else
                    call stdlib_cscal( m-p-i+1, cmplx( z2*cos(phi(i-1)), 0.0_sp,KIND=sp),x21(i,i),&
                               ldx21 )
                    call stdlib_caxpy( m-p-i+1, cmplx( -z2*z3*z4*sin(phi(i-1)),0.0_sp,KIND=sp), &
                              x22(i-1,i), ldx22, x21(i,i), ldx21 )
                 end if
                 theta(i) = atan2( stdlib_scnrm2( m-p-i+1, x21(i,i), ldx21 ),stdlib_scnrm2( p-i+1,&
                            x11(i,i), ldx11 ) )
                 call stdlib_clacgv( p-i+1, x11(i,i), ldx11 )
                 call stdlib_clacgv( m-p-i+1, x21(i,i), ldx21 )
                 call stdlib_clarfgp( p-i+1, x11(i,i), x11(i,i+1), ldx11, taup1(i) )
                 x11(i,i) = cone
                 if ( i == m-p ) then
                    call stdlib_clarfgp( m-p-i+1, x21(i,i), x21(i,i), ldx21,taup2(i) )
                 else
                    call stdlib_clarfgp( m-p-i+1, x21(i,i), x21(i,i+1), ldx21,taup2(i) )
                 end if
                 x21(i,i) = cone
                 call stdlib_clarf( 'R', q-i, p-i+1, x11(i,i), ldx11, taup1(i),x11(i+1,i), ldx11, &
                           work )
                 call stdlib_clarf( 'R', m-q-i+1, p-i+1, x11(i,i), ldx11, taup1(i),x12(i,i), &
                           ldx12, work )
                 call stdlib_clarf( 'R', q-i, m-p-i+1, x21(i,i), ldx21, taup2(i),x21(i+1,i), &
                           ldx21, work )
                 call stdlib_clarf( 'R', m-q-i+1, m-p-i+1, x21(i,i), ldx21,taup2(i), x22(i,i), &
                           ldx22, work )
                 call stdlib_clacgv( p-i+1, x11(i,i), ldx11 )
                 call stdlib_clacgv( m-p-i+1, x21(i,i), ldx21 )
                 if( i < q ) then
                    call stdlib_cscal( q-i, cmplx( -z1*z3*sin(theta(i)), 0.0_sp,KIND=sp),x11(i+1,&
                              i), 1 )
                    call stdlib_caxpy( q-i, cmplx( z2*z3*cos(theta(i)), 0.0_sp,KIND=sp),x21(i+1,i)&
                              , 1, x11(i+1,i), 1 )
                 end if
                 call stdlib_cscal( m-q-i+1, cmplx( -z1*z4*sin(theta(i)), 0.0_sp,KIND=sp),x12(i,i)&
                           , 1 )
                 call stdlib_caxpy( m-q-i+1, cmplx( z2*z4*cos(theta(i)), 0.0_sp,KIND=sp),x22(i,i),&
                            1, x12(i,i), 1 )
                 if( i < q )phi(i) = atan2( stdlib_scnrm2( q-i, x11(i+1,i), 1 ),stdlib_scnrm2( m-&
                           q-i+1, x12(i,i), 1 ) )
                 if( i < q ) then
                    call stdlib_clarfgp( q-i, x11(i+1,i), x11(i+2,i), 1, tauq1(i) )
                    x11(i+1,i) = cone
                 end if
                 call stdlib_clarfgp( m-q-i+1, x12(i,i), x12(i+1,i), 1, tauq2(i) )
                 x12(i,i) = cone
                 if( i < q ) then
                    call stdlib_clarf( 'L', q-i, p-i, x11(i+1,i), 1,conjg(tauq1(i)), x11(i+1,i+1),&
                               ldx11, work )
                    call stdlib_clarf( 'L', q-i, m-p-i, x11(i+1,i), 1,conjg(tauq1(i)), x21(i+1,i+&
                              1), ldx21, work )
                 end if
                 call stdlib_clarf( 'L', m-q-i+1, p-i, x12(i,i), 1, conjg(tauq2(i)),x12(i,i+1), &
                           ldx12, work )
                 if ( m-p > i ) then
                    call stdlib_clarf( 'L', m-q-i+1, m-p-i, x12(i,i), 1,conjg(tauq2(i)), x22(i,i+&
                              1), ldx22, work )
                 end if
              end do
              ! reduce columns q + 1, ..., p of x12, x22
              do i = q + 1, p
                 call stdlib_cscal( m-q-i+1, cmplx( -z1*z4, 0.0_sp,KIND=sp), x12(i,i), 1 )
                 call stdlib_clarfgp( m-q-i+1, x12(i,i), x12(i+1,i), 1, tauq2(i) )
                 x12(i,i) = cone
                 if ( p > i ) then
                    call stdlib_clarf( 'L', m-q-i+1, p-i, x12(i,i), 1,conjg(tauq2(i)), x12(i,i+1),&
                               ldx12, work )
                 end if
                 if( m-p-q >= 1 )call stdlib_clarf( 'L', m-q-i+1, m-p-q, x12(i,i), 1,conjg(tauq2(&
                           i)), x22(i,q+1), ldx22, work )
              end do
              ! reduce columns p + 1, ..., m - q of x12, x22
              do i = 1, m - p - q
                 call stdlib_cscal( m-p-q-i+1, cmplx( z2*z4, 0.0_sp,KIND=sp),x22(p+i,q+i), 1 )
                           
                 call stdlib_clarfgp( m-p-q-i+1, x22(p+i,q+i), x22(p+i+1,q+i), 1,tauq2(p+i) )
                           
                 x22(p+i,q+i) = cone
                 if ( m-p-q /= i ) then
                    call stdlib_clarf( 'L', m-p-q-i+1, m-p-q-i, x22(p+i,q+i), 1,conjg(tauq2(p+i)),&
                               x22(p+i,q+i+1), ldx22,work )
                 end if
              end do
           end if
           return
     end subroutine stdlib_cunbdb


     pure subroutine stdlib_cunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
     !! CUNBDB6 orthogonalizes the column vector
     !! X = [ X1 ]
     !! [ X2 ]
     !! with respect to the columns of
     !! Q = [ Q1 ] .
     !! [ Q2 ]
     !! The columns of Q must be orthonormal.
     !! If the projection is zero according to Kahan's "twice is enough"
     !! criterion, then the zero vector is returned.
               lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x1(*), x2(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: alphasq = 0.01_sp
           real(sp), parameter :: realone = 1.0_sp
           real(sp), parameter :: realzero = 0.0_sp
           
           
           ! Local Scalars 
           integer(ilp) :: i
           real(sp) :: normsq1, normsq2, scl1, scl2, ssq1, ssq2
           ! Intrinsic Function 
           intrinsic :: max
           ! Executable Statements 
           ! test input arguments
           info = 0
           if( m1 < 0 ) then
              info = -1
           else if( m2 < 0 ) then
              info = -2
           else if( n < 0 ) then
              info = -3
           else if( incx1 < 1 ) then
              info = -5
           else if( incx2 < 1 ) then
              info = -7
           else if( ldq1 < max( 1, m1 ) ) then
              info = -9
           else if( ldq2 < max( 1, m2 ) ) then
              info = -11
           else if( lwork < n ) then
              info = -13
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'CUNBDB6', -info )
              return
           end if
           ! first, project x onto the orthogonal complement of q's column
           ! space
           scl1 = realzero
           ssq1 = realone
           call stdlib_classq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_classq( m2, x2, incx2, scl2, ssq2 )
           normsq1 = scl1**2*ssq1 + scl2**2*ssq2
           if( m1 == 0 ) then
              do i = 1, n
                 work(i) = czero
              end do
           else
              call stdlib_cgemv( 'C', m1, n, cone, q1, ldq1, x1, incx1, czero, work,1 )
           end if
           call stdlib_cgemv( 'C', m2, n, cone, q2, ldq2, x2, incx2, cone, work, 1 )
           call stdlib_cgemv( 'N', m1, n, cnegone, q1, ldq1, work, 1, cone, x1,incx1 )
           call stdlib_cgemv( 'N', m2, n, cnegone, q2, ldq2, work, 1, cone, x2,incx2 )
           scl1 = realzero
           ssq1 = realone
           call stdlib_classq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_classq( m2, x2, incx2, scl2, ssq2 )
           normsq2 = scl1**2*ssq1 + scl2**2*ssq2
           ! if projection is sufficiently large in norm, then stop.
           ! if projection is czero, then stop.
           ! otherwise, project again.
           if( normsq2 >= alphasq*normsq1 ) then
              return
           end if
           if( normsq2 == czero ) then
              return
           end if
           normsq1 = normsq2
           do i = 1, n
              work(i) = czero
           end do
           if( m1 == 0 ) then
              do i = 1, n
                 work(i) = czero
              end do
           else
              call stdlib_cgemv( 'C', m1, n, cone, q1, ldq1, x1, incx1, czero, work,1 )
           end if
           call stdlib_cgemv( 'C', m2, n, cone, q2, ldq2, x2, incx2, cone, work, 1 )
           call stdlib_cgemv( 'N', m1, n, cnegone, q1, ldq1, work, 1, cone, x1,incx1 )
           call stdlib_cgemv( 'N', m2, n, cnegone, q2, ldq2, work, 1, cone, x2,incx2 )
           scl1 = realzero
           ssq1 = realone
           call stdlib_classq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_classq( m1, x1, incx1, scl1, ssq1 )
           normsq2 = scl1**2*ssq1 + scl2**2*ssq2
           ! if second projection is sufficiently large in norm, then do
           ! nothing more. alternatively, if it shrunk significantly, then
           ! truncate it to czero.
           if( normsq2 < alphasq*normsq1 ) then
              do i = 1, m1
                 x1(i) = czero
              end do
              do i = 1, m2
                 x2(i) = czero
              end do
           end if
           return
     end subroutine stdlib_cunbdb6


     pure subroutine stdlib_cung2l( m, n, k, a, lda, tau, work, info )
     !! CUNG2L generates an m by n complex matrix Q with orthonormal columns,
     !! which is defined as the last n columns of a product of k elementary
     !! reflectors of order m
     !! Q  =  H(k) . . . H(2) H(1)
     !! as returned by CGEQLF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, ii, j, l
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 .or. n>m ) then
              info = -2
           else if( k<0 .or. k>n ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNG2L', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           ! initialise columns 1:n-k to columns of the unit matrix
           do j = 1, n - k
              do l = 1, m
                 a( l, j ) = czero
              end do
              a( m-n+j, j ) = cone
           end do
           do i = 1, k
              ii = n - k + i
              ! apply h(i) to a(1:m-k+i,1:n-k+i) from the left
              a( m-n+ii, ii ) = cone
              call stdlib_clarf( 'LEFT', m-n+ii, ii-1, a( 1, ii ), 1, tau( i ), a,lda, work )
                        
              call stdlib_cscal( m-n+ii-1, -tau( i ), a( 1, ii ), 1 )
              a( m-n+ii, ii ) = cone - tau( i )
              ! set a(m-k+i+1:m,n-k+i) to czero
              do l = m - n + ii + 1, m
                 a( l, ii ) = czero
              end do
           end do
           return
     end subroutine stdlib_cung2l


     pure subroutine stdlib_cung2r( m, n, k, a, lda, tau, work, info )
     !! CUNG2R generates an m by n complex matrix Q with orthonormal columns,
     !! which is defined as the first n columns of a product of k elementary
     !! reflectors of order m
     !! Q  =  H(1) H(2) . . . H(k)
     !! as returned by CGEQRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, l
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 .or. n>m ) then
              info = -2
           else if( k<0 .or. k>n ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNG2R', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           ! initialise columns k+1:n to columns of the unit matrix
           do j = k + 1, n
              do l = 1, m
                 a( l, j ) = czero
              end do
              a( j, j ) = cone
           end do
           do i = k, 1, -1
              ! apply h(i) to a(i:m,i:n) from the left
              if( i<n ) then
                 a( i, i ) = cone
                 call stdlib_clarf( 'LEFT', m-i+1, n-i, a( i, i ), 1, tau( i ),a( i, i+1 ), lda, &
                           work )
              end if
              if( i<m )call stdlib_cscal( m-i, -tau( i ), a( i+1, i ), 1 )
              a( i, i ) = cone - tau( i )
              ! set a(1:i-1,i) to czero
              do l = 1, i - 1
                 a( l, i ) = czero
              end do
           end do
           return
     end subroutine stdlib_cung2r


     pure subroutine stdlib_cungl2( m, n, k, a, lda, tau, work, info )
     !! CUNGL2 generates an m-by-n complex matrix Q with orthonormal rows,
     !! which is defined as the first m rows of a product of k elementary
     !! reflectors of order n
     !! Q  =  H(k)**H . . . H(2)**H H(1)**H
     !! as returned by CGELQF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, l
           ! Intrinsic Functions 
           intrinsic :: conjg,max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<m ) then
              info = -2
           else if( k<0 .or. k>m ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNGL2', -info )
              return
           end if
           ! quick return if possible
           if( m<=0 )return
           if( k<m ) then
              ! initialise rows k+1:m to rows of the unit matrix
              do j = 1, n
                 do l = k + 1, m
                    a( l, j ) = czero
                 end do
                 if( j>k .and. j<=m )a( j, j ) = cone
              end do
           end if
           do i = k, 1, -1
              ! apply h(i)**h to a(i:m,i:n) from the right
              if( i<n ) then
                 call stdlib_clacgv( n-i, a( i, i+1 ), lda )
                 if( i<m ) then
                    a( i, i ) = cone
                    call stdlib_clarf( 'RIGHT', m-i, n-i+1, a( i, i ), lda,conjg( tau( i ) ), a( &
                              i+1, i ), lda, work )
                 end if
                 call stdlib_cscal( n-i, -tau( i ), a( i, i+1 ), lda )
                 call stdlib_clacgv( n-i, a( i, i+1 ), lda )
              end if
              a( i, i ) = cone - conjg( tau( i ) )
              ! set a(i,1:i-1,i) to czero
              do l = 1, i - 1
                 a( i, l ) = czero
              end do
           end do
           return
     end subroutine stdlib_cungl2


     pure subroutine stdlib_cunglq( m, n, k, a, lda, tau, work, lwork, info )
     !! CUNGLQ generates an M-by-N complex matrix Q with orthonormal rows,
     !! which is defined as the first M rows of a product of K elementary
     !! reflectors of order N
     !! Q  =  H(k)**H . . . H(2)**H H(1)**H
     !! as returned by CGELQF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iws, j, ki, kk, l, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nb = stdlib_ilaenv( 1, 'CUNGLQ', ' ', m, n, k, -1 )
           lwkopt = max( 1, m )*nb
           work( 1 ) = lwkopt
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<m ) then
              info = -2
           else if( k<0 .or. k>m ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( lwork<max( 1, m ) .and. .not.lquery ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNGLQ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m<=0 ) then
              work( 1 ) = 1
              return
           end if
           nbmin = 2
           nx = 0
           iws = m
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'CUNGLQ', ' ', m, n, k, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = m
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'CUNGLQ', ' ', m, n, k, -1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code after the last block.
              ! the first kk rows are handled by the block method.
              ki = ( ( k-nx-1 ) / nb )*nb
              kk = min( k, ki+nb )
              ! set a(kk+1:m,1:kk) to czero.
              do j = 1, kk
                 do i = kk + 1, m
                    a( i, j ) = czero
                 end do
              end do
           else
              kk = 0
           end if
           ! use unblocked code for the last or only block.
           if( kk<m )call stdlib_cungl2( m-kk, n-kk, k-kk, a( kk+1, kk+1 ), lda,tau( kk+1 ), work,&
                      iinfo )
           if( kk>0 ) then
              ! use blocked code
              do i = ki + 1, 1, -nb
                 ib = min( nb, k-i+1 )
                 if( i+ib<=m ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i) h(i+1) . . . h(i+ib-1)
                    call stdlib_clarft( 'FORWARD', 'ROWWISE', n-i+1, ib, a( i, i ),lda, tau( i ), &
                              work, ldwork )
                    ! apply h**h to a(i+ib:m,i:n) from the right
                    call stdlib_clarfb( 'RIGHT', 'CONJUGATE TRANSPOSE', 'FORWARD','ROWWISE', m-i-&
                    ib+1, n-i+1, ib, a( i, i ),lda, work, ldwork, a( i+ib, i ), lda,work( ib+1 ), &
                              ldwork )
                 end if
                 ! apply h**h to columns i:n of current block
                 call stdlib_cungl2( ib, n-i+1, ib, a( i, i ), lda, tau( i ), work,iinfo )
                 ! set columns 1:i-1 of current block to czero
                 do j = 1, i - 1
                    do l = i, i + ib - 1
                       a( l, j ) = czero
                    end do
                 end do
              end do
           end if
           work( 1 ) = iws
           return
     end subroutine stdlib_cunglq


     pure subroutine stdlib_cungql( m, n, k, a, lda, tau, work, lwork, info )
     !! CUNGQL generates an M-by-N complex matrix Q with orthonormal columns,
     !! which is defined as the last N columns of a product of K elementary
     !! reflectors of order M
     !! Q  =  H(k) . . . H(2) H(1)
     !! as returned by CGEQLF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iws, j, kk, l, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 .or. n>m ) then
              info = -2
           else if( k<0 .or. k>n ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'CUNGQL', ' ', m, n, k, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<max( 1, n ) .and. .not.lquery ) then
                 info = -8
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNGQL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           nbmin = 2
           nx = 0
           iws = n
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'CUNGQL', ' ', m, n, k, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'CUNGQL', ' ', m, n, k, -1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code after the first block.
              ! the last kk columns are handled by the block method.
              kk = min( k, ( ( k-nx+nb-1 ) / nb )*nb )
              ! set a(m-kk+1:m,1:n-kk) to czero.
              do j = 1, n - kk
                 do i = m - kk + 1, m
                    a( i, j ) = czero
                 end do
              end do
           else
              kk = 0
           end if
           ! use unblocked code for the first or only block.
           call stdlib_cung2l( m-kk, n-kk, k-kk, a, lda, tau, work, iinfo )
           if( kk>0 ) then
              ! use blocked code
              do i = k - kk + 1, k, nb
                 ib = min( nb, k-i+1 )
                 if( n-k+i>1 ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i+ib-1) . . . h(i+1) h(i)
                    call stdlib_clarft( 'BACKWARD', 'COLUMNWISE', m-k+i+ib-1, ib,a( 1, n-k+i ), &
                              lda, tau( i ), work, ldwork )
                    ! apply h to a(1:m-k+i+ib-1,1:n-k+i-1) from the left
                    call stdlib_clarfb( 'LEFT', 'NO TRANSPOSE', 'BACKWARD','COLUMNWISE', m-k+i+ib-&
                    1, n-k+i-1, ib,a( 1, n-k+i ), lda, work, ldwork, a, lda,work( ib+1 ), ldwork )
                              
                 end if
                 ! apply h to rows 1:m-k+i+ib-1 of current block
                 call stdlib_cung2l( m-k+i+ib-1, ib, ib, a( 1, n-k+i ), lda,tau( i ), work, iinfo &
                           )
                 ! set rows m-k+i+ib:m of current block to czero
                 do j = n - k + i, n - k + i + ib - 1
                    do l = m - k + i + ib, m
                       a( l, j ) = czero
                    end do
                 end do
              end do
           end if
           work( 1 ) = iws
           return
     end subroutine stdlib_cungql


     pure subroutine stdlib_cungqr( m, n, k, a, lda, tau, work, lwork, info )
     !! CUNGQR generates an M-by-N complex matrix Q with orthonormal columns,
     !! which is defined as the first N columns of a product of K elementary
     !! reflectors of order M
     !! Q  =  H(1) H(2) . . . H(k)
     !! as returned by CGEQRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iws, j, ki, kk, l, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nb = stdlib_ilaenv( 1, 'CUNGQR', ' ', m, n, k, -1 )
           lwkopt = max( 1, n )*nb
           work( 1 ) = lwkopt
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 .or. n>m ) then
              info = -2
           else if( k<0 .or. k>n ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNGQR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = 1
              return
           end if
           nbmin = 2
           nx = 0
           iws = n
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'CUNGQR', ' ', m, n, k, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'CUNGQR', ' ', m, n, k, -1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code after the last block.
              ! the first kk columns are handled by the block method.
              ki = ( ( k-nx-1 ) / nb )*nb
              kk = min( k, ki+nb )
              ! set a(1:kk,kk+1:n) to czero.
              do j = kk + 1, n
                 do i = 1, kk
                    a( i, j ) = czero
                 end do
              end do
           else
              kk = 0
           end if
           ! use unblocked code for the last or only block.
           if( kk<n )call stdlib_cung2r( m-kk, n-kk, k-kk, a( kk+1, kk+1 ), lda,tau( kk+1 ), work,&
                      iinfo )
           if( kk>0 ) then
              ! use blocked code
              do i = ki + 1, 1, -nb
                 ib = min( nb, k-i+1 )
                 if( i+ib<=n ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i) h(i+1) . . . h(i+ib-1)
                    call stdlib_clarft( 'FORWARD', 'COLUMNWISE', m-i+1, ib,a( i, i ), lda, tau( i &
                              ), work, ldwork )
                    ! apply h to a(i:m,i+ib:n) from the left
                    call stdlib_clarfb( 'LEFT', 'NO TRANSPOSE', 'FORWARD','COLUMNWISE', m-i+1, n-&
                    i-ib+1, ib,a( i, i ), lda, work, ldwork, a( i, i+ib ),lda, work( ib+1 ), &
                              ldwork )
                 end if
                 ! apply h to rows i:m of current block
                 call stdlib_cung2r( m-i+1, ib, ib, a( i, i ), lda, tau( i ), work,iinfo )
                 ! set rows 1:i-1 of current block to czero
                 do j = i, i + ib - 1
                    do l = 1, i - 1
                       a( l, j ) = czero
                    end do
                 end do
              end do
           end if
           work( 1 ) = iws
           return
     end subroutine stdlib_cungqr


     pure subroutine stdlib_cungr2( m, n, k, a, lda, tau, work, info )
     !! CUNGR2 generates an m by n complex matrix Q with orthonormal rows,
     !! which is defined as the last m rows of a product of k elementary
     !! reflectors of order n
     !! Q  =  H(1)**H H(2)**H . . . H(k)**H
     !! as returned by CGERQF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, ii, j, l
           ! Intrinsic Functions 
           intrinsic :: conjg,max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<m ) then
              info = -2
           else if( k<0 .or. k>m ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNGR2', -info )
              return
           end if
           ! quick return if possible
           if( m<=0 )return
           if( k<m ) then
              ! initialise rows 1:m-k to rows of the unit matrix
              do j = 1, n
                 do l = 1, m - k
                    a( l, j ) = czero
                 end do
                 if( j>n-m .and. j<=n-k )a( m-n+j, j ) = cone
              end do
           end if
           do i = 1, k
              ii = m - k + i
              ! apply h(i)**h to a(1:m-k+i,1:n-k+i) from the right
              call stdlib_clacgv( n-m+ii-1, a( ii, 1 ), lda )
              a( ii, n-m+ii ) = cone
              call stdlib_clarf( 'RIGHT', ii-1, n-m+ii, a( ii, 1 ), lda,conjg( tau( i ) ), a, lda,&
                         work )
              call stdlib_cscal( n-m+ii-1, -tau( i ), a( ii, 1 ), lda )
              call stdlib_clacgv( n-m+ii-1, a( ii, 1 ), lda )
              a( ii, n-m+ii ) = cone - conjg( tau( i ) )
              ! set a(m-k+i,n-k+i+1:n) to czero
              do l = n - m + ii + 1, n
                 a( ii, l ) = czero
              end do
           end do
           return
     end subroutine stdlib_cungr2


     pure subroutine stdlib_cungrq( m, n, k, a, lda, tau, work, lwork, info )
     !! CUNGRQ generates an M-by-N complex matrix Q with orthonormal rows,
     !! which is defined as the last M rows of a product of K elementary
     !! reflectors of order N
     !! Q  =  H(1)**H H(2)**H . . . H(k)**H
     !! as returned by CGERQF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, ii, iinfo, iws, j, kk, l, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<m ) then
              info = -2
           else if( k<0 .or. k>m ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'CUNGRQ', ' ', m, n, k, -1 )
                 lwkopt = m*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<max( 1, m ) .and. .not.lquery ) then
                 info = -8
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNGRQ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m<=0 ) then
              return
           end if
           nbmin = 2
           nx = 0
           iws = m
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'CUNGRQ', ' ', m, n, k, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = m
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'CUNGRQ', ' ', m, n, k, -1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code after the first block.
              ! the last kk rows are handled by the block method.
              kk = min( k, ( ( k-nx+nb-1 ) / nb )*nb )
              ! set a(1:m-kk,n-kk+1:n) to czero.
              do j = n - kk + 1, n
                 do i = 1, m - kk
                    a( i, j ) = czero
                 end do
              end do
           else
              kk = 0
           end if
           ! use unblocked code for the first or only block.
           call stdlib_cungr2( m-kk, n-kk, k-kk, a, lda, tau, work, iinfo )
           if( kk>0 ) then
              ! use blocked code
              do i = k - kk + 1, k, nb
                 ib = min( nb, k-i+1 )
                 ii = m - k + i
                 if( ii>1 ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i+ib-1) . . . h(i+1) h(i)
                    call stdlib_clarft( 'BACKWARD', 'ROWWISE', n-k+i+ib-1, ib,a( ii, 1 ), lda, &
                              tau( i ), work, ldwork )
                    ! apply h**h to a(1:m-k+i-1,1:n-k+i+ib-1) from the right
                    call stdlib_clarfb( 'RIGHT', 'CONJUGATE TRANSPOSE', 'BACKWARD','ROWWISE', ii-&
                    1, n-k+i+ib-1, ib, a( ii, 1 ),lda, work, ldwork, a, lda, work( ib+1 ),ldwork )
                              
                 end if
                 ! apply h**h to columns 1:n-k+i+ib-1 of current block
                 call stdlib_cungr2( ib, n-k+i+ib-1, ib, a( ii, 1 ), lda, tau( i ),work, iinfo )
                           
                 ! set columns n-k+i+ib:n of current block to czero
                 do l = n - k + i + ib, n
                    do j = ii, ii + ib - 1
                       a( j, l ) = czero
                    end do
                 end do
              end do
           end if
           work( 1 ) = iws
           return
     end subroutine stdlib_cungrq


     pure subroutine stdlib_cungtsqr_row( m, n, mb, nb, a, lda, t, ldt, work,lwork, info )
     !! CUNGTSQR_ROW generates an M-by-N complex matrix Q_out with
     !! orthonormal columns from the output of CLATSQR. These N orthonormal
     !! columns are the first N columns of a product of complex unitary
     !! matrices Q(k)_in of order M, which are returned by CLATSQR in
     !! a special format.
     !! Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).
     !! The input matrices Q(k)_in are stored in row and column blocks in A.
     !! See the documentation of CLATSQR for more details on the format of
     !! Q(k)_in, where each Q(k)_in is represented by block Householder
     !! transformations. This routine calls an auxiliary routine CLARFB_GETT,
     !! where the computation is performed on each individual block. The
     !! algorithm first sweeps NB-sized column blocks from the right to left
     !! starting in the bottom row block and continues to the top row block
     !! (hence _ROW in the routine name). This sweep is in reverse order of
     !! the order in which CLATSQR generates the output blocks.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldt, lwork, m, n, mb, nb
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: t(ldt,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: nblocal, mb2, m_plus_one, itmp, ib_bottom, lworkopt, &
                     num_all_row_blocks, jb_t, ib, imb, kb, kb_last, knb, mb1
           ! Local Arrays 
           complex(sp) :: dummy(1,1)
           ! Intrinsic Functions 
           intrinsic :: cmplx,max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           lquery  = lwork==-1
           if( m<0 ) then
              info = -1
           else if( n<0 .or. m<n ) then
              info = -2
           else if( mb<=n ) then
              info = -3
           else if( nb<1 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldt<max( 1, min( nb, n ) ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           nblocal = min( nb, n )
           ! determine the workspace size.
           if( info==0 ) then
              lworkopt = nblocal * max( nblocal, ( n - nblocal ) )
           end if
           ! handle error in the input parameters and handle the workspace query.
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNGTSQR_ROW', -info )
              return
           else if ( lquery ) then
              work( 1 ) = cmplx( lworkopt,KIND=sp)
              return
           end if
           ! quick return if possible
           if( min( m, n )==0 ) then
              work( 1 ) = cmplx( lworkopt,KIND=sp)
              return
           end if
           ! (0) set the upper-triangular part of the matrix a to zero and
           ! its diagonal elements to one.
           call stdlib_claset('U', m, n, czero, cone, a, lda )
           ! kb_last is the column index of the last column block reflector
           ! in the matrices t and v.
           kb_last = ( ( n-1 ) / nblocal ) * nblocal + 1
           ! (1) bottom-up loop over row blocks of a, except the top row block.
           ! note: if mb>=m, then the loop is never executed.
           if ( mb<m ) then
              ! mb2 is the row blocking size for the row blocks before the
              ! first top row block in the matrix a. ib is the row index for
              ! the row blocks in the matrix a before the first top row block.
              ! ib_bottom is the row index for the last bottom row block
              ! in the matrix a. jb_t is the column index of the corresponding
              ! column block in the matrix t.
              ! initialize variables.
              ! num_all_row_blocks is the number of row blocks in the matrix a
              ! including the first row block.
              mb2 = mb - n
              m_plus_one = m + 1
              itmp = ( m - mb - 1 ) / mb2
              ib_bottom = itmp * mb2 + mb + 1
              num_all_row_blocks = itmp + 2
              jb_t = num_all_row_blocks * n + 1
              do ib = ib_bottom, mb+1, -mb2
                 ! determine the block size imb for the current row block
                 ! in the matrix a.
                 imb = min( m_plus_one - ib, mb2 )
                 ! determine the column index jb_t for the current column block
                 ! in the matrix t.
                 jb_t = jb_t - n
                 ! apply column blocks of h in the row block from right to left.
                 ! kb is the column index of the current column block reflector
                 ! in the matrices t and v.
                 do kb = kb_last, 1, -nblocal
                    ! determine the size of the current column block knb in
                    ! the matrices t and v.
                    knb = min( nblocal, n - kb + 1 )
                    call stdlib_clarfb_gett( 'I', imb, n-kb+1, knb,t( 1, jb_t+kb-1 ), ldt, a( kb, &
                              kb ), lda,a( ib, kb ), lda, work, knb )
                 end do
              end do
           end if
           ! (2) top row block of a.
           ! note: if mb>=m, then we have only one row block of a of size m
           ! and we work on the entire matrix a.
           mb1 = min( mb, m )
           ! apply column blocks of h in the top row block from right to left.
           ! kb is the column index of the current block reflector in
           ! the matrices t and v.
           do kb = kb_last, 1, -nblocal
              ! determine the size of the current column block knb in
              ! the matrices t and v.
              knb = min( nblocal, n - kb + 1 )
              if( mb1-kb-knb+1==0 ) then
                 ! in stdlib_slarfb_gett parameters, when m=0, then the matrix b
                 ! does not exist, hence we need to pass a dummy array
                 ! reference dummy(1,1) to b with lddummy=1.
                 call stdlib_clarfb_gett( 'N', 0, n-kb+1, knb,t( 1, kb ), ldt, a( kb, kb ), lda,&
                           dummy( 1, 1 ), 1, work, knb )
              else
                 call stdlib_clarfb_gett( 'N', mb1-kb-knb+1, n-kb+1, knb,t( 1, kb ), ldt, a( kb, &
                           kb ), lda,a( kb+knb, kb), lda, work, knb )
              end if
           end do
           work( 1 ) = cmplx( lworkopt,KIND=sp)
           return
     end subroutine stdlib_cungtsqr_row


     pure subroutine stdlib_cunm22( side, trans, m, n, n1, n2, q, ldq, c, ldc,work, lwork, info )
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(in) :: m, n, n1, n2, ldq, ldc, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(in) :: q(ldq,*)
           complex(sp), intent(inout) :: c(ldc,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: left, lquery, notran
           integer(ilp) :: i, ldwork, len, lwkopt, nb, nq, nw
           ! Intrinsic Functions 
           intrinsic :: cmplx,max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           ! nq is the order of q;
           ! nw is the minimum dimension of work.
           if( left ) then
              nq = m
           else
              nq = n
           end if
           nw = nq
           if( n1==0 .or. n2==0 ) nw = 1
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'C' ) )&
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( n1<0 .or. n1+n2/=nq ) then
              info = -5
           else if( n2<0 ) then
              info = -6
           else if( ldq<max( 1, nq ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              lwkopt = m*n
              work( 1 ) = cmplx( lwkopt,KIND=sp)
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNM22', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              work( 1 ) = 1
              return
           end if
           ! degenerate cases (n1 = 0 or n2 = 0) are handled using stdlib_ctrmm.
           if( n1==0 ) then
              call stdlib_ctrmm( side, 'UPPER', trans, 'NON-UNIT', m, n, cone,q, ldq, c, ldc )
                        
              work( 1 ) = cone
              return
           else if( n2==0 ) then
              call stdlib_ctrmm( side, 'LOWER', trans, 'NON-UNIT', m, n, cone,q, ldq, c, ldc )
                        
              work( 1 ) = cone
              return
           end if
           ! compute the largest chunk size available from the workspace.
           nb = max( 1, min( lwork, lwkopt ) / nq )
           if( left ) then
              if( notran ) then
                 do i = 1, n, nb
                    len = min( nb, n-i+1 )
                    ldwork = m
                    ! multiply bottom part of c by q12.
                    call stdlib_clacpy( 'ALL', n1, len, c( n2+1, i ), ldc, work,ldwork )
                    call stdlib_ctrmm( 'LEFT', 'LOWER', 'NO TRANSPOSE', 'NON-UNIT',n1, len, cone, &
                              q( 1, n2+1 ), ldq, work,ldwork )
                    ! multiply top part of c by q11.
                    call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', n1, len, n2,cone, q, ldq, &
                              c( 1, i ), ldc, cone, work,ldwork )
                    ! multiply top part of c by q21.
                    call stdlib_clacpy( 'ALL', n2, len, c( 1, i ), ldc,work( n1+1 ), ldwork )
                              
                    call stdlib_ctrmm( 'LEFT', 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',n2, len, cone, &
                              q( n1+1, 1 ), ldq,work( n1+1 ), ldwork )
                    ! multiply bottom part of c by q22.
                    call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', n2, len, n1,cone, q( n1+1, &
                              n2+1 ), ldq, c( n2+1, i ), ldc,cone, work( n1+1 ), ldwork )
                    ! copy everything back.
                    call stdlib_clacpy( 'ALL', m, len, work, ldwork, c( 1, i ),ldc )
                 end do
              else
                 do i = 1, n, nb
                    len = min( nb, n-i+1 )
                    ldwork = m
                    ! multiply bottom part of c by q21**h.
                    call stdlib_clacpy( 'ALL', n2, len, c( n1+1, i ), ldc, work,ldwork )
                    call stdlib_ctrmm( 'LEFT', 'UPPER', 'CONJUGATE', 'NON-UNIT',n2, len, cone, q( &
                              n1+1, 1 ), ldq, work,ldwork )
                    ! multiply top part of c by q11**h.
                    call stdlib_cgemm( 'CONJUGATE', 'NO TRANSPOSE', n2, len, n1,cone, q, ldq, c( &
                              1, i ), ldc, cone, work,ldwork )
                    ! multiply top part of c by q12**h.
                    call stdlib_clacpy( 'ALL', n1, len, c( 1, i ), ldc,work( n2+1 ), ldwork )
                              
                    call stdlib_ctrmm( 'LEFT', 'LOWER', 'CONJUGATE', 'NON-UNIT',n1, len, cone, q( &
                              1, n2+1 ), ldq,work( n2+1 ), ldwork )
                    ! multiply bottom part of c by q22**h.
                    call stdlib_cgemm( 'CONJUGATE', 'NO TRANSPOSE', n1, len, n2,cone, q( n1+1, n2+&
                              1 ), ldq, c( n1+1, i ), ldc,cone, work( n2+1 ), ldwork )
                    ! copy everything back.
                    call stdlib_clacpy( 'ALL', m, len, work, ldwork, c( 1, i ),ldc )
                 end do
              end if
           else
              if( notran ) then
                 do i = 1, m, nb
                    len = min( nb, m-i+1 )
                    ldwork = len
                    ! multiply right part of c by q21.
                    call stdlib_clacpy( 'ALL', len, n2, c( i, n1+1 ), ldc, work,ldwork )
                    call stdlib_ctrmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',len, n2, cone,&
                               q( n1+1, 1 ), ldq, work,ldwork )
                    ! multiply left part of c by q11.
                    call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', len, n2, n1,cone, c( i, 1 )&
                              , ldc, q, ldq, cone, work,ldwork )
                    ! multiply left part of c by q12.
                    call stdlib_clacpy( 'ALL', len, n1, c( i, 1 ), ldc,work( 1 + n2*ldwork ), &
                              ldwork )
                    call stdlib_ctrmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE', 'NON-UNIT',len, n1, cone,&
                               q( 1, n2+1 ), ldq,work( 1 + n2*ldwork ), ldwork )
                    ! multiply right part of c by q22.
                    call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', len, n1, n2,cone, c( i, n1+&
                              1 ), ldc, q( n1+1, n2+1 ), ldq,cone, work( 1 + n2*ldwork ), ldwork )
                    ! copy everything back.
                    call stdlib_clacpy( 'ALL', len, n, work, ldwork, c( i, 1 ),ldc )
                 end do
              else
                 do i = 1, m, nb
                    len = min( nb, m-i+1 )
                    ldwork = len
                    ! multiply right part of c by q12**h.
                    call stdlib_clacpy( 'ALL', len, n1, c( i, n2+1 ), ldc, work,ldwork )
                    call stdlib_ctrmm( 'RIGHT', 'LOWER', 'CONJUGATE', 'NON-UNIT',len, n1, cone, q(&
                               1, n2+1 ), ldq, work,ldwork )
                    ! multiply left part of c by q11**h.
                    call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE', len, n1, n2,cone, c( i, 1 ), &
                              ldc, q, ldq, cone, work,ldwork )
                    ! multiply left part of c by q21**h.
                    call stdlib_clacpy( 'ALL', len, n2, c( i, 1 ), ldc,work( 1 + n1*ldwork ), &
                              ldwork )
                    call stdlib_ctrmm( 'RIGHT', 'UPPER', 'CONJUGATE', 'NON-UNIT',len, n2, cone, q(&
                               n1+1, 1 ), ldq,work( 1 + n1*ldwork ), ldwork )
                    ! multiply right part of c by q22**h.
                    call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE', len, n2, n1,cone, c( i, n2+1 )&
                              , ldc, q( n1+1, n2+1 ), ldq,cone, work( 1 + n1*ldwork ), ldwork )
                    ! copy everything back.
                    call stdlib_clacpy( 'ALL', len, n, work, ldwork, c( i, 1 ),ldc )
                 end do
              end if
           end if
           work( 1 ) = cmplx( lwkopt,KIND=sp)
           return
     end subroutine stdlib_cunm22


     pure subroutine stdlib_cunm2l( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )
     !! CUNM2L overwrites the general complex m-by-n matrix C with
     !! Q * C  if SIDE = 'L' and TRANS = 'N', or
     !! Q**H* C  if SIDE = 'L' and TRANS = 'C', or
     !! C * Q  if SIDE = 'R' and TRANS = 'N', or
     !! C * Q**H if SIDE = 'R' and TRANS = 'C',
     !! where Q is a complex unitary matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(k) . . . H(2) H(1)
     !! as returned by CGEQLF. Q is of order m if SIDE = 'L' and of order n
     !! if SIDE = 'R'.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: left, notran
           integer(ilp) :: i, i1, i2, i3, mi, ni, nq
           complex(sp) :: aii, taui
           ! Intrinsic Functions 
           intrinsic :: conjg,max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( lda<max( 1, nq ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNM2L', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. k==0 )return
           if( ( left .and. notran .or. .not.left .and. .not.notran ) ) then
              i1 = 1
              i2 = k
              i3 = 1
           else
              i1 = k
              i2 = 1
              i3 = -1
           end if
           if( left ) then
              ni = n
           else
              mi = m
           end if
           do i = i1, i2, i3
              if( left ) then
                 ! h(i) or h(i)**h is applied to c(1:m-k+i,1:n)
                 mi = m - k + i
              else
                 ! h(i) or h(i)**h is applied to c(1:m,1:n-k+i)
                 ni = n - k + i
              end if
              ! apply h(i) or h(i)**h
              if( notran ) then
                 taui = tau( i )
              else
                 taui = conjg( tau( i ) )
              end if
              aii = a( nq-k+i, i )
              a( nq-k+i, i ) = cone
              call stdlib_clarf( side, mi, ni, a( 1, i ), 1, taui, c, ldc, work )
              a( nq-k+i, i ) = aii
           end do
           return
     end subroutine stdlib_cunm2l


     pure subroutine stdlib_cunm2r( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )
     !! CUNM2R overwrites the general complex m-by-n matrix C with
     !! Q * C  if SIDE = 'L' and TRANS = 'N', or
     !! Q**H* C  if SIDE = 'L' and TRANS = 'C', or
     !! C * Q  if SIDE = 'R' and TRANS = 'N', or
     !! C * Q**H if SIDE = 'R' and TRANS = 'C',
     !! where Q is a complex unitary matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(1) H(2) . . . H(k)
     !! as returned by CGEQRF. Q is of order m if SIDE = 'L' and of order n
     !! if SIDE = 'R'.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: left, notran
           integer(ilp) :: i, i1, i2, i3, ic, jc, mi, ni, nq
           complex(sp) :: aii, taui
           ! Intrinsic Functions 
           intrinsic :: conjg,max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( lda<max( 1, nq ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNM2R', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. k==0 )return
           if( ( left .and. .not.notran .or. .not.left .and. notran ) ) then
              i1 = 1
              i2 = k
              i3 = 1
           else
              i1 = k
              i2 = 1
              i3 = -1
           end if
           if( left ) then
              ni = n
              jc = 1
           else
              mi = m
              ic = 1
           end if
           do i = i1, i2, i3
              if( left ) then
                 ! h(i) or h(i)**h is applied to c(i:m,1:n)
                 mi = m - i + 1
                 ic = i
              else
                 ! h(i) or h(i)**h is applied to c(1:m,i:n)
                 ni = n - i + 1
                 jc = i
              end if
              ! apply h(i) or h(i)**h
              if( notran ) then
                 taui = tau( i )
              else
                 taui = conjg( tau( i ) )
              end if
              aii = a( i, i )
              a( i, i ) = cone
              call stdlib_clarf( side, mi, ni, a( i, i ), 1, taui, c( ic, jc ), ldc,work )
              a( i, i ) = aii
           end do
           return
     end subroutine stdlib_cunm2r


     pure subroutine stdlib_cunml2( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )
     !! CUNML2 overwrites the general complex m-by-n matrix C with
     !! Q * C  if SIDE = 'L' and TRANS = 'N', or
     !! Q**H* C  if SIDE = 'L' and TRANS = 'C', or
     !! C * Q  if SIDE = 'R' and TRANS = 'N', or
     !! C * Q**H if SIDE = 'R' and TRANS = 'C',
     !! where Q is a complex unitary matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(k)**H . . . H(2)**H H(1)**H
     !! as returned by CGELQF. Q is of order m if SIDE = 'L' and of order n
     !! if SIDE = 'R'.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: left, notran
           integer(ilp) :: i, i1, i2, i3, ic, jc, mi, ni, nq
           complex(sp) :: aii, taui
           ! Intrinsic Functions 
           intrinsic :: conjg,max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( lda<max( 1, k ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNML2', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. k==0 )return
           if( ( left .and. notran .or. .not.left .and. .not.notran ) ) then
              i1 = 1
              i2 = k
              i3 = 1
           else
              i1 = k
              i2 = 1
              i3 = -1
           end if
           if( left ) then
              ni = n
              jc = 1
           else
              mi = m
              ic = 1
           end if
           do i = i1, i2, i3
              if( left ) then
                 ! h(i) or h(i)**h is applied to c(i:m,1:n)
                 mi = m - i + 1
                 ic = i
              else
                 ! h(i) or h(i)**h is applied to c(1:m,i:n)
                 ni = n - i + 1
                 jc = i
              end if
              ! apply h(i) or h(i)**h
              if( notran ) then
                 taui = conjg( tau( i ) )
              else
                 taui = tau( i )
              end if
              if( i<nq )call stdlib_clacgv( nq-i, a( i, i+1 ), lda )
              aii = a( i, i )
              a( i, i ) = cone
              call stdlib_clarf( side, mi, ni, a( i, i ), lda, taui, c( ic, jc ),ldc, work )
                        
              a( i, i ) = aii
              if( i<nq )call stdlib_clacgv( nq-i, a( i, i+1 ), lda )
           end do
           return
     end subroutine stdlib_cunml2


     pure subroutine stdlib_cunmlq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, info )
     !! CUNMLQ overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(k)**H . . . H(2)**H H(1)**H
     !! as returned by CGELQF. Q is of order M if SIDE = 'L' and of order N
     !! if SIDE = 'R'.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           ! Local Scalars 
           logical(lk) :: left, lquery, notran
           character :: transt
           integer(ilp) :: i, i1, i2, i3, ib, ic, iinfo, iwt, jc, ldwork, lwkopt, mi, nb, nbmin, &
                     ni, nq, nw
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( lda<max( 1, k ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              if( m==0 .or. n==0 .or. k==0 ) then
                 lwkopt = 1
              else
                 nb = min( nbmax, stdlib_ilaenv( 1, 'CUNMLQ', side // trans, m, n,k, -1 ) )
                           
                 lwkopt = nw*nb + tsize
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNMLQ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. k==0 ) then
              return
           end if
           ! determine the block size
           nbmin = 2
           ldwork = nw
           if( nb>1 .and. nb<k ) then
              if( lwork<lwkopt ) then
                 nb = (lwork-tsize) / ldwork
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CUNMLQ', side // trans, m, n, k,-1 ) )
              end if
           end if
           if( nb<nbmin .or. nb>=k ) then
              ! use unblocked code
              call stdlib_cunml2( side, trans, m, n, k, a, lda, tau, c, ldc, work,iinfo )
           else
              ! use blocked code
              iwt = 1 + nw*nb
              if( ( left .and. notran ) .or.( .not.left .and. .not.notran ) ) then
                 i1 = 1
                 i2 = k
                 i3 = nb
              else
                 i1 = ( ( k-1 ) / nb )*nb + 1
                 i2 = 1
                 i3 = -nb
              end if
              if( left ) then
                 ni = n
                 jc = 1
              else
                 mi = m
                 ic = 1
              end if
              if( notran ) then
                 transt = 'C'
              else
                 transt = 'N'
              end if
              do i = i1, i2, i3
                 ib = min( nb, k-i+1 )
                 ! form the triangular factor of the block reflector
                 ! h = h(i) h(i+1) . . . h(i+ib-1)
                 call stdlib_clarft( 'FORWARD', 'ROWWISE', nq-i+1, ib, a( i, i ),lda, tau( i ), &
                           work( iwt ), ldt )
                 if( left ) then
                    ! h or h**h is applied to c(i:m,1:n)
                    mi = m - i + 1
                    ic = i
                 else
                    ! h or h**h is applied to c(1:m,i:n)
                    ni = n - i + 1
                    jc = i
                 end if
                 ! apply h or h**h
                 call stdlib_clarfb( side, transt, 'FORWARD', 'ROWWISE', mi, ni, ib,a( i, i ), &
                           lda, work( iwt ), ldt,c( ic, jc ), ldc, work, ldwork )
              end do
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cunmlq


     pure subroutine stdlib_cunmql( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, info )
     !! CUNMQL overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(k) . . . H(2) H(1)
     !! as returned by CGEQLF. Q is of order M if SIDE = 'L' and of order N
     !! if SIDE = 'R'.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           ! Local Scalars 
           logical(lk) :: left, lquery, notran
           integer(ilp) :: i, i1, i2, i3, ib, iinfo, iwt, ldwork, lwkopt, mi, nb, nbmin, ni, nq, &
                     nw
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( lda<max( 1, nq ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              if( m==0 .or. n==0 ) then
                 lwkopt = 1
              else
                 nb = min( nbmax, stdlib_ilaenv( 1, 'CUNMQL', side // trans, m, n,k, -1 ) )
                           
                 lwkopt = nw*nb + tsize
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNMQL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! determine the block size
           nbmin = 2
           ldwork = nw
           if( nb>1 .and. nb<k ) then
              if( lwork<lwkopt ) then
                 nb = (lwork-tsize) / ldwork
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CUNMQL', side // trans, m, n, k,-1 ) )
              end if
           end if
           if( nb<nbmin .or. nb>=k ) then
              ! use unblocked code
              call stdlib_cunm2l( side, trans, m, n, k, a, lda, tau, c, ldc, work,iinfo )
           else
              ! use blocked code
              iwt = 1 + nw*nb
              if( ( left .and. notran ) .or.( .not.left .and. .not.notran ) ) then
                 i1 = 1
                 i2 = k
                 i3 = nb
              else
                 i1 = ( ( k-1 ) / nb )*nb + 1
                 i2 = 1
                 i3 = -nb
              end if
              if( left ) then
                 ni = n
              else
                 mi = m
              end if
              do i = i1, i2, i3
                 ib = min( nb, k-i+1 )
                 ! form the triangular factor of the block reflector
                 ! h = h(i+ib-1) . . . h(i+1) h(i)
                 call stdlib_clarft( 'BACKWARD', 'COLUMNWISE', nq-k+i+ib-1, ib,a( 1, i ), lda, &
                           tau( i ), work( iwt ), ldt )
                 if( left ) then
                    ! h or h**h is applied to c(1:m-k+i+ib-1,1:n)
                    mi = m - k + i + ib - 1
                 else
                    ! h or h**h is applied to c(1:m,1:n-k+i+ib-1)
                    ni = n - k + i + ib - 1
                 end if
                 ! apply h or h**h
                 call stdlib_clarfb( side, trans, 'BACKWARD', 'COLUMNWISE', mi, ni,ib, a( 1, i ), &
                           lda, work( iwt ), ldt, c, ldc,work, ldwork )
              end do
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cunmql


     pure subroutine stdlib_cunmqr( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, info )
     !! CUNMQR overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(1) H(2) . . . H(k)
     !! as returned by CGEQRF. Q is of order M if SIDE = 'L' and of order N
     !! if SIDE = 'R'.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           ! Local Scalars 
           logical(lk) :: left, lquery, notran
           integer(ilp) :: i, i1, i2, i3, ib, ic, iinfo, iwt, jc, ldwork, lwkopt, mi, nb, nbmin, &
                     ni, nq, nw
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( lda<max( 1, nq ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'CUNMQR', side // trans, m, n, k,-1 ) )
              lwkopt = nw*nb + tsize
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNMQR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. k==0 ) then
              work( 1 ) = 1
              return
           end if
           nbmin = 2
           ldwork = nw
           if( nb>1 .and. nb<k ) then
              if( lwork<lwkopt ) then
                 nb = (lwork-tsize) / ldwork
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CUNMQR', side // trans, m, n, k,-1 ) )
              end if
           end if
           if( nb<nbmin .or. nb>=k ) then
              ! use unblocked code
              call stdlib_cunm2r( side, trans, m, n, k, a, lda, tau, c, ldc, work,iinfo )
           else
              ! use blocked code
              iwt = 1 + nw*nb
              if( ( left .and. .not.notran ) .or.( .not.left .and. notran ) ) then
                 i1 = 1
                 i2 = k
                 i3 = nb
              else
                 i1 = ( ( k-1 ) / nb )*nb + 1
                 i2 = 1
                 i3 = -nb
              end if
              if( left ) then
                 ni = n
                 jc = 1
              else
                 mi = m
                 ic = 1
              end if
              do i = i1, i2, i3
                 ib = min( nb, k-i+1 )
                 ! form the triangular factor of the block reflector
                 ! h = h(i) h(i+1) . . . h(i+ib-1)
                 call stdlib_clarft( 'FORWARD', 'COLUMNWISE', nq-i+1, ib, a( i, i ),lda, tau( i ),&
                            work( iwt ), ldt )
                 if( left ) then
                    ! h or h**h is applied to c(i:m,1:n)
                    mi = m - i + 1
                    ic = i
                 else
                    ! h or h**h is applied to c(1:m,i:n)
                    ni = n - i + 1
                    jc = i
                 end if
                 ! apply h or h**h
                 call stdlib_clarfb( side, trans, 'FORWARD', 'COLUMNWISE', mi, ni,ib, a( i, i ), &
                           lda, work( iwt ), ldt,c( ic, jc ), ldc, work, ldwork )
              end do
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cunmqr


     pure subroutine stdlib_cunmr2( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )
     !! CUNMR2 overwrites the general complex m-by-n matrix C with
     !! Q * C  if SIDE = 'L' and TRANS = 'N', or
     !! Q**H* C  if SIDE = 'L' and TRANS = 'C', or
     !! C * Q  if SIDE = 'R' and TRANS = 'N', or
     !! C * Q**H if SIDE = 'R' and TRANS = 'C',
     !! where Q is a complex unitary matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(1)**H H(2)**H . . . H(k)**H
     !! as returned by CGERQF. Q is of order m if SIDE = 'L' and of order n
     !! if SIDE = 'R'.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: left, notran
           integer(ilp) :: i, i1, i2, i3, mi, ni, nq
           complex(sp) :: aii, taui
           ! Intrinsic Functions 
           intrinsic :: conjg,max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( lda<max( 1, k ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNMR2', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. k==0 )return
           if( ( left .and. .not.notran .or. .not.left .and. notran ) ) then
              i1 = 1
              i2 = k
              i3 = 1
           else
              i1 = k
              i2 = 1
              i3 = -1
           end if
           if( left ) then
              ni = n
           else
              mi = m
           end if
           do i = i1, i2, i3
              if( left ) then
                 ! h(i) or h(i)**h is applied to c(1:m-k+i,1:n)
                 mi = m - k + i
              else
                 ! h(i) or h(i)**h is applied to c(1:m,1:n-k+i)
                 ni = n - k + i
              end if
              ! apply h(i) or h(i)**h
              if( notran ) then
                 taui = conjg( tau( i ) )
              else
                 taui = tau( i )
              end if
              call stdlib_clacgv( nq-k+i-1, a( i, 1 ), lda )
              aii = a( i, nq-k+i )
              a( i, nq-k+i ) = cone
              call stdlib_clarf( side, mi, ni, a( i, 1 ), lda, taui, c, ldc, work )
              a( i, nq-k+i ) = aii
              call stdlib_clacgv( nq-k+i-1, a( i, 1 ), lda )
           end do
           return
     end subroutine stdlib_cunmr2


     pure subroutine stdlib_cunmr3( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, info )
     !! CUNMR3 overwrites the general complex m by n matrix C with
     !! Q * C  if SIDE = 'L' and TRANS = 'N', or
     !! Q**H* C  if SIDE = 'L' and TRANS = 'C', or
     !! C * Q  if SIDE = 'R' and TRANS = 'N', or
     !! C * Q**H if SIDE = 'R' and TRANS = 'C',
     !! where Q is a complex unitary matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(1) H(2) . . . H(k)
     !! as returned by CTZRZF. Q is of order m if SIDE = 'L' and of order n
     !! if SIDE = 'R'.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, l, lda, ldc, m, n
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), tau(*)
           complex(sp), intent(inout) :: c(ldc,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, notran
           integer(ilp) :: i, i1, i2, i3, ic, ja, jc, mi, ni, nq
           complex(sp) :: taui
           ! Intrinsic Functions 
           intrinsic :: conjg,max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( l<0 .or. ( left .and. ( l>m ) ) .or.( .not.left .and. ( l>n ) ) ) then
              info = -6
           else if( lda<max( 1, k ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNMR3', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. k==0 )return
           if( ( left .and. .not.notran .or. .not.left .and. notran ) ) then
              i1 = 1
              i2 = k
              i3 = 1
           else
              i1 = k
              i2 = 1
              i3 = -1
           end if
           if( left ) then
              ni = n
              ja = m - l + 1
              jc = 1
           else
              mi = m
              ja = n - l + 1
              ic = 1
           end if
           do i = i1, i2, i3
              if( left ) then
                 ! h(i) or h(i)**h is applied to c(i:m,1:n)
                 mi = m - i + 1
                 ic = i
              else
                 ! h(i) or h(i)**h is applied to c(1:m,i:n)
                 ni = n - i + 1
                 jc = i
              end if
              ! apply h(i) or h(i)**h
              if( notran ) then
                 taui = tau( i )
              else
                 taui = conjg( tau( i ) )
              end if
              call stdlib_clarz( side, mi, ni, l, a( i, ja ), lda, taui,c( ic, jc ), ldc, work )
                        
           end do
           return
     end subroutine stdlib_cunmr3


     pure subroutine stdlib_cunmrq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, info )
     !! CUNMRQ overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(1)**H H(2)**H . . . H(k)**H
     !! as returned by CGERQF. Q is of order M if SIDE = 'L' and of order N
     !! if SIDE = 'R'.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           ! Local Scalars 
           logical(lk) :: left, lquery, notran
           character :: transt
           integer(ilp) :: i, i1, i2, i3, ib, iinfo, iwt, ldwork, lwkopt, mi, nb, nbmin, ni, nq, &
                     nw
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( lda<max( 1, k ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              if( m==0 .or. n==0 ) then
                 lwkopt = 1
              else
                 nb = min( nbmax, stdlib_ilaenv( 1, 'CUNMRQ', side // trans, m, n,k, -1 ) )
                           
                 lwkopt = nw*nb + tsize
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNMRQ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           nbmin = 2
           ldwork = nw
           if( nb>1 .and. nb<k ) then
              if( lwork<lwkopt ) then
                 nb = (lwork-tsize) / ldwork
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CUNMRQ', side // trans, m, n, k,-1 ) )
              end if
           end if
           if( nb<nbmin .or. nb>=k ) then
              ! use unblocked code
              call stdlib_cunmr2( side, trans, m, n, k, a, lda, tau, c, ldc, work,iinfo )
           else
              ! use blocked code
              iwt = 1 + nw*nb
              if( ( left .and. .not.notran ) .or.( .not.left .and. notran ) ) then
                 i1 = 1
                 i2 = k
                 i3 = nb
              else
                 i1 = ( ( k-1 ) / nb )*nb + 1
                 i2 = 1
                 i3 = -nb
              end if
              if( left ) then
                 ni = n
              else
                 mi = m
              end if
              if( notran ) then
                 transt = 'C'
              else
                 transt = 'N'
              end if
              do i = i1, i2, i3
                 ib = min( nb, k-i+1 )
                 ! form the triangular factor of the block reflector
                 ! h = h(i+ib-1) . . . h(i+1) h(i)
                 call stdlib_clarft( 'BACKWARD', 'ROWWISE', nq-k+i+ib-1, ib,a( i, 1 ), lda, tau( &
                           i ), work( iwt ), ldt )
                 if( left ) then
                    ! h or h**h is applied to c(1:m-k+i+ib-1,1:n)
                    mi = m - k + i + ib - 1
                 else
                    ! h or h**h is applied to c(1:m,1:n-k+i+ib-1)
                    ni = n - k + i + ib - 1
                 end if
                 ! apply h or h**h
                 call stdlib_clarfb( side, transt, 'BACKWARD', 'ROWWISE', mi, ni,ib, a( i, 1 ), &
                           lda, work( iwt ), ldt, c, ldc,work, ldwork )
              end do
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cunmrq


     pure subroutine stdlib_cunmrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, lwork, &
     !! CUNMRZ overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix defined as the product of k
     !! elementary reflectors
     !! Q = H(1) H(2) . . . H(k)
     !! as returned by CTZRZF. Q is of order M if SIDE = 'L' and of order N
     !! if SIDE = 'R'.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, l, lda, ldc, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           ! Local Scalars 
           logical(lk) :: left, lquery, notran
           character :: transt
           integer(ilp) :: i, i1, i2, i3, ib, ic, iinfo, iwt, ja, jc, ldwork, lwkopt, mi, nb, &
                     nbmin, ni, nq, nw
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>nq ) then
              info = -5
           else if( l<0 .or. ( left .and. ( l>m ) ) .or.( .not.left .and. ( l>n ) ) ) then
              info = -6
           else if( lda<max( 1, k ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              if( m==0 .or. n==0 ) then
                 lwkopt = 1
              else
                 nb = min( nbmax, stdlib_ilaenv( 1, 'CUNMRQ', side // trans, m, n,k, -1 ) )
                           
                 lwkopt = nw*nb + tsize
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNMRZ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! determine the block size.
           nb = min( nbmax, stdlib_ilaenv( 1, 'CUNMRQ', side // trans, m, n, k,-1 ) )
           nbmin = 2
           ldwork = nw
           if( nb>1 .and. nb<k ) then
              if( lwork<lwkopt ) then
                 nb = (lwork-tsize) / ldwork
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CUNMRQ', side // trans, m, n, k,-1 ) )
              end if
           end if
           if( nb<nbmin .or. nb>=k ) then
              ! use unblocked code
              call stdlib_cunmr3( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, iinfo )
                        
           else
              ! use blocked code
              iwt = 1 + nw*nb
              if( ( left .and. .not.notran ) .or.( .not.left .and. notran ) ) then
                 i1 = 1
                 i2 = k
                 i3 = nb
              else
                 i1 = ( ( k-1 ) / nb )*nb + 1
                 i2 = 1
                 i3 = -nb
              end if
              if( left ) then
                 ni = n
                 jc = 1
                 ja = m - l + 1
              else
                 mi = m
                 ic = 1
                 ja = n - l + 1
              end if
              if( notran ) then
                 transt = 'C'
              else
                 transt = 'N'
              end if
              do i = i1, i2, i3
                 ib = min( nb, k-i+1 )
                 ! form the triangular factor of the block reflector
                 ! h = h(i+ib-1) . . . h(i+1) h(i)
                 call stdlib_clarzt( 'BACKWARD', 'ROWWISE', l, ib, a( i, ja ), lda,tau( i ), work(&
                            iwt ), ldt )
                 if( left ) then
                    ! h or h**h is applied to c(i:m,1:n)
                    mi = m - i + 1
                    ic = i
                 else
                    ! h or h**h is applied to c(1:m,i:n)
                    ni = n - i + 1
                    jc = i
                 end if
                 ! apply h or h**h
                 call stdlib_clarzb( side, transt, 'BACKWARD', 'ROWWISE', mi, ni,ib, l, a( i, ja )&
                           , lda, work( iwt ), ldt,c( ic, jc ), ldc, work, ldwork )
              end do
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cunmrz


     pure subroutine stdlib_cbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, u1, &
     !! CBBCSD computes the CS decomposition of a unitary matrix in
     !! bidiagonal-block form,
     !! [ B11 | B12 0  0 ]
     !! [  0  |  0 -I  0 ]
     !! X = [----------------]
     !! [ B21 | B22 0  0 ]
     !! [  0  |  0  0  I ]
     !! [  C | -S  0  0 ]
     !! [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**H
     !! = [---------] [---------------] [---------]   .
     !! [    | U2 ] [  S |  C  0  0 ] [    | V2 ]
     !! [  0 |  0  0  I ]
     !! X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
     !! than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
     !! transposed and/or permuted. This can be done in constant time using
     !! the TRANS and SIGNS options. See CUNCSD for details.)
     !! The bidiagonal matrices B11, B12, B21, and B22 are represented
     !! implicitly by angles THETA(1:Q) and PHI(1:Q-1).
     !! The unitary matrices U1, U2, V1T, and V2T are input/output.
     !! The input matrices are pre- or post-multiplied by the appropriate
     !! singular vector matrices.
     ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d, b22e, rwork, &
               lrwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, lrwork, m, p, q
           ! Array Arguments 
           real(sp), intent(out) :: b11d(*), b11e(*), b12d(*), b12e(*), b21d(*), b21e(*), b22d(*),&
                      b22e(*), rwork(*)
           real(sp), intent(inout) :: phi(*), theta(*)
           complex(sp), intent(inout) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*)
                     
        ! ===================================================================
           ! Parameters 
           integer(ilp), parameter :: maxitr = 6
           real(sp), parameter :: hundred = 100.0_sp
           real(sp), parameter :: meighth = -0.125_sp
           real(sp), parameter :: piover2 = 1.57079632679489661923132169163975144210_sp
           
           
           
           
           ! Local Scalars 
           logical(lk) :: colmajor, lquery, restart11, restart12, restart21, restart22, wantu1, &
                     wantu2, wantv1t, wantv2t
           integer(ilp) :: i, imin, imax, iter, iu1cs, iu1sn, iu2cs, iu2sn, iv1tcs, iv1tsn, &
                     iv2tcs, iv2tsn, j, lrworkmin, lrworkopt, maxit, mini
           real(sp) :: b11bulge, b12bulge, b21bulge, b22bulge, dummy, eps, mu, nu, r, sigma11, &
                     sigma21, temp, thetamax, thetamin, thresh, tol, tolmul, unfl, x1, x2, y1, y2
           ! Intrinsic Functions 
           intrinsic :: abs,atan2,cos,max,min,sin,sqrt
           ! Executable Statements 
           ! test input arguments
           info = 0
           lquery = lrwork == -1
           wantu1 = stdlib_lsame( jobu1, 'Y' )
           wantu2 = stdlib_lsame( jobu2, 'Y' )
           wantv1t = stdlib_lsame( jobv1t, 'Y' )
           wantv2t = stdlib_lsame( jobv2t, 'Y' )
           colmajor = .not. stdlib_lsame( trans, 'T' )
           if( m < 0 ) then
              info = -6
           else if( p < 0 .or. p > m ) then
              info = -7
           else if( q < 0 .or. q > m ) then
              info = -8
           else if( q > p .or. q > m-p .or. q > m-q ) then
              info = -8
           else if( wantu1 .and. ldu1 < p ) then
              info = -12
           else if( wantu2 .and. ldu2 < m-p ) then
              info = -14
           else if( wantv1t .and. ldv1t < q ) then
              info = -16
           else if( wantv2t .and. ldv2t < m-q ) then
              info = -18
           end if
           ! quick return if q = 0
           if( info == 0 .and. q == 0 ) then
              lrworkmin = 1
              rwork(1) = lrworkmin
              return
           end if
           ! compute workspace
           if( info == 0 ) then
              iu1cs = 1
              iu1sn = iu1cs + q
              iu2cs = iu1sn + q
              iu2sn = iu2cs + q
              iv1tcs = iu2sn + q
              iv1tsn = iv1tcs + q
              iv2tcs = iv1tsn + q
              iv2tsn = iv2tcs + q
              lrworkopt = iv2tsn + q - 1
              lrworkmin = lrworkopt
              rwork(1) = lrworkopt
              if( lrwork < lrworkmin .and. .not. lquery ) then
                 info = -28
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'CBBCSD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'EPSILON' )
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           tolmul = max( ten, min( hundred, eps**meighth ) )
           tol = tolmul*eps
           thresh = max( tol, maxitr*q*q*unfl )
           ! test for negligible sines or cosines
           do i = 1, q
              if( theta(i) < thresh ) then
                 theta(i) = zero
              else if( theta(i) > piover2-thresh ) then
                 theta(i) = piover2
              end if
           end do
           do i = 1, q-1
              if( phi(i) < thresh ) then
                 phi(i) = zero
              else if( phi(i) > piover2-thresh ) then
                 phi(i) = piover2
              end if
           end do
           ! initial deflation
           imax = q
           do while( imax > 1 )
              if( phi(imax-1) /= zero ) then
                 exit
              end if
              imax = imax - 1
           end do
           imin = imax - 1
           if  ( imin > 1 ) then
              do while( phi(imin-1) /= zero )
                 imin = imin - 1
                 if  ( imin <= 1 ) exit
              end do
           end if
           ! initialize iteration counter
           maxit = maxitr*q*q
           iter = 0
           ! begin main iteration loop
           do while( imax > 1 )
              ! compute the matrix entries
              b11d(imin) = cos( theta(imin) )
              b21d(imin) = -sin( theta(imin) )
              do i = imin, imax - 1
                 b11e(i) = -sin( theta(i) ) * sin( phi(i) )
                 b11d(i+1) = cos( theta(i+1) ) * cos( phi(i) )
                 b12d(i) = sin( theta(i) ) * cos( phi(i) )
                 b12e(i) = cos( theta(i+1) ) * sin( phi(i) )
                 b21e(i) = -cos( theta(i) ) * sin( phi(i) )
                 b21d(i+1) = -sin( theta(i+1) ) * cos( phi(i) )
                 b22d(i) = cos( theta(i) ) * cos( phi(i) )
                 b22e(i) = -sin( theta(i+1) ) * sin( phi(i) )
              end do
              b12d(imax) = sin( theta(imax) )
              b22d(imax) = cos( theta(imax) )
              ! abort if not converging; otherwise, increment iter
              if( iter > maxit ) then
                 info = 0
                 do i = 1, q
                    if( phi(i) /= zero )info = info + 1
                 end do
                 return
              end if
              iter = iter + imax - imin
              ! compute shifts
              thetamax = theta(imin)
              thetamin = theta(imin)
              do i = imin+1, imax
                 if( theta(i) > thetamax )thetamax = theta(i)
                 if( theta(i) < thetamin )thetamin = theta(i)
              end do
              if( thetamax > piover2 - thresh ) then
                 ! zero on diagonals of b11 and b22; induce deflation with a
                 ! zero shift
                 mu = zero
                 nu = one
              else if( thetamin < thresh ) then
                 ! zero on diagonals of b12 and b22; induce deflation with a
                 ! zero shift
                 mu = one
                 nu = zero
              else
                 ! compute shifts for b11 and b21 and use the lesser
                 call stdlib_slas2( b11d(imax-1), b11e(imax-1), b11d(imax), sigma11,dummy )
                           
                 call stdlib_slas2( b21d(imax-1), b21e(imax-1), b21d(imax), sigma21,dummy )
                           
                 if( sigma11 <= sigma21 ) then
                    mu = sigma11
                    nu = sqrt( one - mu**2 )
                    if( mu < thresh ) then
                       mu = zero
                       nu = one
                    end if
                 else
                    nu = sigma21
                    mu = sqrt( 1.0_sp - nu**2 )
                    if( nu < thresh ) then
                       mu = one
                       nu = zero
                    end if
                 end if
              end if
              ! rotate to produce bulges in b11 and b21
              if( mu <= nu ) then
                 call stdlib_slartgs( b11d(imin), b11e(imin), mu,rwork(iv1tcs+imin-1), rwork(&
                           iv1tsn+imin-1) )
              else
                 call stdlib_slartgs( b21d(imin), b21e(imin), nu,rwork(iv1tcs+imin-1), rwork(&
                           iv1tsn+imin-1) )
              end if
              temp = rwork(iv1tcs+imin-1)*b11d(imin) +rwork(iv1tsn+imin-1)*b11e(imin)
              b11e(imin) = rwork(iv1tcs+imin-1)*b11e(imin) -rwork(iv1tsn+imin-1)*b11d(imin)
                        
              b11d(imin) = temp
              b11bulge = rwork(iv1tsn+imin-1)*b11d(imin+1)
              b11d(imin+1) = rwork(iv1tcs+imin-1)*b11d(imin+1)
              temp = rwork(iv1tcs+imin-1)*b21d(imin) +rwork(iv1tsn+imin-1)*b21e(imin)
              b21e(imin) = rwork(iv1tcs+imin-1)*b21e(imin) -rwork(iv1tsn+imin-1)*b21d(imin)
                        
              b21d(imin) = temp
              b21bulge = rwork(iv1tsn+imin-1)*b21d(imin+1)
              b21d(imin+1) = rwork(iv1tcs+imin-1)*b21d(imin+1)
              ! compute theta(imin)
              theta( imin ) = atan2( sqrt( b21d(imin)**2+b21bulge**2 ),sqrt( b11d(imin)**2+&
                        b11bulge**2 ) )
              ! chase the bulges in b11(imin+1,imin) and b21(imin+1,imin)
              if( b11d(imin)**2+b11bulge**2 > thresh**2 ) then
                 call stdlib_slartgp( b11bulge, b11d(imin), rwork(iu1sn+imin-1),rwork(iu1cs+imin-&
                           1), r )
              else if( mu <= nu ) then
                 call stdlib_slartgs( b11e( imin ), b11d( imin + 1 ), mu,rwork(iu1cs+imin-1), &
                           rwork(iu1sn+imin-1) )
              else
                 call stdlib_slartgs( b12d( imin ), b12e( imin ), nu,rwork(iu1cs+imin-1), rwork(&
                           iu1sn+imin-1) )
              end if
              if( b21d(imin)**2+b21bulge**2 > thresh**2 ) then
                 call stdlib_slartgp( b21bulge, b21d(imin), rwork(iu2sn+imin-1),rwork(iu2cs+imin-&
                           1), r )
              else if( nu < mu ) then
                 call stdlib_slartgs( b21e( imin ), b21d( imin + 1 ), nu,rwork(iu2cs+imin-1), &
                           rwork(iu2sn+imin-1) )
              else
                 call stdlib_slartgs( b22d(imin), b22e(imin), mu,rwork(iu2cs+imin-1), rwork(iu2sn+&
                           imin-1) )
              end if
              rwork(iu2cs+imin-1) = -rwork(iu2cs+imin-1)
              rwork(iu2sn+imin-1) = -rwork(iu2sn+imin-1)
              temp = rwork(iu1cs+imin-1)*b11e(imin) +rwork(iu1sn+imin-1)*b11d(imin+1)
              b11d(imin+1) = rwork(iu1cs+imin-1)*b11d(imin+1) -rwork(iu1sn+imin-1)*b11e(imin)
                        
              b11e(imin) = temp
              if( imax > imin+1 ) then
                 b11bulge = rwork(iu1sn+imin-1)*b11e(imin+1)
                 b11e(imin+1) = rwork(iu1cs+imin-1)*b11e(imin+1)
              end if
              temp = rwork(iu1cs+imin-1)*b12d(imin) +rwork(iu1sn+imin-1)*b12e(imin)
              b12e(imin) = rwork(iu1cs+imin-1)*b12e(imin) -rwork(iu1sn+imin-1)*b12d(imin)
              b12d(imin) = temp
              b12bulge = rwork(iu1sn+imin-1)*b12d(imin+1)
              b12d(imin+1) = rwork(iu1cs+imin-1)*b12d(imin+1)
              temp = rwork(iu2cs+imin-1)*b21e(imin) +rwork(iu2sn+imin-1)*b21d(imin+1)
              b21d(imin+1) = rwork(iu2cs+imin-1)*b21d(imin+1) -rwork(iu2sn+imin-1)*b21e(imin)
                        
              b21e(imin) = temp
              if( imax > imin+1 ) then
                 b21bulge = rwork(iu2sn+imin-1)*b21e(imin+1)
                 b21e(imin+1) = rwork(iu2cs+imin-1)*b21e(imin+1)
              end if
              temp = rwork(iu2cs+imin-1)*b22d(imin) +rwork(iu2sn+imin-1)*b22e(imin)
              b22e(imin) = rwork(iu2cs+imin-1)*b22e(imin) -rwork(iu2sn+imin-1)*b22d(imin)
              b22d(imin) = temp
              b22bulge = rwork(iu2sn+imin-1)*b22d(imin+1)
              b22d(imin+1) = rwork(iu2cs+imin-1)*b22d(imin+1)
              ! inner loop: chase bulges from b11(imin,imin+2),
              ! b12(imin,imin+1), b21(imin,imin+2), and b22(imin,imin+1) to
              ! bottom-right
              do i = imin+1, imax-1
                 ! compute phi(i-1)
                 x1 = sin(theta(i-1))*b11e(i-1) + cos(theta(i-1))*b21e(i-1)
                 x2 = sin(theta(i-1))*b11bulge + cos(theta(i-1))*b21bulge
                 y1 = sin(theta(i-1))*b12d(i-1) + cos(theta(i-1))*b22d(i-1)
                 y2 = sin(theta(i-1))*b12bulge + cos(theta(i-1))*b22bulge
                 phi(i-1) = atan2( sqrt(x1**2+x2**2), sqrt(y1**2+y2**2) )
                 ! determine if there are bulges to chase or if a new direct
                 ! summand has been reached
                 restart11 = b11e(i-1)**2 + b11bulge**2 <= thresh**2
                 restart21 = b21e(i-1)**2 + b21bulge**2 <= thresh**2
                 restart12 = b12d(i-1)**2 + b12bulge**2 <= thresh**2
                 restart22 = b22d(i-1)**2 + b22bulge**2 <= thresh**2
                 ! if possible, chase bulges from b11(i-1,i+1), b12(i-1,i),
                 ! b21(i-1,i+1), and b22(i-1,i). if necessary, restart bulge-
                 ! chasing by applying the original shift again.
                 if( .not. restart11 .and. .not. restart21 ) then
                    call stdlib_slartgp( x2, x1, rwork(iv1tsn+i-1),rwork(iv1tcs+i-1), r )
                 else if( .not. restart11 .and. restart21 ) then
                    call stdlib_slartgp( b11bulge, b11e(i-1), rwork(iv1tsn+i-1),rwork(iv1tcs+i-1),&
                               r )
                 else if( restart11 .and. .not. restart21 ) then
                    call stdlib_slartgp( b21bulge, b21e(i-1), rwork(iv1tsn+i-1),rwork(iv1tcs+i-1),&
                               r )
                 else if( mu <= nu ) then
                    call stdlib_slartgs( b11d(i), b11e(i), mu, rwork(iv1tcs+i-1),rwork(iv1tsn+i-1)&
                               )
                 else
                    call stdlib_slartgs( b21d(i), b21e(i), nu, rwork(iv1tcs+i-1),rwork(iv1tsn+i-1)&
                               )
                 end if
                 rwork(iv1tcs+i-1) = -rwork(iv1tcs+i-1)
                 rwork(iv1tsn+i-1) = -rwork(iv1tsn+i-1)
                 if( .not. restart12 .and. .not. restart22 ) then
                    call stdlib_slartgp( y2, y1, rwork(iv2tsn+i-1-1),rwork(iv2tcs+i-1-1), r )
                              
                 else if( .not. restart12 .and. restart22 ) then
                    call stdlib_slartgp( b12bulge, b12d(i-1), rwork(iv2tsn+i-1-1),rwork(iv2tcs+i-&
                              1-1), r )
                 else if( restart12 .and. .not. restart22 ) then
                    call stdlib_slartgp( b22bulge, b22d(i-1), rwork(iv2tsn+i-1-1),rwork(iv2tcs+i-&
                              1-1), r )
                 else if( nu < mu ) then
                    call stdlib_slartgs( b12e(i-1), b12d(i), nu,rwork(iv2tcs+i-1-1), rwork(iv2tsn+&
                              i-1-1) )
                 else
                    call stdlib_slartgs( b22e(i-1), b22d(i), mu,rwork(iv2tcs+i-1-1), rwork(iv2tsn+&
                              i-1-1) )
                 end if
                 temp = rwork(iv1tcs+i-1)*b11d(i) + rwork(iv1tsn+i-1)*b11e(i)
                 b11e(i) = rwork(iv1tcs+i-1)*b11e(i) -rwork(iv1tsn+i-1)*b11d(i)
                 b11d(i) = temp
                 b11bulge = rwork(iv1tsn+i-1)*b11d(i+1)
                 b11d(i+1) = rwork(iv1tcs+i-1)*b11d(i+1)
                 temp = rwork(iv1tcs+i-1)*b21d(i) + rwork(iv1tsn+i-1)*b21e(i)
                 b21e(i) = rwork(iv1tcs+i-1)*b21e(i) -rwork(iv1tsn+i-1)*b21d(i)
                 b21d(i) = temp
                 b21bulge = rwork(iv1tsn+i-1)*b21d(i+1)
                 b21d(i+1) = rwork(iv1tcs+i-1)*b21d(i+1)
                 temp = rwork(iv2tcs+i-1-1)*b12e(i-1) +rwork(iv2tsn+i-1-1)*b12d(i)
                 b12d(i) = rwork(iv2tcs+i-1-1)*b12d(i) -rwork(iv2tsn+i-1-1)*b12e(i-1)
                 b12e(i-1) = temp
                 b12bulge = rwork(iv2tsn+i-1-1)*b12e(i)
                 b12e(i) = rwork(iv2tcs+i-1-1)*b12e(i)
                 temp = rwork(iv2tcs+i-1-1)*b22e(i-1) +rwork(iv2tsn+i-1-1)*b22d(i)
                 b22d(i) = rwork(iv2tcs+i-1-1)*b22d(i) -rwork(iv2tsn+i-1-1)*b22e(i-1)
                 b22e(i-1) = temp
                 b22bulge = rwork(iv2tsn+i-1-1)*b22e(i)
                 b22e(i) = rwork(iv2tcs+i-1-1)*b22e(i)
                 ! compute theta(i)
                 x1 = cos(phi(i-1))*b11d(i) + sin(phi(i-1))*b12e(i-1)
                 x2 = cos(phi(i-1))*b11bulge + sin(phi(i-1))*b12bulge
                 y1 = cos(phi(i-1))*b21d(i) + sin(phi(i-1))*b22e(i-1)
                 y2 = cos(phi(i-1))*b21bulge + sin(phi(i-1))*b22bulge
                 theta(i) = atan2( sqrt(y1**2+y2**2), sqrt(x1**2+x2**2) )
                 ! determine if there are bulges to chase or if a new direct
                 ! summand has been reached
                 restart11 =   b11d(i)**2 + b11bulge**2 <= thresh**2
                 restart12 = b12e(i-1)**2 + b12bulge**2 <= thresh**2
                 restart21 =   b21d(i)**2 + b21bulge**2 <= thresh**2
                 restart22 = b22e(i-1)**2 + b22bulge**2 <= thresh**2
                 ! if possible, chase bulges from b11(i+1,i), b12(i+1,i-1),
                 ! b21(i+1,i), and b22(i+1,i-1). if necessary, restart bulge-
                 ! chasing by applying the original shift again.
                 if( .not. restart11 .and. .not. restart12 ) then
                    call stdlib_slartgp( x2, x1, rwork(iu1sn+i-1), rwork(iu1cs+i-1),r )
                 else if( .not. restart11 .and. restart12 ) then
                    call stdlib_slartgp( b11bulge, b11d(i), rwork(iu1sn+i-1),rwork(iu1cs+i-1), r )
                              
                 else if( restart11 .and. .not. restart12 ) then
                    call stdlib_slartgp( b12bulge, b12e(i-1), rwork(iu1sn+i-1),rwork(iu1cs+i-1), &
                              r )
                 else if( mu <= nu ) then
                    call stdlib_slartgs( b11e(i), b11d(i+1), mu, rwork(iu1cs+i-1),rwork(iu1sn+i-1)&
                               )
                 else
                    call stdlib_slartgs( b12d(i), b12e(i), nu, rwork(iu1cs+i-1),rwork(iu1sn+i-1) )
                              
                 end if
                 if( .not. restart21 .and. .not. restart22 ) then
                    call stdlib_slartgp( y2, y1, rwork(iu2sn+i-1), rwork(iu2cs+i-1),r )
                 else if( .not. restart21 .and. restart22 ) then
                    call stdlib_slartgp( b21bulge, b21d(i), rwork(iu2sn+i-1),rwork(iu2cs+i-1), r )
                              
                 else if( restart21 .and. .not. restart22 ) then
                    call stdlib_slartgp( b22bulge, b22e(i-1), rwork(iu2sn+i-1),rwork(iu2cs+i-1), &
                              r )
                 else if( nu < mu ) then
                    call stdlib_slartgs( b21e(i), b21e(i+1), nu, rwork(iu2cs+i-1),rwork(iu2sn+i-1)&
                               )
                 else
                    call stdlib_slartgs( b22d(i), b22e(i), mu, rwork(iu2cs+i-1),rwork(iu2sn+i-1) )
                              
                 end if
                 rwork(iu2cs+i-1) = -rwork(iu2cs+i-1)
                 rwork(iu2sn+i-1) = -rwork(iu2sn+i-1)
                 temp = rwork(iu1cs+i-1)*b11e(i) + rwork(iu1sn+i-1)*b11d(i+1)
                 b11d(i+1) = rwork(iu1cs+i-1)*b11d(i+1) -rwork(iu1sn+i-1)*b11e(i)
                 b11e(i) = temp
                 if( i < imax - 1 ) then
                    b11bulge = rwork(iu1sn+i-1)*b11e(i+1)
                    b11e(i+1) = rwork(iu1cs+i-1)*b11e(i+1)
                 end if
                 temp = rwork(iu2cs+i-1)*b21e(i) + rwork(iu2sn+i-1)*b21d(i+1)
                 b21d(i+1) = rwork(iu2cs+i-1)*b21d(i+1) -rwork(iu2sn+i-1)*b21e(i)
                 b21e(i) = temp
                 if( i < imax - 1 ) then
                    b21bulge = rwork(iu2sn+i-1)*b21e(i+1)
                    b21e(i+1) = rwork(iu2cs+i-1)*b21e(i+1)
                 end if
                 temp = rwork(iu1cs+i-1)*b12d(i) + rwork(iu1sn+i-1)*b12e(i)
                 b12e(i) = rwork(iu1cs+i-1)*b12e(i) -rwork(iu1sn+i-1)*b12d(i)
                 b12d(i) = temp
                 b12bulge = rwork(iu1sn+i-1)*b12d(i+1)
                 b12d(i+1) = rwork(iu1cs+i-1)*b12d(i+1)
                 temp = rwork(iu2cs+i-1)*b22d(i) + rwork(iu2sn+i-1)*b22e(i)
                 b22e(i) = rwork(iu2cs+i-1)*b22e(i) -rwork(iu2sn+i-1)*b22d(i)
                 b22d(i) = temp
                 b22bulge = rwork(iu2sn+i-1)*b22d(i+1)
                 b22d(i+1) = rwork(iu2cs+i-1)*b22d(i+1)
              end do
              ! compute phi(imax-1)
              x1 = sin(theta(imax-1))*b11e(imax-1) +cos(theta(imax-1))*b21e(imax-1)
              y1 = sin(theta(imax-1))*b12d(imax-1) +cos(theta(imax-1))*b22d(imax-1)
              y2 = sin(theta(imax-1))*b12bulge + cos(theta(imax-1))*b22bulge
              phi(imax-1) = atan2( abs(x1), sqrt(y1**2+y2**2) )
              ! chase bulges from b12(imax-1,imax) and b22(imax-1,imax)
              restart12 = b12d(imax-1)**2 + b12bulge**2 <= thresh**2
              restart22 = b22d(imax-1)**2 + b22bulge**2 <= thresh**2
              if( .not. restart12 .and. .not. restart22 ) then
                 call stdlib_slartgp( y2, y1, rwork(iv2tsn+imax-1-1),rwork(iv2tcs+imax-1-1), r )
                           
              else if( .not. restart12 .and. restart22 ) then
                 call stdlib_slartgp( b12bulge, b12d(imax-1),rwork(iv2tsn+imax-1-1),rwork(iv2tcs+&
                           imax-1-1), r )
              else if( restart12 .and. .not. restart22 ) then
                 call stdlib_slartgp( b22bulge, b22d(imax-1),rwork(iv2tsn+imax-1-1),rwork(iv2tcs+&
                           imax-1-1), r )
              else if( nu < mu ) then
                 call stdlib_slartgs( b12e(imax-1), b12d(imax), nu,rwork(iv2tcs+imax-1-1),rwork(&
                           iv2tsn+imax-1-1) )
              else
                 call stdlib_slartgs( b22e(imax-1), b22d(imax), mu,rwork(iv2tcs+imax-1-1),rwork(&
                           iv2tsn+imax-1-1) )
              end if
              temp = rwork(iv2tcs+imax-1-1)*b12e(imax-1) +rwork(iv2tsn+imax-1-1)*b12d(imax)
                        
              b12d(imax) = rwork(iv2tcs+imax-1-1)*b12d(imax) -rwork(iv2tsn+imax-1-1)*b12e(imax-1)
                        
              b12e(imax-1) = temp
              temp = rwork(iv2tcs+imax-1-1)*b22e(imax-1) +rwork(iv2tsn+imax-1-1)*b22d(imax)
                        
              b22d(imax) = rwork(iv2tcs+imax-1-1)*b22d(imax) -rwork(iv2tsn+imax-1-1)*b22e(imax-1)
                        
              b22e(imax-1) = temp
              ! update singular vectors
              if( wantu1 ) then
                 if( colmajor ) then
                    call stdlib_clasr( 'R', 'V', 'F', p, imax-imin+1,rwork(iu1cs+imin-1), rwork(&
                              iu1sn+imin-1),u1(1,imin), ldu1 )
                 else
                    call stdlib_clasr( 'L', 'V', 'F', imax-imin+1, p,rwork(iu1cs+imin-1), rwork(&
                              iu1sn+imin-1),u1(imin,1), ldu1 )
                 end if
              end if
              if( wantu2 ) then
                 if( colmajor ) then
                    call stdlib_clasr( 'R', 'V', 'F', m-p, imax-imin+1,rwork(iu2cs+imin-1), rwork(&
                              iu2sn+imin-1),u2(1,imin), ldu2 )
                 else
                    call stdlib_clasr( 'L', 'V', 'F', imax-imin+1, m-p,rwork(iu2cs+imin-1), rwork(&
                              iu2sn+imin-1),u2(imin,1), ldu2 )
                 end if
              end if
              if( wantv1t ) then
                 if( colmajor ) then
                    call stdlib_clasr( 'L', 'V', 'F', imax-imin+1, q,rwork(iv1tcs+imin-1), rwork(&
                              iv1tsn+imin-1),v1t(imin,1), ldv1t )
                 else
                    call stdlib_clasr( 'R', 'V', 'F', q, imax-imin+1,rwork(iv1tcs+imin-1), rwork(&
                              iv1tsn+imin-1),v1t(1,imin), ldv1t )
                 end if
              end if
              if( wantv2t ) then
                 if( colmajor ) then
                    call stdlib_clasr( 'L', 'V', 'F', imax-imin+1, m-q,rwork(iv2tcs+imin-1), &
                              rwork(iv2tsn+imin-1),v2t(imin,1), ldv2t )
                 else
                    call stdlib_clasr( 'R', 'V', 'F', m-q, imax-imin+1,rwork(iv2tcs+imin-1), &
                              rwork(iv2tsn+imin-1),v2t(1,imin), ldv2t )
                 end if
              end if
              ! fix signs on b11(imax-1,imax) and b21(imax-1,imax)
              if( b11e(imax-1)+b21e(imax-1) > 0 ) then
                 b11d(imax) = -b11d(imax)
                 b21d(imax) = -b21d(imax)
                 if( wantv1t ) then
                    if( colmajor ) then
                       call stdlib_cscal( q, cnegone, v1t(imax,1), ldv1t )
                    else
                       call stdlib_cscal( q, cnegone, v1t(1,imax), 1 )
                    end if
                 end if
              end if
              ! compute theta(imax)
              x1 = cos(phi(imax-1))*b11d(imax) +sin(phi(imax-1))*b12e(imax-1)
              y1 = cos(phi(imax-1))*b21d(imax) +sin(phi(imax-1))*b22e(imax-1)
              theta(imax) = atan2( abs(y1), abs(x1) )
              ! fix signs on b11(imax,imax), b12(imax,imax-1), b21(imax,imax),
              ! and b22(imax,imax-1)
              if( b11d(imax)+b12e(imax-1) < 0 ) then
                 b12d(imax) = -b12d(imax)
                 if( wantu1 ) then
                    if( colmajor ) then
                       call stdlib_cscal( p, cnegone, u1(1,imax), 1 )
                    else
                       call stdlib_cscal( p, cnegone, u1(imax,1), ldu1 )
                    end if
                 end if
              end if
              if( b21d(imax)+b22e(imax-1) > 0 ) then
                 b22d(imax) = -b22d(imax)
                 if( wantu2 ) then
                    if( colmajor ) then
                       call stdlib_cscal( m-p, cnegone, u2(1,imax), 1 )
                    else
                       call stdlib_cscal( m-p, cnegone, u2(imax,1), ldu2 )
                    end if
                 end if
              end if
              ! fix signs on b12(imax,imax) and b22(imax,imax)
              if( b12d(imax)+b22d(imax) < 0 ) then
                 if( wantv2t ) then
                    if( colmajor ) then
                       call stdlib_cscal( m-q, cnegone, v2t(imax,1), ldv2t )
                    else
                       call stdlib_cscal( m-q, cnegone, v2t(1,imax), 1 )
                    end if
                 end if
              end if
              ! test for negligible sines or cosines
              do i = imin, imax
                 if( theta(i) < thresh ) then
                    theta(i) = zero
                 else if( theta(i) > piover2-thresh ) then
                    theta(i) = piover2
                 end if
              end do
              do i = imin, imax-1
                 if( phi(i) < thresh ) then
                    phi(i) = zero
                 else if( phi(i) > piover2-thresh ) then
                    phi(i) = piover2
                 end if
              end do
              ! deflate
              if (imax > 1) then
                 do while( phi(imax-1) == zero )
                    imax = imax - 1
                    if (imax <= 1) exit
                 end do
              end if
              if( imin > imax - 1 )imin = imax - 1
              if (imin > 1) then
                 do while (phi(imin-1) /= zero)
                     imin = imin - 1
                     if (imin <= 1) exit
                 end do
              end if
              ! repeat main iteration loop
           end do
           ! postprocessing: order theta from least to greatest
           do i = 1, q
              mini = i
              thetamin = theta(i)
              do j = i+1, q
                 if( theta(j) < thetamin ) then
                    mini = j
                    thetamin = theta(j)
                 end if
              end do
              if( mini /= i ) then
                 theta(mini) = theta(i)
                 theta(i) = thetamin
                 if( colmajor ) then
                    if( wantu1 )call stdlib_cswap( p, u1(1,i), 1, u1(1,mini), 1 )
                    if( wantu2 )call stdlib_cswap( m-p, u2(1,i), 1, u2(1,mini), 1 )
                    if( wantv1t )call stdlib_cswap( q, v1t(i,1), ldv1t, v1t(mini,1), ldv1t )
                              
                    if( wantv2t )call stdlib_cswap( m-q, v2t(i,1), ldv2t, v2t(mini,1),ldv2t )
                              
                 else
                    if( wantu1 )call stdlib_cswap( p, u1(i,1), ldu1, u1(mini,1), ldu1 )
                    if( wantu2 )call stdlib_cswap( m-p, u2(i,1), ldu2, u2(mini,1), ldu2 )
                    if( wantv1t )call stdlib_cswap( q, v1t(1,i), 1, v1t(1,mini), 1 )
                    if( wantv2t )call stdlib_cswap( m-q, v2t(1,i), 1, v2t(1,mini), 1 )
                 end if
              end if
           end do
           return
     end subroutine stdlib_cbbcsd


     pure subroutine stdlib_cbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, rwork,&
     !! CBDSQR computes the singular values and, optionally, the right and/or
     !! left singular vectors from the singular value decomposition (SVD) of
     !! a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
     !! zero-shift QR algorithm.  The SVD of B has the form
     !! B = Q * S * P**H
     !! where S is the diagonal matrix of singular values, Q is an orthogonal
     !! matrix of left singular vectors, and P is an orthogonal matrix of
     !! right singular vectors.  If left singular vectors are requested, this
     !! subroutine actually returns U*Q instead of Q, and, if right singular
     !! vectors are requested, this subroutine returns P**H*VT instead of
     !! P**H, for given complex input matrices U and VT.  When U and VT are
     !! the unitary matrices that reduce a general matrix A to bidiagonal
     !! form: A = U*B*VT, as computed by CGEBRD, then
     !! A = (U*Q) * S * (P**H*VT)
     !! is the SVD of A.  Optionally, the subroutine may also compute Q**H*C
     !! for a given complex input matrix C.
     !! See "Computing  Small Singular Values of Bidiagonal Matrices With
     !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
     !! LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
     !! no. 5, pp. 873-912, Sept 1990) and
     !! "Accurate singular values and differential qd algorithms," by
     !! B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
     !! Department, University of California at Berkeley, July 1992
     !! for a detailed description of the algorithm.
                info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           ! Array Arguments 
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: c(ldc,*), u(ldu,*), vt(ldvt,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: hndrth = 0.01_sp
           real(sp), parameter :: hndrd = 100.0_sp
           real(sp), parameter :: meigth = -0.125_sp
           integer(ilp), parameter :: maxitr = 6
           
           
           
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: lower, rotate
           integer(ilp) :: i, idir, isub, iter, j, ll, lll, m, maxit, nm1, nm12, nm13, oldll, &
                     oldm
           real(sp) :: abse, abss, cosl, cosr, cs, eps, f, g, h, mu, oldcs, oldsn, r, shift, &
           sigmn, sigmx, sinl, sinr, sll, smax, smin, sminl, sminoa, sn, thresh, tol, tolmul, &
                     unfl
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,real,sign,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.lower ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ncvt<0 ) then
              info = -3
           else if( nru<0 ) then
              info = -4
           else if( ncc<0 ) then
              info = -5
           else if( ( ncvt==0 .and. ldvt<1 ) .or.( ncvt>0 .and. ldvt<max( 1, n ) ) ) then
              info = -9
           else if( ldu<max( 1, nru ) ) then
              info = -11
           else if( ( ncc==0 .and. ldc<1 ) .or.( ncc>0 .and. ldc<max( 1, n ) ) ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CBDSQR', -info )
              return
           end if
           if( n==0 )return
           if( n==1 )go to 160
           ! rotate is true if any singular vectors desired, false otherwise
           rotate = ( ncvt>0 ) .or. ( nru>0 ) .or. ( ncc>0 )
           ! if no singular vectors desired, use qd algorithm
           if( .not.rotate ) then
              call stdlib_slasq1( n, d, e, rwork, info )
           ! if info equals 2, dqds didn't finish, try to finish
              if( info /= 2 ) return
              info = 0
           end if
           nm1 = n - 1
           nm12 = nm1 + nm1
           nm13 = nm12 + nm1
           idir = 0
           ! get machine constants
           eps = stdlib_slamch( 'EPSILON' )
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           if( lower ) then
              do i = 1, n - 1
                 call stdlib_slartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 rwork( i ) = cs
                 rwork( nm1+i ) = sn
              end do
              ! update singular vectors if desired
              if( nru>0 )call stdlib_clasr( 'R', 'V', 'F', nru, n, rwork( 1 ), rwork( n ),u, ldu )
                        
              if( ncc>0 )call stdlib_clasr( 'L', 'V', 'F', n, ncc, rwork( 1 ), rwork( n ),c, ldc )
                        
           end if
           ! compute singular values to relative accuracy tol
           ! (by setting tol to be negative, algorithm will compute
           ! singular values to absolute accuracy abs(tol)*norm(input matrix))
           tolmul = max( ten, min( hndrd, eps**meigth ) )
           tol = tolmul*eps
           ! compute approximate maximum, minimum singular values
           smax = zero
           do i = 1, n
              smax = max( smax, abs( d( i ) ) )
           end do
           do i = 1, n - 1
              smax = max( smax, abs( e( i ) ) )
           end do
           sminl = zero
           if( tol>=zero ) then
              ! relative accuracy desired
              sminoa = abs( d( 1 ) )
              if( sminoa==zero )go to 50
              mu = sminoa
              do i = 2, n
                 mu = abs( d( i ) )*( mu / ( mu+abs( e( i-1 ) ) ) )
                 sminoa = min( sminoa, mu )
                 if( sminoa==zero )go to 50
              end do
              50 continue
              sminoa = sminoa / sqrt( real( n,KIND=sp) )
              thresh = max( tol*sminoa, maxitr*n*n*unfl )
           else
              ! absolute accuracy desired
              thresh = max( abs( tol )*smax, maxitr*n*n*unfl )
           end if
           ! prepare for main iteration loop for the singular values
           ! (maxit is the maximum number of passes through the inner
           ! loop permitted before nonconvergence signalled.)
           maxit = maxitr*n*n
           iter = 0
           oldll = -1
           oldm = -1
           ! m points to last element of unconverged part of matrix
           m = n
           ! begin main iteration loop
           60 continue
           ! check for convergence or exceeding iteration count
           if( m<=1 )go to 160
           if( iter>maxit )go to 200
           ! find diagonal block of matrix to work on
           if( tol<zero .and. abs( d( m ) )<=thresh )d( m ) = zero
           smax = abs( d( m ) )
           smin = smax
           do lll = 1, m - 1
              ll = m - lll
              abss = abs( d( ll ) )
              abse = abs( e( ll ) )
              if( tol<zero .and. abss<=thresh )d( ll ) = zero
              if( abse<=thresh )go to 80
              smin = min( smin, abss )
              smax = max( smax, abss, abse )
           end do
           ll = 0
           go to 90
           80 continue
           e( ll ) = zero
           ! matrix splits since e(ll) = 0
           if( ll==m-1 ) then
              ! convergence of bottom singular value, return to top of loop
              m = m - 1
              go to 60
           end if
           90 continue
           ll = ll + 1
           ! e(ll) through e(m-1) are nonzero, e(ll-1) is zero
           if( ll==m-1 ) then
              ! 2 by 2 block, handle separately
              call stdlib_slasv2( d( m-1 ), e( m-1 ), d( m ), sigmn, sigmx, sinr,cosr, sinl, cosl &
                        )
              d( m-1 ) = sigmx
              e( m-1 ) = zero
              d( m ) = sigmn
              ! compute singular vectors, if desired
              if( ncvt>0 )call stdlib_csrot( ncvt, vt( m-1, 1 ), ldvt, vt( m, 1 ), ldvt,cosr, &
                        sinr )
              if( nru>0 )call stdlib_csrot( nru, u( 1, m-1 ), 1, u( 1, m ), 1, cosl, sinl )
                        
              if( ncc>0 )call stdlib_csrot( ncc, c( m-1, 1 ), ldc, c( m, 1 ), ldc, cosl,sinl )
                        
              m = m - 2
              go to 60
           end if
           ! if working on new submatrix, choose shift direction
           ! (from larger end diagonal element towards smaller)
           if( ll>oldm .or. m<oldll ) then
              if( abs( d( ll ) )>=abs( d( m ) ) ) then
                 ! chase bulge from top (big end) to bottom (small end)
                 idir = 1
              else
                 ! chase bulge from bottom (big end) to top (small end)
                 idir = 2
              end if
           end if
           ! apply convergence tests
           if( idir==1 ) then
              ! run convergence test in forward direction
              ! first apply standard test to bottom of matrix
              if( abs( e( m-1 ) )<=abs( tol )*abs( d( m ) ) .or.( tol<zero .and. abs( e( m-1 ) )&
                        <=thresh ) ) then
                 e( m-1 ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion forward
                 mu = abs( d( ll ) )
                 sminl = mu
                 do lll = ll, m - 1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll+1 ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           else
              ! run convergence test in backward direction
              ! first apply standard test to top of matrix
              if( abs( e( ll ) )<=abs( tol )*abs( d( ll ) ) .or.( tol<zero .and. abs( e( ll ) )&
                        <=thresh ) ) then
                 e( ll ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion backward
                 mu = abs( d( m ) )
                 sminl = mu
                 do lll = m - 1, ll, -1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           end if
           oldll = ll
           oldm = m
           ! compute shift.  first, test if shifting would ruin relative
           ! accuracy, and if so set the shift to zero.
           if( tol>=zero .and. n*tol*( sminl / smax )<=max( eps, hndrth*tol ) ) then
              ! use a zero shift to avoid loss of relative accuracy
              shift = zero
           else
              ! compute the shift from 2-by-2 block at end of matrix
              if( idir==1 ) then
                 sll = abs( d( ll ) )
                 call stdlib_slas2( d( m-1 ), e( m-1 ), d( m ), shift, r )
              else
                 sll = abs( d( m ) )
                 call stdlib_slas2( d( ll ), e( ll ), d( ll+1 ), shift, r )
              end if
              ! test if shift negligible, and if so set to zero
              if( sll>zero ) then
                 if( ( shift / sll )**2<eps )shift = zero
              end if
           end if
           ! increment iteration count
           iter = iter + m - ll
           ! if shift = 0, do simplified qr iteration
           if( shift==zero ) then
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = ll, m - 1
                    call stdlib_slartg( d( i )*cs, e( i ), cs, sn, r )
                    if( i>ll )e( i-1 ) = oldsn*r
                    call stdlib_slartg( oldcs*r, d( i+1 )*sn, oldcs, oldsn, d( i ) )
                    rwork( i-ll+1 ) = cs
                    rwork( i-ll+1+nm1 ) = sn
                    rwork( i-ll+1+nm12 ) = oldcs
                    rwork( i-ll+1+nm13 ) = oldsn
                 end do
                 h = d( m )*cs
                 d( m ) = h*oldcs
                 e( m-1 ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_clasr( 'L', 'V', 'F', m-ll+1, ncvt, rwork( 1 ),rwork( n )&
                           , vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_clasr( 'R', 'V', 'F', nru, m-ll+1, rwork( nm12+1 ),rwork( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_clasr( 'L', 'V', 'F', m-ll+1, ncc, rwork( nm12+1 ),rwork( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = m, ll + 1, -1
                    call stdlib_slartg( d( i )*cs, e( i-1 ), cs, sn, r )
                    if( i<m )e( i ) = oldsn*r
                    call stdlib_slartg( oldcs*r, d( i-1 )*sn, oldcs, oldsn, d( i ) )
                    rwork( i-ll ) = cs
                    rwork( i-ll+nm1 ) = -sn
                    rwork( i-ll+nm12 ) = oldcs
                    rwork( i-ll+nm13 ) = -oldsn
                 end do
                 h = d( ll )*cs
                 d( ll ) = h*oldcs
                 e( ll ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_clasr( 'L', 'V', 'B', m-ll+1, ncvt, rwork( nm12+1 ),&
                           rwork( nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_clasr( 'R', 'V', 'B', nru, m-ll+1, rwork( 1 ),rwork( n ), &
                           u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_clasr( 'L', 'V', 'B', m-ll+1, ncc, rwork( 1 ),rwork( n ), &
                           c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
              end if
           else
              ! use nonzero shift
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( ll ) )-shift )*( sign( one, d( ll ) )+shift / d( ll ) )
                 g = e( ll )
                 do i = ll, m - 1
                    call stdlib_slartg( f, g, cosr, sinr, r )
                    if( i>ll )e( i-1 ) = r
                    f = cosr*d( i ) + sinr*e( i )
                    e( i ) = cosr*e( i ) - sinr*d( i )
                    g = sinr*d( i+1 )
                    d( i+1 ) = cosr*d( i+1 )
                    call stdlib_slartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i ) + sinl*d( i+1 )
                    d( i+1 ) = cosl*d( i+1 ) - sinl*e( i )
                    if( i<m-1 ) then
                       g = sinl*e( i+1 )
                       e( i+1 ) = cosl*e( i+1 )
                    end if
                    rwork( i-ll+1 ) = cosr
                    rwork( i-ll+1+nm1 ) = sinr
                    rwork( i-ll+1+nm12 ) = cosl
                    rwork( i-ll+1+nm13 ) = sinl
                 end do
                 e( m-1 ) = f
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_clasr( 'L', 'V', 'F', m-ll+1, ncvt, rwork( 1 ),rwork( n )&
                           , vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_clasr( 'R', 'V', 'F', nru, m-ll+1, rwork( nm12+1 ),rwork( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_clasr( 'L', 'V', 'F', m-ll+1, ncc, rwork( nm12+1 ),rwork( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( m ) )-shift )*( sign( one, d( m ) )+shift /d( m ) )
                 g = e( m-1 )
                 do i = m, ll + 1, -1
                    call stdlib_slartg( f, g, cosr, sinr, r )
                    if( i<m )e( i ) = r
                    f = cosr*d( i ) + sinr*e( i-1 )
                    e( i-1 ) = cosr*e( i-1 ) - sinr*d( i )
                    g = sinr*d( i-1 )
                    d( i-1 ) = cosr*d( i-1 )
                    call stdlib_slartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i-1 ) + sinl*d( i-1 )
                    d( i-1 ) = cosl*d( i-1 ) - sinl*e( i-1 )
                    if( i>ll+1 ) then
                       g = sinl*e( i-2 )
                       e( i-2 ) = cosl*e( i-2 )
                    end if
                    rwork( i-ll ) = cosr
                    rwork( i-ll+nm1 ) = -sinr
                    rwork( i-ll+nm12 ) = cosl
                    rwork( i-ll+nm13 ) = -sinl
                 end do
                 e( ll ) = f
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
                 ! update singular vectors if desired
                 if( ncvt>0 )call stdlib_clasr( 'L', 'V', 'B', m-ll+1, ncvt, rwork( nm12+1 ),&
                           rwork( nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_clasr( 'R', 'V', 'B', nru, m-ll+1, rwork( 1 ),rwork( n ), &
                           u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_clasr( 'L', 'V', 'B', m-ll+1, ncc, rwork( 1 ),rwork( n ), &
                           c( ll, 1 ), ldc )
              end if
           end if
           ! qr iteration finished, go back and check convergence
           go to 60
           ! all singular values converged, so make them positive
           160 continue
           do i = 1, n
              if( d( i )<zero ) then
                 d( i ) = -d( i )
                 ! change sign of singular vectors, if desired
                 if( ncvt>0 )call stdlib_csscal( ncvt, negone, vt( i, 1 ), ldvt )
              end if
           end do
           ! sort the singular values into decreasing order (insertion sort on
           ! singular values, but only one transposition per singular vector)
           do i = 1, n - 1
              ! scan for smallest d(i)
              isub = 1
              smin = d( 1 )
              do j = 2, n + 1 - i
                 if( d( j )<=smin ) then
                    isub = j
                    smin = d( j )
                 end if
              end do
              if( isub/=n+1-i ) then
                 ! swap singular values and vectors
                 d( isub ) = d( n+1-i )
                 d( n+1-i ) = smin
                 if( ncvt>0 )call stdlib_cswap( ncvt, vt( isub, 1 ), ldvt, vt( n+1-i, 1 ),ldvt )
                           
                 if( nru>0 )call stdlib_cswap( nru, u( 1, isub ), 1, u( 1, n+1-i ), 1 )
                 if( ncc>0 )call stdlib_cswap( ncc, c( isub, 1 ), ldc, c( n+1-i, 1 ), ldc )
                           
              end if
           end do
           go to 220
           ! maximum number of iterations exceeded, failure to converge
           200 continue
           info = 0
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           220 continue
           return
     end subroutine stdlib_cbdsqr


     pure subroutine stdlib_cgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,work, rwork, &
     !! CGBCON estimates the reciprocal of the condition number of a complex
     !! general band matrix A, in either the 1-norm or the infinity-norm,
     !! using the LU factorization computed by CGBTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as
     !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(in) :: ab(ldab,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lnoti, onenrm
           character :: normin
           integer(ilp) :: ix, j, jp, kase, kase1, kd, lm
           real(sp) :: ainvnm, scale, smlnum
           complex(sp) :: t, zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,min,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           onenrm = norm=='1' .or. stdlib_lsame( norm, 'O' )
           if( .not.onenrm .and. .not.stdlib_lsame( norm, 'I' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kl<0 ) then
              info = -3
           else if( ku<0 ) then
              info = -4
           else if( ldab<2*kl+ku+1 ) then
              info = -6
           else if( anorm<zero ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGBCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm==zero ) then
              return
           end if
           smlnum = stdlib_slamch( 'SAFE MINIMUM' )
           ! estimate the norm of inv(a).
           ainvnm = zero
           normin = 'N'
           if( onenrm ) then
              kase1 = 1
           else
              kase1 = 2
           end if
           kd = kl + ku + 1
           lnoti = kl>0
           kase = 0
           10 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( kase==kase1 ) then
                 ! multiply by inv(l).
                 if( lnoti ) then
                    do j = 1, n - 1
                       lm = min( kl, n-j )
                       jp = ipiv( j )
                       t = work( jp )
                       if( jp/=j ) then
                          work( jp ) = work( j )
                          work( j ) = t
                       end if
                       call stdlib_caxpy( lm, -t, ab( kd+1, j ), 1, work( j+1 ), 1 )
                    end do
                 end if
                 ! multiply by inv(u).
                 call stdlib_clatbs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', normin, n,kl+ku, ab, &
                           ldab, work, scale, rwork, info )
              else
                 ! multiply by inv(u**h).
                 call stdlib_clatbs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',normin, n, kl+ku, &
                           ab, ldab, work, scale, rwork,info )
                 ! multiply by inv(l**h).
                 if( lnoti ) then
                    do j = n - 1, 1, -1
                       lm = min( kl, n-j )
                       work( j ) = work( j ) - stdlib_cdotc( lm, ab( kd+1, j ), 1,work( j+1 ), 1 )
                                 
                       jp = ipiv( j )
                       if( jp/=j ) then
                          t = work( jp )
                          work( jp ) = work( j )
                          work( j ) = t
                       end if
                    end do
                 end if
              end if
              ! divide x by 1/scale if doing so will not cause overflow.
              normin = 'Y'
              if( scale/=one ) then
                 ix = stdlib_icamax( n, work, 1 )
                 if( scale<cabs1( work( ix ) )*smlnum .or. scale==zero )go to 40
                 call stdlib_csrscl( n, scale, work, 1 )
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           40 continue
           return
     end subroutine stdlib_cgbcon


     pure subroutine stdlib_cgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
     !! CGBTRF computes an LU factorization of a complex m-by-n band matrix A
     !! using partial pivoting with row interchanges.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: ab(ldab,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldwork = nbmax+1
           
           
           ! Local Scalars 
           integer(ilp) :: i, i2, i3, ii, ip, j, j2, j3, jb, jj, jm, jp, ju, k2, km, kv, nb, &
                     nw
           complex(sp) :: temp
           ! Local Arrays 
           complex(sp) :: work13(ldwork,nbmax), work31(ldwork,nbmax)
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! kv is the number of superdiagonals in the factor u, allowing for
           ! fill-in
           kv = ku + kl
           ! test the input parameters.
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kl<0 ) then
              info = -3
           else if( ku<0 ) then
              info = -4
           else if( ldab<kl+kv+1 ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGBTRF', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           ! determine the block size for this environment
           nb = stdlib_ilaenv( 1, 'CGBTRF', ' ', m, n, kl, ku )
           ! the block size must not exceed the limit set by the size of the
           ! local arrays work13 and work31.
           nb = min( nb, nbmax )
           if( nb<=1 .or. nb>kl ) then
              ! use unblocked code
              call stdlib_cgbtf2( m, n, kl, ku, ab, ldab, ipiv, info )
           else
              ! use blocked code
              ! czero the superdiagonal elements of the work array work13
              do j = 1, nb
                 do i = 1, j - 1
                    work13( i, j ) = czero
                 end do
              end do
              ! czero the subdiagonal elements of the work array work31
              do j = 1, nb
                 do i = j + 1, nb
                    work31( i, j ) = czero
                 end do
              end do
              ! gaussian elimination with partial pivoting
              ! set fill-in elements in columns ku+2 to kv to czero
              do j = ku + 2, min( kv, n )
                 do i = kv - j + 2, kl
                    ab( i, j ) = czero
                 end do
              end do
              ! ju is the index of the last column affected by the current
              ! stage of the factorization
              ju = 1
              loop_180: do j = 1, min( m, n ), nb
                 jb = min( nb, min( m, n )-j+1 )
                 ! the active part of the matrix is partitioned
                    ! a11   a12   a13
                    ! a21   a22   a23
                    ! a31   a32   a33
                 ! here a11, a21 and a31 denote the current block of jb columns
                 ! which is about to be factorized. the number of rows in the
                 ! partitioning are jb, i2, i3 respectively, and the numbers
                 ! of columns are jb, j2, j3. the superdiagonal elements of a13
                 ! and the subdiagonal elements of a31 lie outside the band.
                 i2 = min( kl-jb, m-j-jb+1 )
                 i3 = min( jb, m-j-kl+1 )
                 ! j2 and j3 are computed after ju has been updated.
                 ! factorize the current block of jb columns
                 loop_80: do jj = j, j + jb - 1
                    ! set fill-in elements in column jj+kv to czero
                    if( jj+kv<=n ) then
                       do i = 1, kl
                          ab( i, jj+kv ) = czero
                       end do
                    end if
                    ! find pivot and test for singularity. km is the number of
                    ! subdiagonal elements in the current column.
                    km = min( kl, m-jj )
                    jp = stdlib_icamax( km+1, ab( kv+1, jj ), 1 )
                    ipiv( jj ) = jp + jj - j
                    if( ab( kv+jp, jj )/=czero ) then
                       ju = max( ju, min( jj+ku+jp-1, n ) )
                       if( jp/=1 ) then
                          ! apply interchange to columns j to j+jb-1
                          if( jp+jj-1<j+kl ) then
                             call stdlib_cswap( jb, ab( kv+1+jj-j, j ), ldab-1,ab( kv+jp+jj-j, j )&
                                       , ldab-1 )
                          else
                             ! the interchange affects columns j to jj-1 of a31
                             ! which are stored in the work array work31
                             call stdlib_cswap( jj-j, ab( kv+1+jj-j, j ), ldab-1,work31( jp+jj-j-&
                                       kl, 1 ), ldwork )
                             call stdlib_cswap( j+jb-jj, ab( kv+1, jj ), ldab-1,ab( kv+jp, jj ), &
                                       ldab-1 )
                          end if
                       end if
                       ! compute multipliers
                       call stdlib_cscal( km, cone / ab( kv+1, jj ), ab( kv+2, jj ),1 )
                       ! update trailing submatrix within the band and within
                       ! the current block. jm is the index of the last column
                       ! which needs to be updated.
                       jm = min( ju, j+jb-1 )
                       if( jm>jj )call stdlib_cgeru( km, jm-jj, -cone, ab( kv+2, jj ), 1,ab( kv, &
                                 jj+1 ), ldab-1,ab( kv+1, jj+1 ), ldab-1 )
                    else
                       ! if pivot is czero, set info to the index of the pivot
                       ! unless a czero pivot has already been found.
                       if( info==0 )info = jj
                    end if
                    ! copy current column of a31 into the work array work31
                    nw = min( jj-j+1, i3 )
                    if( nw>0 )call stdlib_ccopy( nw, ab( kv+kl+1-jj+j, jj ), 1,work31( 1, jj-j+1 )&
                              , 1 )
                 end do loop_80
                 if( j+jb<=n ) then
                    ! apply the row interchanges to the other blocks.
                    j2 = min( ju-j+1, kv ) - jb
                    j3 = max( 0, ju-j-kv+1 )
                    ! use stdlib_claswp to apply the row interchanges to a12, a22, and
                    ! a32.
                    call stdlib_claswp( j2, ab( kv+1-jb, j+jb ), ldab-1, 1, jb,ipiv( j ), 1 )
                              
                    ! adjust the pivot indices.
                    do i = j, j + jb - 1
                       ipiv( i ) = ipiv( i ) + j - 1
                    end do
                    ! apply the row interchanges to a13, a23, and a33
                    ! columnwise.
                    k2 = j - 1 + jb + j2
                    do i = 1, j3
                       jj = k2 + i
                       do ii = j + i - 1, j + jb - 1
                          ip = ipiv( ii )
                          if( ip/=ii ) then
                             temp = ab( kv+1+ii-jj, jj )
                             ab( kv+1+ii-jj, jj ) = ab( kv+1+ip-jj, jj )
                             ab( kv+1+ip-jj, jj ) = temp
                          end if
                       end do
                    end do
                    ! update the relevant part of the trailing submatrix
                    if( j2>0 ) then
                       ! update a12
                       call stdlib_ctrsm( 'LEFT', 'LOWER', 'NO TRANSPOSE', 'UNIT',jb, j2, cone, &
                                 ab( kv+1, j ), ldab-1,ab( kv+1-jb, j+jb ), ldab-1 )
                       if( i2>0 ) then
                          ! update a22
                          call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', i2, j2,jb, -cone, ab(&
                           kv+1+jb, j ), ldab-1,ab( kv+1-jb, j+jb ), ldab-1, cone,ab( kv+1, j+jb )&
                                     , ldab-1 )
                       end if
                       if( i3>0 ) then
                          ! update a32
                          call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', i3, j2,jb, -cone, &
                          work31, ldwork,ab( kv+1-jb, j+jb ), ldab-1, cone,ab( kv+kl+1-jb, j+jb ),&
                                     ldab-1 )
                       end if
                    end if
                    if( j3>0 ) then
                       ! copy the lower triangle of a13 into the work array
                       ! work13
                       do jj = 1, j3
                          do ii = jj, jb
                             work13( ii, jj ) = ab( ii-jj+1, jj+j+kv-1 )
                          end do
                       end do
                       ! update a13 in the work array
                       call stdlib_ctrsm( 'LEFT', 'LOWER', 'NO TRANSPOSE', 'UNIT',jb, j3, cone, &
                                 ab( kv+1, j ), ldab-1,work13, ldwork )
                       if( i2>0 ) then
                          ! update a23
                          call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', i2, j3,jb, -cone, ab(&
                           kv+1+jb, j ), ldab-1,work13, ldwork, cone, ab( 1+jb, j+kv ),ldab-1 )
                                     
                       end if
                       if( i3>0 ) then
                          ! update a33
                          call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', i3, j3,jb, -cone, &
                                    work31, ldwork, work13,ldwork, cone, ab( 1+kl, j+kv ), ldab-1 )
                       end if
                       ! copy the lower triangle of a13 back into place
                       do jj = 1, j3
                          do ii = jj, jb
                             ab( ii-jj+1, jj+j+kv-1 ) = work13( ii, jj )
                          end do
                       end do
                    end if
                 else
                    ! adjust the pivot indices.
                    do i = j, j + jb - 1
                       ipiv( i ) = ipiv( i ) + j - 1
                    end do
                 end if
                 ! partially undo the interchanges in the current block to
                 ! restore the upper triangular form of a31 and copy the upper
                 ! triangle of a31 back into place
                 do jj = j + jb - 1, j, -1
                    jp = ipiv( jj ) - jj + 1
                    if( jp/=1 ) then
                       ! apply interchange to columns j to jj-1
                       if( jp+jj-1<j+kl ) then
                          ! the interchange does not affect a31
                          call stdlib_cswap( jj-j, ab( kv+1+jj-j, j ), ldab-1,ab( kv+jp+jj-j, j ),&
                                     ldab-1 )
                       else
                          ! the interchange does affect a31
                          call stdlib_cswap( jj-j, ab( kv+1+jj-j, j ), ldab-1,work31( jp+jj-j-kl, &
                                    1 ), ldwork )
                       end if
                    end if
                    ! copy the current column of a31 back into place
                    nw = min( i3, jj-j+1 )
                    if( nw>0 )call stdlib_ccopy( nw, work31( 1, jj-j+1 ), 1,ab( kv+kl+1-jj+j, jj )&
                              , 1 )
                 end do
              end do loop_180
           end if
           return
     end subroutine stdlib_cgbtrf


     pure subroutine stdlib_cgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,info )
     !! CGBTRS solves a system of linear equations
     !! A * X = B,  A**T * X = B,  or  A**H * X = B
     !! with a general band matrix A using the LU factorization computed
     !! by CGBTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: ab(ldab,*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lnoti, notran
           integer(ilp) :: i, j, kd, l, lm
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( trans, &
                     'C' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kl<0 ) then
              info = -3
           else if( ku<0 ) then
              info = -4
           else if( nrhs<0 ) then
              info = -5
           else if( ldab<( 2*kl+ku+1 ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGBTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           kd = ku + kl + 1
           lnoti = kl>0
           if( notran ) then
              ! solve  a*x = b.
              ! solve l*x = b, overwriting b with x.
              ! l is represented as a product of permutations and unit lower
              ! triangular matrices l = p(1) * l(1) * ... * p(n-1) * l(n-1),
              ! where each transformation l(i) is a rank-cone modification of
              ! the identity matrix.
              if( lnoti ) then
                 do j = 1, n - 1
                    lm = min( kl, n-j )
                    l = ipiv( j )
                    if( l/=j )call stdlib_cswap( nrhs, b( l, 1 ), ldb, b( j, 1 ), ldb )
                    call stdlib_cgeru( lm, nrhs, -cone, ab( kd+1, j ), 1, b( j, 1 ),ldb, b( j+1, &
                              1 ), ldb )
                 end do
              end if
              do i = 1, nrhs
                 ! solve u*x = b, overwriting b with x.
                 call stdlib_ctbsv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n, kl+ku,ab, ldab, b( 1, &
                           i ), 1 )
              end do
           else if( stdlib_lsame( trans, 'T' ) ) then
              ! solve a**t * x = b.
              do i = 1, nrhs
                 ! solve u**t * x = b, overwriting b with x.
                 call stdlib_ctbsv( 'UPPER', 'TRANSPOSE', 'NON-UNIT', n, kl+ku, ab,ldab, b( 1, i )&
                           , 1 )
              end do
              ! solve l**t * x = b, overwriting b with x.
              if( lnoti ) then
                 do j = n - 1, 1, -1
                    lm = min( kl, n-j )
                    call stdlib_cgemv( 'TRANSPOSE', lm, nrhs, -cone, b( j+1, 1 ),ldb, ab( kd+1, j &
                              ), 1, cone, b( j, 1 ), ldb )
                    l = ipiv( j )
                    if( l/=j )call stdlib_cswap( nrhs, b( l, 1 ), ldb, b( j, 1 ), ldb )
                 end do
              end if
           else
              ! solve a**h * x = b.
              do i = 1, nrhs
                 ! solve u**h * x = b, overwriting b with x.
                 call stdlib_ctbsv( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT', n,kl+ku, ab, ldab,&
                            b( 1, i ), 1 )
              end do
              ! solve l**h * x = b, overwriting b with x.
              if( lnoti ) then
                 do j = n - 1, 1, -1
                    lm = min( kl, n-j )
                    call stdlib_clacgv( nrhs, b( j, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', lm, nrhs, -cone,b( j+1, 1 ), ldb, &
                              ab( kd+1, j ), 1, cone,b( j, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( j, 1 ), ldb )
                    l = ipiv( j )
                    if( l/=j )call stdlib_cswap( nrhs, b( l, 1 ), ldb, b( j, 1 ), ldb )
                 end do
              end if
           end if
           return
     end subroutine stdlib_cgbtrs


     pure subroutine stdlib_cgebd2( m, n, a, lda, d, e, tauq, taup, work, info )
     !! CGEBD2 reduces a complex general m by n matrix A to upper or lower
     !! real bidiagonal form B by a unitary transformation: Q**H * A * P = B.
     !! If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: taup(*), tauq(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(sp) :: alpha
           ! Intrinsic Functions 
           intrinsic :: conjg,max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info<0 ) then
              call stdlib_xerbla( 'CGEBD2', -info )
              return
           end if
           if( m>=n ) then
              ! reduce to upper bidiagonal form
              do i = 1, n
                 ! generate elementary reflector h(i) to annihilate a(i+1:m,i)
                 alpha = a( i, i )
                 call stdlib_clarfg( m-i+1, alpha, a( min( i+1, m ), i ), 1,tauq( i ) )
                 d( i ) = real( alpha,KIND=sp)
                 a( i, i ) = cone
                 ! apply h(i)**h to a(i:m,i+1:n) from the left
                 if( i<n )call stdlib_clarf( 'LEFT', m-i+1, n-i, a( i, i ), 1,conjg( tauq( i ) ), &
                           a( i, i+1 ), lda, work )
                 a( i, i ) = d( i )
                 if( i<n ) then
                    ! generate elementary reflector g(i) to annihilate
                    ! a(i,i+2:n)
                    call stdlib_clacgv( n-i, a( i, i+1 ), lda )
                    alpha = a( i, i+1 )
                    call stdlib_clarfg( n-i, alpha, a( i, min( i+2, n ) ),lda, taup( i ) )
                    e( i ) = real( alpha,KIND=sp)
                    a( i, i+1 ) = cone
                    ! apply g(i) to a(i+1:m,i+1:n) from the right
                    call stdlib_clarf( 'RIGHT', m-i, n-i, a( i, i+1 ), lda,taup( i ), a( i+1, i+1 &
                              ), lda, work )
                    call stdlib_clacgv( n-i, a( i, i+1 ), lda )
                    a( i, i+1 ) = e( i )
                 else
                    taup( i ) = czero
                 end if
              end do
           else
              ! reduce to lower bidiagonal form
              do i = 1, m
                 ! generate elementary reflector g(i) to annihilate a(i,i+1:n)
                 call stdlib_clacgv( n-i+1, a( i, i ), lda )
                 alpha = a( i, i )
                 call stdlib_clarfg( n-i+1, alpha, a( i, min( i+1, n ) ), lda,taup( i ) )
                 d( i ) = real( alpha,KIND=sp)
                 a( i, i ) = cone
                 ! apply g(i) to a(i+1:m,i:n) from the right
                 if( i<m )call stdlib_clarf( 'RIGHT', m-i, n-i+1, a( i, i ), lda,taup( i ), a( i+&
                           1, i ), lda, work )
                 call stdlib_clacgv( n-i+1, a( i, i ), lda )
                 a( i, i ) = d( i )
                 if( i<m ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(i+2:m,i)
                    alpha = a( i+1, i )
                    call stdlib_clarfg( m-i, alpha, a( min( i+2, m ), i ), 1,tauq( i ) )
                    e( i ) = real( alpha,KIND=sp)
                    a( i+1, i ) = cone
                    ! apply h(i)**h to a(i+1:m,i+1:n) from the left
                    call stdlib_clarf( 'LEFT', m-i, n-i, a( i+1, i ), 1,conjg( tauq( i ) ), a( i+&
                              1, i+1 ), lda,work )
                    a( i+1, i ) = e( i )
                 else
                    tauq( i ) = czero
                 end if
              end do
           end if
           return
     end subroutine stdlib_cgebd2


     pure subroutine stdlib_cgecon( norm, n, a, lda, anorm, rcond, work, rwork,info )
     !! CGECON estimates the reciprocal of the condition number of a general
     !! complex matrix A, in either the 1-norm or the infinity-norm, using
     !! the LU factorization computed by CGETRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as
     !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: onenrm
           character :: normin
           integer(ilp) :: ix, kase, kase1
           real(sp) :: ainvnm, scale, sl, smlnum, su
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           onenrm = norm=='1' .or. stdlib_lsame( norm, 'O' )
           if( .not.onenrm .and. .not.stdlib_lsame( norm, 'I' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGECON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm==zero ) then
              return
           end if
           smlnum = stdlib_slamch( 'SAFE MINIMUM' )
           ! estimate the norm of inv(a).
           ainvnm = zero
           normin = 'N'
           if( onenrm ) then
              kase1 = 1
           else
              kase1 = 2
           end if
           kase = 0
           10 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( kase==kase1 ) then
                 ! multiply by inv(l).
                 call stdlib_clatrs( 'LOWER', 'NO TRANSPOSE', 'UNIT', normin, n, a,lda, work, sl, &
                           rwork, info )
                 ! multiply by inv(u).
                 call stdlib_clatrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', normin, n,a, lda, work, &
                           su, rwork( n+1 ), info )
              else
                 ! multiply by inv(u**h).
                 call stdlib_clatrs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',normin, n, a, lda,&
                            work, su, rwork( n+1 ),info )
                 ! multiply by inv(l**h).
                 call stdlib_clatrs( 'LOWER', 'CONJUGATE TRANSPOSE', 'UNIT', normin,n, a, lda, &
                           work, sl, rwork, info )
              end if
              ! divide x by 1/(sl*su) if doing so will not cause overflow.
              scale = sl*su
              normin = 'Y'
              if( scale/=one ) then
                 ix = stdlib_icamax( n, work, 1 )
                 if( scale<cabs1( work( ix ) )*smlnum .or. scale==zero )go to 20
                 call stdlib_csrscl( n, scale, work, 1 )
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           20 continue
           return
     end subroutine stdlib_cgecon


     pure subroutine stdlib_cgehd2( n, ilo, ihi, a, lda, tau, work, info )
     !! CGEHD2 reduces a complex general matrix A to upper Hessenberg form H
     !! by a unitary similarity transformation:  Q**H * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(sp) :: alpha
           ! Intrinsic Functions 
           intrinsic :: conjg,max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEHD2', -info )
              return
           end if
           do i = ilo, ihi - 1
              ! compute elementary reflector h(i) to annihilate a(i+2:ihi,i)
              alpha = a( i+1, i )
              call stdlib_clarfg( ihi-i, alpha, a( min( i+2, n ), i ), 1, tau( i ) )
              a( i+1, i ) = cone
              ! apply h(i) to a(1:ihi,i+1:ihi) from the right
              call stdlib_clarf( 'RIGHT', ihi, ihi-i, a( i+1, i ), 1, tau( i ),a( 1, i+1 ), lda, &
                        work )
              ! apply h(i)**h to a(i+1:ihi,i+1:n) from the left
              call stdlib_clarf( 'LEFT', ihi-i, n-i, a( i+1, i ), 1,conjg( tau( i ) ), a( i+1, i+&
                        1 ), lda, work )
              a( i+1, i ) = alpha
           end do
           return
     end subroutine stdlib_cgehd2


     pure subroutine stdlib_cgelq2( m, n, a, lda, tau, work, info )
     !! CGELQ2 computes an LQ factorization of a complex m-by-n matrix A:
     !! A = ( L 0 ) *  Q
     !! where:
     !! Q is a n-by-n orthogonal matrix;
     !! L is a lower-triangular m-by-m matrix;
     !! 0 is a m-by-(n-m) zero matrix, if m < n.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, k
           complex(sp) :: alpha
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGELQ2', -info )
              return
           end if
           k = min( m, n )
           do i = 1, k
              ! generate elementary reflector h(i) to annihilate a(i,i+1:n)
              call stdlib_clacgv( n-i+1, a( i, i ), lda )
              alpha = a( i, i )
              call stdlib_clarfg( n-i+1, alpha, a( i, min( i+1, n ) ), lda,tau( i ) )
              if( i<m ) then
                 ! apply h(i) to a(i+1:m,i:n) from the right
                 a( i, i ) = cone
                 call stdlib_clarf( 'RIGHT', m-i, n-i+1, a( i, i ), lda, tau( i ),a( i+1, i ), &
                           lda, work )
              end if
              a( i, i ) = alpha
              call stdlib_clacgv( n-i+1, a( i, i ), lda )
           end do
           return
     end subroutine stdlib_cgelq2


     pure subroutine stdlib_cgelqf( m, n, a, lda, tau, work, lwork, info )
     !! CGELQF computes an LQ factorization of a complex M-by-N matrix A:
     !! A = ( L 0 ) *  Q
     !! where:
     !! Q is a N-by-N orthogonal matrix;
     !! L is a lower-triangular M-by-M matrix;
     !! 0 is a M-by-(N-M) zero matrix, if M < N.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iws, k, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nb = stdlib_ilaenv( 1, 'CGELQF', ' ', m, n, -1, -1 )
           lwkopt = m*nb
           work( 1 ) = lwkopt
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           else if( lwork<max( 1, m ) .and. .not.lquery ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGELQF', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           k = min( m, n )
           if( k==0 ) then
              work( 1 ) = 1
              return
           end if
           nbmin = 2
           nx = 0
           iws = m
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'CGELQF', ' ', m, n, -1, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = m
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'CGELQF', ' ', m, n, -1,-1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code initially
              do i = 1, k - nx, nb
                 ib = min( k-i+1, nb )
                 ! compute the lq factorization of the current block
                 ! a(i:i+ib-1,i:n)
                 call stdlib_cgelq2( ib, n-i+1, a( i, i ), lda, tau( i ), work,iinfo )
                 if( i+ib<=m ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i) h(i+1) . . . h(i+ib-1)
                    call stdlib_clarft( 'FORWARD', 'ROWWISE', n-i+1, ib, a( i, i ),lda, tau( i ), &
                              work, ldwork )
                    ! apply h to a(i+ib:m,i:n) from the right
                    call stdlib_clarfb( 'RIGHT', 'NO TRANSPOSE', 'FORWARD','ROWWISE', m-i-ib+1, n-&
                    i+1, ib, a( i, i ),lda, work, ldwork, a( i+ib, i ), lda,work( ib+1 ), ldwork )
                              
                 end if
              end do
           else
              i = 1
           end if
           ! use unblocked code to factor the last or only block.
           if( i<=k )call stdlib_cgelq2( m-i+1, n-i+1, a( i, i ), lda, tau( i ), work,iinfo )
                     
           work( 1 ) = iws
           return
     end subroutine stdlib_cgelqf


     pure recursive subroutine stdlib_cgelqt3( m, n, a, lda, t, ldt, info )
     !! CGELQT3 recursively computes a LQ factorization of a complex M-by-N
     !! matrix A, using the compact WY representation of Q.
     !! Based on the algorithm of Elmroth and Gustavson,
     !! IBM J. Res. Develop. Vol 44 No. 4 July 2000.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, ldt
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: t(ldt,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, i1, j, j1, m1, m2, iinfo
           ! Executable Statements 
           info = 0
           if( m < 0 ) then
              info = -1
           else if( n < m ) then
              info = -2
           else if( lda < max( 1, m ) ) then
              info = -4
           else if( ldt < max( 1, m ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGELQT3', -info )
              return
           end if
           if( m==1 ) then
              ! compute householder transform when m=1
              call stdlib_clarfg( n, a(1,1), a( 1, min( 2, n ) ), lda, t(1,1) )
              t(1,1)=conjg(t(1,1))
           else
              ! otherwise, split a into blocks...
              m1 = m/2
              m2 = m-m1
              i1 = min( m1+1, m )
              j1 = min( m+1, n )
              ! compute a(1:m1,1:n) <- (y1,r1,t1), where q1 = i - y1 t1 y1^h
              call stdlib_cgelqt3( m1, n, a, lda, t, ldt, iinfo )
              ! compute a(j1:m,1:n) =  a(j1:m,1:n) q1^h [workspace: t(1:n1,j1:n)]
              do i=1,m2
                 do j=1,m1
                    t(  i+m1, j ) = a( i+m1, j )
                 end do
              end do
              call stdlib_ctrmm( 'R', 'U', 'C', 'U', m2, m1, cone,a, lda, t( i1, 1 ), ldt )
                        
              call stdlib_cgemm( 'N', 'C', m2, m1, n-m1, cone, a( i1, i1 ), lda,a( 1, i1 ), lda, &
                        cone, t( i1, 1 ), ldt)
              call stdlib_ctrmm( 'R', 'U', 'N', 'N', m2, m1, cone,t, ldt, t( i1, 1 ), ldt )
                        
              call stdlib_cgemm( 'N', 'N', m2, n-m1, m1, -cone, t( i1, 1 ), ldt,a( 1, i1 ), lda, &
                        cone, a( i1, i1 ), lda )
              call stdlib_ctrmm( 'R', 'U', 'N', 'U', m2, m1 , cone,a, lda, t( i1, 1 ), ldt )
                        
              do i=1,m2
                 do j=1,m1
                    a(  i+m1, j ) = a( i+m1, j ) - t( i+m1, j )
                    t( i+m1, j )= czero
                 end do
              end do
              ! compute a(j1:m,j1:n) <- (y2,r2,t2) where q2 = i - y2 t2 y2^h
              call stdlib_cgelqt3( m2, n-m1, a( i1, i1 ), lda,t( i1, i1 ), ldt, iinfo )
              ! compute t3 = t(j1:n1,1:n) = -t1 y1^h y2 t2
              do i=1,m2
                 do j=1,m1
                    t( j, i+m1  ) = (a( j, i+m1 ))
                 end do
              end do
              call stdlib_ctrmm( 'R', 'U', 'C', 'U', m1, m2, cone,a( i1, i1 ), lda, t( 1, i1 ), &
                        ldt )
              call stdlib_cgemm( 'N', 'C', m1, m2, n-m, cone, a( 1, j1 ), lda,a( i1, j1 ), lda, &
                        cone, t( 1, i1 ), ldt )
              call stdlib_ctrmm( 'L', 'U', 'N', 'N', m1, m2, -cone, t, ldt,t( 1, i1 ), ldt )
                        
              call stdlib_ctrmm( 'R', 'U', 'N', 'N', m1, m2, cone,t( i1, i1 ), ldt, t( 1, i1 ), &
                        ldt )
              ! y = (y1,y2); l = [ l1            0  ];  t = [t1 t3]
                               ! [ a(1:n1,j1:n)  l2 ]       [ 0 t2]
           end if
           return
     end subroutine stdlib_cgelqt3


     pure subroutine stdlib_cgemlqt( side, trans, m, n, k, mb, v, ldv, t, ldt,c, ldc, work, info )
     !! CGEMLQT overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q C            C Q
     !! TRANS = 'C':   Q**H C            C Q**H
     !! where Q is a complex unitary matrix defined as the product of K
     !! elementary reflectors:
     !! Q = H(1) H(2) . . . H(K) = I - V T V**H
     !! generated using the compact WY representation as returned by CGELQT.
     !! Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, ldv, ldc, m, n, mb, ldt
           ! Array Arguments 
           complex(sp), intent(in) :: v(ldv,*), t(ldt,*)
           complex(sp), intent(inout) :: c(ldc,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, right, tran, notran
           integer(ilp) :: i, ib, ldwork, kf, q
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! Test The Input Arguments 
           info   = 0
           left   = stdlib_lsame( side,  'L' )
           right  = stdlib_lsame( side,  'R' )
           tran   = stdlib_lsame( trans, 'C' )
           notran = stdlib_lsame( trans, 'N' )
           if( left ) then
              ldwork = max( 1, n )
              q = m
           else if ( right ) then
              ldwork = max( 1, m )
              q = n
           end if
           if( .not.left .and. .not.right ) then
              info = -1
           else if( .not.tran .and. .not.notran ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>q ) then
              info = -5
           else if( mb<1 .or. (mb>k .and. k>0)) then
              info = -6
           else if( ldv<max( 1, k ) ) then
               info = -8
           else if( ldt<mb ) then
              info = -10
           else if( ldc<max( 1, m ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEMLQT', -info )
              return
           end if
           ! Quick Return If Possible 
           if( m==0 .or. n==0 .or. k==0 ) return
           if( left .and. notran ) then
              do i = 1, k, mb
                 ib = min( mb, k-i+1 )
                 call stdlib_clarfb( 'L', 'C', 'F', 'R', m-i+1, n, ib,v( i, i ), ldv, t( 1, i ), &
                           ldt,c( i, 1 ), ldc, work, ldwork )
              end do
           else if( right .and. tran ) then
              do i = 1, k, mb
                 ib = min( mb, k-i+1 )
                 call stdlib_clarfb( 'R', 'N', 'F', 'R', m, n-i+1, ib,v( i, i ), ldv, t( 1, i ), &
                           ldt,c( 1, i ), ldc, work, ldwork )
              end do
           else if( left .and. tran ) then
              kf = ((k-1)/mb)*mb+1
              do i = kf, 1, -mb
                 ib = min( mb, k-i+1 )
                 call stdlib_clarfb( 'L', 'N', 'F', 'R', m-i+1, n, ib,v( i, i ), ldv, t( 1, i ), &
                           ldt,c( i, 1 ), ldc, work, ldwork )
              end do
           else if( right .and. notran ) then
              kf = ((k-1)/mb)*mb+1
              do i = kf, 1, -mb
                 ib = min( mb, k-i+1 )
                 call stdlib_clarfb( 'R', 'C', 'F', 'R', m, n-i+1, ib,v( i, i ), ldv, t( 1, i ), &
                           ldt,c( 1, i ), ldc, work, ldwork )
              end do
           end if
           return
     end subroutine stdlib_cgemlqt


     pure subroutine stdlib_cgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,c, ldc, work, info )
     !! CGEMQRT overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q C            C Q
     !! TRANS = 'C':    Q**H C            C Q**H
     !! where Q is a complex orthogonal matrix defined as the product of K
     !! elementary reflectors:
     !! Q = H(1) H(2) . . . H(K) = I - V T V**H
     !! generated using the compact WY representation as returned by CGEQRT.
     !! Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, ldv, ldc, m, n, nb, ldt
           ! Array Arguments 
           complex(sp), intent(in) :: v(ldv,*), t(ldt,*)
           complex(sp), intent(inout) :: c(ldc,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, right, tran, notran
           integer(ilp) :: i, ib, ldwork, kf, q
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! Test The Input Arguments 
           info   = 0
           left   = stdlib_lsame( side,  'L' )
           right  = stdlib_lsame( side,  'R' )
           tran   = stdlib_lsame( trans, 'C' )
           notran = stdlib_lsame( trans, 'N' )
           if( left ) then
              ldwork = max( 1, n )
              q = m
           else if ( right ) then
              ldwork = max( 1, m )
              q = n
           end if
           if( .not.left .and. .not.right ) then
              info = -1
           else if( .not.tran .and. .not.notran ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 .or. k>q ) then
              info = -5
           else if( nb<1 .or. (nb>k .and. k>0)) then
              info = -6
           else if( ldv<max( 1, q ) ) then
              info = -8
           else if( ldt<nb ) then
              info = -10
           else if( ldc<max( 1, m ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEMQRT', -info )
              return
           end if
           ! Quick Return If Possible 
           if( m==0 .or. n==0 .or. k==0 ) return
           if( left .and. tran ) then
              do i = 1, k, nb
                 ib = min( nb, k-i+1 )
                 call stdlib_clarfb( 'L', 'C', 'F', 'C', m-i+1, n, ib,v( i, i ), ldv, t( 1, i ), &
                           ldt,c( i, 1 ), ldc, work, ldwork )
              end do
           else if( right .and. notran ) then
              do i = 1, k, nb
                 ib = min( nb, k-i+1 )
                 call stdlib_clarfb( 'R', 'N', 'F', 'C', m, n-i+1, ib,v( i, i ), ldv, t( 1, i ), &
                           ldt,c( 1, i ), ldc, work, ldwork )
              end do
           else if( left .and. notran ) then
              kf = ((k-1)/nb)*nb+1
              do i = kf, 1, -nb
                 ib = min( nb, k-i+1 )
                 call stdlib_clarfb( 'L', 'N', 'F', 'C', m-i+1, n, ib,v( i, i ), ldv, t( 1, i ), &
                           ldt,c( i, 1 ), ldc, work, ldwork )
              end do
           else if( right .and. tran ) then
              kf = ((k-1)/nb)*nb+1
              do i = kf, 1, -nb
                 ib = min( nb, k-i+1 )
                 call stdlib_clarfb( 'R', 'C', 'F', 'C', m, n-i+1, ib,v( i, i ), ldv, t( 1, i ), &
                           ldt,c( 1, i ), ldc, work, ldwork )
              end do
           end if
           return
     end subroutine stdlib_cgemqrt


     pure subroutine stdlib_cgeql2( m, n, a, lda, tau, work, info )
     !! CGEQL2 computes a QL factorization of a complex m by n matrix A:
     !! A = Q * L.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, k
           complex(sp) :: alpha
           ! Intrinsic Functions 
           intrinsic :: conjg,max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEQL2', -info )
              return
           end if
           k = min( m, n )
           do i = k, 1, -1
              ! generate elementary reflector h(i) to annihilate
              ! a(1:m-k+i-1,n-k+i)
              alpha = a( m-k+i, n-k+i )
              call stdlib_clarfg( m-k+i, alpha, a( 1, n-k+i ), 1, tau( i ) )
              ! apply h(i)**h to a(1:m-k+i,1:n-k+i-1) from the left
              a( m-k+i, n-k+i ) = cone
              call stdlib_clarf( 'LEFT', m-k+i, n-k+i-1, a( 1, n-k+i ), 1,conjg( tau( i ) ), a, &
                        lda, work )
              a( m-k+i, n-k+i ) = alpha
           end do
           return
     end subroutine stdlib_cgeql2


     pure subroutine stdlib_cgeqlf( m, n, a, lda, tau, work, lwork, info )
     !! CGEQLF computes a QL factorization of a complex M-by-N matrix A:
     !! A = Q * L.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iws, k, ki, kk, ldwork, lwkopt, mu, nb, nbmin, nu, &
                     nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info==0 ) then
              k = min( m, n )
              if( k==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'CGEQLF', ' ', m, n, -1, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<max( 1, n ) .and. .not.lquery ) then
                 info = -7
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEQLF', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( k==0 ) then
              return
           end if
           nbmin = 2
           nx = 1
           iws = n
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'CGEQLF', ' ', m, n, -1, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'CGEQLF', ' ', m, n, -1,-1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code initially.
              ! the last kk columns are handled by the block method.
              ki = ( ( k-nx-1 ) / nb )*nb
              kk = min( k, ki+nb )
              do i = k - kk + ki + 1, k - kk + 1, -nb
                 ib = min( k-i+1, nb )
                 ! compute the ql factorization of the current block
                 ! a(1:m-k+i+ib-1,n-k+i:n-k+i+ib-1)
                 call stdlib_cgeql2( m-k+i+ib-1, ib, a( 1, n-k+i ), lda, tau( i ),work, iinfo )
                           
                 if( n-k+i>1 ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i+ib-1) . . . h(i+1) h(i)
                    call stdlib_clarft( 'BACKWARD', 'COLUMNWISE', m-k+i+ib-1, ib,a( 1, n-k+i ), &
                              lda, tau( i ), work, ldwork )
                    ! apply h**h to a(1:m-k+i+ib-1,1:n-k+i-1) from the left
                    call stdlib_clarfb( 'LEFT', 'CONJUGATE TRANSPOSE', 'BACKWARD','COLUMNWISE', m-&
                    k+i+ib-1, n-k+i-1, ib,a( 1, n-k+i ), lda, work, ldwork, a, lda,work( ib+1 ), &
                              ldwork )
                 end if
              end do
              mu = m - k + i + nb - 1
              nu = n - k + i + nb - 1
           else
              mu = m
              nu = n
           end if
           ! use unblocked code to factor the last or only block
           if( mu>0 .and. nu>0 )call stdlib_cgeql2( mu, nu, a, lda, tau, work, iinfo )
           work( 1 ) = iws
           return
     end subroutine stdlib_cgeqlf


     pure subroutine stdlib_cgeqr2( m, n, a, lda, tau, work, info )
     !! CGEQR2 computes a QR factorization of a complex m-by-n matrix A:
     !! A = Q * ( R ),
     !! ( 0 )
     !! where:
     !! Q is a m-by-m orthogonal matrix;
     !! R is an upper-triangular n-by-n matrix;
     !! 0 is a (m-n)-by-n zero matrix, if m > n.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, k
           complex(sp) :: alpha
           ! Intrinsic Functions 
           intrinsic :: conjg,max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEQR2', -info )
              return
           end if
           k = min( m, n )
           do i = 1, k
              ! generate elementary reflector h(i) to annihilate a(i+1:m,i)
              call stdlib_clarfg( m-i+1, a( i, i ), a( min( i+1, m ), i ), 1,tau( i ) )
              if( i<n ) then
                 ! apply h(i)**h to a(i:m,i+1:n) from the left
                 alpha = a( i, i )
                 a( i, i ) = cone
                 call stdlib_clarf( 'LEFT', m-i+1, n-i, a( i, i ), 1,conjg( tau( i ) ), a( i, i+1 &
                           ), lda, work )
                 a( i, i ) = alpha
              end if
           end do
           return
     end subroutine stdlib_cgeqr2


     subroutine stdlib_cgeqr2p( m, n, a, lda, tau, work, info )
     !! CGEQR2P computes a QR factorization of a complex m-by-n matrix A:
     !! A = Q * ( R ),
     !! ( 0 )
     !! where:
     !! Q is a m-by-m orthogonal matrix;
     !! R is an upper-triangular n-by-n matrix with nonnegative diagonal
     !! entries;
     !! 0 is a (m-n)-by-n zero matrix, if m > n.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, k
           complex(sp) :: alpha
           ! Intrinsic Functions 
           intrinsic :: conjg,max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEQR2P', -info )
              return
           end if
           k = min( m, n )
           do i = 1, k
              ! generate elementary reflector h(i) to annihilate a(i+1:m,i)
              call stdlib_clarfgp( m-i+1, a( i, i ), a( min( i+1, m ), i ), 1,tau( i ) )
              if( i<n ) then
                 ! apply h(i)**h to a(i:m,i+1:n) from the left
                 alpha = a( i, i )
                 a( i, i ) = cone
                 call stdlib_clarf( 'LEFT', m-i+1, n-i, a( i, i ), 1,conjg( tau( i ) ), a( i, i+1 &
                           ), lda, work )
                 a( i, i ) = alpha
              end if
           end do
           return
     end subroutine stdlib_cgeqr2p


     pure subroutine stdlib_cgeqrf( m, n, a, lda, tau, work, lwork, info )
     !! CGEQRF computes a QR factorization of a complex M-by-N matrix A:
     !! A = Q * ( R ),
     !! ( 0 )
     !! where:
     !! Q is a M-by-M orthogonal matrix;
     !! R is an upper-triangular N-by-N matrix;
     !! 0 is a (M-N)-by-N zero matrix, if M > N.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iws, k, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           k = min( m, n )
           info = 0
           nb = stdlib_ilaenv( 1, 'CGEQRF', ' ', m, n, -1, -1 )
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           else if( .not.lquery ) then
              if( lwork<=0 .or. ( m>0 .and. lwork<max( 1, n ) ) )info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEQRF', -info )
              return
           else if( lquery ) then
              if( k==0 ) then
                 lwkopt = 1
              else
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
              return
           end if
           ! quick return if possible
           if( k==0 ) then
              work( 1 ) = 1
              return
           end if
           nbmin = 2
           nx = 0
           iws = n
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'CGEQRF', ' ', m, n, -1, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'CGEQRF', ' ', m, n, -1,-1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code initially
              do i = 1, k - nx, nb
                 ib = min( k-i+1, nb )
                 ! compute the qr factorization of the current block
                 ! a(i:m,i:i+ib-1)
                 call stdlib_cgeqr2( m-i+1, ib, a( i, i ), lda, tau( i ), work,iinfo )
                 if( i+ib<=n ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i) h(i+1) . . . h(i+ib-1)
                    call stdlib_clarft( 'FORWARD', 'COLUMNWISE', m-i+1, ib,a( i, i ), lda, tau( i &
                              ), work, ldwork )
                    ! apply h**h to a(i:m,i+ib:n) from the left
                    call stdlib_clarfb( 'LEFT', 'CONJUGATE TRANSPOSE', 'FORWARD','COLUMNWISE', m-&
                    i+1, n-i-ib+1, ib,a( i, i ), lda, work, ldwork, a( i, i+ib ),lda, work( ib+1 )&
                              , ldwork )
                 end if
              end do
           else
              i = 1
           end if
           ! use unblocked code to factor the last or only block.
           if( i<=k )call stdlib_cgeqr2( m-i+1, n-i+1, a( i, i ), lda, tau( i ), work,iinfo )
                     
           work( 1 ) = iws
           return
     end subroutine stdlib_cgeqrf


     subroutine stdlib_cgeqrfp( m, n, a, lda, tau, work, lwork, info )
     !! CGEQR2P computes a QR factorization of a complex M-by-N matrix A:
     !! A = Q * ( R ),
     !! ( 0 )
     !! where:
     !! Q is a M-by-M orthogonal matrix;
     !! R is an upper-triangular N-by-N matrix with nonnegative diagonal
     !! entries;
     !! 0 is a (M-N)-by-N zero matrix, if M > N.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iws, k, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nb = stdlib_ilaenv( 1, 'CGEQRF', ' ', m, n, -1, -1 )
           lwkopt = n*nb
           work( 1 ) = lwkopt
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEQRFP', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           k = min( m, n )
           if( k==0 ) then
              work( 1 ) = 1
              return
           end if
           nbmin = 2
           nx = 0
           iws = n
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'CGEQRF', ' ', m, n, -1, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'CGEQRF', ' ', m, n, -1,-1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code initially
              do i = 1, k - nx, nb
                 ib = min( k-i+1, nb )
                 ! compute the qr factorization of the current block
                 ! a(i:m,i:i+ib-1)
                 call stdlib_cgeqr2p( m-i+1, ib, a( i, i ), lda, tau( i ), work,iinfo )
                 if( i+ib<=n ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i) h(i+1) . . . h(i+ib-1)
                    call stdlib_clarft( 'FORWARD', 'COLUMNWISE', m-i+1, ib,a( i, i ), lda, tau( i &
                              ), work, ldwork )
                    ! apply h**h to a(i:m,i+ib:n) from the left
                    call stdlib_clarfb( 'LEFT', 'CONJUGATE TRANSPOSE', 'FORWARD','COLUMNWISE', m-&
                    i+1, n-i-ib+1, ib,a( i, i ), lda, work, ldwork, a( i, i+ib ),lda, work( ib+1 )&
                              , ldwork )
                 end if
              end do
           else
              i = 1
           end if
           ! use unblocked code to factor the last or only block.
           if( i<=k )call stdlib_cgeqr2p( m-i+1, n-i+1, a( i, i ), lda, tau( i ), work,iinfo )
                     
           work( 1 ) = iws
           return
     end subroutine stdlib_cgeqrfp


     pure subroutine stdlib_cgeqrt2( m, n, a, lda, t, ldt, info )
     !! CGEQRT2 computes a QR factorization of a complex M-by-N matrix A,
     !! using the compact WY representation of Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldt, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: t(ldt,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, k
           complex(sp) :: aii, alpha
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( n<0 ) then
              info = -2
           else if( m<n ) then
              info = -1
           else if( lda<max( 1, m ) ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEQRT2', -info )
              return
           end if
           k = min( m, n )
           do i = 1, k
              ! generate elem. refl. h(i) to annihilate a(i+1:m,i), tau(i) -> t(i,1)
              call stdlib_clarfg( m-i+1, a( i, i ), a( min( i+1, m ), i ), 1,t( i, 1 ) )
              if( i<n ) then
                 ! apply h(i) to a(i:m,i+1:n) from the left
                 aii = a( i, i )
                 a( i, i ) = cone
                 ! w(1:n-i) := a(i:m,i+1:n)**h * a(i:m,i) [w = t(:,n)]
                 call stdlib_cgemv( 'C',m-i+1, n-i, cone, a( i, i+1 ), lda,a( i, i ), 1, czero, t(&
                            1, n ), 1 )
                 ! a(i:m,i+1:n) = a(i:m,i+1:n) + alpha*a(i:m,i)*w(1:n-1)**h
                 alpha = -conjg(t( i, 1 ))
                 call stdlib_cgerc( m-i+1, n-i, alpha, a( i, i ), 1,t( 1, n ), 1, a( i, i+1 ), &
                           lda )
                 a( i, i ) = aii
              end if
           end do
           do i = 2, n
              aii = a( i, i )
              a( i, i ) = cone
              ! t(1:i-1,i) := alpha * a(i:m,1:i-1)**h * a(i:m,i)
              alpha = -t( i, 1 )
              call stdlib_cgemv( 'C', m-i+1, i-1, alpha, a( i, 1 ), lda,a( i, i ), 1, czero, t( 1,&
                         i ), 1 )
              a( i, i ) = aii
              ! t(1:i-1,i) := t(1:i-1,1:i-1) * t(1:i-1,i)
              call stdlib_ctrmv( 'U', 'N', 'N', i-1, t, ldt, t( 1, i ), 1 )
                 ! t(i,i) = tau(i)
                 t( i, i ) = t( i, 1 )
                 t( i, 1) = czero
           end do
     end subroutine stdlib_cgeqrt2


     pure recursive subroutine stdlib_cgeqrt3( m, n, a, lda, t, ldt, info )
     !! CGEQRT3 recursively computes a QR factorization of a complex M-by-N matrix A,
     !! using the compact WY representation of Q.
     !! Based on the algorithm of Elmroth and Gustavson,
     !! IBM J. Res. Develop. Vol 44 No. 4 July 2000.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, ldt
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: t(ldt,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, i1, j, j1, n1, n2, iinfo
           ! Executable Statements 
           info = 0
           if( n < 0 ) then
              info = -2
           else if( m < n ) then
              info = -1
           else if( lda < max( 1, m ) ) then
              info = -4
           else if( ldt < max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEQRT3', -info )
              return
           end if
           if( n==1 ) then
              ! compute householder transform when n=1
              call stdlib_clarfg( m, a(1,1), a( min( 2, m ), 1 ), 1, t(1,1) )
           else
              ! otherwise, split a into blocks...
              n1 = n/2
              n2 = n-n1
              j1 = min( n1+1, n )
              i1 = min( n+1, m )
              ! compute a(1:m,1:n1) <- (y1,r1,t1), where q1 = i - y1 t1 y1**h
              call stdlib_cgeqrt3( m, n1, a, lda, t, ldt, iinfo )
              ! compute a(1:m,j1:n) = q1**h a(1:m,j1:n) [workspace: t(1:n1,j1:n)]
              do j=1,n2
                 do i=1,n1
                    t( i, j+n1 ) = a( i, j+n1 )
                 end do
              end do
              call stdlib_ctrmm( 'L', 'L', 'C', 'U', n1, n2, cone,a, lda, t( 1, j1 ), ldt )
                        
              call stdlib_cgemm( 'C', 'N', n1, n2, m-n1, cone, a( j1, 1 ), lda,a( j1, j1 ), lda, &
                        cone, t( 1, j1 ), ldt)
              call stdlib_ctrmm( 'L', 'U', 'C', 'N', n1, n2, cone,t, ldt, t( 1, j1 ), ldt )
                        
              call stdlib_cgemm( 'N', 'N', m-n1, n2, n1, -cone, a( j1, 1 ), lda,t( 1, j1 ), ldt, &
                        cone, a( j1, j1 ), lda )
              call stdlib_ctrmm( 'L', 'L', 'N', 'U', n1, n2, cone,a, lda, t( 1, j1 ), ldt )
                        
              do j=1,n2
                 do i=1,n1
                    a( i, j+n1 ) = a( i, j+n1 ) - t( i, j+n1 )
                 end do
              end do
              ! compute a(j1:m,j1:n) <- (y2,r2,t2) where q2 = i - y2 t2 y2**h
              call stdlib_cgeqrt3( m-n1, n2, a( j1, j1 ), lda,t( j1, j1 ), ldt, iinfo )
              ! compute t3 = t(1:n1,j1:n) = -t1 y1**h y2 t2
              do i=1,n1
                 do j=1,n2
                    t( i, j+n1 ) = conjg(a( j+n1, i ))
                 end do
              end do
              call stdlib_ctrmm( 'R', 'L', 'N', 'U', n1, n2, cone,a( j1, j1 ), lda, t( 1, j1 ), &
                        ldt )
              call stdlib_cgemm( 'C', 'N', n1, n2, m-n, cone, a( i1, 1 ), lda,a( i1, j1 ), lda, &
                        cone, t( 1, j1 ), ldt )
              call stdlib_ctrmm( 'L', 'U', 'N', 'N', n1, n2, -cone, t, ldt,t( 1, j1 ), ldt )
                        
              call stdlib_ctrmm( 'R', 'U', 'N', 'N', n1, n2, cone,t( j1, j1 ), ldt, t( 1, j1 ), &
                        ldt )
              ! y = (y1,y2); r = [ r1  a(1:n1,j1:n) ];  t = [t1 t3]
                               ! [  0        r2     ]       [ 0 t2]
           end if
           return
     end subroutine stdlib_cgeqrt3


     pure subroutine stdlib_cgerq2( m, n, a, lda, tau, work, info )
     !! CGERQ2 computes an RQ factorization of a complex m by n matrix A:
     !! A = R * Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, k
           complex(sp) :: alpha
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGERQ2', -info )
              return
           end if
           k = min( m, n )
           do i = k, 1, -1
              ! generate elementary reflector h(i) to annihilate
              ! a(m-k+i,1:n-k+i-1)
              call stdlib_clacgv( n-k+i, a( m-k+i, 1 ), lda )
              alpha = a( m-k+i, n-k+i )
              call stdlib_clarfg( n-k+i, alpha, a( m-k+i, 1 ), lda,tau( i ) )
              ! apply h(i) to a(1:m-k+i-1,1:n-k+i) from the right
              a( m-k+i, n-k+i ) = cone
              call stdlib_clarf( 'RIGHT', m-k+i-1, n-k+i, a( m-k+i, 1 ), lda,tau( i ), a, lda, &
                        work )
              a( m-k+i, n-k+i ) = alpha
              call stdlib_clacgv( n-k+i-1, a( m-k+i, 1 ), lda )
           end do
           return
     end subroutine stdlib_cgerq2


     pure subroutine stdlib_cgerqf( m, n, a, lda, tau, work, lwork, info )
     !! CGERQF computes an RQ factorization of a complex M-by-N matrix A:
     !! A = R * Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iws, k, ki, kk, ldwork, lwkopt, mu, nb, nbmin, nu, &
                     nx
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info==0 ) then
              k = min( m, n )
              if( k==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'CGERQF', ' ', m, n, -1, -1 )
                 lwkopt = m*nb
              end if
              work( 1 ) = lwkopt
              if ( .not.lquery ) then
                 if( lwork<=0 .or. ( n>0 .and. lwork<max( 1, m ) ) )info = -7
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGERQF', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( k==0 ) then
              return
           end if
           nbmin = 2
           nx = 1
           iws = m
           if( nb>1 .and. nb<k ) then
              ! determine when to cross over from blocked to unblocked code.
              nx = max( 0, stdlib_ilaenv( 3, 'CGERQF', ' ', m, n, -1, -1 ) )
              if( nx<k ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = m
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  reduce nb and
                    ! determine the minimum value of nb.
                    nb = lwork / ldwork
                    nbmin = max( 2, stdlib_ilaenv( 2, 'CGERQF', ' ', m, n, -1,-1 ) )
                 end if
              end if
           end if
           if( nb>=nbmin .and. nb<k .and. nx<k ) then
              ! use blocked code initially.
              ! the last kk rows are handled by the block method.
              ki = ( ( k-nx-1 ) / nb )*nb
              kk = min( k, ki+nb )
              do i = k - kk + ki + 1, k - kk + 1, -nb
                 ib = min( k-i+1, nb )
                 ! compute the rq factorization of the current block
                 ! a(m-k+i:m-k+i+ib-1,1:n-k+i+ib-1)
                 call stdlib_cgerq2( ib, n-k+i+ib-1, a( m-k+i, 1 ), lda, tau( i ),work, iinfo )
                           
                 if( m-k+i>1 ) then
                    ! form the triangular factor of the block reflector
                    ! h = h(i+ib-1) . . . h(i+1) h(i)
                    call stdlib_clarft( 'BACKWARD', 'ROWWISE', n-k+i+ib-1, ib,a( m-k+i, 1 ), lda, &
                              tau( i ), work, ldwork )
                    ! apply h to a(1:m-k+i-1,1:n-k+i+ib-1) from the right
                    call stdlib_clarfb( 'RIGHT', 'NO TRANSPOSE', 'BACKWARD','ROWWISE', m-k+i-1, n-&
                    k+i+ib-1, ib,a( m-k+i, 1 ), lda, work, ldwork, a, lda,work( ib+1 ), ldwork )
                              
                 end if
              end do
              mu = m - k + i + nb - 1
              nu = n - k + i + nb - 1
           else
              mu = m
              nu = n
           end if
           ! use unblocked code to factor the last or only block
           if( mu>0 .and. nu>0 )call stdlib_cgerq2( mu, nu, a, lda, tau, work, iinfo )
           work( 1 ) = iws
           return
     end subroutine stdlib_cgerqf


     pure subroutine stdlib_cgesc2( n, a, lda, rhs, ipiv, jpiv, scale )
     !! CGESC2 solves a system of linear equations
     !! A * X = scale* RHS
     !! with a general N-by-N matrix A using the LU factorization with
     !! complete pivoting computed by CGETC2.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(out) :: scale
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*), jpiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: rhs(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: bignum, eps, smlnum
           complex(sp) :: temp
           ! Intrinsic Functions 
           intrinsic :: abs,cmplx,real
           ! Executable Statements 
           ! set constant to control overflow
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           ! apply permutations ipiv to rhs
           call stdlib_claswp( 1, rhs, lda, 1, n-1, ipiv, 1 )
           ! solve for l part
           do i = 1, n - 1
              do j = i + 1, n
                 rhs( j ) = rhs( j ) - a( j, i )*rhs( i )
              end do
           end do
           ! solve for u part
           scale = one
           ! check for scaling
           i = stdlib_icamax( n, rhs, 1 )
           if( two*smlnum*abs( rhs( i ) )>abs( a( n, n ) ) ) then
              temp = cmplx( one / two, zero,KIND=sp) / abs( rhs( i ) )
              call stdlib_cscal( n, temp, rhs( 1 ), 1 )
              scale = scale*real( temp,KIND=sp)
           end if
           do i = n, 1, -1
              temp = cmplx( one, zero,KIND=sp) / a( i, i )
              rhs( i ) = rhs( i )*temp
              do j = i + 1, n
                 rhs( i ) = rhs( i ) - rhs( j )*( a( i, j )*temp )
              end do
           end do
           ! apply permutations jpiv to the solution (rhs)
           call stdlib_claswp( 1, rhs, lda, 1, n-1, jpiv, -1 )
           return
     end subroutine stdlib_cgesc2


     pure recursive subroutine stdlib_cgetrf2( m, n, a, lda, ipiv, info )
     !! CGETRF2 computes an LU factorization of a general M-by-N matrix A
     !! using partial pivoting with row interchanges.
     !! The factorization has the form
     !! A = P * L * U
     !! where P is a permutation matrix, L is lower triangular with unit
     !! diagonal elements (lower trapezoidal if m > n), and U is upper
     !! triangular (upper trapezoidal if m < n).
     !! This is the recursive version of the algorithm. It divides
     !! the matrix into four submatrices:
     !! [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2
     !! A = [ -----|----- ]  with n1 = min(m,n)/2
     !! [  A21 | A22  ]       n2 = n-n1
     !! [ A11 ]
     !! The subroutine calls itself to factor [ --- ],
     !! [ A12 ]
     !! [ A12 ]
     !! do the swaps on [ --- ], solve A12, update A22,
     !! [ A22 ]
     !! then calls itself to factor A22 and do the swaps on A21.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           real(sp) :: sfmin
           complex(sp) :: temp
           integer(ilp) :: i, iinfo, n1, n2
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGETRF2', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           if ( m==1 ) then
              ! use unblocked code for cone row case
              ! just need to handle ipiv and info
              ipiv( 1 ) = 1
              if ( a(1,1)==czero )info = 1
           else if( n==1 ) then
              ! use unblocked code for cone column case
              ! compute machine safe minimum
              sfmin = stdlib_slamch('S')
              ! find pivot and test for singularity
              i = stdlib_icamax( m, a( 1, 1 ), 1 )
              ipiv( 1 ) = i
              if( a( i, 1 )/=czero ) then
                 ! apply the interchange
                 if( i/=1 ) then
                    temp = a( 1, 1 )
                    a( 1, 1 ) = a( i, 1 )
                    a( i, 1 ) = temp
                 end if
                 ! compute elements 2:m of the column
                 if( abs(a( 1, 1 )) >= sfmin ) then
                    call stdlib_cscal( m-1, cone / a( 1, 1 ), a( 2, 1 ), 1 )
                 else
                    do i = 1, m-1
                       a( 1+i, 1 ) = a( 1+i, 1 ) / a( 1, 1 )
                    end do
                 end if
              else
                 info = 1
              end if
           else
              ! use recursive code
              n1 = min( m, n ) / 2
              n2 = n-n1
                     ! [ a11 ]
              ! factor [ --- ]
                     ! [ a21 ]
              call stdlib_cgetrf2( m, n1, a, lda, ipiv, iinfo )
              if ( info==0 .and. iinfo>0 )info = iinfo
                                    ! [ a12 ]
              ! apply interchanges to [ --- ]
                                    ! [ a22 ]
              call stdlib_claswp( n2, a( 1, n1+1 ), lda, 1, n1, ipiv, 1 )
              ! solve a12
              call stdlib_ctrsm( 'L', 'L', 'N', 'U', n1, n2, cone, a, lda,a( 1, n1+1 ), lda )
                        
              ! update a22
              call stdlib_cgemm( 'N', 'N', m-n1, n2, n1, -cone, a( n1+1, 1 ), lda,a( 1, n1+1 ), &
                        lda, cone, a( n1+1, n1+1 ), lda )
              ! factor a22
              call stdlib_cgetrf2( m-n1, n2, a( n1+1, n1+1 ), lda, ipiv( n1+1 ),iinfo )
              ! adjust info and the pivot indices
              if ( info==0 .and. iinfo>0 )info = iinfo + n1
              do i = n1+1, min( m, n )
                 ipiv( i ) = ipiv( i ) + n1
              end do
              ! apply interchanges to a21
              call stdlib_claswp( n1, a( 1, 1 ), lda, n1+1, min( m, n), ipiv, 1 )
           end if
           return
     end subroutine stdlib_cgetrf2


     pure subroutine stdlib_cgetri( n, a, lda, ipiv, work, lwork, info )
     !! CGETRI computes the inverse of a matrix using the LU factorization
     !! computed by CGETRF.
     !! This method inverts U and then computes inv(A) by solving the system
     !! inv(A)*L = inv(U) for inv(A).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iws, j, jb, jj, jp, ldwork, lwkopt, nb, nbmin, nn
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nb = stdlib_ilaenv( 1, 'CGETRI', ' ', n, -1, -1, -1 )
           lwkopt = n*nb
           work( 1 ) = lwkopt
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( lda<max( 1, n ) ) then
              info = -3
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGETRI', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form inv(u).  if info > 0 from stdlib_ctrtri, then u is singular,
           ! and the inverse is not computed.
           call stdlib_ctrtri( 'UPPER', 'NON-UNIT', n, a, lda, info )
           if( info>0 )return
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = max( ldwork*nb, 1 )
              if( lwork<iws ) then
                 nb = lwork / ldwork
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CGETRI', ' ', n, -1, -1, -1 ) )
              end if
           else
              iws = n
           end if
           ! solve the equation inv(a)*l = inv(u) for inv(a).
           if( nb<nbmin .or. nb>=n ) then
              ! use unblocked code.
              do j = n, 1, -1
                 ! copy current column of l to work and replace with zeros.
                 do i = j + 1, n
                    work( i ) = a( i, j )
                    a( i, j ) = czero
                 end do
                 ! compute current column of inv(a).
                 if( j<n )call stdlib_cgemv( 'NO TRANSPOSE', n, n-j, -cone, a( 1, j+1 ),lda, work(&
                            j+1 ), 1, cone, a( 1, j ), 1 )
              end do
           else
              ! use blocked code.
              nn = ( ( n-1 ) / nb )*nb + 1
              do j = nn, 1, -nb
                 jb = min( nb, n-j+1 )
                 ! copy current block column of l to work and replace with
                 ! zeros.
                 do jj = j, j + jb - 1
                    do i = jj + 1, n
                       work( i+( jj-j )*ldwork ) = a( i, jj )
                       a( i, jj ) = czero
                    end do
                 end do
                 ! compute current block column of inv(a).
                 if( j+jb<=n )call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', n, jb,n-j-jb+1, -&
                           cone, a( 1, j+jb ), lda,work( j+jb ), ldwork, cone, a( 1, j ), lda )
                 call stdlib_ctrsm( 'RIGHT', 'LOWER', 'NO TRANSPOSE', 'UNIT', n, jb,cone, work( j &
                           ), ldwork, a( 1, j ), lda )
              end do
           end if
           ! apply column interchanges.
           do j = n - 1, 1, -1
              jp = ipiv( j )
              if( jp/=j )call stdlib_cswap( n, a( 1, j ), 1, a( 1, jp ), 1 )
           end do
           work( 1 ) = iws
           return
     end subroutine stdlib_cgetri


     pure subroutine stdlib_cgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
     !! CGETRS solves a system of linear equations
     !! A * X = B,  A**T * X = B,  or  A**H * X = B
     !! with a general N-by-N matrix A using the LU factorization computed
     !! by CGETRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notran
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( trans, &
                     'C' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGETRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( notran ) then
              ! solve a * x = b.
              ! apply row interchanges to the right hand sides.
              call stdlib_claswp( nrhs, b, ldb, 1, n, ipiv, 1 )
              ! solve l*x = b, overwriting b with x.
              call stdlib_ctrsm( 'LEFT', 'LOWER', 'NO TRANSPOSE', 'UNIT', n, nrhs,cone, a, lda, b,&
                         ldb )
              ! solve u*x = b, overwriting b with x.
              call stdlib_ctrsm( 'LEFT', 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n,nrhs, cone, a, &
                        lda, b, ldb )
           else
              ! solve a**t * x = b  or a**h * x = b.
              ! solve u**t *x = b or u**h *x = b, overwriting b with x.
              call stdlib_ctrsm( 'LEFT', 'UPPER', trans, 'NON-UNIT', n, nrhs, cone,a, lda, b, ldb &
                        )
              ! solve l**t *x = b, or l**h *x = b overwriting b with x.
              call stdlib_ctrsm( 'LEFT', 'LOWER', trans, 'UNIT', n, nrhs, cone, a,lda, b, ldb )
                        
              ! apply row interchanges to the solution vectors.
              call stdlib_claswp( nrhs, b, ldb, 1, n, ipiv, -1 )
           end if
           return
     end subroutine stdlib_cgetrs


     pure subroutine stdlib_cgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! CGGHRD reduces a pair of complex matrices (A,B) to generalized upper
     !! Hessenberg form using unitary transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the generalized
     !! eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the unitary matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**H*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**H*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**H*x.
     !! The unitary matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
     !! Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
     !! If Q1 is the unitary matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then CGGHRD reduces the original
     !! problem to generalized Hessenberg form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilq, ilz
           integer(ilp) :: icompq, icompz, jcol, jrow
           real(sp) :: c
           complex(sp) :: ctemp, s
           ! Intrinsic Functions 
           intrinsic :: conjg,max
           ! Executable Statements 
           ! decode compq
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           ! decode compz
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! test the input parameters.
           info = 0
           if( icompq<=0 ) then
              info = -1
           else if( icompz<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( ilq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( ilz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGHRD', -info )
              return
           end if
           ! initialize q and z if desired.
           if( icompq==3 )call stdlib_claset( 'FULL', n, n, czero, cone, q, ldq )
           if( icompz==3 )call stdlib_claset( 'FULL', n, n, czero, cone, z, ldz )
           ! quick return if possible
           if( n<=1 )return
           ! zero out lower triangle of b
           do jcol = 1, n - 1
              do jrow = jcol + 1, n
                 b( jrow, jcol ) = czero
              end do
           end do
           ! reduce a and b
           do jcol = ilo, ihi - 2
              do jrow = ihi, jcol + 2, -1
                 ! step 1: rotate rows jrow-1, jrow to kill a(jrow,jcol)
                 ctemp = a( jrow-1, jcol )
                 call stdlib_clartg( ctemp, a( jrow, jcol ), c, s,a( jrow-1, jcol ) )
                 a( jrow, jcol ) = czero
                 call stdlib_crot( n-jcol, a( jrow-1, jcol+1 ), lda,a( jrow, jcol+1 ), lda, c, s )
                           
                 call stdlib_crot( n+2-jrow, b( jrow-1, jrow-1 ), ldb,b( jrow, jrow-1 ), ldb, c, &
                           s )
                 if( ilq )call stdlib_crot( n, q( 1, jrow-1 ), 1, q( 1, jrow ), 1, c,conjg( s ) )
                           
                 ! step 2: rotate columns jrow, jrow-1 to kill b(jrow,jrow-1)
                 ctemp = b( jrow, jrow )
                 call stdlib_clartg( ctemp, b( jrow, jrow-1 ), c, s,b( jrow, jrow ) )
                 b( jrow, jrow-1 ) = czero
                 call stdlib_crot( ihi, a( 1, jrow ), 1, a( 1, jrow-1 ), 1, c, s )
                 call stdlib_crot( jrow-1, b( 1, jrow ), 1, b( 1, jrow-1 ), 1, c,s )
                 if( ilz )call stdlib_crot( n, z( 1, jrow ), 1, z( 1, jrow-1 ), 1, c, s )
              end do
           end do
           return
     end subroutine stdlib_cgghrd


     pure subroutine stdlib_cggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,lwork, info )
     !! CGGQRF computes a generalized QR factorization of an N-by-M matrix A
     !! and an N-by-P matrix B:
     !! A = Q*R,        B = Q*T*Z,
     !! where Q is an N-by-N unitary matrix, Z is a P-by-P unitary matrix,
     !! and R and T assume one of the forms:
     !! if N >= M,  R = ( R11 ) M  ,   or if N < M,  R = ( R11  R12 ) N,
     !! (  0  ) N-M                         N   M-N
     !! M
     !! where R11 is upper triangular, and
     !! if N <= P,  T = ( 0  T12 ) N,   or if N > P,  T = ( T11 ) N-P,
     !! P-N  N                           ( T21 ) P
     !! P
     !! where T12 or T21 is upper triangular.
     !! In particular, if B is square and nonsingular, the GQR factorization
     !! of A and B implicitly gives the QR factorization of inv(B)*A:
     !! inv(B)*A = Z**H * (inv(T)*R)
     !! where inv(B) denotes the inverse of the matrix B, and Z' denotes the
     !! conjugate transpose of matrix Z.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: taua(*), taub(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lopt, lwkopt, nb, nb1, nb2, nb3
           ! Intrinsic Functions 
           intrinsic :: int,max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           nb1 = stdlib_ilaenv( 1, 'CGEQRF', ' ', n, m, -1, -1 )
           nb2 = stdlib_ilaenv( 1, 'CGERQF', ' ', n, p, -1, -1 )
           nb3 = stdlib_ilaenv( 1, 'CUNMQR', ' ', n, m, p, -1 )
           nb = max( nb1, nb2, nb3 )
           lwkopt = max( n, m, p)*nb
           work( 1 ) = lwkopt
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( p<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 1, n, m, p ) .and. .not.lquery ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGQRF', -info )
              return
           else if( lquery ) then
              return
           end if
           ! qr factorization of n-by-m matrix a: a = q*r
           call stdlib_cgeqrf( n, m, a, lda, taua, work, lwork, info )
           lopt = real( work( 1 ),KIND=sp)
           ! update b := q**h*b.
           call stdlib_cunmqr( 'LEFT', 'CONJUGATE TRANSPOSE', n, p, min( n, m ), a,lda, taua, b, &
                     ldb, work, lwork, info )
           lopt = max( lopt, int( work( 1 ),KIND=ilp) )
           ! rq factorization of n-by-p matrix b: b = t*z.
           call stdlib_cgerqf( n, p, b, ldb, taub, work, lwork, info )
           work( 1 ) = max( lopt, int( work( 1 ),KIND=ilp) )
           return
     end subroutine stdlib_cggqrf


     pure subroutine stdlib_cggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,lwork, info )
     !! CGGRQF computes a generalized RQ factorization of an M-by-N matrix A
     !! and a P-by-N matrix B:
     !! A = R*Q,        B = Z*T*Q,
     !! where Q is an N-by-N unitary matrix, Z is a P-by-P unitary
     !! matrix, and R and T assume one of the forms:
     !! if M <= N,  R = ( 0  R12 ) M,   or if M > N,  R = ( R11 ) M-N,
     !! N-M  M                           ( R21 ) N
     !! N
     !! where R12 or R21 is upper triangular, and
     !! if P >= N,  T = ( T11 ) N  ,   or if P < N,  T = ( T11  T12 ) P,
     !! (  0  ) P-N                         P   N-P
     !! N
     !! where T11 is upper triangular.
     !! In particular, if B is square and nonsingular, the GRQ factorization
     !! of A and B implicitly gives the RQ factorization of A*inv(B):
     !! A*inv(B) = (R*inv(T))*Z**H
     !! where inv(B) denotes the inverse of the matrix B, and Z**H denotes the
     !! conjugate transpose of the matrix Z.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: taua(*), taub(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lopt, lwkopt, nb, nb1, nb2, nb3
           ! Intrinsic Functions 
           intrinsic :: int,max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           nb1 = stdlib_ilaenv( 1, 'CGERQF', ' ', m, n, -1, -1 )
           nb2 = stdlib_ilaenv( 1, 'CGEQRF', ' ', p, n, -1, -1 )
           nb3 = stdlib_ilaenv( 1, 'CUNMRQ', ' ', m, n, p, -1 )
           nb = max( nb1, nb2, nb3 )
           lwkopt = max( n, m, p)*nb
           work( 1 ) = lwkopt
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( p<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, p ) ) then
              info = -8
           else if( lwork<max( 1, m, p, n ) .and. .not.lquery ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGRQF', -info )
              return
           else if( lquery ) then
              return
           end if
           ! rq factorization of m-by-n matrix a: a = r*q
           call stdlib_cgerqf( m, n, a, lda, taua, work, lwork, info )
           lopt = real( work( 1 ),KIND=sp)
           ! update b := b*q**h
           call stdlib_cunmrq( 'RIGHT', 'CONJUGATE TRANSPOSE', p, n, min( m, n ),a( max( 1, m-n+1 &
                     ), 1 ), lda, taua, b, ldb, work,lwork, info )
           lopt = max( lopt, int( work( 1 ),KIND=ilp) )
           ! qr factorization of p-by-n matrix b: b = z*t
           call stdlib_cgeqrf( p, n, b, ldb, taub, work, lwork, info )
           work( 1 ) = max( lopt, int( work( 1 ),KIND=ilp) )
           return
     end subroutine stdlib_cggrqf


     pure subroutine stdlib_cgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,info )
     !! CGTTRS solves one of the systems of equations
     !! A * X = B,  A**T * X = B,  or  A**H * X = B,
     !! with a tridiagonal matrix A using the LU factorization computed
     !! by CGTTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: b(ldb,*)
           complex(sp), intent(in) :: d(*), dl(*), du(*), du2(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: itrans, j, jb, nb
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           info = 0
           notran = ( trans=='N' .or. trans=='N' )
           if( .not.notran .and. .not.( trans=='T' .or. trans=='T' ) .and. .not.( trans=='C' .or. &
                     trans=='C' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( n, 1 ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGTTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! decode trans
           if( notran ) then
              itrans = 0
           else if( trans=='T' .or. trans=='T' ) then
              itrans = 1
           else
              itrans = 2
           end if
           ! determine the number of right-hand sides to solve at a time.
           if( nrhs==1 ) then
              nb = 1
           else
              nb = max( 1, stdlib_ilaenv( 1, 'CGTTRS', trans, n, nrhs, -1, -1 ) )
           end if
           if( nb>=nrhs ) then
              call stdlib_cgtts2( itrans, n, nrhs, dl, d, du, du2, ipiv, b, ldb )
           else
              do j = 1, nrhs, nb
                 jb = min( nrhs-j+1, nb )
                 call stdlib_cgtts2( itrans, n, jb, dl, d, du, du2, ipiv, b( 1, j ),ldb )
              end do
           end if
     end subroutine stdlib_cgttrs


     pure subroutine  stdlib_chb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, lda, &
     !! CHB2ST_KERNELS is an internal routine used by the CHETRD_HB2ST
     !! subroutine.
               v, tau, ldvt, work)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           logical(lk), intent(in) :: wantz
           integer(ilp), intent(in) :: ttype, st, ed, sweep, n, nb, ib, lda, ldvt
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: v(*), tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j1, j2, lm, ln, vpos, taupos, dpos, ofdpos, ajeter
           complex(sp) :: ctmp
           ! Intrinsic Functions 
           intrinsic :: conjg,mod
           ! Executable Statements 
           ajeter = ib + ldvt
           upper = stdlib_lsame( uplo, 'U' )
           if( upper ) then
               dpos    = 2 * nb + 1
               ofdpos  = 2 * nb
           else
               dpos    = 1
               ofdpos  = 2
           endif
           ! upper case
           if( upper ) then
               if( wantz ) then
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               else
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               endif
               if( ttype==1 ) then
                   lm = ed - st + 1
                   v( vpos ) = cone
                   do i = 1, lm-1
                       v( vpos+i )         = conjg( a( ofdpos-i, st+i ) )
                       a( ofdpos-i, st+i ) = czero
                   end do
                   ctmp = conjg( a( ofdpos, st ) )
                   call stdlib_clarfg( lm, ctmp, v( vpos+1 ), 1,tau( taupos ) )
                   a( ofdpos, st ) = ctmp
                   lm = ed - st + 1
                   call stdlib_clarfy( uplo, lm, v( vpos ), 1,conjg( tau( taupos ) ),a( dpos, st )&
                             , lda-1, work)
               endif
               if( ttype==3 ) then
                   lm = ed - st + 1
                   call stdlib_clarfy( uplo, lm, v( vpos ), 1,conjg( tau( taupos ) ),a( dpos, st )&
                             , lda-1, work)
               endif
               if( ttype==2 ) then
                   j1 = ed+1
                   j2 = min( ed+nb, n )
                   ln = ed-st+1
                   lm = j2-j1+1
                   if( lm>0) then
                       call stdlib_clarfx( 'LEFT', ln, lm, v( vpos ),conjg( tau( taupos ) ),a( &
                                 dpos-nb, j1 ), lda-1, work)
                       if( wantz ) then
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       else
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       endif
                       v( vpos ) = cone
                       do i = 1, lm-1
                           v( vpos+i )          =conjg( a( dpos-nb-i, j1+i ) )
                           a( dpos-nb-i, j1+i ) = czero
                       end do
                       ctmp = conjg( a( dpos-nb, j1 ) )
                       call stdlib_clarfg( lm, ctmp, v( vpos+1 ), 1, tau( taupos ) )
                       a( dpos-nb, j1 ) = ctmp
                       call stdlib_clarfx( 'RIGHT', ln-1, lm, v( vpos ),tau( taupos ),a( dpos-nb+&
                                 1, j1 ), lda-1, work)
                   endif
               endif
           ! lower case
           else
               if( wantz ) then
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               else
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               endif
               if( ttype==1 ) then
                   lm = ed - st + 1
                   v( vpos ) = cone
                   do i = 1, lm-1
                       v( vpos+i )         = a( ofdpos+i, st-1 )
                       a( ofdpos+i, st-1 ) = czero
                   end do
                   call stdlib_clarfg( lm, a( ofdpos, st-1 ), v( vpos+1 ), 1,tau( taupos ) )
                             
                   lm = ed - st + 1
                   call stdlib_clarfy( uplo, lm, v( vpos ), 1,conjg( tau( taupos ) ),a( dpos, st )&
                             , lda-1, work)
               endif
               if( ttype==3 ) then
                   lm = ed - st + 1
                   call stdlib_clarfy( uplo, lm, v( vpos ), 1,conjg( tau( taupos ) ),a( dpos, st )&
                             , lda-1, work)
               endif
               if( ttype==2 ) then
                   j1 = ed+1
                   j2 = min( ed+nb, n )
                   ln = ed-st+1
                   lm = j2-j1+1
                   if( lm>0) then
                       call stdlib_clarfx( 'RIGHT', lm, ln, v( vpos ),tau( taupos ), a( dpos+nb, &
                                 st ),lda-1, work)
                       if( wantz ) then
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       else
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       endif
                       v( vpos ) = cone
                       do i = 1, lm-1
                           v( vpos+i )        = a( dpos+nb+i, st )
                           a( dpos+nb+i, st ) = czero
                       end do
                       call stdlib_clarfg( lm, a( dpos+nb, st ), v( vpos+1 ), 1,tau( taupos ) )
                                 
                       call stdlib_clarfx( 'LEFT', lm, ln-1, v( vpos ),conjg( tau( taupos ) ),a( &
                                 dpos+nb-1, st+1 ), lda-1, work)
                   endif
               endif
           endif
           return
     end subroutine stdlib_chb2st_kernels


     pure subroutine stdlib_cheequb( uplo, n, a, lda, s, scond, amax, work, info )
     !! CHEEQUB computes row and column scalings intended to equilibrate a
     !! Hermitian matrix A (with respect to the Euclidean norm) and reduce
     !! its condition number. The scale factors S are computed by the BIN
     !! algorithm (see references) so that the scaled matrix B with elements
     !! B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
     !! the smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(out) :: amax, scond
           character, intent(in) :: uplo
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(out) :: s(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: max_iter = 100
           
           
           ! Local Scalars 
           integer(ilp) :: i, j, iter
           real(sp) :: avg, std, tol, c0, c1, c2, t, u, si, d, base, smin, smax, smlnum, bignum, &
                     scale, sumsq
           logical(lk) :: up
           complex(sp) :: zdum
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,int,log,max,min,real,sqrt
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if ( .not. ( stdlib_lsame( uplo, 'U' ) .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -1
           else if ( n < 0 ) then
              info = -2
           else if ( lda < max( 1, n ) ) then
              info = -4
           end if
           if ( info /= 0 ) then
              call stdlib_xerbla( 'CHEEQUB', -info )
              return
           end if
           up = stdlib_lsame( uplo, 'U' )
           amax = zero
           ! quick return if possible.
           if ( n == 0 ) then
              scond = one
              return
           end if
           do i = 1, n
              s( i ) = zero
           end do
           amax = zero
           if ( up ) then
              do j = 1, n
                 do i = 1, j-1
                    s( i ) = max( s( i ), cabs1( a( i, j ) ) )
                    s( j ) = max( s( j ), cabs1( a( i, j ) ) )
                    amax = max( amax, cabs1( a( i, j ) ) )
                 end do
                 s( j ) = max( s( j ), cabs1( a( j, j ) ) )
                 amax = max( amax, cabs1( a( j, j ) ) )
              end do
           else
              do j = 1, n
                 s( j ) = max( s( j ), cabs1( a( j, j ) ) )
                 amax = max( amax, cabs1( a( j, j ) ) )
                 do i = j+1, n
                    s( i ) = max( s( i ), cabs1( a( i, j ) ) )
                    s( j ) = max( s( j ), cabs1( a( i, j ) ) )
                    amax = max( amax, cabs1( a( i, j ) ) )
                 end do
              end do
           end if
           do j = 1, n
              s( j ) = 1.0_sp / s( j )
           end do
           tol = one / sqrt( 2.0_sp * n )
           do iter = 1, max_iter
              scale = zero
              sumsq = zero
              ! beta = |a|s
              do i = 1, n
                 work( i ) = zero
              end do
              if ( up ) then
                 do j = 1, n
                    do i = 1, j-1
                       work( i ) = work( i ) + cabs1( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + cabs1( a( i, j ) ) * s( i )
                    end do
                    work( j ) = work( j ) + cabs1( a( j, j ) ) * s( j )
                 end do
              else
                 do j = 1, n
                    work( j ) = work( j ) + cabs1( a( j, j ) ) * s( j )
                    do i = j+1, n
                       work( i ) = work( i ) + cabs1( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + cabs1( a( i, j ) ) * s( i )
                    end do
                 end do
              end if
              ! avg = s^t beta / n
              avg = zero
              do i = 1, n
                 avg = avg + real( s( i )*work( i ),KIND=sp)
              end do
              avg = avg / n
              std = zero
              do i = n+1, 2*n
                 work( i ) = s( i-n ) * work( i-n ) - avg
              end do
              call stdlib_classq( n, work( n+1 ), 1, scale, sumsq )
              std = scale * sqrt( sumsq / n )
              if ( std < tol * avg ) goto 999
              do i = 1, n
                 t = cabs1( a( i, i ) )
                 si = s( i )
                 c2 = ( n-1 ) * t
                 c1 = real( ( n-2 ) * ( work( i ) - t*si ),KIND=sp)
                 c0 = real( -(t*si)*si + 2*work( i )*si - n*avg,KIND=sp)
                 d = c1*c1 - 4*c0*c2
                 if ( d <= 0 ) then
                    info = -1
                    return
                 end if
                 si = -2*c0 / ( c1 + sqrt( d ) )
                 d = si - s( i )
                 u = zero
                 if ( up ) then
                    do j = 1, i
                       t = cabs1( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = cabs1( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 else
                    do j = 1, i
                       t = cabs1( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = cabs1( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 end if
                 avg = avg + real( ( u + work( i ) ) * d / n,KIND=sp)
                 s( i ) = si
              end do
           end do
           999 continue
           smlnum = stdlib_slamch( 'SAFEMIN' )
           bignum = one / smlnum
           smin = bignum
           smax = zero
           t = one / sqrt( avg )
           base = stdlib_slamch( 'B' )
           u = one / log( base )
           do i = 1, n
              s( i ) = base ** int( u * log( s( i ) * t ),KIND=ilp)
              smin = min( smin, s( i ) )
              smax = max( smax, s( i ) )
           end do
           scond = max( smin, smlnum ) / min( smax, bignum )
     end subroutine stdlib_cheequb


     pure subroutine stdlib_chegs2( itype, uplo, n, a, lda, b, ldb, info )
     !! CHEGS2 reduces a complex Hermitian-definite generalized
     !! eigenproblem to standard form.
     !! If ITYPE = 1, the problem is A*x = lambda*B*x,
     !! and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
     !! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
     !! B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H *A*L.
     !! B must have been previously factorized as U**H *U or L*L**H by ZPOTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: itype, lda, ldb, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k
           real(sp) :: akk, bkk
           complex(sp) :: ct
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHEGS2', -info )
              return
           end if
           if( itype==1 ) then
              if( upper ) then
                 ! compute inv(u**h)*a*inv(u)
                 do k = 1, n
                    ! update the upper triangle of a(k:n,k:n)
                    akk = real( a( k, k ),KIND=sp)
                    bkk = real( b( k, k ),KIND=sp)
                    akk = akk / bkk**2
                    a( k, k ) = akk
                    if( k<n ) then
                       call stdlib_csscal( n-k, one / bkk, a( k, k+1 ), lda )
                       ct = -half*akk
                       call stdlib_clacgv( n-k, a( k, k+1 ), lda )
                       call stdlib_clacgv( n-k, b( k, k+1 ), ldb )
                       call stdlib_caxpy( n-k, ct, b( k, k+1 ), ldb, a( k, k+1 ),lda )
                       call stdlib_cher2( uplo, n-k, -cone, a( k, k+1 ), lda,b( k, k+1 ), ldb, a( &
                                 k+1, k+1 ), lda )
                       call stdlib_caxpy( n-k, ct, b( k, k+1 ), ldb, a( k, k+1 ),lda )
                       call stdlib_clacgv( n-k, b( k, k+1 ), ldb )
                       call stdlib_ctrsv( uplo, 'CONJUGATE TRANSPOSE', 'NON-UNIT',n-k, b( k+1, k+&
                                 1 ), ldb, a( k, k+1 ),lda )
                       call stdlib_clacgv( n-k, a( k, k+1 ), lda )
                    end if
                 end do
              else
                 ! compute inv(l)*a*inv(l**h)
                 do k = 1, n
                    ! update the lower triangle of a(k:n,k:n)
                    akk = real( a( k, k ),KIND=sp)
                    bkk = real( b( k, k ),KIND=sp)
                    akk = akk / bkk**2
                    a( k, k ) = akk
                    if( k<n ) then
                       call stdlib_csscal( n-k, one / bkk, a( k+1, k ), 1 )
                       ct = -half*akk
                       call stdlib_caxpy( n-k, ct, b( k+1, k ), 1, a( k+1, k ), 1 )
                       call stdlib_cher2( uplo, n-k, -cone, a( k+1, k ), 1,b( k+1, k ), 1, a( k+1,&
                                  k+1 ), lda )
                       call stdlib_caxpy( n-k, ct, b( k+1, k ), 1, a( k+1, k ), 1 )
                       call stdlib_ctrsv( uplo, 'NO TRANSPOSE', 'NON-UNIT', n-k,b( k+1, k+1 ), &
                                 ldb, a( k+1, k ), 1 )
                    end if
                 end do
              end if
           else
              if( upper ) then
                 ! compute u*a*u**h
                 do k = 1, n
                    ! update the upper triangle of a(1:k,1:k)
                    akk = real( a( k, k ),KIND=sp)
                    bkk = real( b( k, k ),KIND=sp)
                    call stdlib_ctrmv( uplo, 'NO TRANSPOSE', 'NON-UNIT', k-1, b,ldb, a( 1, k ), 1 &
                              )
                    ct = half*akk
                    call stdlib_caxpy( k-1, ct, b( 1, k ), 1, a( 1, k ), 1 )
                    call stdlib_cher2( uplo, k-1, cone, a( 1, k ), 1, b( 1, k ), 1,a, lda )
                              
                    call stdlib_caxpy( k-1, ct, b( 1, k ), 1, a( 1, k ), 1 )
                    call stdlib_csscal( k-1, bkk, a( 1, k ), 1 )
                    a( k, k ) = akk*bkk**2
                 end do
              else
                 ! compute l**h *a*l
                 do k = 1, n
                    ! update the lower triangle of a(1:k,1:k)
                    akk = real( a( k, k ),KIND=sp)
                    bkk = real( b( k, k ),KIND=sp)
                    call stdlib_clacgv( k-1, a( k, 1 ), lda )
                    call stdlib_ctrmv( uplo, 'CONJUGATE TRANSPOSE', 'NON-UNIT', k-1,b, ldb, a( k, &
                              1 ), lda )
                    ct = half*akk
                    call stdlib_clacgv( k-1, b( k, 1 ), ldb )
                    call stdlib_caxpy( k-1, ct, b( k, 1 ), ldb, a( k, 1 ), lda )
                    call stdlib_cher2( uplo, k-1, cone, a( k, 1 ), lda, b( k, 1 ),ldb, a, lda )
                              
                    call stdlib_caxpy( k-1, ct, b( k, 1 ), ldb, a( k, 1 ), lda )
                    call stdlib_clacgv( k-1, b( k, 1 ), ldb )
                    call stdlib_csscal( k-1, bkk, a( k, 1 ), lda )
                    call stdlib_clacgv( k-1, a( k, 1 ), lda )
                    a( k, k ) = akk*bkk**2
                 end do
              end if
           end if
           return
     end subroutine stdlib_chegs2


     pure subroutine stdlib_chegst( itype, uplo, n, a, lda, b, ldb, info )
     !! CHEGST reduces a complex Hermitian-definite generalized
     !! eigenproblem to standard form.
     !! If ITYPE = 1, the problem is A*x = lambda*B*x,
     !! and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
     !! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
     !! B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.
     !! B must have been previously factorized as U**H*U or L*L**H by CPOTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: itype, lda, ldb, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kb, nb
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHEGST', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine the block size for this environment.
           nb = stdlib_ilaenv( 1, 'CHEGST', uplo, n, -1, -1, -1 )
           if( nb<=1 .or. nb>=n ) then
              ! use unblocked code
              call stdlib_chegs2( itype, uplo, n, a, lda, b, ldb, info )
           else
              ! use blocked code
              if( itype==1 ) then
                 if( upper ) then
                    ! compute inv(u**h)*a*inv(u)
                    do k = 1, n, nb
                       kb = min( n-k+1, nb )
                       ! update the upper triangle of a(k:n,k:n)
                       call stdlib_chegs2( itype, uplo, kb, a( k, k ), lda,b( k, k ), ldb, info )
                                 
                       if( k+kb<=n ) then
                          call stdlib_ctrsm( 'LEFT', uplo, 'CONJUGATE TRANSPOSE','NON-UNIT', kb, &
                                    n-k-kb+1, cone,b( k, k ), ldb, a( k, k+kb ), lda )
                          call stdlib_chemm( 'LEFT', uplo, kb, n-k-kb+1, -chalf,a( k, k ), lda, b(&
                                     k, k+kb ), ldb,cone, a( k, k+kb ), lda )
                          call stdlib_cher2k( uplo, 'CONJUGATE TRANSPOSE', n-k-kb+1,kb, -cone, a( &
                                    k, k+kb ), lda,b( k, k+kb ), ldb, one,a( k+kb, k+kb ), lda )
                          call stdlib_chemm( 'LEFT', uplo, kb, n-k-kb+1, -chalf,a( k, k ), lda, b(&
                                     k, k+kb ), ldb,cone, a( k, k+kb ), lda )
                          call stdlib_ctrsm( 'RIGHT', uplo, 'NO TRANSPOSE','NON-UNIT', kb, n-k-kb+&
                                    1, cone,b( k+kb, k+kb ), ldb, a( k, k+kb ),lda )
                       end if
                    end do
                 else
                    ! compute inv(l)*a*inv(l**h)
                    do k = 1, n, nb
                       kb = min( n-k+1, nb )
                       ! update the lower triangle of a(k:n,k:n)
                       call stdlib_chegs2( itype, uplo, kb, a( k, k ), lda,b( k, k ), ldb, info )
                                 
                       if( k+kb<=n ) then
                          call stdlib_ctrsm( 'RIGHT', uplo, 'CONJUGATE TRANSPOSE','NON-UNIT', n-k-&
                                    kb+1, kb, cone,b( k, k ), ldb, a( k+kb, k ), lda )
                          call stdlib_chemm( 'RIGHT', uplo, n-k-kb+1, kb, -chalf,a( k, k ), lda, &
                                    b( k+kb, k ), ldb,cone, a( k+kb, k ), lda )
                          call stdlib_cher2k( uplo, 'NO TRANSPOSE', n-k-kb+1, kb,-cone, a( k+kb, &
                                    k ), lda,b( k+kb, k ), ldb, one,a( k+kb, k+kb ), lda )
                          call stdlib_chemm( 'RIGHT', uplo, n-k-kb+1, kb, -chalf,a( k, k ), lda, &
                                    b( k+kb, k ), ldb,cone, a( k+kb, k ), lda )
                          call stdlib_ctrsm( 'LEFT', uplo, 'NO TRANSPOSE','NON-UNIT', n-k-kb+1, &
                                    kb, cone,b( k+kb, k+kb ), ldb, a( k+kb, k ),lda )
                       end if
                    end do
                 end if
              else
                 if( upper ) then
                    ! compute u*a*u**h
                    do k = 1, n, nb
                       kb = min( n-k+1, nb )
                       ! update the upper triangle of a(1:k+kb-1,1:k+kb-1)
                       call stdlib_ctrmm( 'LEFT', uplo, 'NO TRANSPOSE', 'NON-UNIT',k-1, kb, cone, &
                                 b, ldb, a( 1, k ), lda )
                       call stdlib_chemm( 'RIGHT', uplo, k-1, kb, chalf, a( k, k ),lda, b( 1, k ),&
                                  ldb, cone, a( 1, k ),lda )
                       call stdlib_cher2k( uplo, 'NO TRANSPOSE', k-1, kb, cone,a( 1, k ), lda, b( &
                                 1, k ), ldb, one, a,lda )
                       call stdlib_chemm( 'RIGHT', uplo, k-1, kb, chalf, a( k, k ),lda, b( 1, k ),&
                                  ldb, cone, a( 1, k ),lda )
                       call stdlib_ctrmm( 'RIGHT', uplo, 'CONJUGATE TRANSPOSE','NON-UNIT', k-1, &
                                 kb, cone, b( k, k ), ldb,a( 1, k ), lda )
                       call stdlib_chegs2( itype, uplo, kb, a( k, k ), lda,b( k, k ), ldb, info )
                                 
                    end do
                 else
                    ! compute l**h*a*l
                    do k = 1, n, nb
                       kb = min( n-k+1, nb )
                       ! update the lower triangle of a(1:k+kb-1,1:k+kb-1)
                       call stdlib_ctrmm( 'RIGHT', uplo, 'NO TRANSPOSE', 'NON-UNIT',kb, k-1, cone,&
                                  b, ldb, a( k, 1 ), lda )
                       call stdlib_chemm( 'LEFT', uplo, kb, k-1, chalf, a( k, k ),lda, b( k, 1 ), &
                                 ldb, cone, a( k, 1 ),lda )
                       call stdlib_cher2k( uplo, 'CONJUGATE TRANSPOSE', k-1, kb,cone, a( k, 1 ), &
                                 lda, b( k, 1 ), ldb,one, a, lda )
                       call stdlib_chemm( 'LEFT', uplo, kb, k-1, chalf, a( k, k ),lda, b( k, 1 ), &
                                 ldb, cone, a( k, 1 ),lda )
                       call stdlib_ctrmm( 'LEFT', uplo, 'CONJUGATE TRANSPOSE','NON-UNIT', kb, k-1,&
                                  cone, b( k, k ), ldb,a( k, 1 ), lda )
                       call stdlib_chegs2( itype, uplo, kb, a( k, k ), lda,b( k, k ), ldb, info )
                                 
                    end do
                 end if
              end if
           end if
           return
     end subroutine stdlib_chegst


     pure subroutine stdlib_chetd2( uplo, n, a, lda, d, e, tau, info )
     !! CHETD2 reduces a complex Hermitian matrix A to real symmetric
     !! tridiagonal form T by a unitary similarity transformation:
     !! Q**H * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           complex(sp) :: alpha, taui
           ! Intrinsic Functions 
           intrinsic :: max,min,real
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETD2', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           if( upper ) then
              ! reduce the upper triangle of a
              a( n, n ) = real( a( n, n ),KIND=sp)
              do i = n - 1, 1, -1
                 ! generate elementary reflector h(i) = i - tau * v * v**h
                 ! to annihilate a(1:i-1,i+1)
                 alpha = a( i, i+1 )
                 call stdlib_clarfg( i, alpha, a( 1, i+1 ), 1, taui )
                 e( i ) = real( alpha,KIND=sp)
                 if( taui/=czero ) then
                    ! apply h(i) from both sides to a(1:i,1:i)
                    a( i, i+1 ) = cone
                    ! compute  x := tau * a * v  storing x in tau(1:i)
                    call stdlib_chemv( uplo, i, taui, a, lda, a( 1, i+1 ), 1, czero,tau, 1 )
                              
                    ! compute  w := x - 1/2 * tau * (x**h * v) * v
                    alpha = -chalf*taui*stdlib_cdotc( i, tau, 1, a( 1, i+1 ), 1 )
                    call stdlib_caxpy( i, alpha, a( 1, i+1 ), 1, tau, 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**h - w * v**h
                    call stdlib_cher2( uplo, i, -cone, a( 1, i+1 ), 1, tau, 1, a,lda )
                 else
                    a( i, i ) = real( a( i, i ),KIND=sp)
                 end if
                 a( i, i+1 ) = e( i )
                 d( i+1 ) = real( a( i+1, i+1 ),KIND=sp)
                 tau( i ) = taui
              end do
              d( 1 ) = real( a( 1, 1 ),KIND=sp)
           else
              ! reduce the lower triangle of a
              a( 1, 1 ) = real( a( 1, 1 ),KIND=sp)
              do i = 1, n - 1
                 ! generate elementary reflector h(i) = i - tau * v * v**h
                 ! to annihilate a(i+2:n,i)
                 alpha = a( i+1, i )
                 call stdlib_clarfg( n-i, alpha, a( min( i+2, n ), i ), 1, taui )
                 e( i ) = real( alpha,KIND=sp)
                 if( taui/=czero ) then
                    ! apply h(i) from both sides to a(i+1:n,i+1:n)
                    a( i+1, i ) = cone
                    ! compute  x := tau * a * v  storing y in tau(i:n-1)
                    call stdlib_chemv( uplo, n-i, taui, a( i+1, i+1 ), lda,a( i+1, i ), 1, czero, &
                              tau( i ), 1 )
                    ! compute  w := x - 1/2 * tau * (x**h * v) * v
                    alpha = -chalf*taui*stdlib_cdotc( n-i, tau( i ), 1, a( i+1, i ),1 )
                    call stdlib_caxpy( n-i, alpha, a( i+1, i ), 1, tau( i ), 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**h - w * v**h
                    call stdlib_cher2( uplo, n-i, -cone, a( i+1, i ), 1, tau( i ), 1,a( i+1, i+1 )&
                              , lda )
                 else
                    a( i+1, i+1 ) = real( a( i+1, i+1 ),KIND=sp)
                 end if
                 a( i+1, i ) = e( i )
                 d( i ) = real( a( i, i ),KIND=sp)
                 tau( i ) = taui
              end do
              d( n ) = real( a( n, n ),KIND=sp)
           end if
           return
     end subroutine stdlib_chetd2


     pure subroutine stdlib_chetrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
     !! CHETRD reduces a complex Hermitian matrix A to real symmetric
     !! tridiagonal form T by a unitary similarity transformation:
     !! Q**H * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, iws, j, kk, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -9
           end if
           if( info==0 ) then
              ! determine the block size.
              nb = stdlib_ilaenv( 1, 'CHETRD', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           nx = n
           iws = 1
           if( nb>1 .and. nb<n ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code).
              nx = max( nb, stdlib_ilaenv( 3, 'CHETRD', uplo, n, -1, -1, -1 ) )
              if( nx<n ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code by setting nx = n.
                    nb = max( lwork / ldwork, 1 )
                    nbmin = stdlib_ilaenv( 2, 'CHETRD', uplo, n, -1, -1, -1 )
                    if( nb<nbmin )nx = n
                 end if
              else
                 nx = n
              end if
           else
              nb = 1
           end if
           if( upper ) then
              ! reduce the upper triangle of a.
              ! columns 1:kk are handled by the unblocked method.
              kk = n - ( ( n-nx+nb-1 ) / nb )*nb
              do i = n - nb + 1, kk + 1, -nb
                 ! reduce columns i:i+nb-1 to tridiagonal form and form the
                 ! matrix w which is needed to update the unreduced part of
                 ! the matrix
                 call stdlib_clatrd( uplo, i+nb-1, nb, a, lda, e, tau, work,ldwork )
                 ! update the unreduced submatrix a(1:i-1,1:i-1), using an
                 ! update of the form:  a := a - v*w**h - w*v**h
                 call stdlib_cher2k( uplo, 'NO TRANSPOSE', i-1, nb, -cone,a( 1, i ), lda, work, &
                           ldwork, one, a, lda )
                 ! copy superdiagonal elements back into a, and diagonal
                 ! elements into d
                 do j = i, i + nb - 1
                    a( j-1, j ) = e( j-1 )
                    d( j ) = real( a( j, j ),KIND=sp)
                 end do
              end do
              ! use unblocked code to reduce the last or only block
              call stdlib_chetd2( uplo, kk, a, lda, d, e, tau, iinfo )
           else
              ! reduce the lower triangle of a
              do i = 1, n - nx, nb
                 ! reduce columns i:i+nb-1 to tridiagonal form and form the
                 ! matrix w which is needed to update the unreduced part of
                 ! the matrix
                 call stdlib_clatrd( uplo, n-i+1, nb, a( i, i ), lda, e( i ),tau( i ), work, &
                           ldwork )
                 ! update the unreduced submatrix a(i+nb:n,i+nb:n), using
                 ! an update of the form:  a := a - v*w**h - w*v**h
                 call stdlib_cher2k( uplo, 'NO TRANSPOSE', n-i-nb+1, nb, -cone,a( i+nb, i ), lda, &
                           work( nb+1 ), ldwork, one,a( i+nb, i+nb ), lda )
                 ! copy subdiagonal elements back into a, and diagonal
                 ! elements into d
                 do j = i, i + nb - 1
                    a( j+1, j ) = e( j )
                    d( j ) = real( a( j, j ),KIND=sp)
                 end do
              end do
              ! use unblocked code to reduce the last or only block
              call stdlib_chetd2( uplo, n-i+1, a( i, i ), lda, d( i ), e( i ),tau( i ), iinfo )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chetrd


     subroutine stdlib_chetrd_hb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, lhous, &
     !! CHETRD_HB2ST reduces a complex Hermitian band matrix A to real symmetric
     !! tridiagonal form T by a unitary similarity transformation:
     !! Q**H * A * Q = T.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: stage1, uplo, vect
           integer(ilp), intent(in) :: n, kd, ldab, lhous, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: ab(ldab,*)
           complex(sp), intent(out) :: hous(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0e+0_sp
           
           
           ! Local Scalars 
           logical(lk) :: lquery, wantq, upper, afters1
           integer(ilp) :: i, m, k, ib, sweepid, myid, shift, stt, st, ed, stind, edind, &
           blklastind, colpt, thed, stepercol, grsiz, thgrsiz, thgrnb, thgrid, nbtiles, ttype, &
           tid, nthreads, debug, abdpos, abofdpos, dpos, ofdpos, awpos, inda, indw, apos, sizea, &
                     lda, indv, indtau, sicev, sizetau, ldv, lhmin, lwmin
           real(sp) :: abstmp
           complex(sp) :: tmp
           ! Intrinsic Functions 
           intrinsic :: min,max,ceiling,real
           ! Executable Statements 
           ! determine the minimal workspace size required.
           ! test the input parameters
           debug   = 0
           info    = 0
           afters1 = stdlib_lsame( stage1, 'Y' )
           wantq   = stdlib_lsame( vect, 'V' )
           upper   = stdlib_lsame( uplo, 'U' )
           lquery  = ( lwork==-1 ) .or. ( lhous==-1 )
           ! determine the block size, the workspace size and the hous size.
           ib     = stdlib_ilaenv2stage( 2, 'CHETRD_HB2ST', vect, n, kd, -1, -1 )
           lhmin  = stdlib_ilaenv2stage( 3, 'CHETRD_HB2ST', vect, n, kd, ib, -1 )
           lwmin  = stdlib_ilaenv2stage( 4, 'CHETRD_HB2ST', vect, n, kd, ib, -1 )
           if( .not.afters1 .and. .not.stdlib_lsame( stage1, 'N' ) ) then
              info = -1
           else if( .not.stdlib_lsame( vect, 'N' ) ) then
              info = -2
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( kd<0 ) then
              info = -5
           else if( ldab<(kd+1) ) then
              info = -7
           else if( lhous<lhmin .and. .not.lquery ) then
              info = -11
           else if( lwork<lwmin .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              hous( 1 ) = lhmin
              work( 1 ) = lwmin
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRD_HB2ST', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
               hous( 1 ) = 1
               work( 1 ) = 1
               return
           end if
           ! determine pointer position
           ldv      = kd + ib
           sizetau  = 2 * n
           sicev    = 2 * n
           indtau   = 1
           indv     = indtau + sizetau
           lda      = 2 * kd + 1
           sizea    = lda * n
           inda     = 1
           indw     = inda + sizea
           nthreads = 1
           tid      = 0
           if( upper ) then
               apos     = inda + kd
               awpos    = inda
               dpos     = apos + kd
               ofdpos   = dpos - 1
               abdpos   = kd + 1
               abofdpos = kd
           else
               apos     = inda
               awpos    = inda + kd + 1
               dpos     = apos
               ofdpos   = dpos + 1
               abdpos   = 1
               abofdpos = 2
           endif
           ! case kd=0:
           ! the matrix is diagonal. we just copy it (convert to "real" for
           ! complex because d is double and the imaginary part should be 0)
           ! and store it in d. a sequential code here is better or
           ! in a parallel environment it might need two cores for d and e
           if( kd==0 ) then
               do i = 1, n
                   d( i ) = real( ab( abdpos, i ),KIND=sp)
               end do
               do i = 1, n-1
                   e( i ) = rzero
               end do
               hous( 1 ) = 1
               work( 1 ) = 1
               return
           end if
           ! case kd=1:
           ! the matrix is already tridiagonal. we have to make diagonal
           ! and offdiagonal elements real, and store them in d and e.
           ! for that, for real precision just copy the diag and offdiag
           ! to d and e while for the complex case the bulge chasing is
           ! performed to convert the hermetian tridiagonal to symmetric
           ! tridiagonal. a simpler conversion formula might be used, but then
           ! updating the q matrix will be required and based if q is generated
           ! or not this might complicate the story.
           if( kd==1 ) then
               do i = 1, n
                   d( i ) = real( ab( abdpos, i ),KIND=sp)
               end do
               ! make off-diagonal elements real and copy them to e
               if( upper ) then
                   do i = 1, n - 1
                       tmp = ab( abofdpos, i+1 )
                       abstmp = abs( tmp )
                       ab( abofdpos, i+1 ) = abstmp
                       e( i ) = abstmp
                       if( abstmp/=rzero ) then
                          tmp = tmp / abstmp
                       else
                          tmp = cone
                       end if
                       if( i<n-1 )ab( abofdpos, i+2 ) = ab( abofdpos, i+2 )*tmp
                        ! if( wantz ) then
                           ! call stdlib_cscal( n, conjg( tmp ), q( 1, i+1 ), 1 )
                        ! end if
                   end do
               else
                   do i = 1, n - 1
                      tmp = ab( abofdpos, i )
                      abstmp = abs( tmp )
                      ab( abofdpos, i ) = abstmp
                      e( i ) = abstmp
                      if( abstmp/=rzero ) then
                         tmp = tmp / abstmp
                      else
                         tmp = cone
                      end if
                      if( i<n-1 )ab( abofdpos, i+1 ) = ab( abofdpos, i+1 )*tmp
                       ! if( wantq ) then
                          ! call stdlib_cscal( n, tmp, q( 1, i+1 ), 1 )
                       ! end if
                   end do
               endif
               hous( 1 ) = 1
               work( 1 ) = 1
               return
           end if
           ! main code start here.
           ! reduce the hermitian band of a to a tridiagonal matrix.
           thgrsiz   = n
           grsiz     = 1
           shift     = 3
           nbtiles   = ceiling( real(n,KIND=sp)/real(kd,KIND=sp) )
           stepercol = ceiling( real(shift,KIND=sp)/real(grsiz,KIND=sp) )
           thgrnb    = ceiling( real(n-1,KIND=sp)/real(thgrsiz,KIND=sp) )
           call stdlib_clacpy( "A", kd+1, n, ab, ldab, work( apos ), lda )
           call stdlib_claset( "A", kd,   n, czero, czero, work( awpos ), lda )
           ! openmp parallelisation start here
           !$OMP PARALLEL PRIVATE( TID, THGRID, BLKLASTIND ) &
           !$OMP&         PRIVATE( THED, I, M, K, ST, ED, STT, SWEEPID ) &
           !$OMP&         PRIVATE( MYID, TTYPE, COLPT, STIND, EDIND ) &
           !$OMP&         SHARED ( UPLO, WANTQ, INDV, INDTAU, HOUS, WORK) &
           !$OMP&         SHARED ( N, KD, IB, NBTILES, LDA, LDV, INDA ) &
           !$OMP&         SHARED ( STEPERCOL, THGRNB, THGRSIZ, GRSIZ, SHIFT )
           !$OMP MASTER
           ! main bulge chasing loop
           loop_100: do thgrid = 1, thgrnb
               stt  = (thgrid-1)*thgrsiz+1
               thed = min( (stt + thgrsiz -1), (n-1))
               loop_110: do i = stt, n-1
                   ed = min( i, thed )
                   if( stt>ed ) exit
                   loop_120: do m = 1, stepercol
                       st = stt
                       loop_130: do sweepid = st, ed
                           loop_140: do k = 1, grsiz
                               myid  = (i-sweepid)*(stepercol*grsiz)+ (m-1)*grsiz + k
                               if ( myid==1 ) then
                                   ttype = 1
                               else
                                   ttype = mod( myid, 2 ) + 2
                               endif
                               if( ttype==2 ) then
                                   colpt      = (myid/2)*kd + sweepid
                                   stind      = colpt-kd+1
                                   edind      = min(colpt,n)
                                   blklastind = colpt
                               else
                                   colpt      = ((myid+1)/2)*kd + sweepid
                                   stind      = colpt-kd+1
                                   edind      = min(colpt,n)
                                   if( ( stind>=edind-1 ).and.( edind==n ) ) then
                                       blklastind = n
                                   else
                                       blklastind = 0
                                   endif
                               endif
                               ! call the kernel
                               !$ if( ttype/=1 ) then
                                   !$OMP TASK DEPEND(in:WORK(MYID+SHIFT-1)) &
                                   !$OMP&     DEPEND(in:WORK(MYID-1)) &
                                   !$OMP&     DEPEND(out:WORK(MYID))
                                   !$ tid      = omp_get_thread_num()
                                   !$ call stdlib_chb2st_kernels( uplo, wantq, ttype,stind, edind, &
                                   !$ sweepid, n, kd, ib,work ( inda ), lda,hous( indv ), hous( &
                                   !$ indtau ), ldv,work( indw + tid*kd ) )
                               !$OMP END TASK
                                   !$ else
                                   !$OMP TASK DEPEND(in:WORK(MYID+SHIFT-1)) &
                                   !$OMP&     DEPEND(out:WORK(MYID))
                                   !$ tid      = omp_get_thread_num()
                                   call stdlib_chb2st_kernels( uplo, wantq, ttype,stind, edind, &
                                   sweepid, n, kd, ib,work ( inda ), lda,hous( indv ), hous( &
                                            indtau ), ldv,work( indw + tid*kd ) )
                                   !$OMP END TASK
                               !$ endif
                               if ( blklastind>=(n-1) ) then
                                   stt = stt + 1
                                   exit
                               endif
                           end do loop_140
                       end do loop_130
                   end do loop_120
               end do loop_110
           end do loop_100
           !$OMP END MASTER
           !$OMP END PARALLEL
           ! copy the diagonal from a to d. note that d is real thus only
           ! the real part is needed, the imaginary part should be czero.
           do i = 1, n
               d( i ) = real( work( dpos+(i-1)*lda ),KIND=sp)
           end do
           ! copy the off diagonal from a to e. note that e is real thus only
           ! the real part is needed, the imaginary part should be czero.
           if( upper ) then
               do i = 1, n-1
                  e( i ) = real( work( ofdpos+i*lda ),KIND=sp)
               end do
           else
               do i = 1, n-1
                  e( i ) = real( work( ofdpos+(i-1)*lda ),KIND=sp)
               end do
           endif
           hous( 1 ) = lhmin
           work( 1 ) = lwmin
           return
     end subroutine stdlib_chetrd_hb2st


     subroutine stdlib_chetrd_he2hb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info )
     !! CHETRD_HE2HB reduces a complex Hermitian matrix A to complex Hermitian
     !! band-diagonal form AB by a unitary similarity transformation:
     !! Q**H * A * Q = AB.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldab, lwork, n, kd
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: ab(ldab,*), tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: rone = 1.0e+0_sp
           
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, j, iinfo, lwmin, pn, pk, llk, ldt, ldw, lds2, lds1, ls2, ls1, lw, lt,&
                      tpos, wpos, s2pos, s1pos
           ! Intrinsic Functions 
           intrinsic :: min,max
           ! Executable Statements 
           ! determine the minimal workspace size required
           ! and test the input parameters
           info   = 0
           upper  = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           lwmin  = stdlib_ilaenv2stage( 4, 'CHETRD_HE2HB', '', n, kd, -1, -1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldab<max( 1, kd+1 ) ) then
              info = -7
           else if( lwork<lwmin .and. .not.lquery ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRD_HE2HB', -info )
              return
           else if( lquery ) then
              work( 1 ) = lwmin
              return
           end if
           ! quick return if possible
           ! copy the upper/lower portion of a into ab
           if( n<=kd+1 ) then
               if( upper ) then
                   do i = 1, n
                       llk = min( kd+1, i )
                       call stdlib_ccopy( llk, a( i-llk+1, i ), 1,ab( kd+1-llk+1, i ), 1 )
                   end do
               else
                   do i = 1, n
                       llk = min( kd+1, n-i+1 )
                       call stdlib_ccopy( llk, a( i, i ), 1, ab( 1, i ), 1 )
                   end do
               endif
               work( 1 ) = 1
               return
           end if
           ! determine the pointer position for the workspace
           ldt    = kd
           lds1   = kd
           lt     = ldt*kd
           lw     = n*kd
           ls1    = lds1*kd
           ls2    = lwmin - lt - lw - ls1
            ! ls2 = n*max(kd,factoptnb)
           tpos   = 1
           wpos   = tpos  + lt
           s1pos  = wpos  + lw
           s2pos  = s1pos + ls1
           if( upper ) then
               ldw    = kd
               lds2   = kd
           else
               ldw    = n
               lds2   = n
           endif
           ! set the workspace of the triangular matrix t to czero once such a
           ! way every time t is generated the upper/lower portion will be always czero
           call stdlib_claset( "A", ldt, kd, czero, czero, work( tpos ), ldt )
           if( upper ) then
               do i = 1, n - kd, kd
                  pn = n-i-kd+1
                  pk = min( n-i-kd+1, kd )
                  ! compute the lq factorization of the current block
                  call stdlib_cgelqf( kd, pn, a( i, i+kd ), lda,tau( i ), work( s2pos ), ls2, &
                            iinfo )
                  ! copy the upper portion of a into ab
                  do j = i, i+pk-1
                     llk = min( kd, n-j ) + 1
                     call stdlib_ccopy( llk, a( j, j ), lda, ab( kd+1, j ), ldab-1 )
                  end do
                  call stdlib_claset( 'LOWER', pk, pk, czero, cone,a( i, i+kd ), lda )
                  ! form the matrix t
                  call stdlib_clarft( 'FORWARD', 'ROWWISE', pn, pk,a( i, i+kd ), lda, tau( i ),&
                            work( tpos ), ldt )
                  ! compute w:
                  call stdlib_cgemm( 'CONJUGATE', 'NO TRANSPOSE', pk, pn, pk,cone,  work( tpos ), &
                            ldt,a( i, i+kd ), lda,czero, work( s2pos ), lds2 )
                  call stdlib_chemm( 'RIGHT', uplo, pk, pn,cone,  a( i+kd, i+kd ), lda,work( &
                            s2pos ), lds2,czero, work( wpos ), ldw )
                  call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE', pk, pk, pn,cone,  work( wpos ), &
                            ldw,work( s2pos ), lds2,czero, work( s1pos ), lds1 )
                  call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', pk, pn, pk,-chalf, work( &
                            s1pos ), lds1,a( i, i+kd ), lda,cone,   work( wpos ), ldw )
                  ! update the unreduced submatrix a(i+kd:n,i+kd:n), using
                  ! an update of the form:  a := a - v'*w - w'*v
                  call stdlib_cher2k( uplo, 'CONJUGATE', pn, pk,-cone, a( i, i+kd ), lda,work( &
                            wpos ), ldw,rone, a( i+kd, i+kd ), lda )
               end do
              ! copy the upper band to ab which is the band storage matrix
              do j = n-kd+1, n
                 llk = min(kd, n-j) + 1
                 call stdlib_ccopy( llk, a( j, j ), lda, ab( kd+1, j ), ldab-1 )
              end do
           else
               ! reduce the lower triangle of a to lower band matrix
               loop_40: do i = 1, n - kd, kd
                  pn = n-i-kd+1
                  pk = min( n-i-kd+1, kd )
                  ! compute the qr factorization of the current block
                  call stdlib_cgeqrf( pn, kd, a( i+kd, i ), lda,tau( i ), work( s2pos ), ls2, &
                            iinfo )
                  ! copy the upper portion of a into ab
                  do j = i, i+pk-1
                     llk = min( kd, n-j ) + 1
                     call stdlib_ccopy( llk, a( j, j ), 1, ab( 1, j ), 1 )
                  end do
                  call stdlib_claset( 'UPPER', pk, pk, czero, cone,a( i+kd, i ), lda )
                  ! form the matrix t
                  call stdlib_clarft( 'FORWARD', 'COLUMNWISE', pn, pk,a( i+kd, i ), lda, tau( i ),&
                            work( tpos ), ldt )
                  ! compute w:
                  call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', pn, pk, pk,cone, a( i+kd, i )&
                            , lda,work( tpos ), ldt,czero, work( s2pos ), lds2 )
                  call stdlib_chemm( 'LEFT', uplo, pn, pk,cone, a( i+kd, i+kd ), lda,work( s2pos )&
                            , lds2,czero, work( wpos ), ldw )
                  call stdlib_cgemm( 'CONJUGATE', 'NO TRANSPOSE', pk, pk, pn,cone, work( s2pos ), &
                            lds2,work( wpos ), ldw,czero, work( s1pos ), lds1 )
                  call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', pn, pk, pk,-chalf, a( i+kd, &
                            i ), lda,work( s1pos ), lds1,cone, work( wpos ), ldw )
                  ! update the unreduced submatrix a(i+kd:n,i+kd:n), using
                  ! an update of the form:  a := a - v*w' - w*v'
                  call stdlib_cher2k( uplo, 'NO TRANSPOSE', pn, pk,-cone, a( i+kd, i ), lda,work( &
                            wpos ), ldw,rone, a( i+kd, i+kd ), lda )
                  ! ==================================================================
                  ! restore a for comparison and checking to be removed
                   ! do 45 j = i, i+pk-1
                      ! llk = min( kd, n-j ) + 1
                      ! call stdlib_ccopy( llk, ab( 1, j ), 1, a( j, j ), 1 )
                      45 continue
                  ! ==================================================================
               end do loop_40
              ! copy the lower band to ab which is the band storage matrix
              do j = n-kd+1, n
                 llk = min(kd, n-j) + 1
                 call stdlib_ccopy( llk, a( j, j ), 1, ab( 1, j ), 1 )
              end do
           end if
           work( 1 ) = lwmin
           return
     end subroutine stdlib_chetrd_he2hb


     pure subroutine stdlib_chetrf( uplo, n, a, lda, ipiv, work, lwork, info )
     !! CHETRF computes the factorization of a complex Hermitian matrix A
     !! using the Bunch-Kaufman diagonal pivoting method.  The form of the
     !! factorization is
     !! A = U*D*U**H  or  A = L*D*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'CHETRF', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRF', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CHETRF', uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clahef;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_clahef( uplo, k, nb, kb, a, lda, ipiv, work, n, iinfo )
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_chetf2( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clahef;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_clahef( uplo, n-k+1, nb, kb, a( k, k ), lda, ipiv( k ),work, n, &
                           iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_chetf2( uplo, n-k+1, a( k, k ), lda, ipiv( k ), iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chetrf


     pure subroutine stdlib_chetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
     !! CHETRF_RK computes the factorization of a complex Hermitian matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, ip, iws, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'CHETRF_RK', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRF_RK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CHETRF_RK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clahef_rk;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 15
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_clahef_rk( uplo, k, nb, kb, a, lda, e,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_chetf2_rk( uplo, k, a, lda, e, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k-kb+1:k and apply row permutations to the
              ! last k+1 colunms k+1:n after that block
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k<n ) then
                 do i = k, ( k - kb + 1 ), -1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_cswap( n-k, a( i, k+1 ), lda,a( ip, k+1 ), lda )
                    end if
                 end do
              end if
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
              ! this label is the exit from main loop over k decreasing
              ! from n to 1 in steps of kb
              15 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clahef_rk;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 35
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_clahef_rk( uplo, n-k+1, nb, kb, a( k, k ), lda, e( k ),ipiv( k ), &
                           work, ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_chetf2_rk( uplo, n-k+1, a( k, k ), lda, e( k ),ipiv( k ), iinfo )
                           
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do i = k, k + kb - 1
                 if( ipiv( i )>0 ) then
                    ipiv( i ) = ipiv( i ) + k - 1
                 else
                    ipiv( i ) = ipiv( i ) - k + 1
                 end if
              end do
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k:k+kb-1 and apply row permutations to the
              ! first k-1 colunms 1:k-1 before that block
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k>1 ) then
                 do i = k, ( k + kb - 1 ), 1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_cswap( k-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                    end if
                 end do
              end if
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
              ! this label is the exit from main loop over k increasing
              ! from 1 to n in steps of kb
              35 continue
           ! end lower
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chetrf_rk


     pure subroutine stdlib_chetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
     !! CHETRF_ROOK computes the factorization of a complex Hermitian matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
     !! The form of the factorization is
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'CHETRF_ROOK', uplo, n, -1, -1, -1 )
              lwkopt = max( 1, n*nb )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRF_ROOK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CHETRF_ROOK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clahef_rook;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_clahef_rook( uplo, k, nb, kb, a, lda,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_chetf2_rook( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clahef_rook;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_clahef_rook( uplo, n-k+1, nb, kb, a( k, k ), lda,ipiv( k ), work, &
                           ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_chetf2_rook( uplo, n-k+1, a( k, k ), lda, ipiv( k ),iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chetrf_rook


     pure subroutine stdlib_chetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
     !! CHETRS solves a system of linear equations A*X = B with a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by CHETRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           real(sp) :: s
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           intrinsic :: conjg,max,real
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**h.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_cgeru( k-1, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=sp) / real( a( k, k ),KIND=sp)
                 call stdlib_csscal( nrhs, s, b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_cgeru( k-2, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 call stdlib_cgeru( k-2, nrhs, -cone, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ), &
                           ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / conjg( akm1k )
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / conjg( akm1k )
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**h *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**h(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**h(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k+1, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k+1 )&
                              , 1, cone, b( k+1, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**h.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgeru( n-k, nrhs, -cone, a( k+1, k ), 1, b( k, 1 ),ldb, b( &
                           k+1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=sp) / real( a( k, k ),KIND=sp)
                 call stdlib_csscal( nrhs, s, b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_cgeru( n-k-1, nrhs, -cone, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_cgeru( n-k-1, nrhs, -cone, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / conjg( akm1k )
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / conjg( akm1k )
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**h *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**h(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**h(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k-1, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k-1 ), 1, cone,b( k-1, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k-1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_chetrs


     pure subroutine stdlib_chetrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
     !! CHETRS2 solves a system of linear equations A*X = B with a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by CHETRF and converted by CSYCONV.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, j, k, kp
           real(sp) :: s
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           intrinsic :: conjg,max,real
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRS2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! convert a
           call stdlib_csyconv( uplo, 'C', n, a, lda, ipiv, work, iinfo )
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**h.
             ! p**t * b
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp==-ipiv( k-1 ) )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb &
                           )
                 k=k-2
              end if
             end do
        ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
             call stdlib_ctrsm('L','U','N','U',n,nrhs,cone,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0 ) then
                   s = real( cone,KIND=sp) / real( a( i, i ),KIND=sp)
                   call stdlib_csscal( nrhs, s, b( i, 1 ), ldb )
                 elseif ( i > 1) then
                    if ( ipiv(i-1) == ipiv(i) ) then
                       akm1k = work(i)
                       akm1 = a( i-1, i-1 ) / akm1k
                       ak = a( i, i ) / conjg( akm1k )
                       denom = akm1*ak - cone
                       do j = 1, nrhs
                          bkm1 = b( i-1, j ) / akm1k
                          bk = b( i, j ) / conjg( akm1k )
                          b( i-1, j ) = ( ak*bkm1-bk ) / denom
                          b( i, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                    i = i - 1
                    endif
                 endif
                 i = i - 1
              end do
            ! compute (u**h \ b) -> b   [ u**h \ (d \ (u \p**t * b) ) ]
              call stdlib_ctrsm('L','U','C','U',n,nrhs,cone,a,lda,b,ldb)
             ! p * b  [ p * (u**h \ (d \ (u \p**t * b) )) ]
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k < n .and. kp==-ipiv( k+1 ) )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp,&
                            1 ), ldb )
                 k=k+2
              endif
             end do
           else
              ! solve a*x = b, where a = l*d*l**h.
             ! p**t * b
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k+1).
                 kp = -ipiv( k+1 )
                 if( kp==-ipiv( k ) )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                           
                 k=k+2
              endif
             end do
        ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
             call stdlib_ctrsm('L','L','N','U',n,nrhs,cone,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                   s = real( cone,KIND=sp) / real( a( i, i ),KIND=sp)
                   call stdlib_csscal( nrhs, s, b( i, 1 ), ldb )
                 else
                       akm1k = work(i)
                       akm1 = a( i, i ) / conjg( akm1k )
                       ak = a( i+1, i+1 ) / akm1k
                       denom = akm1*ak - cone
                       do j = 1, nrhs
                          bkm1 = b( i, j ) / conjg( akm1k )
                          bk = b( i+1, j ) / akm1k
                          b( i, j ) = ( ak*bkm1-bk ) / denom
                          b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                       i = i + 1
                 endif
                 i = i + 1
              end do
        ! compute (l**h \ b) -> b   [ l**h \ (d \ (l \p**t * b) ) ]
             call stdlib_ctrsm('L','L','C','U',n,nrhs,cone,a,lda,b,ldb)
             ! p * b  [ p * (l**h \ (d \ (l \p**t * b) )) ]
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k>1 .and. kp==-ipiv( k-1 ) )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, &
                           1 ), ldb )
                 k=k-2
              endif
             end do
           end if
           ! revert a
           call stdlib_csyconv( uplo, 'R', n, a, lda, ipiv, work, iinfo )
           return
     end subroutine stdlib_chetrs2


     pure subroutine stdlib_chetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
     !! CHETRS_AA solves a system of linear equations A*X = B with a complex
     !! hermitian matrix A using the factorization A = U**H*T*U or
     !! A = L*T*L**H computed by CHETRF_AA.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, nrhs, lda, ldb, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           logical(lk) :: lquery, upper
           integer(ilp) :: k, kp, lwkopt
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 1, 3*n-2 ) .and. .not.lquery ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRS_AA', -info )
              return
           else if( lquery ) then
              lwkopt = (3*n-2)
              work( 1 ) = lwkopt
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u**h*t*u.
              ! 1) forward substitution with u**h
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 k = 1
                 do while ( k<=n )
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                    k = k + 1
                 end do
                 ! compute u**h \ b -> b    [ (u**h \p**t * b) ]
                 call stdlib_ctrsm( 'L', 'U', 'C', 'U', n-1, nrhs, cone, a( 1, 2 ),lda, b( 2, 1 ),&
                            ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (u**h \p**t * b) ]
              call stdlib_clacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1)
              if( n>1 ) then
                  call stdlib_clacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 2*n ), 1)
                  call stdlib_clacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 1 ), 1)
                  call stdlib_clacgv( n-1, work( 1 ), 1 )
              end if
              call stdlib_cgtsv(n, nrhs, work(1), work(n), work(2*n), b, ldb,info)
              ! 3) backward substitution with u
              if( n>1 ) then
                 ! compute u \ b -> b   [ u \ (t \ (u**h \p**t * b) ) ]
                 call stdlib_ctrsm( 'L', 'U', 'N', 'U', n-1, nrhs, cone, a( 1, 2 ),lda, b(2, 1), &
                           ldb)
                 ! pivot, p * b  -> b [ p * (u \ (t \ (u**h \p**t * b) )) ]
                 k = n
                 do while ( k>=1 )
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                    k = k - 1
                 end do
              end if
           else
              ! solve a*x = b, where a = l*t*l**h.
              ! 1) forward substitution with l
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 k = 1
                 do while ( k<=n )
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                    k = k + 1
                 end do
                 ! compute l \ b -> b    [ (l \p**t * b) ]
                 call stdlib_ctrsm( 'L', 'L', 'N', 'U', n-1, nrhs, cone, a( 2, 1),lda, b(2, 1), &
                           ldb )
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (l \p**t * b) ]
              call stdlib_clacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1)
              if( n>1 ) then
                  call stdlib_clacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 1 ), 1 )
                  call stdlib_clacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 2*n ), 1)
                  call stdlib_clacgv( n-1, work( 2*n ), 1 )
              end if
              call stdlib_cgtsv(n, nrhs, work(1), work(n), work(2*n), b, ldb,info)
              ! 3) backward substitution with l**h
              if( n>1 ) then
                 ! compute (l**h \ b) -> b   [ l**h \ (t \ (l \p**t * b) ) ]
                 call stdlib_ctrsm( 'L', 'L', 'C', 'U', n-1, nrhs, cone, a( 2, 1 ),lda, b( 2, 1 ),&
                            ldb )
                 ! pivot, p * b -> b  [ p * (l**h \ (t \ (l \p**t * b) )) ]
                 k = n
                 do while ( k>=1 )
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                    k = k - 1
                 end do
              end if
           end if
           return
     end subroutine stdlib_chetrs_aa


     pure subroutine stdlib_chetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
     !! CHETRS_ROOK solves a system of linear equations A*X = B with a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by CHETRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           real(sp) :: s
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           intrinsic :: conjg,max,real
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRS_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**h.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_cgeru( k-1, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=sp) / real( a( k, k ),KIND=sp)
                 call stdlib_csscal( nrhs, s, b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k), then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1)
                 if( kp/=k-1 )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_cgeru( k-2, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 call stdlib_cgeru( k-2, nrhs, -cone, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ), &
                           ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / conjg( akm1k )
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / conjg( akm1k )
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**h *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**h(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**h(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k+1, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k+1 )&
                              , 1, cone, b( k+1, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k), then k+1 and -ipiv(k+1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**h.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgeru( n-k, nrhs, -cone, a( k+1, k ), 1, b( k, 1 ),ldb, b( &
                           k+1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=sp) / real( a( k, k ),KIND=sp)
                 call stdlib_csscal( nrhs, s, b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k), then k+1 and -ipiv(k+1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_cgeru( n-k-1, nrhs, -cone, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_cgeru( n-k-1, nrhs, -cone, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / conjg( akm1k )
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / conjg( akm1k )
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**h *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**h(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**h(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k-1, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k-1 ), 1, cone,b( k-1, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k-1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k), then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_chetrs_rook


     pure subroutine stdlib_chptrd( uplo, n, ap, d, e, tau, info )
     !! CHPTRD reduces a complex Hermitian matrix A stored in packed form to
     !! real symmetric tridiagonal form T by a unitary similarity
     !! transformation: Q**H * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(out) :: tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, i1, i1i1, ii
           complex(sp) :: alpha, taui
           ! Intrinsic Functions 
           intrinsic :: real
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPTRD', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           if( upper ) then
              ! reduce the upper triangle of a.
              ! i1 is the index in ap of a(1,i+1).
              i1 = n*( n-1 ) / 2 + 1
              ap( i1+n-1 ) = real( ap( i1+n-1 ),KIND=sp)
              do i = n - 1, 1, -1
                 ! generate elementary reflector h(i) = i - tau * v * v**h
                 ! to annihilate a(1:i-1,i+1)
                 alpha = ap( i1+i-1 )
                 call stdlib_clarfg( i, alpha, ap( i1 ), 1, taui )
                 e( i ) = real( alpha,KIND=sp)
                 if( taui/=czero ) then
                    ! apply h(i) from both sides to a(1:i,1:i)
                    ap( i1+i-1 ) = cone
                    ! compute  y := tau * a * v  storing y in tau(1:i)
                    call stdlib_chpmv( uplo, i, taui, ap, ap( i1 ), 1, czero, tau,1 )
                    ! compute  w := y - 1/2 * tau * (y**h *v) * v
                    alpha = -chalf*taui*stdlib_cdotc( i, tau, 1, ap( i1 ), 1 )
                    call stdlib_caxpy( i, alpha, ap( i1 ), 1, tau, 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**h - w * v**h
                    call stdlib_chpr2( uplo, i, -cone, ap( i1 ), 1, tau, 1, ap )
                 end if
                 ap( i1+i-1 ) = e( i )
                 d( i+1 ) = real( ap( i1+i ),KIND=sp)
                 tau( i ) = taui
                 i1 = i1 - i
              end do
              d( 1 ) = real( ap( 1 ),KIND=sp)
           else
              ! reduce the lower triangle of a. ii is the index in ap of
              ! a(i,i) and i1i1 is the index of a(i+1,i+1).
              ii = 1
              ap( 1 ) = real( ap( 1 ),KIND=sp)
              do i = 1, n - 1
                 i1i1 = ii + n - i + 1
                 ! generate elementary reflector h(i) = i - tau * v * v**h
                 ! to annihilate a(i+2:n,i)
                 alpha = ap( ii+1 )
                 call stdlib_clarfg( n-i, alpha, ap( ii+2 ), 1, taui )
                 e( i ) = real( alpha,KIND=sp)
                 if( taui/=czero ) then
                    ! apply h(i) from both sides to a(i+1:n,i+1:n)
                    ap( ii+1 ) = cone
                    ! compute  y := tau * a * v  storing y in tau(i:n-1)
                    call stdlib_chpmv( uplo, n-i, taui, ap( i1i1 ), ap( ii+1 ), 1,czero, tau( i ),&
                               1 )
                    ! compute  w := y - 1/2 * tau * (y**h *v) * v
                    alpha = -chalf*taui*stdlib_cdotc( n-i, tau( i ), 1, ap( ii+1 ),1 )
                    call stdlib_caxpy( n-i, alpha, ap( ii+1 ), 1, tau( i ), 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**h - w * v**h
                    call stdlib_chpr2( uplo, n-i, -cone, ap( ii+1 ), 1, tau( i ), 1,ap( i1i1 ) )
                              
                 end if
                 ap( ii+1 ) = e( i )
                 d( i ) = real( ap( ii ),KIND=sp)
                 tau( i ) = taui
                 ii = i1i1
              end do
              d( n ) = real( ap( ii ),KIND=sp)
           end if
           return
     end subroutine stdlib_chptrd


     pure subroutine stdlib_chptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! CHPTRS solves a system of linear equations A*X = B with a complex
     !! Hermitian matrix A stored in packed format using the factorization
     !! A = U*D*U**H or A = L*D*L**H computed by CHPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: ap(*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kp
           real(sp) :: s
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           intrinsic :: conjg,max,real
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**h.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              kc = kc - k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_cgeru( k-1, nrhs, -cone, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=sp) / real( ap( kc+k-1 ),KIND=sp)
                 call stdlib_csscal( nrhs, s, b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_cgeru( k-2, nrhs, -cone, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 call stdlib_cgeru( k-2, nrhs, -cone, ap( kc-( k-1 ) ), 1,b( k-1, 1 ), ldb, b( 1, &
                           1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+k-2 )
                 akm1 = ap( kc-1 ) / akm1k
                 ak = ap( kc+k-1 ) / conjg( akm1k )
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / conjg( akm1k )
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc - k + 1
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**h *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**h(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, ap( kc ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + k
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**h(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, ap( kc ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k+1, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, ap( kc+k ),&
                               1, cone, b( k+1, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + 2*k + 1
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**h.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgeru( n-k, nrhs, -cone, ap( kc+1 ), 1, b( k, 1 ),ldb, b( k+&
                           1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=sp) / real( ap( kc ),KIND=sp)
                 call stdlib_csscal( nrhs, s, b( k, 1 ), ldb )
                 kc = kc + n - k + 1
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_cgeru( n-k-1, nrhs, -cone, ap( kc+2 ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_cgeru( n-k-1, nrhs, -cone, ap( kc+n-k+2 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+1 )
                 akm1 = ap( kc ) / conjg( akm1k )
                 ak = ap( kc+n-k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / conjg( akm1k )
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc + 2*( n-k ) + 1
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**h *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              kc = kc - ( n-k+1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**h(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              ap( kc+1 ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**h(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              ap( kc+1 ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k-1, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              ap( kc-( n-k ) ), 1, cone,b( k-1, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k-1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc - ( n-k+2 )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_chptrs


     real(sp) function stdlib_cla_gbrcond_c( trans, n, kl, ku, ab, ldab, afb,ldafb, ipiv, c, &
     !! CLA_GBRCOND_C Computes the infinity norm condition number of
     !! op(A) * inv(diag(C)) where C is a REAL vector.
               capply, info, work,rwork )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, kl, ku, ldab, ldafb
           integer(ilp) :: kd, ke
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: ab(ldab,*), afb(ldafb,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(in) :: c(*)
           real(sp), intent(out) :: rwork(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: notrans
           integer(ilp) :: kase, i, j
           real(sp) :: ainvnm, anorm, tmp
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           stdlib_cla_gbrcond_c = zero
           info = 0
           notrans = stdlib_lsame( trans, 'N' )
           if ( .not. notrans .and. .not. stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kl<0 .or. kl>n-1 ) then
              info = -3
           else if( ku<0 .or. ku>n-1 ) then
              info = -4
           else if( ldab<kl+ku+1 ) then
              info = -6
           else if( ldafb<2*kl+ku+1 ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLA_GBRCOND_C', -info )
              return
           end if
           ! compute norm of op(a)*op2(c).
           anorm = zero
           kd = ku + 1
           ke = kl + 1
           if ( notrans ) then
              do i = 1, n
                 tmp = zero
                 if ( capply ) then
                    do j = max( i-kl, 1 ), min( i+ku, n )
                       tmp = tmp + cabs1( ab( kd+i-j, j ) ) / c( j )
                    end do
                 else
                    do j = max( i-kl, 1 ), min( i+ku, n )
                       tmp = tmp + cabs1( ab( kd+i-j, j ) )
                    end do
                 end if
                 rwork( i ) = tmp
                 anorm = max( anorm, tmp )
              end do
           else
              do i = 1, n
                 tmp = zero
                 if ( capply ) then
                    do j = max( i-kl, 1 ), min( i+ku, n )
                       tmp = tmp + cabs1( ab( ke-i+j, i ) ) / c( j )
                    end do
                 else
                    do j = max( i-kl, 1 ), min( i+ku, n )
                       tmp = tmp + cabs1( ab( ke-i+j, i ) )
                    end do
                 end if
                 rwork( i ) = tmp
                 anorm = max( anorm, tmp )
              end do
           end if
           ! quick return if possible.
           if( n==0 ) then
              stdlib_cla_gbrcond_c = one
              return
           else if( anorm == zero ) then
              return
           end if
           ! estimate the norm of inv(op(a)).
           ainvnm = zero
           kase = 0
           10 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( kase==2 ) then
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * rwork( i )
                 end do
                 if ( notrans ) then
                    call stdlib_cgbtrs( 'NO TRANSPOSE', n, kl, ku, 1, afb, ldafb,ipiv, work, n, &
                              info )
                 else
                    call stdlib_cgbtrs( 'CONJUGATE TRANSPOSE', n, kl, ku, 1, afb,ldafb, ipiv, &
                              work, n, info )
                 endif
                 ! multiply by inv(c).
                 if ( capply ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
              else
                 ! multiply by inv(c**h).
                 if ( capply ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
                 if ( notrans ) then
                    call stdlib_cgbtrs( 'CONJUGATE TRANSPOSE', n, kl, ku, 1, afb,ldafb, ipiv,  &
                              work, n, info )
                 else
                    call stdlib_cgbtrs( 'NO TRANSPOSE', n, kl, ku, 1, afb, ldafb,ipiv, work, n, &
                              info )
                 end if
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * rwork( i )
                 end do
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm /= zero )stdlib_cla_gbrcond_c = one / ainvnm
           return
     end function stdlib_cla_gbrcond_c


     real(sp) function stdlib_cla_gercond_c( trans, n, a, lda, af, ldaf, ipiv, c,capply, info, &
     !! CLA_GERCOND_C computes the infinity norm condition number of
     !! op(A) * inv(diag(C)) where C is a REAL vector.
               work, rwork )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, lda, ldaf
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(in) :: c(*)
           real(sp), intent(out) :: rwork(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: notrans
           integer(ilp) :: kase, i, j
           real(sp) :: ainvnm, anorm, tmp
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max,real,aimag
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           stdlib_cla_gercond_c = zero
           info = 0
           notrans = stdlib_lsame( trans, 'N' )
           if ( .not. notrans .and. .not. stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldaf<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLA_GERCOND_C', -info )
              return
           end if
           ! compute norm of op(a)*op2(c).
           anorm = zero
           if ( notrans ) then
              do i = 1, n
                 tmp = zero
                 if ( capply ) then
                    do j = 1, n
                       tmp = tmp + cabs1( a( i, j ) ) / c( j )
                    end do
                 else
                    do j = 1, n
                       tmp = tmp + cabs1( a( i, j ) )
                    end do
                 end if
                 rwork( i ) = tmp
                 anorm = max( anorm, tmp )
              end do
           else
              do i = 1, n
                 tmp = zero
                 if ( capply ) then
                    do j = 1, n
                       tmp = tmp + cabs1( a( j, i ) ) / c( j )
                    end do
                 else
                    do j = 1, n
                       tmp = tmp + cabs1( a( j, i ) )
                    end do
                 end if
                 rwork( i ) = tmp
                 anorm = max( anorm, tmp )
              end do
           end if
           ! quick return if possible.
           if( n==0 ) then
              stdlib_cla_gercond_c = one
              return
           else if( anorm == zero ) then
              return
           end if
           ! estimate the norm of inv(op(a)).
           ainvnm = zero
           kase = 0
           10 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( kase==2 ) then
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * rwork( i )
                 end do
                 if (notrans) then
                    call stdlib_cgetrs( 'NO TRANSPOSE', n, 1, af, ldaf, ipiv,work, n, info )
                              
                 else
                    call stdlib_cgetrs( 'CONJUGATE TRANSPOSE', n, 1, af, ldaf, ipiv,work, n, info &
                              )
                 endif
                 ! multiply by inv(c).
                 if ( capply ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
              else
                 ! multiply by inv(c**h).
                 if ( capply ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
                 if ( notrans ) then
                    call stdlib_cgetrs( 'CONJUGATE TRANSPOSE', n, 1, af, ldaf, ipiv,work, n, info &
                              )
                 else
                    call stdlib_cgetrs( 'NO TRANSPOSE', n, 1, af, ldaf, ipiv,work, n, info )
                              
                 end if
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * rwork( i )
                 end do
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm /= zero )stdlib_cla_gercond_c = one / ainvnm
           return
     end function stdlib_cla_gercond_c


     real(sp) function stdlib_cla_hercond_c( uplo, n, a, lda, af, ldaf, ipiv, c,capply, info, &
     !! CLA_HERCOND_C computes the infinity norm condition number of
     !! op(A) * inv(diag(C)) where C is a REAL vector.
               work, rwork )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, lda, ldaf
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(in) :: c(*)
           real(sp), intent(out) :: rwork(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: kase, i, j
           real(sp) :: ainvnm, anorm, tmp
           logical(lk) :: up, upper
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           stdlib_cla_hercond_c = zero
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldaf<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLA_HERCOND_C', -info )
              return
           end if
           up = .false.
           if ( stdlib_lsame( uplo, 'U' ) ) up = .true.
           ! compute norm of op(a)*op2(c).
           anorm = zero
           if ( up ) then
              do i = 1, n
                 tmp = zero
                 if ( capply ) then
                    do j = 1, i
                       tmp = tmp + cabs1( a( j, i ) ) / c( j )
                    end do
                    do j = i+1, n
                       tmp = tmp + cabs1( a( i, j ) ) / c( j )
                    end do
                 else
                    do j = 1, i
                       tmp = tmp + cabs1( a( j, i ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + cabs1( a( i, j ) )
                    end do
                 end if
                 rwork( i ) = tmp
                 anorm = max( anorm, tmp )
              end do
           else
              do i = 1, n
                 tmp = zero
                 if ( capply ) then
                    do j = 1, i
                       tmp = tmp + cabs1( a( i, j ) ) / c( j )
                    end do
                    do j = i+1, n
                       tmp = tmp + cabs1( a( j, i ) ) / c( j )
                    end do
                 else
                    do j = 1, i
                       tmp = tmp + cabs1( a( i, j ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + cabs1( a( j, i ) )
                    end do
                 end if
                 rwork( i ) = tmp
                 anorm = max( anorm, tmp )
              end do
           end if
           ! quick return if possible.
           if( n==0 ) then
              stdlib_cla_hercond_c = one
              return
           else if( anorm == zero ) then
              return
           end if
           ! estimate the norm of inv(op(a)).
           ainvnm = zero
           kase = 0
           10 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( kase==2 ) then
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * rwork( i )
                 end do
                 if ( up ) then
                    call stdlib_chetrs( 'U', n, 1, af, ldaf, ipiv,work, n, info )
                 else
                    call stdlib_chetrs( 'L', n, 1, af, ldaf, ipiv,work, n, info )
                 endif
                 ! multiply by inv(c).
                 if ( capply ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
              else
                 ! multiply by inv(c**h).
                 if ( capply ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
                 if ( up ) then
                    call stdlib_chetrs( 'U', n, 1, af, ldaf, ipiv,work, n, info )
                 else
                    call stdlib_chetrs( 'L', n, 1, af, ldaf, ipiv,work, n, info )
                 end if
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * rwork( i )
                 end do
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm /= zero )stdlib_cla_hercond_c = one / ainvnm
           return
     end function stdlib_cla_hercond_c


     real(sp) function stdlib_cla_herpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,work )
     !! CLA_HERPVGRW computes the reciprocal pivot growth factor
     !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
     !! much less than 1, the stability of the LU factorization of the
     !! (equilibrated) matrix A could be poor. This also means that the
     !! solution X, estimated condition numbers, and error bounds could be
     !! unreliable.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, info, lda, ldaf
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: ncols, i, j, k, kp
           real(sp) :: amax, umax, rpvgrw, tmp
           logical(lk) :: upper, lsame
           complex(sp) :: zdum
           ! Intrinsic Functions 
           intrinsic :: abs,real,aimag,max,min
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag ( zdum ) )
           ! Executable Statements 
           upper = stdlib_lsame( 'UPPER', uplo )
           if ( info==0 ) then
              if (upper) then
                 ncols = 1
              else
                 ncols = n
              end if
           else
              ncols = info
           end if
           rpvgrw = one
           do i = 1, 2*n
              work( i ) = zero
           end do
           ! find the max magnitude entry of each column of a.  compute the max
           ! for all n columns so we can apply the pivot permutation while
           ! looping below.  assume a full factorization is the common case.
           if ( upper ) then
              do j = 1, n
                 do i = 1, j
                    work( n+i ) = max( cabs1( a( i,j ) ), work( n+i ) )
                    work( n+j ) = max( cabs1( a( i,j ) ), work( n+j ) )
                 end do
              end do
           else
              do j = 1, n
                 do i = j, n
                    work( n+i ) = max( cabs1( a( i, j ) ), work( n+i ) )
                    work( n+j ) = max( cabs1( a( i, j ) ), work( n+j ) )
                 end do
              end do
           end if
           ! now find the max magnitude entry of each column of u or l.  also
           ! permute the magnitudes of a above so they're in the same order as
           ! the factor.
           ! the iteration orders and permutations were copied from stdlib_csytrs.
           ! calls to stdlib_sswap would be severe overkill.
           if ( upper ) then
              k = n
              do while ( k < ncols .and. k>0 )
                 if ( ipiv( k )>0 ) then
                    ! 1x1 pivot
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    do i = 1, k
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                    end do
                    k = k - 1
                 else
                    ! 2x2 pivot
                    kp = -ipiv( k )
                    tmp = work( n+k-1 )
                    work( n+k-1 ) = work( n+kp )
                    work( n+kp ) = tmp
                    do i = 1, k-1
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                       work( k-1 ) =max( cabs1( af( i, k-1 ) ), work( k-1 ) )
                    end do
                    work( k ) = max( cabs1( af( k, k ) ), work( k ) )
                    k = k - 2
                 end if
              end do
              k = ncols
              do while ( k <= n )
                 if ( ipiv( k )>0 ) then
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    k = k + 1
                 else
                    kp = -ipiv( k )
                    tmp = work( n+k )
                    work( n+k ) = work( n+kp )
                    work( n+kp ) = tmp
                    k = k + 2
                 end if
              end do
           else
              k = 1
              do while ( k <= ncols )
                 if ( ipiv( k )>0 ) then
                    ! 1x1 pivot
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    do i = k, n
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                    end do
                    k = k + 1
                 else
                    ! 2x2 pivot
                    kp = -ipiv( k )
                    tmp = work( n+k+1 )
                    work( n+k+1 ) = work( n+kp )
                    work( n+kp ) = tmp
                    do i = k+1, n
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                       work( k+1 ) =max( cabs1( af( i, k+1 ) ) , work( k+1 ) )
                    end do
                    work(k) = max( cabs1( af( k, k ) ), work( k ) )
                    k = k + 2
                 end if
              end do
              k = ncols
              do while ( k >= 1 )
                 if ( ipiv( k )>0 ) then
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    k = k - 1
                 else
                    kp = -ipiv( k )
                    tmp = work( n+k )
                    work( n+k ) = work( n+kp )
                    work( n+kp ) = tmp
                    k = k - 2
                 endif
              end do
           end if
           ! compute the *inverse* of the max element growth factor.  dividing
           ! by zero would imply the largest entry of the factor's column is
           ! zero.  than can happen when either the column of a is zero or
           ! massive pivots made the factor underflow to zero.  neither counts
           ! as growth in itself, so simply ignore terms with zero
           ! denominators.
           if ( upper ) then
              do i = ncols, n
                 umax = work( i )
                 amax = work( n+i )
                 if ( umax /= 0.0_sp ) then
                    rpvgrw = min( amax / umax, rpvgrw )
                 end if
              end do
           else
              do i = 1, ncols
                 umax = work( i )
                 amax = work( n+i )
                 if ( umax /= 0.0_sp ) then
                    rpvgrw = min( amax / umax, rpvgrw )
                 end if
              end do
           end if
           stdlib_cla_herpvgrw = rpvgrw
     end function stdlib_cla_herpvgrw


     real(sp) function stdlib_cla_porcond_c( uplo, n, a, lda, af, ldaf, c, capply,info, work, &
     !! CLA_PORCOND_C Computes the infinity norm condition number of
     !! op(A) * inv(diag(C)) where C is a REAL vector
               rwork )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, lda, ldaf
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(in) :: c(*)
           real(sp), intent(out) :: rwork(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: kase
           real(sp) :: ainvnm, anorm, tmp
           integer(ilp) :: i, j
           logical(lk) :: up, upper
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max,real,aimag
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           stdlib_cla_porcond_c = zero
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldaf<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLA_PORCOND_C', -info )
              return
           end if
           up = .false.
           if ( stdlib_lsame( uplo, 'U' ) ) up = .true.
           ! compute norm of op(a)*op2(c).
           anorm = zero
           if ( up ) then
              do i = 1, n
                 tmp = zero
                 if ( capply ) then
                    do j = 1, i
                       tmp = tmp + cabs1( a( j, i ) ) / c( j )
                    end do
                    do j = i+1, n
                       tmp = tmp + cabs1( a( i, j ) ) / c( j )
                    end do
                 else
                    do j = 1, i
                       tmp = tmp + cabs1( a( j, i ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + cabs1( a( i, j ) )
                    end do
                 end if
                 rwork( i ) = tmp
                 anorm = max( anorm, tmp )
              end do
           else
              do i = 1, n
                 tmp = zero
                 if ( capply ) then
                    do j = 1, i
                       tmp = tmp + cabs1( a( i, j ) ) / c( j )
                    end do
                    do j = i+1, n
                       tmp = tmp + cabs1( a( j, i ) ) / c( j )
                    end do
                 else
                    do j = 1, i
                       tmp = tmp + cabs1( a( i, j ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + cabs1( a( j, i ) )
                    end do
                 end if
                 rwork( i ) = tmp
                 anorm = max( anorm, tmp )
              end do
           end if
           ! quick return if possible.
           if( n==0 ) then
              stdlib_cla_porcond_c = one
              return
           else if( anorm == zero ) then
              return
           end if
           ! estimate the norm of inv(op(a)).
           ainvnm = zero
           kase = 0
           10 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( kase==2 ) then
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * rwork( i )
                 end do
                 if ( up ) then
                    call stdlib_cpotrs( 'U', n, 1, af, ldaf,work, n, info )
                 else
                    call stdlib_cpotrs( 'L', n, 1, af, ldaf,work, n, info )
                 endif
                 ! multiply by inv(c).
                 if ( capply ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
              else
                 ! multiply by inv(c**h).
                 if ( capply ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
                 if ( up ) then
                    call stdlib_cpotrs( 'U', n, 1, af, ldaf,work, n, info )
                 else
                    call stdlib_cpotrs( 'L', n, 1, af, ldaf,work, n, info )
                 end if
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * rwork( i )
                 end do
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm /= zero )stdlib_cla_porcond_c = one / ainvnm
           return
     end function stdlib_cla_porcond_c


     real(sp) function stdlib_cla_syrcond_c( uplo, n, a, lda, af, ldaf, ipiv, c,capply, info, &
     !! CLA_SYRCOND_C Computes the infinity norm condition number of
     !! op(A) * inv(diag(C)) where C is a REAL vector.
               work, rwork )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, lda, ldaf
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(in) :: c(*)
           real(sp), intent(out) :: rwork(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: kase
           real(sp) :: ainvnm, anorm, tmp
           integer(ilp) :: i, j
           logical(lk) :: up, upper
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,max
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           stdlib_cla_syrcond_c = zero
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldaf<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLA_SYRCOND_C', -info )
              return
           end if
           up = .false.
           if ( stdlib_lsame( uplo, 'U' ) ) up = .true.
           ! compute norm of op(a)*op2(c).
           anorm = zero
           if ( up ) then
              do i = 1, n
                 tmp = zero
                 if ( capply ) then
                    do j = 1, i
                       tmp = tmp + cabs1( a( j, i ) ) / c( j )
                    end do
                    do j = i+1, n
                       tmp = tmp + cabs1( a( i, j ) ) / c( j )
                    end do
                 else
                    do j = 1, i
                       tmp = tmp + cabs1( a( j, i ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + cabs1( a( i, j ) )
                    end do
                 end if
                 rwork( i ) = tmp
                 anorm = max( anorm, tmp )
              end do
           else
              do i = 1, n
                 tmp = zero
                 if ( capply ) then
                    do j = 1, i
                       tmp = tmp + cabs1( a( i, j ) ) / c( j )
                    end do
                    do j = i+1, n
                       tmp = tmp + cabs1( a( j, i ) ) / c( j )
                    end do
                 else
                    do j = 1, i
                       tmp = tmp + cabs1( a( i, j ) )
                    end do
                    do j = i+1, n
                       tmp = tmp + cabs1( a( j, i ) )
                    end do
                 end if
                 rwork( i ) = tmp
                 anorm = max( anorm, tmp )
              end do
           end if
           ! quick return if possible.
           if( n==0 ) then
              stdlib_cla_syrcond_c = one
              return
           else if( anorm == zero ) then
              return
           end if
           ! estimate the norm of inv(op(a)).
           ainvnm = zero
           kase = 0
           10 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( kase==2 ) then
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * rwork( i )
                 end do
                 if ( up ) then
                    call stdlib_csytrs( 'U', n, 1, af, ldaf, ipiv,work, n, info )
                 else
                    call stdlib_csytrs( 'L', n, 1, af, ldaf, ipiv,work, n, info )
                 endif
                 ! multiply by inv(c).
                 if ( capply ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
              else
                 ! multiply by inv(c**t).
                 if ( capply ) then
                    do i = 1, n
                       work( i ) = work( i ) * c( i )
                    end do
                 end if
                 if ( up ) then
                    call stdlib_csytrs( 'U', n, 1, af, ldaf, ipiv,work, n, info )
                 else
                    call stdlib_csytrs( 'L', n, 1, af, ldaf, ipiv,work, n, info )
                 end if
                 ! multiply by r.
                 do i = 1, n
                    work( i ) = work( i ) * rwork( i )
                 end do
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm /= zero )stdlib_cla_syrcond_c = one / ainvnm
           return
     end function stdlib_cla_syrcond_c


     real(sp) function stdlib_cla_syrpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,work )
     !! CLA_SYRPVGRW computes the reciprocal pivot growth factor
     !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
     !! much less than 1, the stability of the LU factorization of the
     !! (equilibrated) matrix A could be poor. This also means that the
     !! solution X, estimated condition numbers, and error bounds could be
     !! unreliable.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, info, lda, ldaf
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*)
           real(sp), intent(out) :: work(*)
           integer(ilp), intent(in) :: ipiv(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: ncols, i, j, k, kp
           real(sp) :: amax, umax, rpvgrw, tmp
           logical(lk) :: upper
           complex(sp) :: zdum
           ! Intrinsic Functions 
           intrinsic :: abs,real,aimag,max,min
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag ( zdum ) )
           ! Executable Statements 
           upper = stdlib_lsame( 'UPPER', uplo )
           if ( info==0 ) then
              if ( upper ) then
                 ncols = 1
              else
                 ncols = n
              end if
           else
              ncols = info
           end if
           rpvgrw = one
           do i = 1, 2*n
              work( i ) = zero
           end do
           ! find the max magnitude entry of each column of a.  compute the max
           ! for all n columns so we can apply the pivot permutation while
           ! looping below.  assume a full factorization is the common case.
           if ( upper ) then
              do j = 1, n
                 do i = 1, j
                    work( n+i ) = max( cabs1( a( i, j ) ), work( n+i ) )
                    work( n+j ) = max( cabs1( a( i, j ) ), work( n+j ) )
                 end do
              end do
           else
              do j = 1, n
                 do i = j, n
                    work( n+i ) = max( cabs1( a( i, j ) ), work( n+i ) )
                    work( n+j ) = max( cabs1( a( i, j ) ), work( n+j ) )
                 end do
              end do
           end if
           ! now find the max magnitude entry of each column of u or l.  also
           ! permute the magnitudes of a above so they're in the same order as
           ! the factor.
           ! the iteration orders and permutations were copied from stdlib_csytrs.
           ! calls to stdlib_sswap would be severe overkill.
           if ( upper ) then
              k = n
              do while ( k < ncols .and. k>0 )
                 if ( ipiv( k )>0 ) then
                    ! 1x1 pivot
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    do i = 1, k
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                    end do
                    k = k - 1
                 else
                    ! 2x2 pivot
                    kp = -ipiv( k )
                    tmp = work( n+k-1 )
                    work( n+k-1 ) = work( n+kp )
                    work( n+kp ) = tmp
                    do i = 1, k-1
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                       work( k-1 ) =max( cabs1( af( i, k-1 ) ), work( k-1 ) )
                    end do
                    work( k ) = max( cabs1( af( k, k ) ), work( k ) )
                    k = k - 2
                 end if
              end do
              k = ncols
              do while ( k <= n )
                 if ( ipiv( k )>0 ) then
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    k = k + 1
                 else
                    kp = -ipiv( k )
                    tmp = work( n+k )
                    work( n+k ) = work( n+kp )
                    work( n+kp ) = tmp
                    k = k + 2
                 end if
              end do
           else
              k = 1
              do while ( k <= ncols )
                 if ( ipiv( k )>0 ) then
                    ! 1x1 pivot
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    do i = k, n
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                    end do
                    k = k + 1
                 else
                    ! 2x2 pivot
                    kp = -ipiv( k )
                    tmp = work( n+k+1 )
                    work( n+k+1 ) = work( n+kp )
                    work( n+kp ) = tmp
                    do i = k+1, n
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                       work( k+1 ) =max( cabs1( af( i, k+1 ) ), work( k+1 ) )
                    end do
                    work( k ) = max( cabs1( af( k, k ) ), work( k ) )
                    k = k + 2
                 end if
              end do
              k = ncols
              do while ( k >= 1 )
                 if ( ipiv( k )>0 ) then
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    k = k - 1
                 else
                    kp = -ipiv( k )
                    tmp = work( n+k )
                    work( n+k ) = work( n+kp )
                    work( n+kp ) = tmp
                    k = k - 2
                 endif
              end do
           end if
           ! compute the *inverse* of the max element growth factor.  dividing
           ! by zero would imply the largest entry of the factor's column is
           ! zero.  than can happen when either the column of a is zero or
           ! massive pivots made the factor underflow to zero.  neither counts
           ! as growth in itself, so simply ignore terms with zero
           ! denominators.
           if ( upper ) then
              do i = ncols, n
                 umax = work( i )
                 amax = work( n+i )
                 if ( umax /= 0.0_sp ) then
                    rpvgrw = min( amax / umax, rpvgrw )
                 end if
              end do
           else
              do i = 1, ncols
                 umax = work( i )
                 amax = work( n+i )
                 if ( umax /= 0.0_sp ) then
                    rpvgrw = min( amax / umax, rpvgrw )
                 end if
              end do
           end if
           stdlib_cla_syrpvgrw = rpvgrw
     end function stdlib_cla_syrpvgrw


     pure subroutine stdlib_clabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
     !! CLABRD reduces the first NB rows and columns of a complex general
     !! m by n matrix A to upper or lower real bidiagonal form by a unitary
     !! transformation Q**H * A * P, and returns the matrices X and Y which
     !! are needed to apply the transformation to the unreduced part of A.
     !! If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
     !! bidiagonal form.
     !! This is an auxiliary routine called by CGEBRD
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: lda, ldx, ldy, m, n, nb
           ! Array Arguments 
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: taup(*), tauq(*), x(ldx,*), y(ldy,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(sp) :: alpha
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           ! quick return if possible
           if( m<=0 .or. n<=0 )return
           if( m>=n ) then
              ! reduce to upper bidiagonal form
              loop_10: do i = 1, nb
                 ! update a(i:m,i)
                 call stdlib_clacgv( i-1, y( i, 1 ), ldy )
                 call stdlib_cgemv( 'NO TRANSPOSE', m-i+1, i-1, -cone, a( i, 1 ),lda, y( i, 1 ), &
                           ldy, cone, a( i, i ), 1 )
                 call stdlib_clacgv( i-1, y( i, 1 ), ldy )
                 call stdlib_cgemv( 'NO TRANSPOSE', m-i+1, i-1, -cone, x( i, 1 ),ldx, a( 1, i ), &
                           1, cone, a( i, i ), 1 )
                 ! generate reflection q(i) to annihilate a(i+1:m,i)
                 alpha = a( i, i )
                 call stdlib_clarfg( m-i+1, alpha, a( min( i+1, m ), i ), 1,tauq( i ) )
                 d( i ) = real( alpha,KIND=sp)
                 if( i<n ) then
                    a( i, i ) = cone
                    ! compute y(i+1:n,i)
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', m-i+1, n-i, cone,a( i, i+1 ), lda, &
                              a( i, i ), 1, czero,y( i+1, i ), 1 )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', m-i+1, i-1, cone,a( i, 1 ), lda, a( &
                              i, i ), 1, czero,y( 1, i ), 1 )
                    call stdlib_cgemv( 'NO TRANSPOSE', n-i, i-1, -cone, y( i+1, 1 ),ldy, y( 1, i )&
                              , 1, cone, y( i+1, i ), 1 )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', m-i+1, i-1, cone,x( i, 1 ), ldx, a( &
                              i, i ), 1, czero,y( 1, i ), 1 )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', i-1, n-i, -cone,a( 1, i+1 ), lda, y(&
                               1, i ), 1, cone,y( i+1, i ), 1 )
                    call stdlib_cscal( n-i, tauq( i ), y( i+1, i ), 1 )
                    ! update a(i,i+1:n)
                    call stdlib_clacgv( n-i, a( i, i+1 ), lda )
                    call stdlib_clacgv( i, a( i, 1 ), lda )
                    call stdlib_cgemv( 'NO TRANSPOSE', n-i, i, -cone, y( i+1, 1 ),ldy, a( i, 1 ), &
                              lda, cone, a( i, i+1 ), lda )
                    call stdlib_clacgv( i, a( i, 1 ), lda )
                    call stdlib_clacgv( i-1, x( i, 1 ), ldx )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', i-1, n-i, -cone,a( 1, i+1 ), lda, x(&
                               i, 1 ), ldx, cone,a( i, i+1 ), lda )
                    call stdlib_clacgv( i-1, x( i, 1 ), ldx )
                    ! generate reflection p(i) to annihilate a(i,i+2:n)
                    alpha = a( i, i+1 )
                    call stdlib_clarfg( n-i, alpha, a( i, min( i+2, n ) ),lda, taup( i ) )
                    e( i ) = real( alpha,KIND=sp)
                    a( i, i+1 ) = cone
                    ! compute x(i+1:m,i)
                    call stdlib_cgemv( 'NO TRANSPOSE', m-i, n-i, cone, a( i+1, i+1 ),lda, a( i, i+&
                              1 ), lda, czero, x( i+1, i ), 1 )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-i, i, cone,y( i+1, 1 ), ldy, a( i,&
                               i+1 ), lda, czero,x( 1, i ), 1 )
                    call stdlib_cgemv( 'NO TRANSPOSE', m-i, i, -cone, a( i+1, 1 ),lda, x( 1, i ), &
                              1, cone, x( i+1, i ), 1 )
                    call stdlib_cgemv( 'NO TRANSPOSE', i-1, n-i, cone, a( 1, i+1 ),lda, a( i, i+1 &
                              ), lda, czero, x( 1, i ), 1 )
                    call stdlib_cgemv( 'NO TRANSPOSE', m-i, i-1, -cone, x( i+1, 1 ),ldx, x( 1, i )&
                              , 1, cone, x( i+1, i ), 1 )
                    call stdlib_cscal( m-i, taup( i ), x( i+1, i ), 1 )
                    call stdlib_clacgv( n-i, a( i, i+1 ), lda )
                 end if
              end do loop_10
           else
              ! reduce to lower bidiagonal form
              loop_20: do i = 1, nb
                 ! update a(i,i:n)
                 call stdlib_clacgv( n-i+1, a( i, i ), lda )
                 call stdlib_clacgv( i-1, a( i, 1 ), lda )
                 call stdlib_cgemv( 'NO TRANSPOSE', n-i+1, i-1, -cone, y( i, 1 ),ldy, a( i, 1 ), &
                           lda, cone, a( i, i ), lda )
                 call stdlib_clacgv( i-1, a( i, 1 ), lda )
                 call stdlib_clacgv( i-1, x( i, 1 ), ldx )
                 call stdlib_cgemv( 'CONJUGATE TRANSPOSE', i-1, n-i+1, -cone,a( 1, i ), lda, x( i,&
                            1 ), ldx, cone, a( i, i ),lda )
                 call stdlib_clacgv( i-1, x( i, 1 ), ldx )
                 ! generate reflection p(i) to annihilate a(i,i+1:n)
                 alpha = a( i, i )
                 call stdlib_clarfg( n-i+1, alpha, a( i, min( i+1, n ) ), lda,taup( i ) )
                 d( i ) = real( alpha,KIND=sp)
                 if( i<m ) then
                    a( i, i ) = cone
                    ! compute x(i+1:m,i)
                    call stdlib_cgemv( 'NO TRANSPOSE', m-i, n-i+1, cone, a( i+1, i ),lda, a( i, i &
                              ), lda, czero, x( i+1, i ), 1 )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-i+1, i-1, cone,y( i, 1 ), ldy, a( &
                              i, i ), lda, czero,x( 1, i ), 1 )
                    call stdlib_cgemv( 'NO TRANSPOSE', m-i, i-1, -cone, a( i+1, 1 ),lda, x( 1, i )&
                              , 1, cone, x( i+1, i ), 1 )
                    call stdlib_cgemv( 'NO TRANSPOSE', i-1, n-i+1, cone, a( 1, i ),lda, a( i, i ),&
                               lda, czero, x( 1, i ), 1 )
                    call stdlib_cgemv( 'NO TRANSPOSE', m-i, i-1, -cone, x( i+1, 1 ),ldx, x( 1, i )&
                              , 1, cone, x( i+1, i ), 1 )
                    call stdlib_cscal( m-i, taup( i ), x( i+1, i ), 1 )
                    call stdlib_clacgv( n-i+1, a( i, i ), lda )
                    ! update a(i+1:m,i)
                    call stdlib_clacgv( i-1, y( i, 1 ), ldy )
                    call stdlib_cgemv( 'NO TRANSPOSE', m-i, i-1, -cone, a( i+1, 1 ),lda, y( i, 1 )&
                              , ldy, cone, a( i+1, i ), 1 )
                    call stdlib_clacgv( i-1, y( i, 1 ), ldy )
                    call stdlib_cgemv( 'NO TRANSPOSE', m-i, i, -cone, x( i+1, 1 ),ldx, a( 1, i ), &
                              1, cone, a( i+1, i ), 1 )
                    ! generate reflection q(i) to annihilate a(i+2:m,i)
                    alpha = a( i+1, i )
                    call stdlib_clarfg( m-i, alpha, a( min( i+2, m ), i ), 1,tauq( i ) )
                    e( i ) = real( alpha,KIND=sp)
                    a( i+1, i ) = cone
                    ! compute y(i+1:n,i)
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', m-i, n-i, cone,a( i+1, i+1 ), lda, &
                              a( i+1, i ), 1, czero,y( i+1, i ), 1 )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', m-i, i-1, cone,a( i+1, 1 ), lda, a( &
                              i+1, i ), 1, czero,y( 1, i ), 1 )
                    call stdlib_cgemv( 'NO TRANSPOSE', n-i, i-1, -cone, y( i+1, 1 ),ldy, y( 1, i )&
                              , 1, cone, y( i+1, i ), 1 )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', m-i, i, cone,x( i+1, 1 ), ldx, a( i+&
                              1, i ), 1, czero,y( 1, i ), 1 )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', i, n-i, -cone,a( 1, i+1 ), lda, y( &
                              1, i ), 1, cone,y( i+1, i ), 1 )
                    call stdlib_cscal( n-i, tauq( i ), y( i+1, i ), 1 )
                 else
                    call stdlib_clacgv( n-i+1, a( i, i ), lda )
                 end if
              end do loop_20
           end if
           return
     end subroutine stdlib_clabrd


     pure subroutine stdlib_claed7( n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q,ldq, rho, indxq, &
     !! CLAED7 computes the updated eigensystem of a diagonal
     !! matrix after modification by a rank-one symmetric matrix. This
     !! routine is used only for the eigenproblem which requires all
     !! eigenvalues and optionally eigenvectors of a dense or banded
     !! Hermitian matrix that has been reduced to tridiagonal form.
     !! T = Q(in) ( D(in) + RHO * Z*Z**H ) Q**H(in) = Q(out) * D(out) * Q**H(out)
     !! where Z = Q**Hu, u is a vector of length N with ones in the
     !! CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
     !! The eigenvectors of the original matrix are stored in Q, and the
     !! eigenvalues are in D.  The algorithm consists of three stages:
     !! The first stage consists of deflating the size of the problem
     !! when there are multiple eigenvalues or if there is a zero in
     !! the Z vector.  For each such occurrence the dimension of the
     !! secular equation problem is reduced by one.  This stage is
     !! performed by the routine SLAED2.
     !! The second stage consists of calculating the updated
     !! eigenvalues. This is done by finding the roots of the secular
     !! equation via the routine SLAED4 (as called by SLAED3).
     !! This routine also calculates the eigenvectors of the current
     !! problem.
     !! The final stage consists of computing the updated eigenvectors
     !! directly using the updated eigenvalues.  The eigenvectors for
     !! the current problem are multiplied with the eigenvectors from
     !! the overall problem.
               qstore, qptr, prmptr, perm,givptr, givcol, givnum, work, rwork, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: curlvl, curpbm, cutpnt, ldq, n, qsiz, tlvls
           integer(ilp), intent(out) :: info
           real(sp), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(inout) :: givcol(2,*), givptr(*), perm(*), prmptr(*), qptr(*)
                     
           integer(ilp), intent(out) :: indxq(*), iwork(*)
           real(sp), intent(inout) :: d(*), givnum(2,*), qstore(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: q(ldq,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: coltyp, curr, i, idlmda, indx, indxc, indxp, iq, iw, iz, k, n1, n2, &
                     ptr
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           ! if( icompq<0 .or. icompq>1 ) then
              ! info = -1
           ! else if( n<0 ) then
           if( n<0 ) then
              info = -1
           else if( min( 1, n )>cutpnt .or. n<cutpnt ) then
              info = -2
           else if( qsiz<n ) then
              info = -3
           else if( ldq<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAED7', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! the following values are for bookkeeping purposes only.  they are
           ! integer pointers which indicate the portion of the workspace
           ! used by a particular array in stdlib_slaed2 and stdlib_slaed3.
           iz = 1
           idlmda = iz + n
           iw = idlmda + n
           iq = iw + n
           indx = 1
           indxc = indx + n
           coltyp = indxc + n
           indxp = coltyp + n
           ! form the z-vector which consists of the last row of q_1 and the
           ! first row of q_2.
           ptr = 1 + 2**tlvls
           do i = 1, curlvl - 1
              ptr = ptr + 2**( tlvls-i )
           end do
           curr = ptr + curpbm
           call stdlib_slaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, givnum, &
                     qstore, qptr, rwork( iz ),rwork( iz+n ), info )
           ! when solving the final problem, we no longer need the stored data,
           ! so we will overwrite the data from this level onto the previously
           ! used storage space.
           if( curlvl==tlvls ) then
              qptr( curr ) = 1
              prmptr( curr ) = 1
              givptr( curr ) = 1
           end if
           ! sort and deflate eigenvalues.
           call stdlib_claed8( k, n, qsiz, q, ldq, d, rho, cutpnt, rwork( iz ),rwork( idlmda ), &
           work, qsiz, rwork( iw ),iwork( indxp ), iwork( indx ), indxq,perm( prmptr( curr ) ), &
           givptr( curr+1 ),givcol( 1, givptr( curr ) ),givnum( 1, givptr( curr ) ), info )
                     
           prmptr( curr+1 ) = prmptr( curr ) + n
           givptr( curr+1 ) = givptr( curr+1 ) + givptr( curr )
           ! solve secular equation.
           if( k/=0 ) then
              call stdlib_slaed9( k, 1, k, n, d, rwork( iq ), k, rho,rwork( idlmda ), rwork( iw ),&
                        qstore( qptr( curr ) ), k, info )
              call stdlib_clacrm( qsiz, k, work, qsiz, qstore( qptr( curr ) ), k, q,ldq, rwork( &
                        iq ) )
              qptr( curr+1 ) = qptr( curr ) + k**2
              if( info/=0 ) then
                 return
              end if
           ! prepare the indxq sorting premutation.
              n1 = k
              n2 = n - k
              call stdlib_slamrg( n1, n2, d, 1, -1, indxq )
           else
              qptr( curr+1 ) = qptr( curr )
              do i = 1, n
                 indxq( i ) = i
              end do
           end if
           return
     end subroutine stdlib_claed7


     pure subroutine stdlib_claein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,eps3, smlnum, &
     !! CLAEIN uses inverse iteration to find a right or left eigenvector
     !! corresponding to the eigenvalue W of a complex upper Hessenberg
     !! matrix H.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: noinit, rightv
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldh, n
           real(sp), intent(in) :: eps3, smlnum
           complex(sp), intent(in) :: w
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(out) :: b(ldb,*)
           complex(sp), intent(in) :: h(ldh,*)
           complex(sp), intent(inout) :: v(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: tenth = 1.0e-1_sp
           
           
           ! Local Scalars 
           character :: normin, trans
           integer(ilp) :: i, ierr, its, j
           real(sp) :: growto, nrmsml, rootn, rtemp, scale, vnorm
           complex(sp) :: cdum, ei, ej, temp, x
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real,sqrt
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! growto is the threshold used in the acceptance test for an
           ! eigenvector.
           rootn = sqrt( real( n,KIND=sp) )
           growto = tenth / rootn
           nrmsml = max( one, eps3*rootn )*smlnum
           ! form b = h - w*i (except that the subdiagonal elements are not
           ! stored).
           do j = 1, n
              do i = 1, j - 1
                 b( i, j ) = h( i, j )
              end do
              b( j, j ) = h( j, j ) - w
           end do
           if( noinit ) then
              ! initialize v.
              do i = 1, n
                 v( i ) = eps3
              end do
           else
              ! scale supplied initial vector.
              vnorm = stdlib_scnrm2( n, v, 1 )
              call stdlib_csscal( n, ( eps3*rootn ) / max( vnorm, nrmsml ), v, 1 )
           end if
           if( rightv ) then
              ! lu decomposition with partial pivoting of b, replacing czero
              ! pivots by eps3.
              do i = 1, n - 1
                 ei = h( i+1, i )
                 if( cabs1( b( i, i ) )<cabs1( ei ) ) then
                    ! interchange rows and eliminate.
                    x = stdlib_cladiv( b( i, i ), ei )
                    b( i, i ) = ei
                    do j = i + 1, n
                       temp = b( i+1, j )
                       b( i+1, j ) = b( i, j ) - x*temp
                       b( i, j ) = temp
                    end do
                 else
                    ! eliminate without interchange.
                    if( b( i, i )==czero )b( i, i ) = eps3
                    x = stdlib_cladiv( ei, b( i, i ) )
                    if( x/=czero ) then
                       do j = i + 1, n
                          b( i+1, j ) = b( i+1, j ) - x*b( i, j )
                       end do
                    end if
                 end if
              end do
              if( b( n, n )==czero )b( n, n ) = eps3
              trans = 'N'
           else
              ! ul decomposition with partial pivoting of b, replacing czero
              ! pivots by eps3.
              do j = n, 2, -1
                 ej = h( j, j-1 )
                 if( cabs1( b( j, j ) )<cabs1( ej ) ) then
                    ! interchange columns and eliminate.
                    x = stdlib_cladiv( b( j, j ), ej )
                    b( j, j ) = ej
                    do i = 1, j - 1
                       temp = b( i, j-1 )
                       b( i, j-1 ) = b( i, j ) - x*temp
                       b( i, j ) = temp
                    end do
                 else
                    ! eliminate without interchange.
                    if( b( j, j )==czero )b( j, j ) = eps3
                    x = stdlib_cladiv( ej, b( j, j ) )
                    if( x/=czero ) then
                       do i = 1, j - 1
                          b( i, j-1 ) = b( i, j-1 ) - x*b( i, j )
                       end do
                    end if
                 end if
              end do
              if( b( 1, 1 )==czero )b( 1, 1 ) = eps3
              trans = 'C'
           end if
           normin = 'N'
           do its = 1, n
              ! solve u*x = scale*v for a right eigenvector
                ! or u**h *x = scale*v for a left eigenvector,
              ! overwriting x on v.
              call stdlib_clatrs( 'UPPER', trans, 'NONUNIT', normin, n, b, ldb, v,scale, rwork, &
                        ierr )
              normin = 'Y'
              ! test for sufficient growth in the norm of v.
              vnorm = stdlib_scasum( n, v, 1 )
              if( vnorm>=growto*scale )go to 120
              ! choose new orthogonal starting vector and try again.
              rtemp = eps3 / ( rootn+one )
              v( 1 ) = eps3
              do i = 2, n
                 v( i ) = rtemp
              end do
              v( n-its+1 ) = v( n-its+1 ) - eps3*rootn
           end do
           ! failure to find eigenvector in n iterations.
           info = 1
           120 continue
           ! normalize eigenvector.
           i = stdlib_icamax( n, v, 1 )
           call stdlib_csscal( n, one / cabs1( v( i ) ), v, 1 )
           return
     end subroutine stdlib_claein


     pure subroutine stdlib_clags2( upper, a1, a2, a3, b1, b2, b3, csu, snu, csv,snv, csq, snq )
     !! CLAGS2 computes 2-by-2 unitary matrices U, V and Q, such
     !! that if ( UPPER ) then
     !! U**H *A*Q = U**H *( A1 A2 )*Q = ( x  0  )
     !! ( 0  A3 )     ( x  x  )
     !! and
     !! V**H*B*Q = V**H *( B1 B2 )*Q = ( x  0  )
     !! ( 0  B3 )     ( x  x  )
     !! or if ( .NOT.UPPER ) then
     !! U**H *A*Q = U**H *( A1 0  )*Q = ( x  x  )
     !! ( A2 A3 )     ( 0  x  )
     !! and
     !! V**H *B*Q = V**H *( B1 0  )*Q = ( x  x  )
     !! ( B2 B3 )     ( 0  x  )
     !! where
     !! U = (   CSU    SNU ), V = (  CSV    SNV ),
     !! ( -SNU**H  CSU )      ( -SNV**H CSV )
     !! Q = (   CSQ    SNQ )
     !! ( -SNQ**H  CSQ )
     !! The rows of the transformed A and B are parallel. Moreover, if the
     !! input 2-by-2 matrix A is not zero, then the transformed (1,1) entry
     !! of A is not zero. If the input matrices A and B are both not zero,
     !! then the transformed (2,2) element of B is not zero, except when the
     !! first rows of input A and B are parallel and the second rows are
     !! zero.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: upper
           real(sp), intent(in) :: a1, a3, b1, b3
           real(sp), intent(out) :: csq, csu, csv
           complex(sp), intent(in) :: a2, b2
           complex(sp), intent(out) :: snq, snu, snv
        ! =====================================================================
           
           ! Local Scalars 
           real(sp) :: a, aua11, aua12, aua21, aua22, avb11, avb12, avb21, avb22, csl, csr, d, fb,&
                      fc, s1, s2, snl, snr, ua11r, ua22r, vb11r, vb22r
           complex(sp) :: b, c, d1, r, t, ua11, ua12, ua21, ua22, vb11, vb12, vb21, vb22
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,conjg,real
           ! Statement Functions 
           real(sp) :: abs1
           ! Statement Function Definitions 
           abs1( t ) = abs( real( t,KIND=sp) ) + abs( aimag( t ) )
           ! Executable Statements 
           if( upper ) then
              ! input matrices a and b are upper triangular matrices
              ! form matrix c = a*adj(b) = ( a b )
                                         ! ( 0 d )
              a = a1*b3
              d = a3*b1
              b = a2*b1 - a1*b2
              fb = abs( b )
              ! transform complex 2-by-2 matrix c to real matrix by unitary
              ! diagonal matrix diag(1,d1).
              d1 = one
              if( fb/=zero )d1 = b / fb
              ! the svd of real 2 by 2 triangular c
               ! ( csl -snl )*( a b )*(  csr  snr ) = ( r 0 )
               ! ( snl  csl ) ( 0 d ) ( -snr  csr )   ( 0 t )
              call stdlib_slasv2( a, fb, d, s1, s2, snr, csr, snl, csl )
              if( abs( csl )>=abs( snl ) .or. abs( csr )>=abs( snr ) )then
                 ! compute the (1,1) and (1,2) elements of u**h *a and v**h *b,
                 ! and (1,2) element of |u|**h *|a| and |v|**h *|b|.
                 ua11r = csl*a1
                 ua12 = csl*a2 + d1*snl*a3
                 vb11r = csr*b1
                 vb12 = csr*b2 + d1*snr*b3
                 aua12 = abs( csl )*abs1( a2 ) + abs( snl )*abs( a3 )
                 avb12 = abs( csr )*abs1( b2 ) + abs( snr )*abs( b3 )
                 ! zero (1,2) elements of u**h *a and v**h *b
                 if( ( abs( ua11r )+abs1( ua12 ) )==zero ) then
                    call stdlib_clartg( -cmplx( vb11r,KIND=sp), conjg( vb12 ), csq, snq,r )
                              
                 else if( ( abs( vb11r )+abs1( vb12 ) )==zero ) then
                    call stdlib_clartg( -cmplx( ua11r,KIND=sp), conjg( ua12 ), csq, snq,r )
                              
                 else if( aua12 / ( abs( ua11r )+abs1( ua12 ) )<=avb12 /( abs( vb11r )+abs1( vb12 &
                           ) ) ) then
                    call stdlib_clartg( -cmplx( ua11r,KIND=sp), conjg( ua12 ), csq, snq,r )
                              
                 else
                    call stdlib_clartg( -cmplx( vb11r,KIND=sp), conjg( vb12 ), csq, snq,r )
                              
                 end if
                 csu = csl
                 snu = -d1*snl
                 csv = csr
                 snv = -d1*snr
              else
                 ! compute the (2,1) and (2,2) elements of u**h *a and v**h *b,
                 ! and (2,2) element of |u|**h *|a| and |v|**h *|b|.
                 ua21 = -conjg( d1 )*snl*a1
                 ua22 = -conjg( d1 )*snl*a2 + csl*a3
                 vb21 = -conjg( d1 )*snr*b1
                 vb22 = -conjg( d1 )*snr*b2 + csr*b3
                 aua22 = abs( snl )*abs1( a2 ) + abs( csl )*abs( a3 )
                 avb22 = abs( snr )*abs1( b2 ) + abs( csr )*abs( b3 )
                 ! zero (2,2) elements of u**h *a and v**h *b, and then swap.
                 if( ( abs1( ua21 )+abs1( ua22 ) )==zero ) then
                    call stdlib_clartg( -conjg( vb21 ), conjg( vb22 ), csq, snq, r )
                 else if( ( abs1( vb21 )+abs( vb22 ) )==zero ) then
                    call stdlib_clartg( -conjg( ua21 ), conjg( ua22 ), csq, snq, r )
                 else if( aua22 / ( abs1( ua21 )+abs1( ua22 ) )<=avb22 /( abs1( vb21 )+abs1( vb22 &
                           ) ) ) then
                    call stdlib_clartg( -conjg( ua21 ), conjg( ua22 ), csq, snq, r )
                 else
                    call stdlib_clartg( -conjg( vb21 ), conjg( vb22 ), csq, snq, r )
                 end if
                 csu = snl
                 snu = d1*csl
                 csv = snr
                 snv = d1*csr
              end if
           else
              ! input matrices a and b are lower triangular matrices
              ! form matrix c = a*adj(b) = ( a 0 )
                                         ! ( c d )
              a = a1*b3
              d = a3*b1
              c = a2*b3 - a3*b2
              fc = abs( c )
              ! transform complex 2-by-2 matrix c to real matrix by unitary
              ! diagonal matrix diag(d1,1).
              d1 = one
              if( fc/=zero )d1 = c / fc
              ! the svd of real 2 by 2 triangular c
               ! ( csl -snl )*( a 0 )*(  csr  snr ) = ( r 0 )
               ! ( snl  csl ) ( c d ) ( -snr  csr )   ( 0 t )
              call stdlib_slasv2( a, fc, d, s1, s2, snr, csr, snl, csl )
              if( abs( csr )>=abs( snr ) .or. abs( csl )>=abs( snl ) )then
                 ! compute the (2,1) and (2,2) elements of u**h *a and v**h *b,
                 ! and (2,1) element of |u|**h *|a| and |v|**h *|b|.
                 ua21 = -d1*snr*a1 + csr*a2
                 ua22r = csr*a3
                 vb21 = -d1*snl*b1 + csl*b2
                 vb22r = csl*b3
                 aua21 = abs( snr )*abs( a1 ) + abs( csr )*abs1( a2 )
                 avb21 = abs( snl )*abs( b1 ) + abs( csl )*abs1( b2 )
                 ! zero (2,1) elements of u**h *a and v**h *b.
                 if( ( abs1( ua21 )+abs( ua22r ) )==zero ) then
                    call stdlib_clartg( cmplx( vb22r,KIND=sp), vb21, csq, snq, r )
                 else if( ( abs1( vb21 )+abs( vb22r ) )==zero ) then
                    call stdlib_clartg( cmplx( ua22r,KIND=sp), ua21, csq, snq, r )
                 else if( aua21 / ( abs1( ua21 )+abs( ua22r ) )<=avb21 /( abs1( vb21 )+abs( vb22r &
                           ) ) ) then
                    call stdlib_clartg( cmplx( ua22r,KIND=sp), ua21, csq, snq, r )
                 else
                    call stdlib_clartg( cmplx( vb22r,KIND=sp), vb21, csq, snq, r )
                 end if
                 csu = csr
                 snu = -conjg( d1 )*snr
                 csv = csl
                 snv = -conjg( d1 )*snl
              else
                 ! compute the (1,1) and (1,2) elements of u**h *a and v**h *b,
                 ! and (1,1) element of |u|**h *|a| and |v|**h *|b|.
                 ua11 = csr*a1 + conjg( d1 )*snr*a2
                 ua12 = conjg( d1 )*snr*a3
                 vb11 = csl*b1 + conjg( d1 )*snl*b2
                 vb12 = conjg( d1 )*snl*b3
                 aua11 = abs( csr )*abs( a1 ) + abs( snr )*abs1( a2 )
                 avb11 = abs( csl )*abs( b1 ) + abs( snl )*abs1( b2 )
                 ! zero (1,1) elements of u**h *a and v**h *b, and then swap.
                 if( ( abs1( ua11 )+abs1( ua12 ) )==zero ) then
                    call stdlib_clartg( vb12, vb11, csq, snq, r )
                 else if( ( abs1( vb11 )+abs1( vb12 ) )==zero ) then
                    call stdlib_clartg( ua12, ua11, csq, snq, r )
                 else if( aua11 / ( abs1( ua11 )+abs1( ua12 ) )<=avb11 /( abs1( vb11 )+abs1( vb12 &
                           ) ) ) then
                    call stdlib_clartg( ua12, ua11, csq, snq, r )
                 else
                    call stdlib_clartg( vb12, vb11, csq, snq, r )
                 end if
                 csu = snr
                 snu = conjg( d1 )*csr
                 csv = snl
                 snv = conjg( d1 )*csl
              end if
           end if
           return
     end subroutine stdlib_clags2


     pure subroutine stdlib_clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, info &
     !! CLAHQR is an auxiliary routine called by CHSEQR to update the
     !! eigenvalues and Schur decomposition already computed by CHSEQR, by
     !! dealing with the Hessenberg submatrix in rows and columns ILO to
     !! IHI.
               )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: w(*)
        ! =========================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0_sp
           real(sp), parameter :: rone = 1.0_sp
           real(sp), parameter :: dat1 = 3.0_sp/4.0_sp
           integer(ilp), parameter :: kexsh = 10
           
           
           
           
           ! Local Scalars 
           complex(sp) :: cdum, h11, h11s, h22, sc, sum, t, t1, temp, u, v2, x, y
           real(sp) :: aa, ab, ba, bb, h10, h21, rtemp, s, safmax, safmin, smlnum, sx, t2, tst, &
                     ulp
           integer(ilp) :: i, i1, i2, its, itmax, j, jhi, jlo, k, l, m, nh, nz, kdefl
           ! Local Arrays 
           complex(sp) :: v(2)
           ! Statement Functions 
           real(sp) :: cabs1
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,conjg,max,min,real,sqrt
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 )return
           if( ilo==ihi ) then
              w( ilo ) = h( ilo, ilo )
              return
           end if
           ! ==== clear out the trash ====
           do j = ilo, ihi - 3
              h( j+2, j ) = czero
              h( j+3, j ) = czero
           end do
           if( ilo<=ihi-2 )h( ihi, ihi-2 ) = czero
           ! ==== ensure that subdiagonal entries are real ====
           if( wantt ) then
              jlo = 1
              jhi = n
           else
              jlo = ilo
              jhi = ihi
           end if
           do i = ilo + 1, ihi
              if( aimag( h( i, i-1 ) )/=rzero ) then
                 ! ==== the following redundant normalization
                 ! .    avoids problems with both gradual and
                 ! .    sudden underflow in abs(h(i,i-1)) ====
                 sc = h( i, i-1 ) / cabs1( h( i, i-1 ) )
                 sc = conjg( sc ) / abs( sc )
                 h( i, i-1 ) = abs( h( i, i-1 ) )
                 call stdlib_cscal( jhi-i+1, sc, h( i, i ), ldh )
                 call stdlib_cscal( min( jhi, i+1 )-jlo+1, conjg( sc ), h( jlo, i ),1 )
                 if( wantz )call stdlib_cscal( ihiz-iloz+1, conjg( sc ), z( iloz, i ), 1 )
              end if
           end do
           nh = ihi - ilo + 1
           nz = ihiz - iloz + 1
           ! set machine-dependent constants for the stopping criterion.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( nh,KIND=sp) / ulp )
           ! i1 and i2 are the indices of the first row and last column of h
           ! to which transformations must be applied. if eigenvalues only are
           ! being computed, i1 and i2 are set inside the main loop.
           if( wantt ) then
              i1 = 1
              i2 = n
           end if
           ! itmax is the total number of qr iterations allowed.
           itmax = 30 * max( 10, nh )
           ! kdefl counts the number of iterations since a deflation
           kdefl = 0
           ! the main loop begins here. i is the loop index and decreases from
           ! ihi to ilo in steps of 1. each iteration of the loop works
           ! with the active submatrix in rows and columns l to i.
           ! eigenvalues i+1 to ihi have already converged. either l = ilo, or
           ! h(l,l-1) is negligible so that the matrix splits.
           i = ihi
           30 continue
           if( i<ilo )go to 150
           ! perform qr iterations on rows and columns ilo to i until a
           ! submatrix of order 1 splits off at the bottom because a
           ! subdiagonal element has become negligible.
           l = ilo
           loop_130: do its = 0, itmax
              ! look for a single small subdiagonal element.
              do k = i, l + 1, -1
                 if( cabs1( h( k, k-1 ) )<=smlnum )go to 50
                 tst = cabs1( h( k-1, k-1 ) ) + cabs1( h( k, k ) )
                 if( tst==czero ) then
                    if( k-2>=ilo )tst = tst + abs( real( h( k-1, k-2 ),KIND=sp) )
                    if( k+1<=ihi )tst = tst + abs( real( h( k+1, k ),KIND=sp) )
                 end if
                 ! ==== the following is a conservative small subdiagonal
                 ! .    deflation criterion due to ahues
                 ! .    1997). it has better mathematical foundation and
                 ! .    improves accuracy in some examples.  ====
                 if( abs( real( h( k, k-1 ),KIND=sp) )<=ulp*tst ) then
                    ab = max( cabs1( h( k, k-1 ) ), cabs1( h( k-1, k ) ) )
                    ba = min( cabs1( h( k, k-1 ) ), cabs1( h( k-1, k ) ) )
                    aa = max( cabs1( h( k, k ) ),cabs1( h( k-1, k-1 )-h( k, k ) ) )
                    bb = min( cabs1( h( k, k ) ),cabs1( h( k-1, k-1 )-h( k, k ) ) )
                    s = aa + ab
                    if( ba*( ab / s )<=max( smlnum,ulp*( bb*( aa / s ) ) ) )go to 50
                 end if
              end do
              50 continue
              l = k
              if( l>ilo ) then
                 ! h(l,l-1) is negligible
                 h( l, l-1 ) = czero
              end if
              ! exit from loop if a submatrix of order 1 has split off.
              if( l>=i )go to 140
              kdefl = kdefl + 1
              ! now the active submatrix is in rows and columns l to i. if
              ! eigenvalues only are being computed, only the active submatrix
              ! need be transformed.
              if( .not.wantt ) then
                 i1 = l
                 i2 = i
              end if
              if( mod(kdefl,2*kexsh)==0 ) then
                 ! exceptional shift.
                 s = dat1*abs( real( h( i, i-1 ),KIND=sp) )
                 t = s + h( i, i )
              else if( mod(kdefl,kexsh)==0 ) then
                 ! exceptional shift.
                 s = dat1*abs( real( h( l+1, l ),KIND=sp) )
                 t = s + h( l, l )
              else
                 ! wilkinson's shift.
                 t = h( i, i )
                 u = sqrt( h( i-1, i ) )*sqrt( h( i, i-1 ) )
                 s = cabs1( u )
                 if( s/=rzero ) then
                    x = half*( h( i-1, i-1 )-t )
                    sx = cabs1( x )
                    s = max( s, cabs1( x ) )
                    y = s*sqrt( ( x / s )**2+( u / s )**2 )
                    if( sx>rzero ) then
                       if( real( x / sx,KIND=sp)*real( y,KIND=sp)+aimag( x / sx )*aimag( y )&
                                 <rzero )y = -y
                    end if
                    t = t - u*stdlib_cladiv( u, ( x+y ) )
                 end if
              end if
              ! look for two consecutive small subdiagonal elements.
              do m = i - 1, l + 1, -1
                 ! determine the effect of starting the single-shift qr
                 ! iteration at row m, and see if this would make h(m,m-1)
                 ! negligible.
                 h11 = h( m, m )
                 h22 = h( m+1, m+1 )
                 h11s = h11 - t
                 h21 = real( h( m+1, m ),KIND=sp)
                 s = cabs1( h11s ) + abs( h21 )
                 h11s = h11s / s
                 h21 = h21 / s
                 v( 1 ) = h11s
                 v( 2 ) = h21
                 h10 = real( h( m, m-1 ),KIND=sp)
                 if( abs( h10 )*abs( h21 )<=ulp*( cabs1( h11s )*( cabs1( h11 )+cabs1( h22 ) ) ) )&
                           go to 70
              end do
              h11 = h( l, l )
              h22 = h( l+1, l+1 )
              h11s = h11 - t
              h21 = real( h( l+1, l ),KIND=sp)
              s = cabs1( h11s ) + abs( h21 )
              h11s = h11s / s
              h21 = h21 / s
              v( 1 ) = h11s
              v( 2 ) = h21
              70 continue
              ! single-shift qr step
              loop_120: do k = m, i - 1
                 ! the first iteration of this loop determines a reflection g
                 ! from the vector v and applies it from left and right to h,
                 ! thus creating a nonzero bulge below the subdiagonal.
                 ! each subsequent iteration determines a reflection g to
                 ! restore the hessenberg form in the (k-1)th column, and thus
                 ! chases the bulge cone step toward the bottom of the active
                 ! submatrix.
                 ! v(2) is always real before the call to stdlib_clarfg, and hence
                 ! after the call t2 ( = t1*v(2) ) is also real.
                 if( k>m )call stdlib_ccopy( 2, h( k, k-1 ), 1, v, 1 )
                 call stdlib_clarfg( 2, v( 1 ), v( 2 ), 1, t1 )
                 if( k>m ) then
                    h( k, k-1 ) = v( 1 )
                    h( k+1, k-1 ) = czero
                 end if
                 v2 = v( 2 )
                 t2 = real( t1*v2,KIND=sp)
                 ! apply g from the left to transform the rows of the matrix
                 ! in columns k to i2.
                 do j = k, i2
                    sum = conjg( t1 )*h( k, j ) + t2*h( k+1, j )
                    h( k, j ) = h( k, j ) - sum
                    h( k+1, j ) = h( k+1, j ) - sum*v2
                 end do
                 ! apply g from the right to transform the columns of the
                 ! matrix in rows i1 to min(k+2,i).
                 do j = i1, min( k+2, i )
                    sum = t1*h( j, k ) + t2*h( j, k+1 )
                    h( j, k ) = h( j, k ) - sum
                    h( j, k+1 ) = h( j, k+1 ) - sum*conjg( v2 )
                 end do
                 if( wantz ) then
                    ! accumulate transformations in the matrix z
                    do j = iloz, ihiz
                       sum = t1*z( j, k ) + t2*z( j, k+1 )
                       z( j, k ) = z( j, k ) - sum
                       z( j, k+1 ) = z( j, k+1 ) - sum*conjg( v2 )
                    end do
                 end if
                 if( k==m .and. m>l ) then
                    ! if the qr step was started at row m > l because two
                    ! consecutive small subdiagonals were found, then extra
                    ! scaling must be performed to ensure that h(m,m-1) remains
                    ! real.
                    temp = cone - t1
                    temp = temp / abs( temp )
                    h( m+1, m ) = h( m+1, m )*conjg( temp )
                    if( m+2<=i )h( m+2, m+1 ) = h( m+2, m+1 )*temp
                    do j = m, i
                       if( j/=m+1 ) then
                          if( i2>j )call stdlib_cscal( i2-j, temp, h( j, j+1 ), ldh )
                          call stdlib_cscal( j-i1, conjg( temp ), h( i1, j ), 1 )
                          if( wantz ) then
                             call stdlib_cscal( nz, conjg( temp ), z( iloz, j ), 1 )
                          end if
                       end if
                    end do
                 end if
              end do loop_120
              ! ensure that h(i,i-1) is real.
              temp = h( i, i-1 )
              if( aimag( temp )/=rzero ) then
                 rtemp = abs( temp )
                 h( i, i-1 ) = rtemp
                 temp = temp / rtemp
                 if( i2>i )call stdlib_cscal( i2-i, conjg( temp ), h( i, i+1 ), ldh )
                 call stdlib_cscal( i-i1, temp, h( i1, i ), 1 )
                 if( wantz ) then
                    call stdlib_cscal( nz, temp, z( iloz, i ), 1 )
                 end if
              end if
           end do loop_130
           ! failure to converge in remaining number of iterations
           info = i
           return
           140 continue
           ! h(i,i-1) is negligible: cone eigenvalue has converged.
           w( i ) = h( i, i )
           ! reset deflation counter
           kdefl = 0
           ! return to start of the main loop with new value of i.
           i = l - 1
           go to 30
           150 continue
           return
     end subroutine stdlib_clahqr


     pure subroutine stdlib_clahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
     !! CLAHR2 reduces the first NB columns of A complex general n-BY-(n-k+1)
     !! matrix A so that elements below the k-th subdiagonal are zero. The
     !! reduction is performed by an unitary similarity transformation
     !! Q**H * A * Q. The routine returns the matrices V and T which determine
     !! Q as a block reflector I - V*T*v**H, and also the matrix Y = A * V * T.
     !! This is an auxiliary routine called by CGEHRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: k, lda, ldt, ldy, n, nb
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(sp) :: ei
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 )return
           loop_10: do i = 1, nb
              if( i>1 ) then
                 ! update a(k+1:n,i)
                 ! update i-th column of a - y * v**h
                 call stdlib_clacgv( i-1, a( k+i-1, 1 ), lda )
                 call stdlib_cgemv( 'NO TRANSPOSE', n-k, i-1, -cone, y(k+1,1), ldy,a( k+i-1, 1 ), &
                           lda, cone, a( k+1, i ), 1 )
                 call stdlib_clacgv( i-1, a( k+i-1, 1 ), lda )
                 ! apply i - v * t**h * v**h to this column (call it b) from the
                 ! left, using the last column of t as workspace
                 ! let  v = ( v1 )   and   b = ( b1 )   (first i-1 rows)
                          ! ( v2 )             ( b2 )
                 ! where v1 is unit lower triangular
                 ! w := v1**h * b1
                 call stdlib_ccopy( i-1, a( k+1, i ), 1, t( 1, nb ), 1 )
                 call stdlib_ctrmv( 'LOWER', 'CONJUGATE TRANSPOSE', 'UNIT',i-1, a( k+1, 1 ),lda, &
                           t( 1, nb ), 1 )
                 ! w := w + v2**h * b2
                 call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k-i+1, i-1,cone, a( k+i, 1 ),lda, a( &
                           k+i, i ), 1, cone, t( 1, nb ), 1 )
                 ! w := t**h * w
                 call stdlib_ctrmv( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, &
                           nb ), 1 )
                 ! b2 := b2 - v2*w
                 call stdlib_cgemv( 'NO TRANSPOSE', n-k-i+1, i-1, -cone,a( k+i, 1 ),lda, t( 1, nb &
                           ), 1, cone, a( k+i, i ), 1 )
                 ! b1 := b1 - v1*w
                 call stdlib_ctrmv( 'LOWER', 'NO TRANSPOSE','UNIT', i-1,a( k+1, 1 ), lda, t( 1, &
                           nb ), 1 )
                 call stdlib_caxpy( i-1, -cone, t( 1, nb ), 1, a( k+1, i ), 1 )
                 a( k+i-1, i-1 ) = ei
              end if
              ! generate the elementary reflector h(i) to annihilate
              ! a(k+i+1:n,i)
              call stdlib_clarfg( n-k-i+1, a( k+i, i ), a( min( k+i+1, n ), i ), 1,tau( i ) )
                        
              ei = a( k+i, i )
              a( k+i, i ) = cone
              ! compute  y(k+1:n,i)
              call stdlib_cgemv( 'NO TRANSPOSE', n-k, n-k-i+1,cone, a( k+1, i+1 ),lda, a( k+i, i )&
                        , 1, czero, y( k+1, i ), 1 )
              call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k-i+1, i-1,cone, a( k+i, 1 ), lda,a( k+&
                        i, i ), 1, czero, t( 1, i ), 1 )
              call stdlib_cgemv( 'NO TRANSPOSE', n-k, i-1, -cone,y( k+1, 1 ), ldy,t( 1, i ), 1, &
                        cone, y( k+1, i ), 1 )
              call stdlib_cscal( n-k, tau( i ), y( k+1, i ), 1 )
              ! compute t(1:i,i)
              call stdlib_cscal( i-1, -tau( i ), t( 1, i ), 1 )
              call stdlib_ctrmv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, i ), 1 )
                        
              t( i, i ) = tau( i )
           end do loop_10
           a( k+nb, nb ) = ei
           ! compute y(1:k,1:nb)
           call stdlib_clacpy( 'ALL', k, nb, a( 1, 2 ), lda, y, ldy )
           call stdlib_ctrmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE','UNIT', k, nb,cone, a( k+1, 1 ), &
                     lda, y, ldy )
           if( n>k+nb )call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', k,nb, n-k-nb, cone,a( 1,&
                      2+nb ), lda, a( k+1+nb, 1 ), lda, cone, y,ldy )
           call stdlib_ctrmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE','NON-UNIT', k, nb,cone, t, ldt, y, &
                     ldy )
           return
     end subroutine stdlib_clahr2


     pure subroutine stdlib_clals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
     !! CLALS0 applies back the multiplying factors of either the left or the
     !! right singular vector matrix of a diagonal matrix appended by a row
     !! to the right hand side matrix B in solving the least squares problem
     !! using the divide-and-conquer SVD approach.
     !! For the left singular vector matrix, three types of orthogonal
     !! matrices are involved:
     !! (1L) Givens rotations: the number of such rotations is GIVPTR; the
     !! pairs of columns/rows they were applied to are stored in GIVCOL;
     !! and the C- and S-values of these rotations are stored in GIVNUM.
     !! (2L) Permutation. The (NL+1)-st row of B is to be moved to the first
     !! row, and for J=2:N, PERM(J)-th row of B is to be moved to the
     !! J-th row.
     !! (3L) The left singular vector matrix of the remaining matrix.
     !! For the right singular vector matrix, four types of orthogonal
     !! matrices are involved:
     !! (1R) The right singular vector matrix of the remaining matrix.
     !! (2R) If SQRE = 1, one extra Givens rotation to generate the right
     !! null space.
     !! (3R) The inverse transformation of (2L).
     !! (4R) The inverse transformation of (1L).
               givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: givptr, icompq, k, ldb, ldbx, ldgcol, ldgnum, nl, nr, nrhs,&
                      sqre
           integer(ilp), intent(out) :: info
           real(sp), intent(in) :: c, s
           ! Array Arguments 
           integer(ilp), intent(in) :: givcol(ldgcol,*), perm(*)
           real(sp), intent(in) :: difl(*), difr(ldgnum,*), givnum(ldgnum,*), poles(ldgnum,*), z(&
                     *)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: b(ldb,*)
           complex(sp), intent(out) :: bx(ldbx,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, jcol, jrow, m, n, nlp1
           real(sp) :: diflj, difrj, dj, dsigj, dsigjp, temp
           ! Intrinsic Functions 
           intrinsic :: aimag,cmplx,max,real
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           n = nl + nr + 1
           if( ( icompq<0 ) .or. ( icompq>1 ) ) then
              info = -1
           else if( nl<1 ) then
              info = -2
           else if( nr<1 ) then
              info = -3
           else if( ( sqre<0 ) .or. ( sqre>1 ) ) then
              info = -4
           else if( nrhs<1 ) then
              info = -5
           else if( ldb<n ) then
              info = -7
           else if( ldbx<n ) then
              info = -9
           else if( givptr<0 ) then
              info = -11
           else if( ldgcol<n ) then
              info = -13
           else if( ldgnum<n ) then
              info = -15
           else if( k<1 ) then
              info = -20
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLALS0', -info )
              return
           end if
           m = n + sqre
           nlp1 = nl + 1
           if( icompq==0 ) then
              ! apply back orthogonal transformations from the left.
              ! step (1l): apply back the givens rotations performed.
              do i = 1, givptr
                 call stdlib_csrot( nrhs, b( givcol( i, 2 ), 1 ), ldb,b( givcol( i, 1 ), 1 ), ldb,&
                            givnum( i, 2 ),givnum( i, 1 ) )
              end do
              ! step (2l): permute rows of b.
              call stdlib_ccopy( nrhs, b( nlp1, 1 ), ldb, bx( 1, 1 ), ldbx )
              do i = 2, n
                 call stdlib_ccopy( nrhs, b( perm( i ), 1 ), ldb, bx( i, 1 ), ldbx )
              end do
              ! step (3l): apply the inverse of the left singular vector
              ! matrix to bx.
              if( k==1 ) then
                 call stdlib_ccopy( nrhs, bx, ldbx, b, ldb )
                 if( z( 1 )<zero ) then
                    call stdlib_csscal( nrhs, negone, b, ldb )
                 end if
              else
                 loop_100: do j = 1, k
                    diflj = difl( j )
                    dj = poles( j, 1 )
                    dsigj = -poles( j, 2 )
                    if( j<k ) then
                       difrj = -difr( j, 1 )
                       dsigjp = -poles( j+1, 2 )
                    end if
                    if( ( z( j )==zero ) .or. ( poles( j, 2 )==zero ) )then
                       rwork( j ) = zero
                    else
                       rwork( j ) = -poles( j, 2 )*z( j ) / diflj /( poles( j, 2 )+dj )
                    end if
                    do i = 1, j - 1
                       if( ( z( i )==zero ) .or.( poles( i, 2 )==zero ) ) then
                          rwork( i ) = zero
                       else
                          rwork( i ) = poles( i, 2 )*z( i ) /( stdlib_slamc3( poles( i, 2 ), &
                                    dsigj )-diflj ) / ( poles( i, 2 )+dj )
                       end if
                    end do
                    do i = j + 1, k
                       if( ( z( i )==zero ) .or.( poles( i, 2 )==zero ) ) then
                          rwork( i ) = zero
                       else
                          rwork( i ) = poles( i, 2 )*z( i ) /( stdlib_slamc3( poles( i, 2 ), &
                                    dsigjp )+difrj ) / ( poles( i, 2 )+dj )
                       end if
                    end do
                    rwork( 1 ) = negone
                    temp = stdlib_snrm2( k, rwork, 1 )
                    ! since b and bx are complex, the following call to stdlib_sgemv
                    ! is performed in two steps (real and imaginary parts).
                    ! call stdlib_sgemv( 't', k, nrhs, one, bx, ldbx, work, 1, zero,
          ! $                     b( j, 1 ), ldb )
                    i = k + nrhs*2
                    do jcol = 1, nrhs
                       do jrow = 1, k
                          i = i + 1
                          rwork( i ) = real( bx( jrow, jcol ),KIND=sp)
                       end do
                    end do
                    call stdlib_sgemv( 'T', k, nrhs, one, rwork( 1+k+nrhs*2 ), k,rwork( 1 ), 1, &
                              zero, rwork( 1+k ), 1 )
                    i = k + nrhs*2
                    do jcol = 1, nrhs
                       do jrow = 1, k
                          i = i + 1
                          rwork( i ) = aimag( bx( jrow, jcol ) )
                       end do
                    end do
                    call stdlib_sgemv( 'T', k, nrhs, one, rwork( 1+k+nrhs*2 ), k,rwork( 1 ), 1, &
                              zero, rwork( 1+k+nrhs ), 1 )
                    do jcol = 1, nrhs
                       b( j, jcol ) = cmplx( rwork( jcol+k ),rwork( jcol+k+nrhs ),KIND=sp)
                    end do
                    call stdlib_clascl( 'G', 0, 0, temp, one, 1, nrhs, b( j, 1 ),ldb, info )
                              
                 end do loop_100
              end if
              ! move the deflated rows of bx to b also.
              if( k<max( m, n ) )call stdlib_clacpy( 'A', n-k, nrhs, bx( k+1, 1 ), ldbx,b( k+1, 1 &
                        ), ldb )
           else
              ! apply back the right orthogonal transformations.
              ! step (1r): apply back the new right singular vector matrix
              ! to b.
              if( k==1 ) then
                 call stdlib_ccopy( nrhs, b, ldb, bx, ldbx )
              else
                 loop_180: do j = 1, k
                    dsigj = poles( j, 2 )
                    if( z( j )==zero ) then
                       rwork( j ) = zero
                    else
                       rwork( j ) = -z( j ) / difl( j ) /( dsigj+poles( j, 1 ) ) / difr( j, 2 )
                                 
                    end if
                    do i = 1, j - 1
                       if( z( j )==zero ) then
                          rwork( i ) = zero
                       else
                          rwork( i ) = z( j ) / ( stdlib_slamc3( dsigj, -poles( i+1,2 ) )-difr( i,&
                                     1 ) ) /( dsigj+poles( i, 1 ) ) / difr( i, 2 )
                       end if
                    end do
                    do i = j + 1, k
                       if( z( j )==zero ) then
                          rwork( i ) = zero
                       else
                          rwork( i ) = z( j ) / ( stdlib_slamc3( dsigj, -poles( i,2 ) )-difl( i ) &
                                    ) /( dsigj+poles( i, 1 ) ) / difr( i, 2 )
                       end if
                    end do
                    ! since b and bx are complex, the following call to stdlib_sgemv
                    ! is performed in two steps (real and imaginary parts).
                    ! call stdlib_sgemv( 't', k, nrhs, one, b, ldb, work, 1, zero,
          ! $                     bx( j, 1 ), ldbx )
                    i = k + nrhs*2
                    do jcol = 1, nrhs
                       do jrow = 1, k
                          i = i + 1
                          rwork( i ) = real( b( jrow, jcol ),KIND=sp)
                       end do
                    end do
                    call stdlib_sgemv( 'T', k, nrhs, one, rwork( 1+k+nrhs*2 ), k,rwork( 1 ), 1, &
                              zero, rwork( 1+k ), 1 )
                    i = k + nrhs*2
                    do jcol = 1, nrhs
                       do jrow = 1, k
                          i = i + 1
                          rwork( i ) = aimag( b( jrow, jcol ) )
                       end do
                    end do
                    call stdlib_sgemv( 'T', k, nrhs, one, rwork( 1+k+nrhs*2 ), k,rwork( 1 ), 1, &
                              zero, rwork( 1+k+nrhs ), 1 )
                    do jcol = 1, nrhs
                       bx( j, jcol ) = cmplx( rwork( jcol+k ),rwork( jcol+k+nrhs ),KIND=sp)
                                 
                    end do
                 end do loop_180
              end if
              ! step (2r): if sqre = 1, apply back the rotation that is
              ! related to the right null space of the subproblem.
              if( sqre==1 ) then
                 call stdlib_ccopy( nrhs, b( m, 1 ), ldb, bx( m, 1 ), ldbx )
                 call stdlib_csrot( nrhs, bx( 1, 1 ), ldbx, bx( m, 1 ), ldbx, c, s )
              end if
              if( k<max( m, n ) )call stdlib_clacpy( 'A', n-k, nrhs, b( k+1, 1 ), ldb,bx( k+1, 1 )&
                        , ldbx )
              ! step (3r): permute rows of b.
              call stdlib_ccopy( nrhs, bx( 1, 1 ), ldbx, b( nlp1, 1 ), ldb )
              if( sqre==1 ) then
                 call stdlib_ccopy( nrhs, bx( m, 1 ), ldbx, b( m, 1 ), ldb )
              end if
              do i = 2, n
                 call stdlib_ccopy( nrhs, bx( i, 1 ), ldbx, b( perm( i ), 1 ), ldb )
              end do
              ! step (4r): apply back the givens rotations performed.
              do i = givptr, 1, -1
                 call stdlib_csrot( nrhs, b( givcol( i, 2 ), 1 ), ldb,b( givcol( i, 1 ), 1 ), ldb,&
                            givnum( i, 2 ),-givnum( i, 1 ) )
              end do
           end if
           return
     end subroutine stdlib_clals0


     pure subroutine stdlib_clalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, difl,&
     !! CLALSA is an itermediate step in solving the least squares problem
     !! by computing the SVD of the coefficient matrix in compact form (The
     !! singular vectors are computed as products of simple orthorgonal
     !! matrices.).
     !! If ICOMPQ = 0, CLALSA applies the inverse of the left singular vector
     !! matrix of an upper bidiagonal matrix to the right hand side; and if
     !! ICOMPQ = 1, CLALSA applies the right singular vector matrix to the
     !! right hand side. The singular vector matrices were generated in
     !! compact form by CLALSA.
                difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, rwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: icompq, ldb, ldbx, ldgcol, ldu, n, nrhs, smlsiz
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: givcol(ldgcol,*), givptr(*), k(*), perm(ldgcol,*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(in) :: c(*), difl(ldu,*), difr(ldu,*), givnum(ldu,*), poles(ldu,*), s(&
                     *), u(ldu,*), vt(ldu,*), z(ldu,*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: b(ldb,*)
           complex(sp), intent(out) :: bx(ldbx,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, i1, ic, im1, inode, j, jcol, jimag, jreal, jrow, lf, ll, lvl, lvl2, &
                     nd, ndb1, ndiml, ndimr, nl, nlf, nlp1, nlvl, nr, nrf, nrp1, sqre
           ! Intrinsic Functions 
           intrinsic :: aimag,cmplx,real
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( ( icompq<0 ) .or. ( icompq>1 ) ) then
              info = -1
           else if( smlsiz<3 ) then
              info = -2
           else if( n<smlsiz ) then
              info = -3
           else if( nrhs<1 ) then
              info = -4
           else if( ldb<n ) then
              info = -6
           else if( ldbx<n ) then
              info = -8
           else if( ldu<n ) then
              info = -10
           else if( ldgcol<n ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLALSA', -info )
              return
           end if
           ! book-keeping and  setting up the computation tree.
           inode = 1
           ndiml = inode + n
           ndimr = ndiml + n
           call stdlib_slasdt( n, nlvl, nd, iwork( inode ), iwork( ndiml ),iwork( ndimr ), smlsiz &
                     )
           ! the following code applies back the left singular vector factors.
           ! for applying back the right singular vector factors, go to 170.
           if( icompq==1 ) then
              go to 170
           end if
           ! the nodes on the bottom level of the tree were solved
           ! by stdlib_slasdq. the corresponding left and right singular vector
           ! matrices are in explicit form. first apply back the left
           ! singular vector matrices.
           ndb1 = ( nd+1 ) / 2
           loop_130: do i = ndb1, nd
              ! ic : center row of each node
              ! nl : number of rows of left  subproblem
              ! nr : number of rows of right subproblem
              ! nlf: starting row of the left   subproblem
              ! nrf: starting row of the right  subproblem
              i1 = i - 1
              ic = iwork( inode+i1 )
              nl = iwork( ndiml+i1 )
              nr = iwork( ndimr+i1 )
              nlf = ic - nl
              nrf = ic + 1
              ! since b and bx are complex, the following call to stdlib_sgemm
              ! is performed in two steps (real and imaginary parts).
              ! call stdlib_sgemm( 't', 'n', nl, nrhs, nl, one, u( nlf, 1 ), ldu,
           ! $               b( nlf, 1 ), ldb, zero, bx( nlf, 1 ), ldbx )
              j = nl*nrhs*2
              do jcol = 1, nrhs
                 do jrow = nlf, nlf + nl - 1
                    j = j + 1
                    rwork( j ) = real( b( jrow, jcol ),KIND=sp)
                 end do
              end do
              call stdlib_sgemm( 'T', 'N', nl, nrhs, nl, one, u( nlf, 1 ), ldu,rwork( 1+nl*nrhs*2 &
                        ), nl, zero, rwork( 1 ), nl )
              j = nl*nrhs*2
              do jcol = 1, nrhs
                 do jrow = nlf, nlf + nl - 1
                    j = j + 1
                    rwork( j ) = aimag( b( jrow, jcol ) )
                 end do
              end do
              call stdlib_sgemm( 'T', 'N', nl, nrhs, nl, one, u( nlf, 1 ), ldu,rwork( 1+nl*nrhs*2 &
                        ), nl, zero, rwork( 1+nl*nrhs ),nl )
              jreal = 0
              jimag = nl*nrhs
              do jcol = 1, nrhs
                 do jrow = nlf, nlf + nl - 1
                    jreal = jreal + 1
                    jimag = jimag + 1
                    bx( jrow, jcol ) = cmplx( rwork( jreal ),rwork( jimag ),KIND=sp)
                 end do
              end do
              ! since b and bx are complex, the following call to stdlib_sgemm
              ! is performed in two steps (real and imaginary parts).
              ! call stdlib_sgemm( 't', 'n', nr, nrhs, nr, one, u( nrf, 1 ), ldu,
          ! $               b( nrf, 1 ), ldb, zero, bx( nrf, 1 ), ldbx )
              j = nr*nrhs*2
              do jcol = 1, nrhs
                 do jrow = nrf, nrf + nr - 1
                    j = j + 1
                    rwork( j ) = real( b( jrow, jcol ),KIND=sp)
                 end do
              end do
              call stdlib_sgemm( 'T', 'N', nr, nrhs, nr, one, u( nrf, 1 ), ldu,rwork( 1+nr*nrhs*2 &
                        ), nr, zero, rwork( 1 ), nr )
              j = nr*nrhs*2
              do jcol = 1, nrhs
                 do jrow = nrf, nrf + nr - 1
                    j = j + 1
                    rwork( j ) = aimag( b( jrow, jcol ) )
                 end do
              end do
              call stdlib_sgemm( 'T', 'N', nr, nrhs, nr, one, u( nrf, 1 ), ldu,rwork( 1+nr*nrhs*2 &
                        ), nr, zero, rwork( 1+nr*nrhs ),nr )
              jreal = 0
              jimag = nr*nrhs
              do jcol = 1, nrhs
                 do jrow = nrf, nrf + nr - 1
                    jreal = jreal + 1
                    jimag = jimag + 1
                    bx( jrow, jcol ) = cmplx( rwork( jreal ),rwork( jimag ),KIND=sp)
                 end do
              end do
           end do loop_130
           ! next copy the rows of b that correspond to unchanged rows
           ! in the bidiagonal matrix to bx.
           do i = 1, nd
              ic = iwork( inode+i-1 )
              call stdlib_ccopy( nrhs, b( ic, 1 ), ldb, bx( ic, 1 ), ldbx )
           end do
           ! finally go through the left singular vector matrices of all
           ! the other subproblems bottom-up on the tree.
           j = 2**nlvl
           sqre = 0
           do lvl = nlvl, 1, -1
              lvl2 = 2*lvl - 1
              ! find the first node lf and last node ll on
              ! the current level lvl
              if( lvl==1 ) then
                 lf = 1
                 ll = 1
              else
                 lf = 2**( lvl-1 )
                 ll = 2*lf - 1
              end if
              do i = lf, ll
                 im1 = i - 1
                 ic = iwork( inode+im1 )
                 nl = iwork( ndiml+im1 )
                 nr = iwork( ndimr+im1 )
                 nlf = ic - nl
                 nrf = ic + 1
                 j = j - 1
                 call stdlib_clals0( icompq, nl, nr, sqre, nrhs, bx( nlf, 1 ), ldbx,b( nlf, 1 ), &
                 ldb, perm( nlf, lvl ),givptr( j ), givcol( nlf, lvl2 ), ldgcol,givnum( nlf, lvl2 &
                 ), ldu, poles( nlf, lvl2 ),difl( nlf, lvl ), difr( nlf, lvl2 ),z( nlf, lvl ), k( &
                           j ), c( j ), s( j ), rwork,info )
              end do
           end do
           go to 330
           ! icompq = 1: applying back the right singular vector factors.
           170 continue
           ! first now go through the right singular vector matrices of all
           ! the tree nodes top-down.
           j = 0
           loop_190: do lvl = 1, nlvl
              lvl2 = 2*lvl - 1
              ! find the first node lf and last node ll on
              ! the current level lvl.
              if( lvl==1 ) then
                 lf = 1
                 ll = 1
              else
                 lf = 2**( lvl-1 )
                 ll = 2*lf - 1
              end if
              do i = ll, lf, -1
                 im1 = i - 1
                 ic = iwork( inode+im1 )
                 nl = iwork( ndiml+im1 )
                 nr = iwork( ndimr+im1 )
                 nlf = ic - nl
                 nrf = ic + 1
                 if( i==ll ) then
                    sqre = 0
                 else
                    sqre = 1
                 end if
                 j = j + 1
                 call stdlib_clals0( icompq, nl, nr, sqre, nrhs, b( nlf, 1 ), ldb,bx( nlf, 1 ), &
                 ldbx, perm( nlf, lvl ),givptr( j ), givcol( nlf, lvl2 ), ldgcol,givnum( nlf, &
                 lvl2 ), ldu, poles( nlf, lvl2 ),difl( nlf, lvl ), difr( nlf, lvl2 ),z( nlf, lvl )&
                           , k( j ), c( j ), s( j ), rwork,info )
              end do
           end do loop_190
           ! the nodes on the bottom level of the tree were solved
           ! by stdlib_slasdq. the corresponding right singular vector
           ! matrices are in explicit form. apply them back.
           ndb1 = ( nd+1 ) / 2
           loop_320: do i = ndb1, nd
              i1 = i - 1
              ic = iwork( inode+i1 )
              nl = iwork( ndiml+i1 )
              nr = iwork( ndimr+i1 )
              nlp1 = nl + 1
              if( i==nd ) then
                 nrp1 = nr
              else
                 nrp1 = nr + 1
              end if
              nlf = ic - nl
              nrf = ic + 1
              ! since b and bx are complex, the following call to stdlib_sgemm is
              ! performed in two steps (real and imaginary parts).
              ! call stdlib_sgemm( 't', 'n', nlp1, nrhs, nlp1, one, vt( nlf, 1 ), ldu,
          ! $               b( nlf, 1 ), ldb, zero, bx( nlf, 1 ), ldbx )
              j = nlp1*nrhs*2
              do jcol = 1, nrhs
                 do jrow = nlf, nlf + nlp1 - 1
                    j = j + 1
                    rwork( j ) = real( b( jrow, jcol ),KIND=sp)
                 end do
              end do
              call stdlib_sgemm( 'T', 'N', nlp1, nrhs, nlp1, one, vt( nlf, 1 ), ldu,rwork( 1+&
                        nlp1*nrhs*2 ), nlp1, zero, rwork( 1 ),nlp1 )
              j = nlp1*nrhs*2
              do jcol = 1, nrhs
                 do jrow = nlf, nlf + nlp1 - 1
                    j = j + 1
                    rwork( j ) = aimag( b( jrow, jcol ) )
                 end do
              end do
              call stdlib_sgemm( 'T', 'N', nlp1, nrhs, nlp1, one, vt( nlf, 1 ), ldu,rwork( 1+&
                        nlp1*nrhs*2 ), nlp1, zero,rwork( 1+nlp1*nrhs ), nlp1 )
              jreal = 0
              jimag = nlp1*nrhs
              do jcol = 1, nrhs
                 do jrow = nlf, nlf + nlp1 - 1
                    jreal = jreal + 1
                    jimag = jimag + 1
                    bx( jrow, jcol ) = cmplx( rwork( jreal ),rwork( jimag ),KIND=sp)
                 end do
              end do
              ! since b and bx are complex, the following call to stdlib_sgemm is
              ! performed in two steps (real and imaginary parts).
              ! call stdlib_sgemm( 't', 'n', nrp1, nrhs, nrp1, one, vt( nrf, 1 ), ldu,
          ! $               b( nrf, 1 ), ldb, zero, bx( nrf, 1 ), ldbx )
              j = nrp1*nrhs*2
              do jcol = 1, nrhs
                 do jrow = nrf, nrf + nrp1 - 1
                    j = j + 1
                    rwork( j ) = real( b( jrow, jcol ),KIND=sp)
                 end do
              end do
              call stdlib_sgemm( 'T', 'N', nrp1, nrhs, nrp1, one, vt( nrf, 1 ), ldu,rwork( 1+&
                        nrp1*nrhs*2 ), nrp1, zero, rwork( 1 ),nrp1 )
              j = nrp1*nrhs*2
              do jcol = 1, nrhs
                 do jrow = nrf, nrf + nrp1 - 1
                    j = j + 1
                    rwork( j ) = aimag( b( jrow, jcol ) )
                 end do
              end do
              call stdlib_sgemm( 'T', 'N', nrp1, nrhs, nrp1, one, vt( nrf, 1 ), ldu,rwork( 1+&
                        nrp1*nrhs*2 ), nrp1, zero,rwork( 1+nrp1*nrhs ), nrp1 )
              jreal = 0
              jimag = nrp1*nrhs
              do jcol = 1, nrhs
                 do jrow = nrf, nrf + nrp1 - 1
                    jreal = jreal + 1
                    jimag = jimag + 1
                    bx( jrow, jcol ) = cmplx( rwork( jreal ),rwork( jimag ),KIND=sp)
                 end do
              end do
           end do loop_320
           330 continue
           return
     end subroutine stdlib_clalsa


     pure subroutine stdlib_clalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, rwork, &
     !! CLALSD uses the singular value decomposition of A to solve the least
     !! squares problem of finding X to minimize the Euclidean norm of each
     !! column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
     !! are N-by-NRHS. The solution X overwrites B.
     !! The singular values of A smaller than RCOND times the largest
     !! singular value are treated as zero in solving the least squares
     !! problem; in this case a minimum norm solution is returned.
     !! The actual singular values are returned in D in ascending order.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, rank
           integer(ilp), intent(in) :: ldb, n, nrhs, smlsiz
           real(sp), intent(in) :: rcond
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           integer(ilp) :: bx, bxst, c, difl, difr, givcol, givnum, givptr, i, icmpq1, icmpq2, &
           irwb, irwib, irwrb, irwu, irwvt, irwwrk, iwk, j, jcol, jimag, jreal, jrow, k, nlvl, &
           nm1, nrwork, nsize, nsub, perm, poles, s, sizei, smlszp, sqre, st, st1, u, vt, &
                     z
           real(sp) :: cs, eps, orgnrm, r, rcnd, sn, tol
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,int,log,real,sign
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -3
           else if( nrhs<1 ) then
              info = -4
           else if( ( ldb<1 ) .or. ( ldb<n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLALSD', -info )
              return
           end if
           eps = stdlib_slamch( 'EPSILON' )
           ! set up the tolerance.
           if( ( rcond<=zero ) .or. ( rcond>=one ) ) then
              rcnd = eps
           else
              rcnd = rcond
           end if
           rank = 0
           ! quick return if possible.
           if( n==0 ) then
              return
           else if( n==1 ) then
              if( d( 1 )==zero ) then
                 call stdlib_claset( 'A', 1, nrhs, czero, czero, b, ldb )
              else
                 rank = 1
                 call stdlib_clascl( 'G', 0, 0, d( 1 ), one, 1, nrhs, b, ldb, info )
                 d( 1 ) = abs( d( 1 ) )
              end if
              return
           end if
           ! rotate the matrix if it is lower bidiagonal.
           if( uplo=='L' ) then
              do i = 1, n - 1
                 call stdlib_slartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 if( nrhs==1 ) then
                    call stdlib_csrot( 1, b( i, 1 ), 1, b( i+1, 1 ), 1, cs, sn )
                 else
                    rwork( i*2-1 ) = cs
                    rwork( i*2 ) = sn
                 end if
              end do
              if( nrhs>1 ) then
                 do i = 1, nrhs
                    do j = 1, n - 1
                       cs = rwork( j*2-1 )
                       sn = rwork( j*2 )
                       call stdlib_csrot( 1, b( j, i ), 1, b( j+1, i ), 1, cs, sn )
                    end do
                 end do
              end if
           end if
           ! scale.
           nm1 = n - 1
           orgnrm = stdlib_slanst( 'M', n, d, e )
           if( orgnrm==zero ) then
              call stdlib_claset( 'A', n, nrhs, czero, czero, b, ldb )
              return
           end if
           call stdlib_slascl( 'G', 0, 0, orgnrm, one, n, 1, d, n, info )
           call stdlib_slascl( 'G', 0, 0, orgnrm, one, nm1, 1, e, nm1, info )
           ! if n is smaller than the minimum divide size smlsiz, then solve
           ! the problem with another solver.
           if( n<=smlsiz ) then
              irwu = 1
              irwvt = irwu + n*n
              irwwrk = irwvt + n*n
              irwrb = irwwrk
              irwib = irwrb + n*nrhs
              irwb = irwib + n*nrhs
              call stdlib_slaset( 'A', n, n, zero, one, rwork( irwu ), n )
              call stdlib_slaset( 'A', n, n, zero, one, rwork( irwvt ), n )
              call stdlib_slasdq( 'U', 0, n, n, n, 0, d, e, rwork( irwvt ), n,rwork( irwu ), n, &
                        rwork( irwwrk ), 1,rwork( irwwrk ), info )
              if( info/=0 ) then
                 return
              end if
              ! in the real version, b is passed to stdlib_slasdq and multiplied
              ! internally by q**h. here b is complex and that product is
              ! computed below in two steps (real and imaginary parts).
              j = irwb - 1
              do jcol = 1, nrhs
                 do jrow = 1, n
                    j = j + 1
                    rwork( j ) = real( b( jrow, jcol ),KIND=sp)
                 end do
              end do
              call stdlib_sgemm( 'T', 'N', n, nrhs, n, one, rwork( irwu ), n,rwork( irwb ), n, &
                        zero, rwork( irwrb ), n )
              j = irwb - 1
              do jcol = 1, nrhs
                 do jrow = 1, n
                    j = j + 1
                    rwork( j ) = aimag( b( jrow, jcol ) )
                 end do
              end do
              call stdlib_sgemm( 'T', 'N', n, nrhs, n, one, rwork( irwu ), n,rwork( irwb ), n, &
                        zero, rwork( irwib ), n )
              jreal = irwrb - 1
              jimag = irwib - 1
              do jcol = 1, nrhs
                 do jrow = 1, n
                    jreal = jreal + 1
                    jimag = jimag + 1
                    b( jrow, jcol ) = cmplx( rwork( jreal ), rwork( jimag ),KIND=sp)
                 end do
              end do
              tol = rcnd*abs( d( stdlib_isamax( n, d, 1 ) ) )
              do i = 1, n
                 if( d( i )<=tol ) then
                    call stdlib_claset( 'A', 1, nrhs, czero, czero, b( i, 1 ), ldb )
                 else
                    call stdlib_clascl( 'G', 0, 0, d( i ), one, 1, nrhs, b( i, 1 ),ldb, info )
                              
                    rank = rank + 1
                 end if
              end do
              ! since b is complex, the following call to stdlib_sgemm is performed
              ! in two steps (real and imaginary parts). that is for v * b
              ! (in the real version of the code v**h is stored in work).
              ! call stdlib_sgemm( 't', 'n', n, nrhs, n, one, work, n, b, ldb, zero,
          ! $               work( nwork ), n )
              j = irwb - 1
              do jcol = 1, nrhs
                 do jrow = 1, n
                    j = j + 1
                    rwork( j ) = real( b( jrow, jcol ),KIND=sp)
                 end do
              end do
              call stdlib_sgemm( 'T', 'N', n, nrhs, n, one, rwork( irwvt ), n,rwork( irwb ), n, &
                        zero, rwork( irwrb ), n )
              j = irwb - 1
              do jcol = 1, nrhs
                 do jrow = 1, n
                    j = j + 1
                    rwork( j ) = aimag( b( jrow, jcol ) )
                 end do
              end do
              call stdlib_sgemm( 'T', 'N', n, nrhs, n, one, rwork( irwvt ), n,rwork( irwb ), n, &
                        zero, rwork( irwib ), n )
              jreal = irwrb - 1
              jimag = irwib - 1
              do jcol = 1, nrhs
                 do jrow = 1, n
                    jreal = jreal + 1
                    jimag = jimag + 1
                    b( jrow, jcol ) = cmplx( rwork( jreal ), rwork( jimag ),KIND=sp)
                 end do
              end do
              ! unscale.
              call stdlib_slascl( 'G', 0, 0, one, orgnrm, n, 1, d, n, info )
              call stdlib_slasrt( 'D', n, d, info )
              call stdlib_clascl( 'G', 0, 0, orgnrm, one, n, nrhs, b, ldb, info )
              return
           end if
           ! book-keeping and setting up some constants.
           nlvl = int( log( real( n,KIND=sp) / real( smlsiz+1,KIND=sp) ) / log( two ),KIND=ilp) + &
                     1
           smlszp = smlsiz + 1
           u = 1
           vt = 1 + smlsiz*n
           difl = vt + smlszp*n
           difr = difl + nlvl*n
           z = difr + nlvl*n*2
           c = z + nlvl*n
           s = c + n
           poles = s + n
           givnum = poles + 2*nlvl*n
           nrwork = givnum + 2*nlvl*n
           bx = 1
           irwrb = nrwork
           irwib = irwrb + smlsiz*nrhs
           irwb = irwib + smlsiz*nrhs
           sizei = 1 + n
           k = sizei + n
           givptr = k + n
           perm = givptr + n
           givcol = perm + nlvl*n
           iwk = givcol + nlvl*n*2
           st = 1
           sqre = 0
           icmpq1 = 1
           icmpq2 = 0
           nsub = 0
           do i = 1, n
              if( abs( d( i ) )<eps ) then
                 d( i ) = sign( eps, d( i ) )
              end if
           end do
           loop_240: do i = 1, nm1
              if( ( abs( e( i ) )<eps ) .or. ( i==nm1 ) ) then
                 nsub = nsub + 1
                 iwork( nsub ) = st
                 ! subproblem found. first determine its size and then
                 ! apply divide and conquer on it.
                 if( i<nm1 ) then
                    ! a subproblem with e(i) small for i < nm1.
                    nsize = i - st + 1
                    iwork( sizei+nsub-1 ) = nsize
                 else if( abs( e( i ) )>=eps ) then
                    ! a subproblem with e(nm1) not too small but i = nm1.
                    nsize = n - st + 1
                    iwork( sizei+nsub-1 ) = nsize
                 else
                    ! a subproblem with e(nm1) small. this implies an
                    ! 1-by-1 subproblem at d(n), which is not solved
                    ! explicitly.
                    nsize = i - st + 1
                    iwork( sizei+nsub-1 ) = nsize
                    nsub = nsub + 1
                    iwork( nsub ) = n
                    iwork( sizei+nsub-1 ) = 1
                    call stdlib_ccopy( nrhs, b( n, 1 ), ldb, work( bx+nm1 ), n )
                 end if
                 st1 = st - 1
                 if( nsize==1 ) then
                    ! this is a 1-by-1 subproblem and is not solved
                    ! explicitly.
                    call stdlib_ccopy( nrhs, b( st, 1 ), ldb, work( bx+st1 ), n )
                 else if( nsize<=smlsiz ) then
                    ! this is a small subproblem and is solved by stdlib_slasdq.
                    call stdlib_slaset( 'A', nsize, nsize, zero, one,rwork( vt+st1 ), n )
                    call stdlib_slaset( 'A', nsize, nsize, zero, one,rwork( u+st1 ), n )
                    call stdlib_slasdq( 'U', 0, nsize, nsize, nsize, 0, d( st ),e( st ), rwork( &
                    vt+st1 ), n, rwork( u+st1 ),n, rwork( nrwork ), 1, rwork( nrwork ),info )
                              
                    if( info/=0 ) then
                       return
                    end if
                    ! in the real version, b is passed to stdlib_slasdq and multiplied
                    ! internally by q**h. here b is complex and that product is
                    ! computed below in two steps (real and imaginary parts).
                    j = irwb - 1
                    do jcol = 1, nrhs
                       do jrow = st, st + nsize - 1
                          j = j + 1
                          rwork( j ) = real( b( jrow, jcol ),KIND=sp)
                       end do
                    end do
                    call stdlib_sgemm( 'T', 'N', nsize, nrhs, nsize, one,rwork( u+st1 ), n, rwork(&
                               irwb ), nsize,zero, rwork( irwrb ), nsize )
                    j = irwb - 1
                    do jcol = 1, nrhs
                       do jrow = st, st + nsize - 1
                          j = j + 1
                          rwork( j ) = aimag( b( jrow, jcol ) )
                       end do
                    end do
                    call stdlib_sgemm( 'T', 'N', nsize, nrhs, nsize, one,rwork( u+st1 ), n, rwork(&
                               irwb ), nsize,zero, rwork( irwib ), nsize )
                    jreal = irwrb - 1
                    jimag = irwib - 1
                    do jcol = 1, nrhs
                       do jrow = st, st + nsize - 1
                          jreal = jreal + 1
                          jimag = jimag + 1
                          b( jrow, jcol ) = cmplx( rwork( jreal ),rwork( jimag ),KIND=sp)
                       end do
                    end do
                    call stdlib_clacpy( 'A', nsize, nrhs, b( st, 1 ), ldb,work( bx+st1 ), n )
                              
                 else
                    ! a large problem. solve it using divide and conquer.
                    call stdlib_slasda( icmpq1, smlsiz, nsize, sqre, d( st ),e( st ), rwork( u+&
                    st1 ), n, rwork( vt+st1 ),iwork( k+st1 ), rwork( difl+st1 ),rwork( difr+st1 ),&
                     rwork( z+st1 ),rwork( poles+st1 ), iwork( givptr+st1 ),iwork( givcol+st1 ), &
                     n, iwork( perm+st1 ),rwork( givnum+st1 ), rwork( c+st1 ),rwork( s+st1 ), &
                               rwork( nrwork ),iwork( iwk ), info )
                    if( info/=0 ) then
                       return
                    end if
                    bxst = bx + st1
                    call stdlib_clalsa( icmpq2, smlsiz, nsize, nrhs, b( st, 1 ),ldb, work( bxst ),&
                     n, rwork( u+st1 ), n,rwork( vt+st1 ), iwork( k+st1 ),rwork( difl+st1 ), &
                     rwork( difr+st1 ),rwork( z+st1 ), rwork( poles+st1 ),iwork( givptr+st1 ), &
                     iwork( givcol+st1 ), n,iwork( perm+st1 ), rwork( givnum+st1 ),rwork( c+st1 ),&
                                rwork( s+st1 ),rwork( nrwork ), iwork( iwk ), info )
                    if( info/=0 ) then
                       return
                    end if
                 end if
                 st = i + 1
              end if
           end do loop_240
           ! apply the singular values and treat the tiny ones as zero.
           tol = rcnd*abs( d( stdlib_isamax( n, d, 1 ) ) )
           do i = 1, n
              ! some of the elements in d can be negative because 1-by-1
              ! subproblems were not solved explicitly.
              if( abs( d( i ) )<=tol ) then
                 call stdlib_claset( 'A', 1, nrhs, czero, czero, work( bx+i-1 ), n )
              else
                 rank = rank + 1
                 call stdlib_clascl( 'G', 0, 0, d( i ), one, 1, nrhs,work( bx+i-1 ), n, info )
                           
              end if
              d( i ) = abs( d( i ) )
           end do
           ! now apply back the right singular vectors.
           icmpq2 = 1
           loop_320: do i = 1, nsub
              st = iwork( i )
              st1 = st - 1
              nsize = iwork( sizei+i-1 )
              bxst = bx + st1
              if( nsize==1 ) then
                 call stdlib_ccopy( nrhs, work( bxst ), n, b( st, 1 ), ldb )
              else if( nsize<=smlsiz ) then
                 ! since b and bx are complex, the following call to stdlib_sgemm
                 ! is performed in two steps (real and imaginary parts).
                 ! call stdlib_sgemm( 't', 'n', nsize, nrhs, nsize, one,
          ! $                  rwork( vt+st1 ), n, rwork( bxst ), n, zero,
          ! $                  b( st, 1 ), ldb )
                 j = bxst - n - 1
                 jreal = irwb - 1
                 do jcol = 1, nrhs
                    j = j + n
                    do jrow = 1, nsize
                       jreal = jreal + 1
                       rwork( jreal ) = real( work( j+jrow ),KIND=sp)
                    end do
                 end do
                 call stdlib_sgemm( 'T', 'N', nsize, nrhs, nsize, one,rwork( vt+st1 ), n, rwork( &
                           irwb ), nsize, zero,rwork( irwrb ), nsize )
                 j = bxst - n - 1
                 jimag = irwb - 1
                 do jcol = 1, nrhs
                    j = j + n
                    do jrow = 1, nsize
                       jimag = jimag + 1
                       rwork( jimag ) = aimag( work( j+jrow ) )
                    end do
                 end do
                 call stdlib_sgemm( 'T', 'N', nsize, nrhs, nsize, one,rwork( vt+st1 ), n, rwork( &
                           irwb ), nsize, zero,rwork( irwib ), nsize )
                 jreal = irwrb - 1
                 jimag = irwib - 1
                 do jcol = 1, nrhs
                    do jrow = st, st + nsize - 1
                       jreal = jreal + 1
                       jimag = jimag + 1
                       b( jrow, jcol ) = cmplx( rwork( jreal ),rwork( jimag ),KIND=sp)
                    end do
                 end do
              else
                 call stdlib_clalsa( icmpq2, smlsiz, nsize, nrhs, work( bxst ), n,b( st, 1 ), ldb,&
                  rwork( u+st1 ), n,rwork( vt+st1 ), iwork( k+st1 ),rwork( difl+st1 ), rwork( &
                  difr+st1 ),rwork( z+st1 ), rwork( poles+st1 ),iwork( givptr+st1 ), iwork( &
                  givcol+st1 ), n,iwork( perm+st1 ), rwork( givnum+st1 ),rwork( c+st1 ), rwork( s+&
                            st1 ),rwork( nrwork ), iwork( iwk ), info )
                 if( info/=0 ) then
                    return
                 end if
              end if
           end do loop_320
           ! unscale and sort the singular values.
           call stdlib_slascl( 'G', 0, 0, one, orgnrm, n, 1, d, n, info )
           call stdlib_slasrt( 'D', n, d, info )
           call stdlib_clascl( 'G', 0, 0, orgnrm, one, n, nrhs, b, ldb, info )
           return
     end subroutine stdlib_clalsd


     real(sp)             function stdlib_clangb( norm, n, kl, ku, ab, ldab,work )
     !! CLANGB returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the element of  largest absolute value  of an
     !! n by n band matrix  A,  with kl sub-diagonals and ku super-diagonals.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm
           integer(ilp), intent(in) :: kl, ku, ldab, n
           ! Array Arguments 
           real(sp), intent(out) :: work(*)
           complex(sp), intent(in) :: ab(ldab,*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, k, l
           real(sp) :: scale, sum, value, temp
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              value = zero
              do j = 1, n
                 do i = max( ku+2-j, 1 ), min( n+ku+1-j, kl+ku+1 )
                    temp = abs( ab( i, j ) )
                    if( value<temp .or. stdlib_sisnan( temp ) ) value = temp
                 end do
              end do
           else if( ( stdlib_lsame( norm, 'O' ) ) .or. ( norm=='1' ) ) then
              ! find norm1(a).
              value = zero
              do j = 1, n
                 sum = zero
                 do i = max( ku+2-j, 1 ), min( n+ku+1-j, kl+ku+1 )
                    sum = sum + abs( ab( i, j ) )
                 end do
                 if( value<sum .or. stdlib_sisnan( sum ) ) value = sum
              end do
           else if( stdlib_lsame( norm, 'I' ) ) then
              ! find normi(a).
              do i = 1, n
                 work( i ) = zero
              end do
              do j = 1, n
                 k = ku + 1 - j
                 do i = max( 1, j-ku ), min( n, j+kl )
                    work( i ) = work( i ) + abs( ab( k+i, j ) )
                 end do
              end do
              value = zero
              do i = 1, n
                 temp = work( i )
                 if( value<temp .or. stdlib_sisnan( temp ) ) value = temp
              end do
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              do j = 1, n
                 l = max( 1, j-ku )
                 k = ku + 1 - j + l
                 call stdlib_classq( min( n, j+kl )-l+1, ab( k, j ), 1, scale, sum )
              end do
              value = scale*sqrt( sum )
           end if
           stdlib_clangb = value
           return
     end function stdlib_clangb


     real(sp)             function stdlib_clange( norm, m, n, a, lda, work )
     !! CLANGE returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! complex matrix A.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           real(sp), intent(out) :: work(*)
           complex(sp), intent(in) :: a(lda,*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: scale, sum, value, temp
           ! Intrinsic Functions 
           intrinsic :: abs,min,sqrt
           ! Executable Statements 
           if( min( m, n )==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              value = zero
              do j = 1, n
                 do i = 1, m
                    temp = abs( a( i, j ) )
                    if( value<temp .or. stdlib_sisnan( temp ) ) value = temp
                 end do
              end do
           else if( ( stdlib_lsame( norm, 'O' ) ) .or. ( norm=='1' ) ) then
              ! find norm1(a).
              value = zero
              do j = 1, n
                 sum = zero
                 do i = 1, m
                    sum = sum + abs( a( i, j ) )
                 end do
                 if( value<sum .or. stdlib_sisnan( sum ) ) value = sum
              end do
           else if( stdlib_lsame( norm, 'I' ) ) then
              ! find normi(a).
              do i = 1, m
                 work( i ) = zero
              end do
              do j = 1, n
                 do i = 1, m
                    work( i ) = work( i ) + abs( a( i, j ) )
                 end do
              end do
              value = zero
              do i = 1, m
                 temp = work( i )
                 if( value<temp .or. stdlib_sisnan( temp ) ) value = temp
              end do
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              do j = 1, n
                 call stdlib_classq( m, a( 1, j ), 1, scale, sum )
              end do
              value = scale*sqrt( sum )
           end if
           stdlib_clange = value
           return
     end function stdlib_clange


     pure real(sp)             function stdlib_clangt( norm, n, dl, d, du )
     !! CLANGT returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! complex tridiagonal matrix A.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           complex(sp), intent(in) :: d(*), dl(*), du(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(sp) :: anorm, scale, sum, temp
           ! Intrinsic Functions 
           intrinsic :: abs,sqrt
           ! Executable Statements 
           if( n<=0 ) then
              anorm = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              anorm = abs( d( n ) )
              do i = 1, n - 1
                 if( anorm<abs( dl( i ) ) .or. stdlib_sisnan( abs( dl( i ) ) ) )anorm = abs(dl(i))
                           
                 if( anorm<abs( d( i ) ) .or. stdlib_sisnan( abs( d( i ) ) ) )anorm = abs(d(i))
                           
                 if( anorm<abs( du( i ) ) .or. stdlib_sisnan (abs( du( i ) ) ) )anorm = abs(du(i))
                           
              end do
           else if( stdlib_lsame( norm, 'O' ) .or. norm=='1' ) then
              ! find norm1(a).
              if( n==1 ) then
                 anorm = abs( d( 1 ) )
              else
                 anorm = abs( d( 1 ) )+abs( dl( 1 ) )
                 temp = abs( d( n ) )+abs( du( n-1 ) )
                 if( anorm < temp .or. stdlib_sisnan( temp ) ) anorm = temp
                 do i = 2, n - 1
                    temp = abs( d( i ) )+abs( dl( i ) )+abs( du( i-1 ) )
                    if( anorm < temp .or. stdlib_sisnan( temp ) ) anorm = temp
                 end do
              end if
           else if( stdlib_lsame( norm, 'I' ) ) then
              ! find normi(a).
              if( n==1 ) then
                 anorm = abs( d( 1 ) )
              else
                 anorm = abs( d( 1 ) )+abs( du( 1 ) )
                 temp = abs( d( n ) )+abs( dl( n-1 ) )
                 if( anorm < temp .or. stdlib_sisnan( temp ) ) anorm = temp
                 do i = 2, n - 1
                    temp = abs( d( i ) )+abs( du( i ) )+abs( dl( i-1 ) )
                    if( anorm < temp .or. stdlib_sisnan( temp ) ) anorm = temp
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              call stdlib_classq( n, d, 1, scale, sum )
              if( n>1 ) then
                 call stdlib_classq( n-1, dl, 1, scale, sum )
                 call stdlib_classq( n-1, du, 1, scale, sum )
              end if
              anorm = scale*sqrt( sum )
           end if
           stdlib_clangt = anorm
           return
     end function stdlib_clangt


     real(sp)             function stdlib_clanhb( norm, uplo, n, k, ab, ldab,work )
     !! CLANHB returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the element of  largest absolute value  of an
     !! n by n hermitian band matrix A,  with k super-diagonals.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm, uplo
           integer(ilp), intent(in) :: k, ldab, n
           ! Array Arguments 
           real(sp), intent(out) :: work(*)
           complex(sp), intent(in) :: ab(ldab,*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, l
           real(sp) :: absa, scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,real,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    do i = max( k+2-j, 1 ), k
                       sum = abs( ab( i, j ) )
                       if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                    end do
                    sum = abs( real( ab( k+1, j ),KIND=sp) )
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              else
                 do j = 1, n
                    sum = abs( real( ab( 1, j ),KIND=sp) )
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                    do i = 2, min( n+1-j, k+1 )
                       sum = abs( ab( i, j ) )
                       if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                    end do
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'I' ) ) .or. ( stdlib_lsame( norm, 'O' ) ) .or.( &
                     norm=='1' ) ) then
              ! find normi(a) ( = norm1(a), since a is hermitian).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    sum = zero
                    l = k + 1 - j
                    do i = max( 1, j-k ), j - 1
                       absa = abs( ab( l+i, j ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                    end do
                    work( j ) = sum + abs( real( ab( k+1, j ),KIND=sp) )
                 end do
                 do i = 1, n
                    sum = work( i )
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              else
                 do i = 1, n
                    work( i ) = zero
                 end do
                 do j = 1, n
                    sum = work( j ) + abs( real( ab( 1, j ),KIND=sp) )
                    l = 1 - j
                    do i = j + 1, min( n, j+k )
                       absa = abs( ab( l+i, j ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                    end do
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              if( k>0 ) then
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    do j = 2, n
                       call stdlib_classq( min( j-1, k ), ab( max( k+2-j, 1 ), j ),1, scale, sum )
                                 
                    end do
                    l = k + 1
                 else
                    do j = 1, n - 1
                       call stdlib_classq( min( n-j, k ), ab( 2, j ), 1, scale,sum )
                    end do
                    l = 1
                 end if
                 sum = 2*sum
              else
                 l = 1
              end if
              do j = 1, n
                 if( real( ab( l, j ),KIND=sp)/=zero ) then
                    absa = abs( real( ab( l, j ),KIND=sp) )
                    if( scale<absa ) then
                       sum = one + sum*( scale / absa )**2
                       scale = absa
                    else
                       sum = sum + ( absa / scale )**2
                    end if
                 end if
              end do
              value = scale*sqrt( sum )
           end if
           stdlib_clanhb = value
           return
     end function stdlib_clanhb


     real(sp)             function stdlib_clanhe( norm, uplo, n, a, lda, work )
     !! CLANHE returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! complex hermitian matrix A.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm, uplo
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(sp), intent(out) :: work(*)
           complex(sp), intent(in) :: a(lda,*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: absa, scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,real,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    do i = 1, j - 1
                       sum = abs( a( i, j ) )
                       if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                    end do
                    sum = abs( real( a( j, j ),KIND=sp) )
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              else
                 do j = 1, n
                    sum = abs( real( a( j, j ),KIND=sp) )
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                    do i = j + 1, n
                       sum = abs( a( i, j ) )
                       if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                    end do
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'I' ) ) .or. ( stdlib_lsame( norm, 'O' ) ) .or.( &
                     norm=='1' ) ) then
              ! find normi(a) ( = norm1(a), since a is hermitian).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    sum = zero
                    do i = 1, j - 1
                       absa = abs( a( i, j ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                    end do
                    work( j ) = sum + abs( real( a( j, j ),KIND=sp) )
                 end do
                 do i = 1, n
                    sum = work( i )
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              else
                 do i = 1, n
                    work( i ) = zero
                 end do
                 do j = 1, n
                    sum = work( j ) + abs( real( a( j, j ),KIND=sp) )
                    do i = j + 1, n
                       absa = abs( a( i, j ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                    end do
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 2, n
                    call stdlib_classq( j-1, a( 1, j ), 1, scale, sum )
                 end do
              else
                 do j = 1, n - 1
                    call stdlib_classq( n-j, a( j+1, j ), 1, scale, sum )
                 end do
              end if
              sum = 2*sum
              do i = 1, n
                 if( real( a( i, i ),KIND=sp)/=zero ) then
                    absa = abs( real( a( i, i ),KIND=sp) )
                    if( scale<absa ) then
                       sum = one + sum*( scale / absa )**2
                       scale = absa
                    else
                       sum = sum + ( absa / scale )**2
                    end if
                 end if
              end do
              value = scale*sqrt( sum )
           end if
           stdlib_clanhe = value
           return
     end function stdlib_clanhe


     real(sp) function stdlib_clanhf( norm, transr, uplo, n, a, work )
     !! CLANHF returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! complex Hermitian matrix A in RFP format.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm, transr, uplo
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(sp), intent(out) :: work(0:*)
           complex(sp), intent(in) :: a(0:*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, ifm, ilu, noe, n1, k, l, lda
           real(sp) :: scale, s, value, aa, temp
           ! Intrinsic Functions 
           intrinsic :: abs,real,sqrt
           ! Executable Statements 
           if( n==0 ) then
              stdlib_clanhf = zero
              return
           else if( n==1 ) then
              stdlib_clanhf = abs(real(a(0),KIND=sp))
              return
           end if
           ! set noe = 1 if n is odd. if n is even set noe=0
           noe = 1
           if( mod( n, 2 )==0 )noe = 0
           ! set ifm = 0 when form='c' or 'c' and 1 otherwise
           ifm = 1
           if( stdlib_lsame( transr, 'C' ) )ifm = 0
           ! set ilu = 0 when uplo='u or 'u' and 1 otherwise
           ilu = 1
           if( stdlib_lsame( uplo, 'U' ) )ilu = 0
           ! set lda = (n+1)/2 when ifm = 0
           ! set lda = n when ifm = 1 and noe = 1
           ! set lda = n+1 when ifm = 1 and noe = 0
           if( ifm==1 ) then
              if( noe==1 ) then
                 lda = n
              else
                 ! noe=0
                 lda = n + 1
              end if
           else
              ! ifm=0
              lda = ( n+1 ) / 2
           end if
           if( stdlib_lsame( norm, 'M' ) ) then
             ! find max(abs(a(i,j))).
              k = ( n+1 ) / 2
              value = zero
              if( noe==1 ) then
                 ! n is odd
                 if( ifm==1 ) then
                    ! a is n by k
                    if( ilu==1 ) then
                       ! uplo ='l'
                       j = 0
                       ! -> l(0,0)
                       temp = abs( real( a( j+j*lda ),KIND=sp) )
                       if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       do i = 1, n - 1
                          temp = abs( a( i+j*lda ) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       end do
                       do j = 1, k - 1
                          do i = 0, j - 2
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                          i = j - 1
                          ! l(k+j,k+j)
                          temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          i = j
                          ! -> l(j,j)
                          temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          do i = j + 1, n - 1
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                       end do
                    else
                       ! uplo = 'u'
                       do j = 0, k - 2
                          do i = 0, k + j - 2
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                          i = k + j - 1
                          ! -> u(i,i)
                          temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          i = i + 1
                          ! =k+j; i -> u(j,j)
                          temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          do i = k + j + 1, n - 1
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                       end do
                       do i = 0, n - 2
                          temp = abs( a( i+j*lda ) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          ! j=k-1
                       end do
                       ! i=n-1 -> u(n-1,n-1)
                       temp = abs( real( a( i+j*lda ),KIND=sp) )
                       if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                    end if
                 else
                    ! xpose case; a is k by n
                    if( ilu==1 ) then
                       ! uplo ='l'
                       do j = 0, k - 2
                          do i = 0, j - 1
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                          i = j
                          ! l(i,i)
                          temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          i = j + 1
                          ! l(j+k,j+k)
                          temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          do i = j + 2, k - 1
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                       end do
                       j = k - 1
                       do i = 0, k - 2
                          temp = abs( a( i+j*lda ) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       end do
                       i = k - 1
                       ! -> l(i,i) is at a(i,j)
                       temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       do j = k, n - 1
                          do i = 0, k - 1
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                       end do
                    else
                       ! uplo = 'u'
                       do j = 0, k - 2
                          do i = 0, k - 1
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                       end do
                       j = k - 1
                       ! -> u(j,j) is at a(0,j)
                       temp = abs( real( a( 0+j*lda ),KIND=sp) )
                       if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       do i = 1, k - 1
                          temp = abs( a( i+j*lda ) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       end do
                       do j = k, n - 1
                          do i = 0, j - k - 1
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                          i = j - k
                          ! -> u(i,i) at a(i,j)
                          temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          i = j - k + 1
                          ! u(j,j)
                          temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          do i = j - k + 2, k - 1
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                       end do
                    end if
                 end if
              else
                 ! n is even
                 if( ifm==1 ) then
                    ! a is n+1 by k
                    if( ilu==1 ) then
                       ! uplo ='l'
                       j = 0
                       ! -> l(k,k)
                       temp = abs( real( a( j+j*lda ),KIND=sp) )
                       if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       temp = abs( real( a( j+1+j*lda ),KIND=sp) )
                       if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       do i = 2, n
                          temp = abs( a( i+j*lda ) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       end do
                       do j = 1, k - 1
                          do i = 0, j - 1
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                          i = j
                          ! l(k+j,k+j)
                          temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          i = j + 1
                          ! -> l(j,j)
                          temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          do i = j + 2, n
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                       end do
                    else
                       ! uplo = 'u'
                       do j = 0, k - 2
                          do i = 0, k + j - 1
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                          i = k + j
                          ! -> u(i,i)
                          temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          i = i + 1
                          ! =k+j+1; i -> u(j,j)
                          temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          do i = k + j + 2, n
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                       end do
                       do i = 0, n - 2
                          temp = abs( a( i+j*lda ) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       ! j=k-1
                       end do
                       ! i=n-1 -> u(n-1,n-1)
                       temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       i = n
                       ! -> u(k-1,k-1)
                       temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                    end if
                 else
                    ! xpose case; a is k by n+1
                    if( ilu==1 ) then
                       ! uplo ='l'
                       j = 0
                       ! -> l(k,k) at a(0,0)
                       temp = abs( real( a( j+j*lda ),KIND=sp) )
                       if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       do i = 1, k - 1
                          temp = abs( a( i+j*lda ) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       end do
                       do j = 1, k - 1
                          do i = 0, j - 2
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                          i = j - 1
                          ! l(i,i)
                          temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          i = j
                          ! l(j+k,j+k)
                          temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          do i = j + 1, k - 1
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                       end do
                       j = k
                       do i = 0, k - 2
                          temp = abs( a( i+j*lda ) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       end do
                       i = k - 1
                       ! -> l(i,i) is at a(i,j)
                       temp = abs( real( a( i+j*lda ),KIND=sp) )
                       if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       do j = k + 1, n
                          do i = 0, k - 1
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                       end do
                    else
                       ! uplo = 'u'
                       do j = 0, k - 1
                          do i = 0, k - 1
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                       end do
                       j = k
                       ! -> u(j,j) is at a(0,j)
                       temp = abs( real( a( 0+j*lda ),KIND=sp) )
                       if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       do i = 1, k - 1
                          temp = abs( a( i+j*lda ) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       end do
                       do j = k + 1, n - 1
                          do i = 0, j - k - 2
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                          i = j - k - 1
                          ! -> u(i,i) at a(i,j)
                          temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          i = j - k
                          ! u(j,j)
                          temp = abs( real( a( i+j*lda ),KIND=sp) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          do i = j - k + 1, k - 1
                             temp = abs( a( i+j*lda ) )
                             if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                          end do
                       end do
                       j = n
                       do i = 0, k - 2
                          temp = abs( a( i+j*lda ) )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       end do
                       i = k - 1
                       ! u(k,k) at a(i,j)
                       temp = abs( real( a( i+j*lda ),KIND=sp) )
                       if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                    end if
                 end if
              end if
           else if( ( stdlib_lsame( norm, 'I' ) ) .or. ( stdlib_lsame( norm, 'O' ) ) .or.( &
                     norm=='1' ) ) then
             ! find normi(a) ( = norm1(a), since a is hermitian).
              if( ifm==1 ) then
                 ! a is 'n'
                 k = n / 2
                 if( noe==1 ) then
                    ! n is odd
                    if( ilu==0 ) then
                       ! uplo = 'u'
                       do i = 0, k - 1
                          work( i ) = zero
                       end do
                       do j = 0, k
                          s = zero
                          do i = 0, k + j - 1
                             aa = abs( a( i+j*lda ) )
                             ! -> a(i,j+k)
                             s = s + aa
                             work( i ) = work( i ) + aa
                          end do
                          aa = abs( real( a( i+j*lda ),KIND=sp) )
                          ! -> a(j+k,j+k)
                          work( j+k ) = s + aa
                          if( i==k+k )go to 10
                          i = i + 1
                          aa = abs( real( a( i+j*lda ),KIND=sp) )
                          ! -> a(j,j)
                          work( j ) = work( j ) + aa
                          s = zero
                          do l = j + 1, k - 1
                             i = i + 1
                             aa = abs( a( i+j*lda ) )
                             ! -> a(l,j)
                             s = s + aa
                             work( l ) = work( l ) + aa
                          end do
                          work( j ) = work( j ) + s
                       end do
                       10 continue
                       value = work( 0 )
                       do i = 1, n-1
                          temp = work( i )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       end do
                    else
                       ! ilu = 1
                       k = k + 1
                       ! k=(n+1)/2 for n odd and ilu=1
                       do i = k, n - 1
                          work( i ) = zero
                       end do
                       do j = k - 1, 0, -1
                          s = zero
                          do i = 0, j - 2
                             aa = abs( a( i+j*lda ) )
                             ! -> a(j+k,i+k)
                             s = s + aa
                             work( i+k ) = work( i+k ) + aa
                          end do
                          if( j>0 ) then
                             aa = abs( real( a( i+j*lda ),KIND=sp) )
                             ! -> a(j+k,j+k)
                             s = s + aa
                             work( i+k ) = work( i+k ) + s
                             ! i=j
                             i = i + 1
                          end if
                          aa = abs( real( a( i+j*lda ),KIND=sp) )
                          ! -> a(j,j)
                          work( j ) = aa
                          s = zero
                          do l = j + 1, n - 1
                             i = i + 1
                             aa = abs( a( i+j*lda ) )
                             ! -> a(l,j)
                             s = s + aa
                             work( l ) = work( l ) + aa
                          end do
                          work( j ) = work( j ) + s
                       end do
                       value = work( 0 )
                       do i = 1, n-1
                          temp = work( i )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       end do
                    end if
                 else
                    ! n is even
                    if( ilu==0 ) then
                       ! uplo = 'u'
                       do i = 0, k - 1
                          work( i ) = zero
                       end do
                       do j = 0, k - 1
                          s = zero
                          do i = 0, k + j - 1
                             aa = abs( a( i+j*lda ) )
                             ! -> a(i,j+k)
                             s = s + aa
                             work( i ) = work( i ) + aa
                          end do
                          aa = abs( real( a( i+j*lda ),KIND=sp) )
                          ! -> a(j+k,j+k)
                          work( j+k ) = s + aa
                          i = i + 1
                          aa = abs( real( a( i+j*lda ),KIND=sp) )
                          ! -> a(j,j)
                          work( j ) = work( j ) + aa
                          s = zero
                          do l = j + 1, k - 1
                             i = i + 1
                             aa = abs( a( i+j*lda ) )
                             ! -> a(l,j)
                             s = s + aa
                             work( l ) = work( l ) + aa
                          end do
                          work( j ) = work( j ) + s
                       end do
                       value = work( 0 )
                       do i = 1, n-1
                          temp = work( i )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       end do
                    else
                       ! ilu = 1
                       do i = k, n - 1
                          work( i ) = zero
                       end do
                       do j = k - 1, 0, -1
                          s = zero
                          do i = 0, j - 1
                             aa = abs( a( i+j*lda ) )
                             ! -> a(j+k,i+k)
                             s = s + aa
                             work( i+k ) = work( i+k ) + aa
                          end do
                          aa = abs( real( a( i+j*lda ),KIND=sp) )
                          ! -> a(j+k,j+k)
                          s = s + aa
                          work( i+k ) = work( i+k ) + s
                          ! i=j
                          i = i + 1
                          aa = abs( real( a( i+j*lda ),KIND=sp) )
                          ! -> a(j,j)
                          work( j ) = aa
                          s = zero
                          do l = j + 1, n - 1
                             i = i + 1
                             aa = abs( a( i+j*lda ) )
                             ! -> a(l,j)
                             s = s + aa
                             work( l ) = work( l ) + aa
                          end do
                          work( j ) = work( j ) + s
                       end do
                       value = work( 0 )
                       do i = 1, n-1
                          temp = work( i )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       end do
                    end if
                 end if
              else
                 ! ifm=0
                 k = n / 2
                 if( noe==1 ) then
                    ! n is odd
                    if( ilu==0 ) then
                       ! uplo = 'u'
                       n1 = k
                       ! n/2
                       k = k + 1
                       ! k is the row size and lda
                       do i = n1, n - 1
                          work( i ) = zero
                       end do
                       do j = 0, n1 - 1
                          s = zero
                          do i = 0, k - 1
                             aa = abs( a( i+j*lda ) )
                             ! a(j,n1+i)
                             work( i+n1 ) = work( i+n1 ) + aa
                             s = s + aa
                          end do
                          work( j ) = s
                       end do
                       ! j=n1=k-1 is special
                       s = abs( real( a( 0+j*lda ),KIND=sp) )
                       ! a(k-1,k-1)
                       do i = 1, k - 1
                          aa = abs( a( i+j*lda ) )
                          ! a(k-1,i+n1)
                          work( i+n1 ) = work( i+n1 ) + aa
                          s = s + aa
                       end do
                       work( j ) = work( j ) + s
                       do j = k, n - 1
                          s = zero
                          do i = 0, j - k - 1
                             aa = abs( a( i+j*lda ) )
                             ! a(i,j-k)
                             work( i ) = work( i ) + aa
                             s = s + aa
                          end do
                          ! i=j-k
                          aa = abs( real( a( i+j*lda ),KIND=sp) )
                          ! a(j-k,j-k)
                          s = s + aa
                          work( j-k ) = work( j-k ) + s
                          i = i + 1
                          s = abs( real( a( i+j*lda ),KIND=sp) )
                          ! a(j,j)
                          do l = j + 1, n - 1
                             i = i + 1
                             aa = abs( a( i+j*lda ) )
                             ! a(j,l)
                             work( l ) = work( l ) + aa
                             s = s + aa
                          end do
                          work( j ) = work( j ) + s
                       end do
                       value = work( 0 )
                       do i = 1, n-1
                          temp = work( i )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       end do
                    else
                       ! ilu=1
                       k = k + 1
                       ! k=(n+1)/2 for n odd and ilu=1
                       do i = k, n - 1
                          work( i ) = zero
                       end do
                       do j = 0, k - 2
                          ! process
                          s = zero
                          do i = 0, j - 1
                             aa = abs( a( i+j*lda ) )
                             ! a(j,i)
                             work( i ) = work( i ) + aa
                             s = s + aa
                          end do
                          aa = abs( real( a( i+j*lda ),KIND=sp) )
                          ! i=j so process of a(j,j)
                          s = s + aa
                          work( j ) = s
                          ! is initialised here
                          i = i + 1
                          ! i=j process a(j+k,j+k)
                          aa = abs( real( a( i+j*lda ),KIND=sp) )
                          s = aa
                          do l = k + j + 1, n - 1
                             i = i + 1
                             aa = abs( a( i+j*lda ) )
                             ! a(l,k+j)
                             s = s + aa
                             work( l ) = work( l ) + aa
                          end do
                          work( k+j ) = work( k+j ) + s
                       end do
                       ! j=k-1 is special :process col a(k-1,0:k-1)
                       s = zero
                       do i = 0, k - 2
                          aa = abs( a( i+j*lda ) )
                          ! a(k,i)
                          work( i ) = work( i ) + aa
                          s = s + aa
                       end do
                       ! i=k-1
                       aa = abs( real( a( i+j*lda ),KIND=sp) )
                       ! a(k-1,k-1)
                       s = s + aa
                       work( i ) = s
                       ! done with col j=k+1
                       do j = k, n - 1
                          ! process col j of a = a(j,0:k-1)
                          s = zero
                          do i = 0, k - 1
                             aa = abs( a( i+j*lda ) )
                             ! a(j,i)
                             work( i ) = work( i ) + aa
                             s = s + aa
                          end do
                          work( j ) = work( j ) + s
                       end do
                       value = work( 0 )
                       do i = 1, n-1
                          temp = work( i )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       end do
                    end if
                 else
                    ! n is even
                    if( ilu==0 ) then
                       ! uplo = 'u'
                       do i = k, n - 1
                          work( i ) = zero
                       end do
                       do j = 0, k - 1
                          s = zero
                          do i = 0, k - 1
                             aa = abs( a( i+j*lda ) )
                             ! a(j,i+k)
                             work( i+k ) = work( i+k ) + aa
                             s = s + aa
                          end do
                          work( j ) = s
                       end do
                       ! j=k
                       aa = abs( real( a( 0+j*lda ),KIND=sp) )
                       ! a(k,k)
                       s = aa
                       do i = 1, k - 1
                          aa = abs( a( i+j*lda ) )
                          ! a(k,k+i)
                          work( i+k ) = work( i+k ) + aa
                          s = s + aa
                       end do
                       work( j ) = work( j ) + s
                       do j = k + 1, n - 1
                          s = zero
                          do i = 0, j - 2 - k
                             aa = abs( a( i+j*lda ) )
                             ! a(i,j-k-1)
                             work( i ) = work( i ) + aa
                             s = s + aa
                          end do
                          ! i=j-1-k
                          aa = abs( real( a( i+j*lda ),KIND=sp) )
                          ! a(j-k-1,j-k-1)
                          s = s + aa
                          work( j-k-1 ) = work( j-k-1 ) + s
                          i = i + 1
                          aa = abs( real( a( i+j*lda ),KIND=sp) )
                          ! a(j,j)
                          s = aa
                          do l = j + 1, n - 1
                             i = i + 1
                             aa = abs( a( i+j*lda ) )
                             ! a(j,l)
                             work( l ) = work( l ) + aa
                             s = s + aa
                          end do
                          work( j ) = work( j ) + s
                       end do
                       ! j=n
                       s = zero
                       do i = 0, k - 2
                          aa = abs( a( i+j*lda ) )
                          ! a(i,k-1)
                          work( i ) = work( i ) + aa
                          s = s + aa
                       end do
                       ! i=k-1
                       aa = abs( real( a( i+j*lda ),KIND=sp) )
                       ! a(k-1,k-1)
                       s = s + aa
                       work( i ) = work( i ) + s
                       value = work( 0 )
                       do i = 1, n-1
                          temp = work( i )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       end do
                    else
                       ! ilu=1
                       do i = k, n - 1
                          work( i ) = zero
                       end do
                       ! j=0 is special :process col a(k:n-1,k)
                       s = abs( real( a( 0 ),KIND=sp) )
                       ! a(k,k)
                       do i = 1, k - 1
                          aa = abs( a( i ) )
                          ! a(k+i,k)
                          work( i+k ) = work( i+k ) + aa
                          s = s + aa
                       end do
                       work( k ) = work( k ) + s
                       do j = 1, k - 1
                          ! process
                          s = zero
                          do i = 0, j - 2
                             aa = abs( a( i+j*lda ) )
                             ! a(j-1,i)
                             work( i ) = work( i ) + aa
                             s = s + aa
                          end do
                          aa = abs( real( a( i+j*lda ),KIND=sp) )
                          ! i=j-1 so process of a(j-1,j-1)
                          s = s + aa
                          work( j-1 ) = s
                          ! is initialised here
                          i = i + 1
                          ! i=j process a(j+k,j+k)
                          aa = abs( real( a( i+j*lda ),KIND=sp) )
                          s = aa
                          do l = k + j + 1, n - 1
                             i = i + 1
                             aa = abs( a( i+j*lda ) )
                             ! a(l,k+j)
                             s = s + aa
                             work( l ) = work( l ) + aa
                          end do
                          work( k+j ) = work( k+j ) + s
                       end do
                       ! j=k is special :process col a(k,0:k-1)
                       s = zero
                       do i = 0, k - 2
                          aa = abs( a( i+j*lda ) )
                          ! a(k,i)
                          work( i ) = work( i ) + aa
                          s = s + aa
                       end do
                       ! i=k-1
                       aa = abs( real( a( i+j*lda ),KIND=sp) )
                       ! a(k-1,k-1)
                       s = s + aa
                       work( i ) = s
                       ! done with col j=k+1
                       do j = k + 1, n
                          ! process col j-1 of a = a(j-1,0:k-1)
                          s = zero
                          do i = 0, k - 1
                             aa = abs( a( i+j*lda ) )
                             ! a(j-1,i)
                             work( i ) = work( i ) + aa
                             s = s + aa
                          end do
                          work( j-1 ) = work( j-1 ) + s
                       end do
                       value = work( 0 )
                       do i = 1, n-1
                          temp = work( i )
                          if( value < temp .or. stdlib_sisnan( temp ) )value = temp
                       end do
                    end if
                 end if
              end if
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
             ! find normf(a).
              k = ( n+1 ) / 2
              scale = zero
              s = one
              if( noe==1 ) then
                 ! n is odd
                 if( ifm==1 ) then
                    ! a is normal
                    if( ilu==0 ) then
                       ! a is upper
                       do j = 0, k - 3
                          call stdlib_classq( k-j-2, a( k+j+1+j*lda ), 1, scale, s )
                          ! l at a(k,0)
                       end do
                       do j = 0, k - 1
                          call stdlib_classq( k+j-1, a( 0+j*lda ), 1, scale, s )
                          ! trap u at a(0,0)
                       end do
                       s = s + s
                       ! double s for the off diagonal elements
                       l = k - 1
                       ! -> u(k,k) at a(k-1,0)
                       do i = 0, k - 2
                          aa = real( a( l ),KIND=sp)
                          ! u(k+i,k+i)
                          if( aa/=zero ) then
                             if( scale<aa ) then
                                s = one + s*( scale / aa )**2
                                scale = aa
                             else
                                s = s + ( aa / scale )**2
                             end if
                          end if
                          aa = real( a( l+1 ),KIND=sp)
                          ! u(i,i)
                          if( aa/=zero ) then
                             if( scale<aa ) then
                                s = one + s*( scale / aa )**2
                                scale = aa
                             else
                                s = s + ( aa / scale )**2
                             end if
                          end if
                          l = l + lda + 1
                       end do
                       aa = real( a( l ),KIND=sp)
                       ! u(n-1,n-1)
                       if( aa/=zero ) then
                          if( scale<aa ) then
                             s = one + s*( scale / aa )**2
                             scale = aa
                          else
                             s = s + ( aa / scale )**2
                          end if
                       end if
                    else
                       ! ilu=1
                       do j = 0, k - 1
                          call stdlib_classq( n-j-1, a( j+1+j*lda ), 1, scale, s )
                          ! trap l at a(0,0)
                       end do
                       do j = 1, k - 2
                          call stdlib_classq( j, a( 0+( 1+j )*lda ), 1, scale, s )
                          ! u at a(0,1)
                       end do
                       s = s + s
                       ! double s for the off diagonal elements
                       aa = real( a( 0 ),KIND=sp)
                       ! l(0,0) at a(0,0)
                       if( aa/=zero ) then
                          if( scale<aa ) then
                             s = one + s*( scale / aa )**2
                             scale = aa
                          else
                             s = s + ( aa / scale )**2
                          end if
                       end if
                       l = lda
                       ! -> l(k,k) at a(0,1)
                       do i = 1, k - 1
                          aa = real( a( l ),KIND=sp)
                          ! l(k-1+i,k-1+i)
                          if( aa/=zero ) then
                             if( scale<aa ) then
                                s = one + s*( scale / aa )**2
                                scale = aa
                             else
                                s = s + ( aa / scale )**2
                             end if
                          end if
                          aa = real( a( l+1 ),KIND=sp)
                          ! l(i,i)
                          if( aa/=zero ) then
                             if( scale<aa ) then
                                s = one + s*( scale / aa )**2
                                scale = aa
                             else
                                s = s + ( aa / scale )**2
                             end if
                          end if
                          l = l + lda + 1
                       end do
                    end if
                 else
                    ! a is xpose
                    if( ilu==0 ) then
                       ! a**h is upper
                       do j = 1, k - 2
                          call stdlib_classq( j, a( 0+( k+j )*lda ), 1, scale, s )
                          ! u at a(0,k)
                       end do
                       do j = 0, k - 2
                          call stdlib_classq( k, a( 0+j*lda ), 1, scale, s )
                          ! k by k-1 rect. at a(0,0)
                       end do
                       do j = 0, k - 2
                          call stdlib_classq( k-j-1, a( j+1+( j+k-1 )*lda ), 1,scale, s )
                          ! l at a(0,k-1)
                       end do
                       s = s + s
                       ! double s for the off diagonal elements
                       l = 0 + k*lda - lda
                       ! -> u(k-1,k-1) at a(0,k-1)
                       aa = real( a( l ),KIND=sp)
                       ! u(k-1,k-1)
                       if( aa/=zero ) then
                          if( scale<aa ) then
                             s = one + s*( scale / aa )**2
                             scale = aa
                          else
                             s = s + ( aa / scale )**2
                          end if
                       end if
                       l = l + lda
                       ! -> u(0,0) at a(0,k)
                       do j = k, n - 1
                          aa = real( a( l ),KIND=sp)
                          ! -> u(j-k,j-k)
                          if( aa/=zero ) then
                             if( scale<aa ) then
                                s = one + s*( scale / aa )**2
                                scale = aa
                             else
                                s = s + ( aa / scale )**2
                             end if
                          end if
                          aa = real( a( l+1 ),KIND=sp)
                          ! -> u(j,j)
                          if( aa/=zero ) then
                             if( scale<aa ) then
                                s = one + s*( scale / aa )**2
                                scale = aa
                             else
                                s = s + ( aa / scale )**2
                             end if
                          end if
                          l = l + lda + 1
                       end do
                    else
                       ! a**h is lower
                       do j = 1, k - 1
                          call stdlib_classq( j, a( 0+j*lda ), 1, scale, s )
                          ! u at a(0,0)
                       end do
                       do j = k, n - 1
                          call stdlib_classq( k, a( 0+j*lda ), 1, scale, s )
                          ! k by k-1 rect. at a(0,k)
                       end do
                       do j = 0, k - 3
                          call stdlib_classq( k-j-2, a( j+2+j*lda ), 1, scale, s )
                          ! l at a(1,0)
                       end do
                       s = s + s
                       ! double s for the off diagonal elements
                       l = 0
                       ! -> l(0,0) at a(0,0)
                       do i = 0, k - 2
                          aa = real( a( l ),KIND=sp)
                          ! l(i,i)
                          if( aa/=zero ) then
                             if( scale<aa ) then
                                s = one + s*( scale / aa )**2
                                scale = aa
                             else
                                s = s + ( aa / scale )**2
                             end if
                          end if
                          aa = real( a( l+1 ),KIND=sp)
                          ! l(k+i,k+i)
                          if( aa/=zero ) then
                             if( scale<aa ) then
                                s = one + s*( scale / aa )**2
                                scale = aa
                             else
                                s = s + ( aa / scale )**2
                             end if
                          end if
                          l = l + lda + 1
                       end do
                       ! l-> k-1 + (k-1)*lda or l(k-1,k-1) at a(k-1,k-1)
                       aa = real( a( l ),KIND=sp)
                       ! l(k-1,k-1) at a(k-1,k-1)
                       if( aa/=zero ) then
                          if( scale<aa ) then
                             s = one + s*( scale / aa )**2
                             scale = aa
                          else
                             s = s + ( aa / scale )**2
                          end if
                       end if
                    end if
                 end if
              else
                 ! n is even
                 if( ifm==1 ) then
                    ! a is normal
                    if( ilu==0 ) then
                       ! a is upper
                       do j = 0, k - 2
                          call stdlib_classq( k-j-1, a( k+j+2+j*lda ), 1, scale, s )
                       ! l at a(k+1,0)
                       end do
                       do j = 0, k - 1
                          call stdlib_classq( k+j, a( 0+j*lda ), 1, scale, s )
                       ! trap u at a(0,0)
                       end do
                       s = s + s
                       ! double s for the off diagonal elements
                       l = k
                       ! -> u(k,k) at a(k,0)
                       do i = 0, k - 1
                          aa = real( a( l ),KIND=sp)
                          ! u(k+i,k+i)
                          if( aa/=zero ) then
                             if( scale<aa ) then
                                s = one + s*( scale / aa )**2
                                scale = aa
                             else
                                s = s + ( aa / scale )**2
                             end if
                          end if
                          aa = real( a( l+1 ),KIND=sp)
                          ! u(i,i)
                          if( aa/=zero ) then
                             if( scale<aa ) then
                                s = one + s*( scale / aa )**2
                                scale = aa
                             else
                                s = s + ( aa / scale )**2
                             end if
                          end if
                          l = l + lda + 1
                       end do
                    else
                       ! ilu=1
                       do j = 0, k - 1
                          call stdlib_classq( n-j-1, a( j+2+j*lda ), 1, scale, s )
                          ! trap l at a(1,0)
                       end do
                       do j = 1, k - 1
                          call stdlib_classq( j, a( 0+j*lda ), 1, scale, s )
                          ! u at a(0,0)
                       end do
                       s = s + s
                       ! double s for the off diagonal elements
                       l = 0
                       ! -> l(k,k) at a(0,0)
                       do i = 0, k - 1
                          aa = real( a( l ),KIND=sp)
                          ! l(k-1+i,k-1+i)
                          if( aa/=zero ) then
                             if( scale<aa ) then
                                s = one + s*( scale / aa )**2
                                scale = aa
                             else
                                s = s + ( aa / scale )**2
                             end if
                          end if
                          aa = real( a( l+1 ),KIND=sp)
                          ! l(i,i)
                          if( aa/=zero ) then
                             if( scale<aa ) then
                                s = one + s*( scale / aa )**2
                                scale = aa
                             else
                                s = s + ( aa / scale )**2
                             end if
                          end if
                          l = l + lda + 1
                       end do
                    end if
                 else
                    ! a is xpose
                    if( ilu==0 ) then
                       ! a**h is upper
                       do j = 1, k - 1
                          call stdlib_classq( j, a( 0+( k+1+j )*lda ), 1, scale, s )
                       ! u at a(0,k+1)
                       end do
                       do j = 0, k - 1
                          call stdlib_classq( k, a( 0+j*lda ), 1, scale, s )
                       ! k by k rect. at a(0,0)
                       end do
                       do j = 0, k - 2
                          call stdlib_classq( k-j-1, a( j+1+( j+k )*lda ), 1, scale,s )
                       ! l at a(0,k)
                       end do
                       s = s + s
                       ! double s for the off diagonal elements
                       l = 0 + k*lda
                       ! -> u(k,k) at a(0,k)
                       aa = real( a( l ),KIND=sp)
                       ! u(k,k)
                       if( aa/=zero ) then
                          if( scale<aa ) then
                             s = one + s*( scale / aa )**2
                             scale = aa
                          else
                             s = s + ( aa / scale )**2
                          end if
                       end if
                       l = l + lda
                       ! -> u(0,0) at a(0,k+1)
                       do j = k + 1, n - 1
                          aa = real( a( l ),KIND=sp)
                          ! -> u(j-k-1,j-k-1)
                          if( aa/=zero ) then
                             if( scale<aa ) then
                                s = one + s*( scale / aa )**2
                                scale = aa
                             else
                                s = s + ( aa / scale )**2
                             end if
                          end if
                          aa = real( a( l+1 ),KIND=sp)
                          ! -> u(j,j)
                          if( aa/=zero ) then
                             if( scale<aa ) then
                                s = one + s*( scale / aa )**2
                                scale = aa
                             else
                                s = s + ( aa / scale )**2
                             end if
                          end if
                          l = l + lda + 1
                       end do
                       ! l=k-1+n*lda
                       ! -> u(k-1,k-1) at a(k-1,n)
                       aa = real( a( l ),KIND=sp)
                       ! u(k,k)
                       if( aa/=zero ) then
                          if( scale<aa ) then
                             s = one + s*( scale / aa )**2
                             scale = aa
                          else
                             s = s + ( aa / scale )**2
                          end if
                       end if
                    else
                       ! a**h is lower
                       do j = 1, k - 1
                          call stdlib_classq( j, a( 0+( j+1 )*lda ), 1, scale, s )
                       ! u at a(0,1)
                       end do
                       do j = k + 1, n
                          call stdlib_classq( k, a( 0+j*lda ), 1, scale, s )
                       ! k by k rect. at a(0,k+1)
                       end do
                       do j = 0, k - 2
                          call stdlib_classq( k-j-1, a( j+1+j*lda ), 1, scale, s )
                       ! l at a(0,0)
                       end do
                       s = s + s
                       ! double s for the off diagonal elements
                       l = 0
                       ! -> l(k,k) at a(0,0)
                       aa = real( a( l ),KIND=sp)
                       ! l(k,k) at a(0,0)
                       if( aa/=zero ) then
                          if( scale<aa ) then
                             s = one + s*( scale / aa )**2
                             scale = aa
                          else
                             s = s + ( aa / scale )**2
                          end if
                       end if
                       l = lda
                       ! -> l(0,0) at a(0,1)
                       do i = 0, k - 2
                          aa = real( a( l ),KIND=sp)
                          ! l(i,i)
                          if( aa/=zero ) then
                             if( scale<aa ) then
                                s = one + s*( scale / aa )**2
                                scale = aa
                             else
                                s = s + ( aa / scale )**2
                             end if
                          end if
                          aa = real( a( l+1 ),KIND=sp)
                          ! l(k+i+1,k+i+1)
                          if( aa/=zero ) then
                             if( scale<aa ) then
                                s = one + s*( scale / aa )**2
                                scale = aa
                             else
                                s = s + ( aa / scale )**2
                             end if
                          end if
                          l = l + lda + 1
                       end do
                       ! l-> k - 1 + k*lda or l(k-1,k-1) at a(k-1,k)
                       aa = real( a( l ),KIND=sp)
                       ! l(k-1,k-1) at a(k-1,k)
                       if( aa/=zero ) then
                          if( scale<aa ) then
                             s = one + s*( scale / aa )**2
                             scale = aa
                          else
                             s = s + ( aa / scale )**2
                          end if
                       end if
                    end if
                 end if
              end if
              value = scale*sqrt( s )
           end if
           stdlib_clanhf = value
           return
     end function stdlib_clanhf


     real(sp)             function stdlib_clanhp( norm, uplo, n, ap, work )
     !! CLANHP returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! complex hermitian matrix A,  supplied in packed form.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm, uplo
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(sp), intent(out) :: work(*)
           complex(sp), intent(in) :: ap(*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, k
           real(sp) :: absa, scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,real,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 k = 0
                 do j = 1, n
                    do i = k + 1, k + j - 1
                       sum = abs( ap( i ) )
                       if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                    end do
                    k = k + j
                    sum = abs( real( ap( k ),KIND=sp) )
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              else
                 k = 1
                 do j = 1, n
                    sum = abs( real( ap( k ),KIND=sp) )
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                    do i = k + 1, k + n - j
                       sum = abs( ap( i ) )
                       if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                    end do
                    k = k + n - j + 1
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'I' ) ) .or. ( stdlib_lsame( norm, 'O' ) ) .or.( &
                     norm=='1' ) ) then
              ! find normi(a) ( = norm1(a), since a is hermitian).
              value = zero
              k = 1
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    sum = zero
                    do i = 1, j - 1
                       absa = abs( ap( k ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                       k = k + 1
                    end do
                    work( j ) = sum + abs( real( ap( k ),KIND=sp) )
                    k = k + 1
                 end do
                 do i = 1, n
                    sum = work( i )
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              else
                 do i = 1, n
                    work( i ) = zero
                 end do
                 do j = 1, n
                    sum = work( j ) + abs( real( ap( k ),KIND=sp) )
                    k = k + 1
                    do i = j + 1, n
                       absa = abs( ap( k ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                       k = k + 1
                    end do
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              k = 2
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 2, n
                    call stdlib_classq( j-1, ap( k ), 1, scale, sum )
                    k = k + j
                 end do
              else
                 do j = 1, n - 1
                    call stdlib_classq( n-j, ap( k ), 1, scale, sum )
                    k = k + n - j + 1
                 end do
              end if
              sum = 2*sum
              k = 1
              do i = 1, n
                 if( real( ap( k ),KIND=sp)/=zero ) then
                    absa = abs( real( ap( k ),KIND=sp) )
                    if( scale<absa ) then
                       sum = one + sum*( scale / absa )**2
                       scale = absa
                    else
                       sum = sum + ( absa / scale )**2
                    end if
                 end if
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    k = k + i + 1
                 else
                    k = k + n - i + 1
                 end if
              end do
              value = scale*sqrt( sum )
           end if
           stdlib_clanhp = value
           return
     end function stdlib_clanhp


     real(sp)             function stdlib_clanhs( norm, n, a, lda, work )
     !! CLANHS returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! Hessenberg matrix A.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(sp), intent(out) :: work(*)
           complex(sp), intent(in) :: a(lda,*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,min,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              value = zero
              do j = 1, n
                 do i = 1, min( n, j+1 )
                    sum = abs( a( i, j ) )
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              end do
           else if( ( stdlib_lsame( norm, 'O' ) ) .or. ( norm=='1' ) ) then
              ! find norm1(a).
              value = zero
              do j = 1, n
                 sum = zero
                 do i = 1, min( n, j+1 )
                    sum = sum + abs( a( i, j ) )
                 end do
                 if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
              end do
           else if( stdlib_lsame( norm, 'I' ) ) then
              ! find normi(a).
              do i = 1, n
                 work( i ) = zero
              end do
              do j = 1, n
                 do i = 1, min( n, j+1 )
                    work( i ) = work( i ) + abs( a( i, j ) )
                 end do
              end do
              value = zero
              do i = 1, n
                 sum = work( i )
                 if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
              end do
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              do j = 1, n
                 call stdlib_classq( min( n, j+1 ), a( 1, j ), 1, scale, sum )
              end do
              value = scale*sqrt( sum )
           end if
           stdlib_clanhs = value
           return
     end function stdlib_clanhs


     pure real(sp)             function stdlib_clanht( norm, n, d, e )
     !! CLANHT returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! complex Hermitian tridiagonal matrix A.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(sp), intent(in) :: d(*)
           complex(sp), intent(in) :: e(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(sp) :: anorm, scale, sum
           ! Intrinsic Functions 
           intrinsic :: abs,sqrt
           ! Executable Statements 
           if( n<=0 ) then
              anorm = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              anorm = abs( d( n ) )
              do i = 1, n - 1
                 sum = abs( d( i ) )
                 if( anorm < sum .or. stdlib_sisnan( sum ) ) anorm = sum
                 sum = abs( e( i ) )
                 if( anorm < sum .or. stdlib_sisnan( sum ) ) anorm = sum
              end do
           else if( stdlib_lsame( norm, 'O' ) .or. norm=='1' .or.stdlib_lsame( norm, 'I' ) ) &
                     then
              ! find norm1(a).
              if( n==1 ) then
                 anorm = abs( d( 1 ) )
              else
                 anorm = abs( d( 1 ) )+abs( e( 1 ) )
                 sum = abs( e( n-1 ) )+abs( d( n ) )
                 if( anorm < sum .or. stdlib_sisnan( sum ) ) anorm = sum
                 do i = 2, n - 1
                    sum = abs( d( i ) )+abs( e( i ) )+abs( e( i-1 ) )
                    if( anorm < sum .or. stdlib_sisnan( sum ) ) anorm = sum
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              if( n>1 ) then
                 call stdlib_classq( n-1, e, 1, scale, sum )
                 sum = 2*sum
              end if
              call stdlib_slassq( n, d, 1, scale, sum )
              anorm = scale*sqrt( sum )
           end if
           stdlib_clanht = anorm
           return
     end function stdlib_clanht


     real(sp)             function stdlib_clansb( norm, uplo, n, k, ab, ldab,work )
     !! CLANSB returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the element of  largest absolute value  of an
     !! n by n symmetric band matrix A,  with k super-diagonals.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm, uplo
           integer(ilp), intent(in) :: k, ldab, n
           ! Array Arguments 
           real(sp), intent(out) :: work(*)
           complex(sp), intent(in) :: ab(ldab,*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, l
           real(sp) :: absa, scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    do i = max( k+2-j, 1 ), k + 1
                       sum = abs( ab( i, j ) )
                       if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                    end do
                 end do
              else
                 do j = 1, n
                    do i = 1, min( n+1-j, k+1 )
                       sum = abs( ab( i, j ) )
                       if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                    end do
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'I' ) ) .or. ( stdlib_lsame( norm, 'O' ) ) .or.( &
                     norm=='1' ) ) then
              ! find normi(a) ( = norm1(a), since a is symmetric).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    sum = zero
                    l = k + 1 - j
                    do i = max( 1, j-k ), j - 1
                       absa = abs( ab( l+i, j ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                    end do
                    work( j ) = sum + abs( ab( k+1, j ) )
                 end do
                 do i = 1, n
                    sum = work( i )
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              else
                 do i = 1, n
                    work( i ) = zero
                 end do
                 do j = 1, n
                    sum = work( j ) + abs( ab( 1, j ) )
                    l = 1 - j
                    do i = j + 1, min( n, j+k )
                       absa = abs( ab( l+i, j ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                    end do
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              if( k>0 ) then
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    do j = 2, n
                       call stdlib_classq( min( j-1, k ), ab( max( k+2-j, 1 ), j ),1, scale, sum )
                                 
                    end do
                    l = k + 1
                 else
                    do j = 1, n - 1
                       call stdlib_classq( min( n-j, k ), ab( 2, j ), 1, scale,sum )
                    end do
                    l = 1
                 end if
                 sum = 2*sum
              else
                 l = 1
              end if
              call stdlib_classq( n, ab( l, 1 ), ldab, scale, sum )
              value = scale*sqrt( sum )
           end if
           stdlib_clansb = value
           return
     end function stdlib_clansb


     real(sp)             function stdlib_clansp( norm, uplo, n, ap, work )
     !! CLANSP returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! complex symmetric matrix A,  supplied in packed form.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm, uplo
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(sp), intent(out) :: work(*)
           complex(sp), intent(in) :: ap(*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j, k
           real(sp) :: absa, scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,real,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 k = 1
                 do j = 1, n
                    do i = k, k + j - 1
                       sum = abs( ap( i ) )
                       if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                    end do
                    k = k + j
                 end do
              else
                 k = 1
                 do j = 1, n
                    do i = k, k + n - j
                       sum = abs( ap( i ) )
                       if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                    end do
                    k = k + n - j + 1
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'I' ) ) .or. ( stdlib_lsame( norm, 'O' ) ) .or.( &
                     norm=='1' ) ) then
              ! find normi(a) ( = norm1(a), since a is symmetric).
              value = zero
              k = 1
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    sum = zero
                    do i = 1, j - 1
                       absa = abs( ap( k ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                       k = k + 1
                    end do
                    work( j ) = sum + abs( ap( k ) )
                    k = k + 1
                 end do
                 do i = 1, n
                    sum = work( i )
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              else
                 do i = 1, n
                    work( i ) = zero
                 end do
                 do j = 1, n
                    sum = work( j ) + abs( ap( k ) )
                    k = k + 1
                    do i = j + 1, n
                       absa = abs( ap( k ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                       k = k + 1
                    end do
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              k = 2
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 2, n
                    call stdlib_classq( j-1, ap( k ), 1, scale, sum )
                    k = k + j
                 end do
              else
                 do j = 1, n - 1
                    call stdlib_classq( n-j, ap( k ), 1, scale, sum )
                    k = k + n - j + 1
                 end do
              end if
              sum = 2*sum
              k = 1
              do i = 1, n
                 if( real( ap( k ),KIND=sp)/=zero ) then
                    absa = abs( real( ap( k ),KIND=sp) )
                    if( scale<absa ) then
                       sum = one + sum*( scale / absa )**2
                       scale = absa
                    else
                       sum = sum + ( absa / scale )**2
                    end if
                 end if
                 if( aimag( ap( k ) )/=zero ) then
                    absa = abs( aimag( ap( k ) ) )
                    if( scale<absa ) then
                       sum = one + sum*( scale / absa )**2
                       scale = absa
                    else
                       sum = sum + ( absa / scale )**2
                    end if
                 end if
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    k = k + i + 1
                 else
                    k = k + n - i + 1
                 end if
              end do
              value = scale*sqrt( sum )
           end if
           stdlib_clansp = value
           return
     end function stdlib_clansp


     real(sp)             function stdlib_clansy( norm, uplo, n, a, lda, work )
     !! CLANSY returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! complex symmetric matrix A.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm, uplo
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(sp), intent(out) :: work(*)
           complex(sp), intent(in) :: a(lda,*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: absa, scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    do i = 1, j
                       sum = abs( a( i, j ) )
                       if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                    end do
                 end do
              else
                 do j = 1, n
                    do i = j, n
                       sum = abs( a( i, j ) )
                       if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                    end do
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'I' ) ) .or. ( stdlib_lsame( norm, 'O' ) ) .or.( &
                     norm=='1' ) ) then
              ! find normi(a) ( = norm1(a), since a is symmetric).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    sum = zero
                    do i = 1, j - 1
                       absa = abs( a( i, j ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                    end do
                    work( j ) = sum + abs( a( j, j ) )
                 end do
                 do i = 1, n
                    sum = work( i )
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              else
                 do i = 1, n
                    work( i ) = zero
                 end do
                 do j = 1, n
                    sum = work( j ) + abs( a( j, j ) )
                    do i = j + 1, n
                       absa = abs( a( i, j ) )
                       sum = sum + absa
                       work( i ) = work( i ) + absa
                    end do
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              end if
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              scale = zero
              sum = one
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 2, n
                    call stdlib_classq( j-1, a( 1, j ), 1, scale, sum )
                 end do
              else
                 do j = 1, n - 1
                    call stdlib_classq( n-j, a( j+1, j ), 1, scale, sum )
                 end do
              end if
              sum = 2*sum
              call stdlib_classq( n, a, lda+1, scale, sum )
              value = scale*sqrt( sum )
           end if
           stdlib_clansy = value
           return
     end function stdlib_clansy


     real(sp)             function stdlib_clantb( norm, uplo, diag, n, k, ab,ldab, work )
     !! CLANTB returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the element of  largest absolute value  of an
     !! n by n triangular band matrix A,  with ( k + 1 ) diagonals.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, norm, uplo
           integer(ilp), intent(in) :: k, ldab, n
           ! Array Arguments 
           real(sp), intent(out) :: work(*)
           complex(sp), intent(in) :: ab(ldab,*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: udiag
           integer(ilp) :: i, j, l
           real(sp) :: scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              if( stdlib_lsame( diag, 'U' ) ) then
                 value = one
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    do j = 1, n
                       do i = max( k+2-j, 1 ), k
                          sum = abs( ab( i, j ) )
                          if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                       end do
                    end do
                 else
                    do j = 1, n
                       do i = 2, min( n+1-j, k+1 )
                          sum = abs( ab( i, j ) )
                          if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                       end do
                    end do
                 end if
              else
                 value = zero
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    do j = 1, n
                       do i = max( k+2-j, 1 ), k + 1
                          sum = abs( ab( i, j ) )
                          if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                       end do
                    end do
                 else
                    do j = 1, n
                       do i = 1, min( n+1-j, k+1 )
                          sum = abs( ab( i, j ) )
                          if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                       end do
                    end do
                 end if
              end if
           else if( ( stdlib_lsame( norm, 'O' ) ) .or. ( norm=='1' ) ) then
              ! find norm1(a).
              value = zero
              udiag = stdlib_lsame( diag, 'U' )
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    if( udiag ) then
                       sum = one
                       do i = max( k+2-j, 1 ), k
                          sum = sum + abs( ab( i, j ) )
                       end do
                    else
                       sum = zero
                       do i = max( k+2-j, 1 ), k + 1
                          sum = sum + abs( ab( i, j ) )
                       end do
                    end if
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              else
                 do j = 1, n
                    if( udiag ) then
                       sum = one
                       do i = 2, min( n+1-j, k+1 )
                          sum = sum + abs( ab( i, j ) )
                       end do
                    else
                       sum = zero
                       do i = 1, min( n+1-j, k+1 )
                          sum = sum + abs( ab( i, j ) )
                       end do
                    end if
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              end if
           else if( stdlib_lsame( norm, 'I' ) ) then
              ! find normi(a).
              value = zero
              if( stdlib_lsame( uplo, 'U' ) ) then
                 if( stdlib_lsame( diag, 'U' ) ) then
                    do i = 1, n
                       work( i ) = one
                    end do
                    do j = 1, n
                       l = k + 1 - j
                       do i = max( 1, j-k ), j - 1
                          work( i ) = work( i ) + abs( ab( l+i, j ) )
                       end do
                    end do
                 else
                    do i = 1, n
                       work( i ) = zero
                    end do
                    do j = 1, n
                       l = k + 1 - j
                       do i = max( 1, j-k ), j
                          work( i ) = work( i ) + abs( ab( l+i, j ) )
                       end do
                    end do
                 end if
              else
                 if( stdlib_lsame( diag, 'U' ) ) then
                    do i = 1, n
                       work( i ) = one
                    end do
                    do j = 1, n
                       l = 1 - j
                       do i = j + 1, min( n, j+k )
                          work( i ) = work( i ) + abs( ab( l+i, j ) )
                       end do
                    end do
                 else
                    do i = 1, n
                       work( i ) = zero
                    end do
                    do j = 1, n
                       l = 1 - j
                       do i = j, min( n, j+k )
                          work( i ) = work( i ) + abs( ab( l+i, j ) )
                       end do
                    end do
                 end if
              end if
              do i = 1, n
                 sum = work( i )
                 if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
              end do
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 if( stdlib_lsame( diag, 'U' ) ) then
                    scale = one
                    sum = n
                    if( k>0 ) then
                       do j = 2, n
                          call stdlib_classq( min( j-1, k ),ab( max( k+2-j, 1 ), j ), 1, scale,&
                                    sum )
                       end do
                    end if
                 else
                    scale = zero
                    sum = one
                    do j = 1, n
                       call stdlib_classq( min( j, k+1 ), ab( max( k+2-j, 1 ), j ),1, scale, sum )
                                 
                    end do
                 end if
              else
                 if( stdlib_lsame( diag, 'U' ) ) then
                    scale = one
                    sum = n
                    if( k>0 ) then
                       do j = 1, n - 1
                          call stdlib_classq( min( n-j, k ), ab( 2, j ), 1, scale,sum )
                       end do
                    end if
                 else
                    scale = zero
                    sum = one
                    do j = 1, n
                       call stdlib_classq( min( n-j+1, k+1 ), ab( 1, j ), 1, scale,sum )
                    end do
                 end if
              end if
              value = scale*sqrt( sum )
           end if
           stdlib_clantb = value
           return
     end function stdlib_clantb


     real(sp)             function stdlib_clantp( norm, uplo, diag, n, ap, work )
     !! CLANTP returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! triangular matrix A, supplied in packed form.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, norm, uplo
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(sp), intent(out) :: work(*)
           complex(sp), intent(in) :: ap(*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: udiag
           integer(ilp) :: i, j, k
           real(sp) :: scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,sqrt
           ! Executable Statements 
           if( n==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              k = 1
              if( stdlib_lsame( diag, 'U' ) ) then
                 value = one
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    do j = 1, n
                       do i = k, k + j - 2
                          sum = abs( ap( i ) )
                          if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                       end do
                       k = k + j
                    end do
                 else
                    do j = 1, n
                       do i = k + 1, k + n - j
                          sum = abs( ap( i ) )
                          if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                       end do
                       k = k + n - j + 1
                    end do
                 end if
              else
                 value = zero
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    do j = 1, n
                       do i = k, k + j - 1
                          sum = abs( ap( i ) )
                          if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                       end do
                       k = k + j
                    end do
                 else
                    do j = 1, n
                       do i = k, k + n - j
                          sum = abs( ap( i ) )
                          if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                       end do
                       k = k + n - j + 1
                    end do
                 end if
              end if
           else if( ( stdlib_lsame( norm, 'O' ) ) .or. ( norm=='1' ) ) then
              ! find norm1(a).
              value = zero
              k = 1
              udiag = stdlib_lsame( diag, 'U' )
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    if( udiag ) then
                       sum = one
                       do i = k, k + j - 2
                          sum = sum + abs( ap( i ) )
                       end do
                    else
                       sum = zero
                       do i = k, k + j - 1
                          sum = sum + abs( ap( i ) )
                       end do
                    end if
                    k = k + j
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              else
                 do j = 1, n
                    if( udiag ) then
                       sum = one
                       do i = k + 1, k + n - j
                          sum = sum + abs( ap( i ) )
                       end do
                    else
                       sum = zero
                       do i = k, k + n - j
                          sum = sum + abs( ap( i ) )
                       end do
                    end if
                    k = k + n - j + 1
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              end if
           else if( stdlib_lsame( norm, 'I' ) ) then
              ! find normi(a).
              k = 1
              if( stdlib_lsame( uplo, 'U' ) ) then
                 if( stdlib_lsame( diag, 'U' ) ) then
                    do i = 1, n
                       work( i ) = one
                    end do
                    do j = 1, n
                       do i = 1, j - 1
                          work( i ) = work( i ) + abs( ap( k ) )
                          k = k + 1
                       end do
                       k = k + 1
                    end do
                 else
                    do i = 1, n
                       work( i ) = zero
                    end do
                    do j = 1, n
                       do i = 1, j
                          work( i ) = work( i ) + abs( ap( k ) )
                          k = k + 1
                       end do
                    end do
                 end if
              else
                 if( stdlib_lsame( diag, 'U' ) ) then
                    do i = 1, n
                       work( i ) = one
                    end do
                    do j = 1, n
                       k = k + 1
                       do i = j + 1, n
                          work( i ) = work( i ) + abs( ap( k ) )
                          k = k + 1
                       end do
                    end do
                 else
                    do i = 1, n
                       work( i ) = zero
                    end do
                    do j = 1, n
                       do i = j, n
                          work( i ) = work( i ) + abs( ap( k ) )
                          k = k + 1
                       end do
                    end do
                 end if
              end if
              value = zero
              do i = 1, n
                 sum = work( i )
                 if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
              end do
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 if( stdlib_lsame( diag, 'U' ) ) then
                    scale = one
                    sum = n
                    k = 2
                    do j = 2, n
                       call stdlib_classq( j-1, ap( k ), 1, scale, sum )
                       k = k + j
                    end do
                 else
                    scale = zero
                    sum = one
                    k = 1
                    do j = 1, n
                       call stdlib_classq( j, ap( k ), 1, scale, sum )
                       k = k + j
                    end do
                 end if
              else
                 if( stdlib_lsame( diag, 'U' ) ) then
                    scale = one
                    sum = n
                    k = 2
                    do j = 1, n - 1
                       call stdlib_classq( n-j, ap( k ), 1, scale, sum )
                       k = k + n - j + 1
                    end do
                 else
                    scale = zero
                    sum = one
                    k = 1
                    do j = 1, n
                       call stdlib_classq( n-j+1, ap( k ), 1, scale, sum )
                       k = k + n - j + 1
                    end do
                 end if
              end if
              value = scale*sqrt( sum )
           end if
           stdlib_clantp = value
           return
     end function stdlib_clantp


     real(sp)             function stdlib_clantr( norm, uplo, diag, m, n, a, lda,work )
     !! CLANTR returns the value of the one norm,  or the Frobenius norm, or
     !! the  infinity norm,  or the  element of  largest absolute value  of a
     !! trapezoidal or triangular matrix A.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, norm, uplo
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           real(sp), intent(out) :: work(*)
           complex(sp), intent(in) :: a(lda,*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: udiag
           integer(ilp) :: i, j
           real(sp) :: scale, sum, value
           ! Intrinsic Functions 
           intrinsic :: abs,min,sqrt
           ! Executable Statements 
           if( min( m, n )==0 ) then
              value = zero
           else if( stdlib_lsame( norm, 'M' ) ) then
              ! find max(abs(a(i,j))).
              if( stdlib_lsame( diag, 'U' ) ) then
                 value = one
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    do j = 1, n
                       do i = 1, min( m, j-1 )
                          sum = abs( a( i, j ) )
                          if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                       end do
                    end do
                 else
                    do j = 1, n
                       do i = j + 1, m
                          sum = abs( a( i, j ) )
                          if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                       end do
                    end do
                 end if
              else
                 value = zero
                 if( stdlib_lsame( uplo, 'U' ) ) then
                    do j = 1, n
                       do i = 1, min( m, j )
                          sum = abs( a( i, j ) )
                          if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                       end do
                    end do
                 else
                    do j = 1, n
                       do i = j, m
                          sum = abs( a( i, j ) )
                          if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                       end do
                    end do
                 end if
              end if
           else if( ( stdlib_lsame( norm, 'O' ) ) .or. ( norm=='1' ) ) then
              ! find norm1(a).
              value = zero
              udiag = stdlib_lsame( diag, 'U' )
              if( stdlib_lsame( uplo, 'U' ) ) then
                 do j = 1, n
                    if( ( udiag ) .and. ( j<=m ) ) then
                       sum = one
                       do i = 1, j - 1
                          sum = sum + abs( a( i, j ) )
                       end do
                    else
                       sum = zero
                       do i = 1, min( m, j )
                          sum = sum + abs( a( i, j ) )
                       end do
                    end if
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              else
                 do j = 1, n
                    if( udiag ) then
                       sum = one
                       do i = j + 1, m
                          sum = sum + abs( a( i, j ) )
                       end do
                    else
                       sum = zero
                       do i = j, m
                          sum = sum + abs( a( i, j ) )
                       end do
                    end if
                    if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
                 end do
              end if
           else if( stdlib_lsame( norm, 'I' ) ) then
              ! find normi(a).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 if( stdlib_lsame( diag, 'U' ) ) then
                    do i = 1, m
                       work( i ) = one
                    end do
                    do j = 1, n
                       do i = 1, min( m, j-1 )
                          work( i ) = work( i ) + abs( a( i, j ) )
                       end do
                    end do
                 else
                    do i = 1, m
                       work( i ) = zero
                    end do
                    do j = 1, n
                       do i = 1, min( m, j )
                          work( i ) = work( i ) + abs( a( i, j ) )
                       end do
                    end do
                 end if
              else
                 if( stdlib_lsame( diag, 'U' ) ) then
                    do i = 1, min( m, n )
                       work( i ) = one
                    end do
                    do i = n + 1, m
                       work( i ) = zero
                    end do
                    do j = 1, n
                       do i = j + 1, m
                          work( i ) = work( i ) + abs( a( i, j ) )
                       end do
                    end do
                 else
                    do i = 1, m
                       work( i ) = zero
                    end do
                    do j = 1, n
                       do i = j, m
                          work( i ) = work( i ) + abs( a( i, j ) )
                       end do
                    end do
                 end if
              end if
              value = zero
              do i = 1, m
                 sum = work( i )
                 if( value < sum .or. stdlib_sisnan( sum ) ) value = sum
              end do
           else if( ( stdlib_lsame( norm, 'F' ) ) .or. ( stdlib_lsame( norm, 'E' ) ) ) &
                     then
              ! find normf(a).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 if( stdlib_lsame( diag, 'U' ) ) then
                    scale = one
                    sum = min( m, n )
                    do j = 2, n
                       call stdlib_classq( min( m, j-1 ), a( 1, j ), 1, scale, sum )
                    end do
                 else
                    scale = zero
                    sum = one
                    do j = 1, n
                       call stdlib_classq( min( m, j ), a( 1, j ), 1, scale, sum )
                    end do
                 end if
              else
                 if( stdlib_lsame( diag, 'U' ) ) then
                    scale = one
                    sum = min( m, n )
                    do j = 1, n
                       call stdlib_classq( m-j, a( min( m, j+1 ), j ), 1, scale,sum )
                    end do
                 else
                    scale = zero
                    sum = one
                    do j = 1, n
                       call stdlib_classq( m-j+1, a( j, j ), 1, scale, sum )
                    end do
                 end if
              end if
              value = scale*sqrt( sum )
           end if
           stdlib_clantr = value
           return
     end function stdlib_clantr


     pure subroutine stdlib_clapll( n, x, incx, y, incy, ssmin )
     !! Given two column vectors X and Y, let
     !! A = ( X Y ).
     !! The subroutine first computes the QR factorization of A = Q*R,
     !! and then computes the SVD of the 2-by-2 upper triangular matrix R.
     !! The smaller singular value of R is returned in SSMIN, which is used
     !! as the measurement of the linear dependency of the vectors X and Y.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, incy, n
           real(sp), intent(out) :: ssmin
           ! Array Arguments 
           complex(sp), intent(inout) :: x(*), y(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           real(sp) :: ssmax
           complex(sp) :: a11, a12, a22, c, tau
           ! Intrinsic Functions 
           intrinsic :: abs,conjg
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 ) then
              ssmin = zero
              return
           end if
           ! compute the qr factorization of the n-by-2 matrix ( x y )
           call stdlib_clarfg( n, x( 1 ), x( 1+incx ), incx, tau )
           a11 = x( 1 )
           x( 1 ) = cone
           c = -conjg( tau )*stdlib_cdotc( n, x, incx, y, incy )
           call stdlib_caxpy( n, c, x, incx, y, incy )
           call stdlib_clarfg( n-1, y( 1+incy ), y( 1+2*incy ), incy, tau )
           a12 = y( 1 )
           a22 = y( 1+incy )
           ! compute the svd of 2-by-2 upper triangular matrix.
           call stdlib_slas2( abs( a11 ), abs( a12 ), abs( a22 ), ssmin, ssmax )
           return
     end subroutine stdlib_clapll


     pure subroutine stdlib_claqp2( m, n, offset, a, lda, jpvt, tau, vn1, vn2,work )
     !! CLAQP2 computes a QR factorization with column pivoting of
     !! the block A(OFFSET+1:M,1:N).
     !! The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: lda, m, n, offset
           ! Array Arguments 
           integer(ilp), intent(inout) :: jpvt(*)
           real(sp), intent(inout) :: vn1(*), vn2(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           integer(ilp) :: i, itemp, j, mn, offpi, pvt
           real(sp) :: temp, temp2, tol3z
           complex(sp) :: aii
           ! Intrinsic Functions 
           intrinsic :: abs,conjg,max,min,sqrt
           ! Executable Statements 
           mn = min( m-offset, n )
           tol3z = sqrt(stdlib_slamch('EPSILON'))
           ! compute factorization.
           loop_20: do i = 1, mn
              offpi = offset + i
              ! determine ith pivot column and swap if necessary.
              pvt = ( i-1 ) + stdlib_isamax( n-i+1, vn1( i ), 1 )
              if( pvt/=i ) then
                 call stdlib_cswap( m, a( 1, pvt ), 1, a( 1, i ), 1 )
                 itemp = jpvt( pvt )
                 jpvt( pvt ) = jpvt( i )
                 jpvt( i ) = itemp
                 vn1( pvt ) = vn1( i )
                 vn2( pvt ) = vn2( i )
              end if
              ! generate elementary reflector h(i).
              if( offpi<m ) then
                 call stdlib_clarfg( m-offpi+1, a( offpi, i ), a( offpi+1, i ), 1,tau( i ) )
                           
              else
                 call stdlib_clarfg( 1, a( m, i ), a( m, i ), 1, tau( i ) )
              end if
              if( i<n ) then
                 ! apply h(i)**h to a(offset+i:m,i+1:n) from the left.
                 aii = a( offpi, i )
                 a( offpi, i ) = cone
                 call stdlib_clarf( 'LEFT', m-offpi+1, n-i, a( offpi, i ), 1,conjg( tau( i ) ), a(&
                            offpi, i+1 ), lda,work( 1 ) )
                 a( offpi, i ) = aii
              end if
              ! update partial column norms.
              do j = i + 1, n
                 if( vn1( j )/=zero ) then
                    ! note: the following 4 lines follow from the analysis in
                    ! lapack working note 176.
                    temp = one - ( abs( a( offpi, j ) ) / vn1( j ) )**2
                    temp = max( temp, zero )
                    temp2 = temp*( vn1( j ) / vn2( j ) )**2
                    if( temp2 <= tol3z ) then
                       if( offpi<m ) then
                          vn1( j ) = stdlib_scnrm2( m-offpi, a( offpi+1, j ), 1 )
                          vn2( j ) = vn1( j )
                       else
                          vn1( j ) = zero
                          vn2( j ) = zero
                       end if
                    else
                       vn1( j ) = vn1( j )*sqrt( temp )
                    end if
                 end if
              end do
           end do loop_20
           return
     end subroutine stdlib_claqp2


     pure subroutine stdlib_claqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,vn2, auxv, f, &
     !! CLAQPS computes a step of QR factorization with column pivoting
     !! of a complex M-by-N matrix A by using Blas-3.  It tries to factorize
     !! NB columns from A starting from the row OFFSET+1, and updates all
     !! of the matrix with Blas-3 xGEMM.
     !! In some cases, due to catastrophic cancellations, it cannot
     !! factorize NB columns.  Hence, the actual number of factorized
     !! columns is returned in KB.
     !! Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
               ldf )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: kb
           integer(ilp), intent(in) :: lda, ldf, m, n, nb, offset
           ! Array Arguments 
           integer(ilp), intent(inout) :: jpvt(*)
           real(sp), intent(inout) :: vn1(*), vn2(*)
           complex(sp), intent(inout) :: a(lda,*), auxv(*), f(ldf,*)
           complex(sp), intent(out) :: tau(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           integer(ilp) :: itemp, j, k, lastrk, lsticc, pvt, rk
           real(sp) :: temp, temp2, tol3z
           complex(sp) :: akk
           ! Intrinsic Functions 
           intrinsic :: abs,conjg,max,min,nint,real,sqrt
           ! Executable Statements 
           lastrk = min( m, n+offset )
           lsticc = 0
           k = 0
           tol3z = sqrt(stdlib_slamch('EPSILON'))
           ! beginning of while loop.
           10 continue
           if( ( k<nb ) .and. ( lsticc==0 ) ) then
              k = k + 1
              rk = offset + k
              ! determine ith pivot column and swap if necessary
              pvt = ( k-1 ) + stdlib_isamax( n-k+1, vn1( k ), 1 )
              if( pvt/=k ) then
                 call stdlib_cswap( m, a( 1, pvt ), 1, a( 1, k ), 1 )
                 call stdlib_cswap( k-1, f( pvt, 1 ), ldf, f( k, 1 ), ldf )
                 itemp = jpvt( pvt )
                 jpvt( pvt ) = jpvt( k )
                 jpvt( k ) = itemp
                 vn1( pvt ) = vn1( k )
                 vn2( pvt ) = vn2( k )
              end if
              ! apply previous householder reflectors to column k:
              ! a(rk:m,k) := a(rk:m,k) - a(rk:m,1:k-1)*f(k,1:k-1)**h.
              if( k>1 ) then
                 do j = 1, k - 1
                    f( k, j ) = conjg( f( k, j ) )
                 end do
                 call stdlib_cgemv( 'NO TRANSPOSE', m-rk+1, k-1, -cone, a( rk, 1 ),lda, f( k, 1 ),&
                            ldf, cone, a( rk, k ), 1 )
                 do j = 1, k - 1
                    f( k, j ) = conjg( f( k, j ) )
                 end do
              end if
              ! generate elementary reflector h(k).
              if( rk<m ) then
                 call stdlib_clarfg( m-rk+1, a( rk, k ), a( rk+1, k ), 1, tau( k ) )
              else
                 call stdlib_clarfg( 1, a( rk, k ), a( rk, k ), 1, tau( k ) )
              end if
              akk = a( rk, k )
              a( rk, k ) = cone
              ! compute kth column of f:
              ! compute  f(k+1:n,k) := tau(k)*a(rk:m,k+1:n)**h*a(rk:m,k).
              if( k<n ) then
                 call stdlib_cgemv( 'CONJUGATE TRANSPOSE', m-rk+1, n-k, tau( k ),a( rk, k+1 ), &
                           lda, a( rk, k ), 1, czero,f( k+1, k ), 1 )
              end if
              ! padding f(1:k,k) with zeros.
              do j = 1, k
                 f( j, k ) = czero
              end do
              ! incremental updating of f:
              ! f(1:n,k) := f(1:n,k) - tau(k)*f(1:n,1:k-1)*a(rk:m,1:k-1)**h
                          ! *a(rk:m,k).
              if( k>1 ) then
                 call stdlib_cgemv( 'CONJUGATE TRANSPOSE', m-rk+1, k-1, -tau( k ),a( rk, 1 ), lda,&
                            a( rk, k ), 1, czero,auxv( 1 ), 1 )
                 call stdlib_cgemv( 'NO TRANSPOSE', n, k-1, cone, f( 1, 1 ), ldf,auxv( 1 ), 1, &
                           cone, f( 1, k ), 1 )
              end if
              ! update the current row of a:
              ! a(rk,k+1:n) := a(rk,k+1:n) - a(rk,1:k)*f(k+1:n,1:k)**h.
              if( k<n ) then
                 call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE', 1, n-k,k, -cone, a( rk,&
                            1 ), lda, f( k+1, 1 ), ldf,cone, a( rk, k+1 ), lda )
              end if
              ! update partial column norms.
              if( rk<lastrk ) then
                 do j = k + 1, n
                    if( vn1( j )/=zero ) then
                       ! note: the following 4 lines follow from the analysis in
                       ! lapack working note 176.
                       temp = abs( a( rk, j ) ) / vn1( j )
                       temp = max( zero, ( one+temp )*( one-temp ) )
                       temp2 = temp*( vn1( j ) / vn2( j ) )**2
                       if( temp2 <= tol3z ) then
                          vn2( j ) = real( lsticc,KIND=sp)
                          lsticc = j
                       else
                          vn1( j ) = vn1( j )*sqrt( temp )
                       end if
                    end if
                 end do
              end if
              a( rk, k ) = akk
              ! end of while loop.
              go to 10
           end if
           kb = k
           rk = offset + kb
           ! apply the block reflector to the rest of the matrix:
           ! a(offset+kb+1:m,kb+1:n) := a(offset+kb+1:m,kb+1:n) -
                               ! a(offset+kb+1:m,1:kb)*f(kb+1:n,1:kb)**h.
           if( kb<min( n, m-offset ) ) then
              call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE', m-rk, n-kb,kb, -cone, a( &
                        rk+1, 1 ), lda, f( kb+1, 1 ), ldf,cone, a( rk+1, kb+1 ), lda )
           end if
           ! recomputation of difficult columns.
           60 continue
           if( lsticc>0 ) then
              itemp = nint( vn2( lsticc ),KIND=ilp)
              vn1( lsticc ) = stdlib_scnrm2( m-rk, a( rk+1, lsticc ), 1 )
              ! note: the computation of vn1( lsticc ) relies on the fact that
              ! stdlib_snrm2 does not fail on vectors with norm below the value of
              ! sqrt(stdlib_dlamch('s'))
              vn2( lsticc ) = vn1( lsticc )
              lsticc = itemp
              go to 60
           end if
           return
     end subroutine stdlib_claqps


     pure subroutine stdlib_claqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,h, ldh, iloz, &
     !! CLAQR5 called by CLAQR0 performs a
     !! single small-bulge multi-shift QR sweep.
               ihiz, z, ldz, v, ldv, u, ldu, nv,wv, ldwv, nh, wh, ldwh )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), s(*), z(ldz,*)
           complex(sp), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0_sp
           real(sp), parameter :: rone = 1.0_sp
           
           
           ! Local Scalars 
           complex(sp) :: alpha, beta, cdum, refsum
           real(sp) :: h11, h12, h21, h22, safmax, safmin, scl, smlnum, tst1, tst2, ulp
           integer(ilp) :: i2, i4, incol, j, jbot, jcol, jlen, jrow, jtop, k, k1, kdu, kms, krcol,&
                      m, m22, mbot, mtop, nbmps, ndcol, ns, nu
           logical(lk) :: accum, bmp22
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,conjg,max,min,mod,real
           ! Local Arrays 
           complex(sp) :: vt(3)
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== if there are no shifts, then there is nothing to do. ====
           if( nshfts<2 )return
           ! ==== if the active block is empty or 1-by-1, then there
           ! .    is nothing to do. ====
           if( ktop>=kbot )return
           ! ==== nshfts is supposed to be even, but if it is odd,
           ! .    then simply reduce it by cone.  ====
           ns = nshfts - mod( nshfts, 2 )
           ! ==== machine constants for deflation ====
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp) / ulp )
           ! ==== use accumulated reflections to update far-from-diagonal
           ! .    entries ? ====
           accum = ( kacc22==1 ) .or. ( kacc22==2 )
           ! ==== clear trash ====
           if( ktop+2<=kbot )h( ktop+2, ktop ) = czero
           ! ==== nbmps = number of 2-shift bulges in the chain ====
           nbmps = ns / 2
           ! ==== kdu = width of slab ====
           kdu = 4*nbmps
           ! ==== create and chase chains of nbmps bulges ====
           loop_180: do incol = ktop - 2*nbmps + 1, kbot - 2, 2*nbmps
              ! jtop = index from which updates from the right start.
              if( accum ) then
                 jtop = max( ktop, incol )
              else if( wantt ) then
                 jtop = 1
              else
                 jtop = ktop
              end if
              ndcol = incol + kdu
              if( accum )call stdlib_claset( 'ALL', kdu, kdu, czero, cone, u, ldu )
              ! ==== near-the-diagonal bulge chase.  the following loop
              ! .    performs the near-the-diagonal part of a small bulge
              ! .    multi-shift qr sweep.  each 4*nbmps column diagonal
              ! .    chunk extends from column incol to column ndcol
              ! .    (including both column incol and column ndcol). the
              ! .    following loop chases a 2*nbmps+1 column long chain of
              ! .    nbmps bulges 2*nbmps columns to the right.  (incol
              ! .    may be less than ktop and and ndcol may be greater than
              ! .    kbot indicating phantom columns from which to chase
              ! .    bulges before they are actually introduced or to which
              ! .    to chase bulges beyond column kbot.)  ====
              loop_145: do krcol = incol, min( incol+2*nbmps-1, kbot-2 )
                 ! ==== bulges number mtop to mbot are active double implicit
                 ! .    shift bulges.  there may or may not also be small
                 ! .    2-by-2 bulge, if there is room.  the inactive bulges
                 ! .    (if any) must wait until the active bulges have moved
                 ! .    down the diagonal to make room.  the phantom matrix
                 ! .    paradigm described above helps keep track.  ====
                 mtop = max( 1, ( ktop-krcol ) / 2+1 )
                 mbot = min( nbmps, ( kbot-krcol-1 ) / 2 )
                 m22 = mbot + 1
                 bmp22 = ( mbot<nbmps ) .and. ( krcol+2*( m22-1 ) )==( kbot-2 )
                 ! ==== generate reflections to chase the chain right
                 ! .    cone column.  (the minimum value of k is ktop-1.) ====
                 if ( bmp22 ) then
                    ! ==== special case: 2-by-2 reflection at bottom treated
                    ! .    separately ====
                    k = krcol + 2*( m22-1 )
                    if( k==ktop-1 ) then
                       call stdlib_claqr1( 2, h( k+1, k+1 ), ldh, s( 2*m22-1 ),s( 2*m22 ), v( 1, &
                                 m22 ) )
                       beta = v( 1, m22 )
                       call stdlib_clarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                    else
                       beta = h( k+1, k )
                       v( 2, m22 ) = h( k+2, k )
                       call stdlib_clarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                       h( k+1, k ) = beta
                       h( k+2, k ) = czero
                    end if
                    ! ==== perform update from right within
                    ! .    computational window. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m22 )*( h( j, k+1 )+v( 2, m22 )*h( j, k+2 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) -refsum*conjg( v( 2, m22 ) )
                    end do
                    ! ==== perform update from left within
                    ! .    computational window. ====
                    if( accum ) then
                       jbot = min( ndcol, kbot )
                    else if( wantt ) then
                       jbot = n
                    else
                       jbot = kbot
                    end if
                    do j = k+1, jbot
                       refsum = conjg( v( 1, m22 ) )*( h( k+1, j )+conjg( v( 2, m22 ) )*h( k+2, j &
                                 ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m22 )
                    end do
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is czero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k>=ktop) then
                       if( h( k+1, k )/=czero ) then
                          tst1 = cabs1( h( k, k ) ) + cabs1( h( k+1, k+1 ) )
                          if( tst1==rzero ) then
                             if( k>=ktop+1 )tst1 = tst1 + cabs1( h( k, k-1 ) )
                             if( k>=ktop+2 )tst1 = tst1 + cabs1( h( k, k-2 ) )
                             if( k>=ktop+3 )tst1 = tst1 + cabs1( h( k, k-3 ) )
                             if( k<=kbot-2 )tst1 = tst1 + cabs1( h( k+2, k+1 ) )
                             if( k<=kbot-3 )tst1 = tst1 + cabs1( h( k+3, k+1 ) )
                             if( k<=kbot-4 )tst1 = tst1 + cabs1( h( k+4, k+1 ) )
                          end if
                          if( cabs1( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) ) then
                             h12 = max( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                             h21 = min( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                             h11 = max( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             h22 = min( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             scl = h11 + h12
                             tst2 = h22*( h11 / scl )
                             if( tst2==rzero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) )h( &
                                       k+1, k ) = czero
                          end if
                       end if
                    end if
                    ! ==== accumulate orthogonal transformations. ====
                    if( accum ) then
                       kms = k - incol
                       do j = max( 1, ktop-incol ), kdu
                          refsum = v( 1, m22 )*( u( j, kms+1 )+v( 2, m22 )*u( j, kms+2 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) -refsum*conjg( v( 2, m22 ) )
                       end do
                    else if( wantz ) then
                       do j = iloz, ihiz
                          refsum = v( 1, m22 )*( z( j, k+1 )+v( 2, m22 )*z( j, k+2 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) -refsum*conjg( v( 2, m22 ) )
                       end do
                    end if
                 end if
                 ! ==== normal case: chain of 3-by-3 reflections ====
                 loop_80: do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    if( k==ktop-1 ) then
                       call stdlib_claqr1( 3, h( ktop, ktop ), ldh, s( 2*m-1 ),s( 2*m ), v( 1, m )&
                                  )
                       alpha = v( 1, m )
                       call stdlib_clarfg( 3, alpha, v( 2, m ), 1, v( 1, m ) )
                    else
                       ! ==== perform delayed transformation of row below
                       ! .    mth bulge. exploit fact that first two elements
                       ! .    of row are actually czero. ====
                       refsum = v( 1, m )*v( 3, m )*h( k+3, k+2 )
                       h( k+3, k   ) = -refsum
                       h( k+3, k+1 ) = -refsum*conjg( v( 2, m ) )
                       h( k+3, k+2 ) = h( k+3, k+2 ) -refsum*conjg( v( 3, m ) )
                       ! ==== calculate reflection to move
                       ! .    mth bulge cone step. ====
                       beta      = h( k+1, k )
                       v( 2, m ) = h( k+2, k )
                       v( 3, m ) = h( k+3, k )
                       call stdlib_clarfg( 3, beta, v( 2, m ), 1, v( 1, m ) )
                       ! ==== a bulge may collapse because of vigilant
                       ! .    deflation or destructive underflow.  in the
                       ! .    underflow case, try the two-small-subdiagonals
                       ! .    trick to try to reinflate the bulge.  ====
                       if( h( k+3, k )/=czero .or. h( k+3, k+1 )/=czero .or. h( k+3, k+2 )==czero &
                                 ) then
                          ! ==== typical case: not collapsed (yet). ====
                          h( k+1, k ) = beta
                          h( k+2, k ) = czero
                          h( k+3, k ) = czero
                       else
                          ! ==== atypical case: collapsed.  attempt to
                          ! .    reintroduce ignoring h(k+1,k) and h(k+2,k).
                          ! .    if the fill resulting from the new
                          ! .    reflector is too large, then abandon it.
                          ! .    otherwise, use the new cone. ====
                          call stdlib_claqr1( 3, h( k+1, k+1 ), ldh, s( 2*m-1 ),s( 2*m ), vt )
                                    
                          alpha = vt( 1 )
                          call stdlib_clarfg( 3, alpha, vt( 2 ), 1, vt( 1 ) )
                          refsum = conjg( vt( 1 ) )*( h( k+1, k )+conjg( vt( 2 ) )*h( k+2, k ) )
                                    
                          if( cabs1( h( k+2, k )-refsum*vt( 2 ) )+cabs1( refsum*vt( 3 ) )>ulp*( &
                          cabs1( h( k, k ) )+cabs1( h( k+1,k+1 ) )+cabs1( h( k+2, k+2 ) ) ) ) &
                                    then
                             ! ==== starting a new bulge here would
                             ! .    create non-negligible fill.  use
                             ! .    the old cone with trepidation. ====
                             h( k+1, k ) = beta
                             h( k+2, k ) = czero
                             h( k+3, k ) = czero
                          else
                             ! ==== starting a new bulge here would
                             ! .    create only negligible fill.
                             ! .    replace the old reflector with
                             ! .    the new cone. ====
                             h( k+1, k ) = h( k+1, k ) - refsum
                             h( k+2, k ) = czero
                             h( k+3, k ) = czero
                             v( 1, m ) = vt( 1 )
                             v( 2, m ) = vt( 2 )
                             v( 3, m ) = vt( 3 )
                          end if
                       end if
                    end if
                    ! ====  apply reflection from the right and
                    ! .     the first column of update from the left.
                    ! .     these updates are required for the vigilant
                    ! .     deflation check. we still delay most of the
                    ! .     updates from the left for efficiency. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m )*( h( j, k+1 )+v( 2, m )*h( j, k+2 )+v( 3, m )*h( j, k+3 &
                                 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) -refsum*conjg( v( 2, m ) )
                       h( j, k+3 ) = h( j, k+3 ) -refsum*conjg( v( 3, m ) )
                    end do
                    ! ==== perform update from left for subsequent
                    ! .    column. ====
                    refsum =  conjg( v( 1, m ) )*( h( k+1, k+1 )+conjg( v( 2, m ) )*h( k+2, k+1 )+&
                              conjg( v( 3, m ) )*h( k+3, k+1 ) )
                    h( k+1, k+1 ) = h( k+1, k+1 ) - refsum
                    h( k+2, k+1 ) = h( k+2, k+1 ) - refsum*v( 2, m )
                    h( k+3, k+1 ) = h( k+3, k+1 ) - refsum*v( 3, m )
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is czero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k<ktop)cycle
                    if( h( k+1, k )/=czero ) then
                       tst1 = cabs1( h( k, k ) ) + cabs1( h( k+1, k+1 ) )
                       if( tst1==rzero ) then
                          if( k>=ktop+1 )tst1 = tst1 + cabs1( h( k, k-1 ) )
                          if( k>=ktop+2 )tst1 = tst1 + cabs1( h( k, k-2 ) )
                          if( k>=ktop+3 )tst1 = tst1 + cabs1( h( k, k-3 ) )
                          if( k<=kbot-2 )tst1 = tst1 + cabs1( h( k+2, k+1 ) )
                          if( k<=kbot-3 )tst1 = tst1 + cabs1( h( k+3, k+1 ) )
                          if( k<=kbot-4 )tst1 = tst1 + cabs1( h( k+4, k+1 ) )
                       end if
                       if( cabs1( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) )then
                          h12 = max( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                          h21 = min( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                          h11 = max( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                    
                          h22 = min( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                    
                          scl = h11 + h12
                          tst2 = h22*( h11 / scl )
                          if( tst2==rzero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) )h( k+1,&
                                     k ) = czero
                       end if
                    end if
                 end do loop_80
                 ! ==== multiply h by reflections from the left ====
                 if( accum ) then
                    jbot = min( ndcol, kbot )
                 else if( wantt ) then
                    jbot = n
                 else
                    jbot = kbot
                 end if
                 do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    do j = max( ktop, krcol + 2*m ), jbot
                       refsum = conjg( v( 1, m ) )*( h( k+1, j )+conjg( v( 2, m ) )*h( k+2, j )+&
                                 conjg( v( 3, m ) )*h( k+3, j ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m )
                       h( k+3, j ) = h( k+3, j ) - refsum*v( 3, m )
                    end do
                 end do
                 ! ==== accumulate orthogonal transformations. ====
                 if( accum ) then
                    ! ==== accumulate u. (if needed, update z later
                    ! .    with an efficient matrix-matrix
                    ! .    multiply.) ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       kms = k - incol
                       i2 = max( 1, ktop-incol )
                       i2 = max( i2, kms-(krcol-incol)+1 )
                       i4 = min( kdu, krcol + 2*( mbot-1 ) - incol + 5 )
                       do j = i2, i4
                          refsum = v( 1, m )*( u( j, kms+1 )+v( 2, m )*u( j, kms+2 )+v( 3, m )*u( &
                                    j, kms+3 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) -refsum*conjg( v( 2, m ) )
                          u( j, kms+3 ) = u( j, kms+3 ) -refsum*conjg( v( 3, m ) )
                       end do
                    end do
                 else if( wantz ) then
                    ! ==== u is not accumulated, so update z
                    ! .    now by multiplying by reflections
                    ! .    from the right. ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       do j = iloz, ihiz
                          refsum = v( 1, m )*( z( j, k+1 )+v( 2, m )*z( j, k+2 )+v( 3, m )*z( j, &
                                    k+3 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) -refsum*conjg( v( 2, m ) )
                          z( j, k+3 ) = z( j, k+3 ) -refsum*conjg( v( 3, m ) )
                       end do
                    end do
                 end if
                 ! ==== end of near-the-diagonal bulge chase. ====
              end do loop_145
              ! ==== use u (if accumulated) to update far-from-diagonal
              ! .    entries in h.  if required, use u to update z as
              ! .    well. ====
              if( accum ) then
                 if( wantt ) then
                    jtop = 1
                    jbot = n
                 else
                    jtop = ktop
                    jbot = kbot
                 end if
                 k1 = max( 1, ktop-incol )
                 nu = ( kdu-max( 0, ndcol-kbot ) ) - k1 + 1
                 ! ==== horizontal multiply ====
                 do jcol = min( ndcol, kbot ) + 1, jbot, nh
                    jlen = min( nh, jbot-jcol+1 )
                    call stdlib_cgemm( 'C', 'N', nu, jlen, nu, cone, u( k1, k1 ),ldu, h( incol+k1,&
                               jcol ), ldh, czero, wh,ldwh )
                    call stdlib_clacpy( 'ALL', nu, jlen, wh, ldwh,h( incol+k1, jcol ), ldh )
                              
                 end do
                 ! ==== vertical multiply ====
                 do jrow = jtop, max( ktop, incol ) - 1, nv
                    jlen = min( nv, max( ktop, incol )-jrow )
                    call stdlib_cgemm( 'N', 'N', jlen, nu, nu, cone,h( jrow, incol+k1 ), ldh, u( &
                              k1, k1 ),ldu, czero, wv, ldwv )
                    call stdlib_clacpy( 'ALL', jlen, nu, wv, ldwv,h( jrow, incol+k1 ), ldh )
                              
                 end do
                 ! ==== z multiply (also vertical) ====
                 if( wantz ) then
                    do jrow = iloz, ihiz, nv
                       jlen = min( nv, ihiz-jrow+1 )
                       call stdlib_cgemm( 'N', 'N', jlen, nu, nu, cone,z( jrow, incol+k1 ), ldz, &
                                 u( k1, k1 ),ldu, czero, wv, ldwv )
                       call stdlib_clacpy( 'ALL', jlen, nu, wv, ldwv,z( jrow, incol+k1 ), ldz )
                                 
                    end do
                 end if
              end if
           end do loop_180
     end subroutine stdlib_claqr5


     pure subroutine stdlib_claqz1( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
     !! CLAQZ1 chases a 1x1 shift bulge in a matrix pencil down a single position
               q, ldq, nz, zstart, z, ldz )
           ! arguments
           logical(lk), intent( in ) :: ilq, ilz
           integer(ilp), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           
           
           ! local variables
           real(sp) :: c
           complex(sp) :: s, temp
           if( k+1 == ihi ) then
              ! shift is located on the edge of the matrix, remove it
              call stdlib_clartg( b( ihi, ihi ), b( ihi, ihi-1 ), c, s, temp )
              b( ihi, ihi ) = temp
              b( ihi, ihi-1 ) = czero
              call stdlib_crot( ihi-istartm, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c, s )
                        
              call stdlib_crot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c, s )
                        
              if ( ilz ) then
                 call stdlib_crot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c, s )
                           
              end if
           else
              ! normal operation, move bulge down
              ! apply transformation from the right
              call stdlib_clartg( b( k+1, k+1 ), b( k+1, k ), c, s, temp )
              b( k+1, k+1 ) = temp
              b( k+1, k ) = czero
              call stdlib_crot( k+2-istartm+1, a( istartm, k+1 ), 1, a( istartm,k ), 1, c, s )
                        
              call stdlib_crot( k-istartm+1, b( istartm, k+1 ), 1, b( istartm, k ),1, c, s )
                        
              if ( ilz ) then
                 call stdlib_crot( nz, z( 1, k+1-zstart+1 ), 1, z( 1, k-zstart+1 ),1, c, s )
                           
              end if
              ! apply transformation from the left
              call stdlib_clartg( a( k+1, k ), a( k+2, k ), c, s, temp )
              a( k+1, k ) = temp
              a( k+2, k ) = czero
              call stdlib_crot( istopm-k, a( k+1, k+1 ), lda, a( k+2, k+1 ), lda, c,s )
              call stdlib_crot( istopm-k, b( k+1, k+1 ), ldb, b( k+2, k+1 ), ldb, c,s )
              if ( ilq ) then
                 call stdlib_crot( nq, q( 1, k+1-qstart+1 ), 1, q( 1, k+2-qstart+1 ), 1, c, conjg(&
                            s ) )
              end if
           end if
     end subroutine stdlib_claqz1


     pure subroutine stdlib_claqz3( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, alpha,&
     !! CLAQZ3 Executes a single multishift QZ sweep
                beta, a, lda, b, ldb,q, ldq, z, ldz, qc, ldqc, zc, ldzc, work,lwork, info )
           ! function arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_desired, ldqc, ldzc
           complex(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), qc( &
                     ldqc, * ), zc( ldzc, * ), work( * ),alpha( * ), beta( * )
           integer(ilp), intent( out ) :: info
           
           
           ! local scalars
           integer(ilp) :: i, j, ns, istartm, istopm, sheight, swidth, k, np, istartb, istopb, &
                     ishift, nblock, npos
           real(sp) :: safmin, safmax, c, scale
           complex(sp) :: temp, temp2, temp3, s
           info = 0
           if ( nblock_desired < nshifts+1 ) then
              info = -8
           end if
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = n*nblock_desired
              return
           else if ( lwork < n*nblock_desired ) then
              info = -25
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAQZ3', -info )
              return
           end if
           ! executable statements
           ! get machine constants
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_slabad( safmin, safmax )
           if ( ilo >= ihi ) then
              return
           end if
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           ns = nshifts
           npos = max( nblock_desired-ns, 1 )
           ! the following block introduces the shifts and chases
           ! them down one by one just enough to make space for
           ! the other shifts. the near-the-diagonal block is
           ! of size (ns+1) x ns.
           call stdlib_claset( 'FULL', ns+1, ns+1, czero, cone, qc, ldqc )
           call stdlib_claset( 'FULL', ns, ns, czero, cone, zc, ldzc )
           do i = 1, ns
              ! introduce the shift
              scale = sqrt( abs( alpha( i ) ) ) * sqrt( abs( beta( i ) ) )
              if( scale >= safmin .and. scale <= safmax ) then
                 alpha( i ) = alpha( i )/scale
                 beta( i ) = beta( i )/scale
              end if
              temp2 = beta( i )*a( ilo, ilo )-alpha( i )*b( ilo, ilo )
              temp3 = beta( i )*a( ilo+1, ilo )
              if ( abs( temp2 ) > safmax .or.abs( temp3 ) > safmax ) then
                 temp2 = cone
                 temp3 = czero
              end if
              call stdlib_clartg( temp2, temp3, c, s, temp )
              call stdlib_crot( ns, a( ilo, ilo ), lda, a( ilo+1, ilo ), lda, c,s )
              call stdlib_crot( ns, b( ilo, ilo ), ldb, b( ilo+1, ilo ), ldb, c,s )
              call stdlib_crot( ns+1, qc( 1, 1 ), 1, qc( 1, 2 ), 1, c, conjg( s ) )
              ! chase the shift down
              do j = 1, ns-i
                 call stdlib_claqz1( .true., .true., j, 1, ns, ihi-ilo+1, a( ilo,ilo ), lda, b( &
                           ilo, ilo ), ldb, ns+1, 1, qc,ldqc, ns, 1, zc, ldzc )
              end do
           end do
           ! update the rest of the pencil
           ! update a(ilo:ilo+ns,ilo+ns:istopm) and b(ilo:ilo+ns,ilo+ns:istopm)
           ! from the left with qc(1:ns+1,1:ns+1)'
           sheight = ns+1
           swidth = istopm-( ilo+ns )+1
           if ( swidth > 0 ) then
              call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,a( ilo, ilo+&
                        ns ), lda, czero, work, sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, a( ilo,ilo+ns ), lda )
                        
              call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,b( ilo, ilo+&
                        ns ), ldb, czero, work, sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, b( ilo,ilo+ns ), ldb )
                        
           end if
           if ( ilq ) then
             call stdlib_cgemm( 'N', 'N', n, sheight, sheight, cone, q( 1, ilo ),ldq, qc, ldqc, &
                       czero, work, n )
              call stdlib_clacpy( 'ALL', n, sheight, work, n, q( 1, ilo ), ldq )
           end if
           ! update a(istartm:ilo-1,ilo:ilo+ns-1) and b(istartm:ilo-1,ilo:ilo+ns-1)
           ! from the right with zc(1:ns,1:ns)
           sheight = ilo-1-istartm+1
           swidth = ns
           if ( sheight > 0 ) then
              call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, ilo ), lda, &
                        zc, ldzc, czero, work,sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ilo ), lda )
                        
              call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, ilo ), ldb, &
                        zc, ldzc, czero, work,sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ilo ), ldb )
                        
           end if
           if ( ilz ) then
              call stdlib_cgemm( 'N', 'N', n, swidth, swidth, cone, z( 1, ilo ),ldz, zc, ldzc, &
                        czero, work, n )
              call stdlib_clacpy( 'ALL', n, swidth, work, n, z( 1, ilo ), ldz )
           end if
           ! the following block chases the shifts down to the bottom
           ! right block. if possible, a shift is moved down npos
           ! positions at a time
           k = ilo
           do while ( k < ihi-ns )
              np = min( ihi-ns-k, npos )
              ! size of the near-the-diagonal block
              nblock = ns+np
              ! istartb points to the first row we will be updating
              istartb = k+1
              ! istopb points to the last column we will be updating
              istopb = k+nblock-1
              call stdlib_claset( 'FULL', ns+np, ns+np, czero, cone, qc, ldqc )
              call stdlib_claset( 'FULL', ns+np, ns+np, czero, cone, zc, ldzc )
              ! near the diagonal shift chase
              do i = ns-1, 0, -1
                 do j = 0, np-1
                    ! move down the block with index k+i+j, updating
                    ! the (ns+np x ns+np) block:
                    ! (k:k+ns+np,k:k+ns+np-1)
                    call stdlib_claqz1( .true., .true., k+i+j, istartb, istopb, ihi,a, lda, b, &
                              ldb, nblock, k+1, qc, ldqc,nblock, k, zc, ldzc )
                 end do
              end do
              ! update rest of the pencil
              ! update a(k+1:k+ns+np, k+ns+np:istopm) and
              ! b(k+1:k+ns+np, k+ns+np:istopm)
              ! from the left with qc(1:ns+np,1:ns+np)'
              sheight = ns+np
              swidth = istopm-( k+ns+np )+1
              if ( swidth > 0 ) then
                 call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc,ldqc, a( k+1, k+&
                           ns+np ), lda, czero, work,sheight )
                 call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, a( k+1,k+ns+np ), lda &
                           )
                 call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc,ldqc, b( k+1, k+&
                           ns+np ), ldb, czero, work,sheight )
                 call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, b( k+1,k+ns+np ), ldb &
                           )
              end if
              if ( ilq ) then
                 call stdlib_cgemm( 'N', 'N', n, nblock, nblock, cone, q( 1, k+1 ),ldq, qc, ldqc, &
                           czero, work, n )
                 call stdlib_clacpy( 'ALL', n, nblock, work, n, q( 1, k+1 ), ldq )
              end if
              ! update a(istartm:k,k:k+ns+npos-1) and b(istartm:k,k:k+ns+npos-1)
              ! from the right with zc(1:ns+np,1:ns+np)
              sheight = k-istartm+1
              swidth = nblock
              if ( sheight > 0 ) then
                 call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, k ), lda, &
                           zc, ldzc, czero, work,sheight )
                 call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight,a( istartm, k ), lda )
                           
                 call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, k ), ldb, &
                           zc, ldzc, czero, work,sheight )
                 call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight,b( istartm, k ), ldb )
                           
              end if
              if ( ilz ) then
                 call stdlib_cgemm( 'N', 'N', n, nblock, nblock, cone, z( 1, k ),ldz, zc, ldzc, &
                           czero, work, n )
                 call stdlib_clacpy( 'ALL', n, nblock, work, n, z( 1, k ), ldz )
              end if
              k = k+np
           end do
           ! the following block removes the shifts from the bottom right corner
           ! one by one. updates are initially applied to a(ihi-ns+1:ihi,ihi-ns:ihi).
           call stdlib_claset( 'FULL', ns, ns, czero, cone, qc, ldqc )
           call stdlib_claset( 'FULL', ns+1, ns+1, czero, cone, zc, ldzc )
           ! istartb points to the first row we will be updating
           istartb = ihi-ns+1
           ! istopb points to the last column we will be updating
           istopb = ihi
           do i = 1, ns
              ! chase the shift down to the bottom right corner
              do ishift = ihi-i, ihi-1
                 call stdlib_claqz1( .true., .true., ishift, istartb, istopb, ihi,a, lda, b, ldb, &
                           ns, ihi-ns+1, qc, ldqc, ns+1,ihi-ns, zc, ldzc )
              end do
           end do
           ! update rest of the pencil
           ! update a(ihi-ns+1:ihi, ihi+1:istopm)
           ! from the left with qc(1:ns,1:ns)'
           sheight = ns
           swidth = istopm-( ihi+1 )+1
           if ( swidth > 0 ) then
              call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,a( ihi-ns+1, &
                        ihi+1 ), lda, czero, work, sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight,a( ihi-ns+1, ihi+1 ), lda &
                        )
              call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,b( ihi-ns+1, &
                        ihi+1 ), ldb, czero, work, sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight,b( ihi-ns+1, ihi+1 ), ldb &
                        )
           end if
           if ( ilq ) then
              call stdlib_cgemm( 'N', 'N', n, ns, ns, cone, q( 1, ihi-ns+1 ), ldq,qc, ldqc, czero,&
                         work, n )
              call stdlib_clacpy( 'ALL', n, ns, work, n, q( 1, ihi-ns+1 ), ldq )
           end if
           ! update a(istartm:ihi-ns,ihi-ns:ihi)
           ! from the right with zc(1:ns+1,1:ns+1)
           sheight = ihi-ns-istartm+1
           swidth = ns+1
           if ( sheight > 0 ) then
              call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, ihi-ns ), &
                        lda, zc, ldzc, czero, work,sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ihi-ns ), lda &
                        )
              call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, ihi-ns ), &
                        ldb, zc, ldzc, czero, work,sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ihi-ns ), ldb &
                        )
           end if
           if ( ilz ) then
              call stdlib_cgemm( 'N', 'N', n, ns+1, ns+1, cone, z( 1, ihi-ns ), ldz,zc, ldzc, &
                        czero, work, n )
              call stdlib_clacpy( 'ALL', n, ns+1, work, n, z( 1, ihi-ns ), ldz )
           end if
     end subroutine stdlib_claqz3


     pure subroutine stdlib_clargv( n, x, incx, y, incy, c, incc )
     !! CLARGV generates a vector of complex plane rotations with real
     !! cosines, determined by elements of the complex vectors x and y.
     !! For i = 1,2,...,n
     !! (        c(i)   s(i) ) ( x(i) ) = ( r(i) )
     !! ( -conjg(s(i))  c(i) ) ( y(i) ) = (   0  )
     !! where c(i)**2 + ABS(s(i))**2 = 1
     !! The following conventions are used (these are the same as in CLARTG,
     !! but differ from the BLAS1 routine CROTG):
     !! If y(i)=0, then c(i)=1 and s(i)=0.
     !! If x(i)=0, then c(i)=0 and s(i) is chosen so that r(i) is real.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incc, incx, incy, n
           ! Array Arguments 
           real(sp), intent(out) :: c(*)
           complex(sp), intent(inout) :: x(*), y(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           ! logical            first
           integer(ilp) :: count, i, ic, ix, iy, j
           real(sp) :: cs, d, di, dr, eps, f2, f2s, g2, g2s, safmin, safmn2, safmx2, scale
           complex(sp) :: f, ff, fs, g, gs, r, sn
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,conjg,int,log,max,real,sqrt
           ! Statement Functions 
           real(sp) :: abs1, abssq
           ! Save Statement 
           ! save               first, safmx2, safmin, safmn2
           ! Data Statements 
           ! data               first / .true. /
           ! Statement Function Definitions 
           abs1( ff ) = max( abs( real( ff,KIND=sp) ), abs( aimag( ff ) ) )
           abssq( ff ) = real( ff,KIND=sp)**2 + aimag( ff )**2
           ! Executable Statements 
           ! if( first ) then
              ! first = .false.
              safmin = stdlib_slamch( 'S' )
              eps = stdlib_slamch( 'E' )
              safmn2 = stdlib_slamch( 'B' )**int( log( safmin / eps ) /log( stdlib_slamch( 'B' ) )&
                         / two,KIND=ilp)
              safmx2 = one / safmn2
           ! end if
           ix = 1
           iy = 1
           ic = 1
           loop_60: do i = 1, n
              f = x( ix )
              g = y( iy )
              ! use identical algorithm as in stdlib_clartg
              scale = max( abs1( f ), abs1( g ) )
              fs = f
              gs = g
              count = 0
              if( scale>=safmx2 ) then
              10 continue
                 count = count + 1
                 fs = fs*safmn2
                 gs = gs*safmn2
                 scale = scale*safmn2
                 if( scale>=safmx2 .and. count < 20 )go to 10
              else if( scale<=safmn2 ) then
                 if( g==czero ) then
                    cs = one
                    sn = czero
                    r = f
                    go to 50
                 end if
                 20 continue
                 count = count - 1
                 fs = fs*safmx2
                 gs = gs*safmx2
                 scale = scale*safmx2
                 if( scale<=safmn2 )go to 20
              end if
              f2 = abssq( fs )
              g2 = abssq( gs )
              if( f2<=max( g2, one )*safmin ) then
                 ! this is a rare case: f is very small.
                 if( f==czero ) then
                    cs = zero
                    r = stdlib_slapy2( real( g,KIND=sp), aimag( g ) )
                    ! do complex/real division explicitly with two real
                    ! divisions
                    d = stdlib_slapy2( real( gs,KIND=sp), aimag( gs ) )
                    sn = cmplx( real( gs,KIND=sp) / d, -aimag( gs ) / d,KIND=sp)
                    go to 50
                 end if
                 f2s = stdlib_slapy2( real( fs,KIND=sp), aimag( fs ) )
                 ! g2 and g2s are accurate
                 ! g2 is at least safmin, and g2s is at least safmn2
                 g2s = sqrt( g2 )
                 ! error in cs from underflow in f2s is at most
                 ! unfl / safmn2 .lt. sqrt(unfl*eps) .lt. eps
                 ! if max(g2,one)=g2, then f2 .lt. g2*safmin,
                 ! and so cs .lt. sqrt(safmin)
                 ! if max(g2,one)=one, then f2 .lt. safmin
                 ! and so cs .lt. sqrt(safmin)/safmn2 = sqrt(eps)
                 ! therefore, cs = f2s/g2s / sqrt( 1 + (f2s/g2s)**2 ) = f2s/g2s
                 cs = f2s / g2s
                 ! make sure abs(ff) = 1
                 ! do complex/real division explicitly with 2 real divisions
                 if( abs1( f )>one ) then
                    d = stdlib_slapy2( real( f,KIND=sp), aimag( f ) )
                    ff = cmplx( real( f,KIND=sp) / d, aimag( f ) / d,KIND=sp)
                 else
                    dr = safmx2*real( f,KIND=sp)
                    di = safmx2*aimag( f )
                    d = stdlib_slapy2( dr, di )
                    ff = cmplx( dr / d, di / d,KIND=sp)
                 end if
                 sn = ff*cmplx( real( gs,KIND=sp) / g2s, -aimag( gs ) / g2s,KIND=sp)
                 r = cs*f + sn*g
              else
                 ! this is the most common case.
                 ! neither f2 nor f2/g2 are less than safmin
                 ! f2s cannot overflow, and it is accurate
                 f2s = sqrt( one+g2 / f2 )
                 ! do the f2s(real)*fs(complex) multiply with two real
                 ! multiplies
                 r = cmplx( f2s*real( fs,KIND=sp), f2s*aimag( fs ),KIND=sp)
                 cs = one / f2s
                 d = f2 + g2
                 ! do complex/real division explicitly with two real divisions
                 sn = cmplx( real( r,KIND=sp) / d, aimag( r ) / d,KIND=sp)
                 sn = sn*conjg( gs )
                 if( count/=0 ) then
                    if( count>0 ) then
                       do j = 1, count
                          r = r*safmx2
                       end do
                    else
                       do j = 1, -count
                          r = r*safmn2
                       end do
                    end if
                 end if
              end if
              50 continue
              c( ic ) = cs
              y( iy ) = sn
              x( ix ) = r
              ic = ic + incc
              iy = iy + incy
              ix = ix + incx
           end do loop_60
           return
     end subroutine stdlib_clargv


     pure subroutine stdlib_clarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
     !! CLARRV computes the eigenvectors of the tridiagonal matrix
     !! T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.
     !! The input eigenvalues should have been computed by SLARRE.
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: dol, dou, ldz, m, n
           integer(ilp), intent(out) :: info
           real(sp), intent(in) :: minrgp, pivmin, vl, vu
           real(sp), intent(inout) :: rtol1, rtol2
           ! Array Arguments 
           integer(ilp), intent(in) :: iblock(*), indexw(*), isplit(*)
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), l(*), w(*), werr(*), wgap(*)
           real(sp), intent(in) :: gers(*)
           real(sp), intent(out) :: work(*)
           complex(sp), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxitr = 10
           
           
           
           ! Local Scalars 
           logical(lk) :: eskip, needbs, stp2ii, tryrqc, usedbs, usedrq
           integer(ilp) :: done, i, ibegin, idone, iend, ii, iindc1, iindc2, iindr, iindwk, iinfo,&
            im, in, indeig, indld, indlld, indwrk, isupmn, isupmx, iter, itmp1, j, jblk, k, &
            miniwsize, minwsize, nclus, ndepth, negcnt, newcls, newfst, newftt, newlst, newsiz, &
            offset, oldcls, oldfst, oldien, oldlst, oldncl, p, parity, q, wbegin, wend, windex, &
                      windmn, windpl, zfrom, zto, zusedl, zusedu, zusedw
           integer(ilp) :: indin1, indin2
           real(sp) :: bstres, bstw, eps, fudge, gap, gaptol, gl, gu, lambda, left, lgap, mingma, &
           nrminv, resid, rgap, right, rqcorr, rqtol, savgap, sgndef, sigma, spdiam, ssigma, tau, &
                     tmp, tol, ztz
           ! Intrinsic Functions 
           intrinsic :: abs,real,max,min
           intrinsic :: cmplx
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( (n<=0).or.(m<=0) ) then
              return
           end if
           ! the first n entries of work are reserved for the eigenvalues
           indld = n+1
           indlld= 2*n+1
           indin1 = 3*n + 1
           indin2 = 4*n + 1
           indwrk = 5*n + 1
           minwsize = 12 * n
           do i= 1,minwsize
              work( i ) = zero
           end do
           ! iwork(iindr+1:iindr+n) hold the twist indices r for the
           ! factorization used to compute the fp vector
           iindr = 0
           ! iwork(iindc1+1:iinc2+n) are used to store the clusters of the current
           ! layer and the one above.
           iindc1 = n
           iindc2 = 2*n
           iindwk = 3*n + 1
           miniwsize = 7 * n
           do i= 1,miniwsize
              iwork( i ) = 0
           end do
           zusedl = 1
           if(dol>1) then
              ! set lower bound for use of z
              zusedl = dol-1
           endif
           zusedu = m
           if(dou<m) then
              ! set lower bound for use of z
              zusedu = dou+1
           endif
           ! the width of the part of z that is used
           zusedw = zusedu - zusedl + 1
           call stdlib_claset( 'FULL', n, zusedw, czero, czero,z(1,zusedl), ldz )
           eps = stdlib_slamch( 'PRECISION' )
           rqtol = two * eps
           ! set expert flags for standard code.
           tryrqc = .true.
           if((dol==1).and.(dou==m)) then
           else
              ! only selected eigenpairs are computed. since the other evalues
              ! are not refined by rq iteration, bisection has to compute to full
              ! accuracy.
              rtol1 = four * eps
              rtol2 = four * eps
           endif
           ! the entries wbegin:wend in w, werr, wgap correspond to the
           ! desired eigenvalues. the support of the nonzero eigenvector
           ! entries is contained in the interval ibegin:iend.
           ! remark that if k eigenpairs are desired, then the eigenvectors
           ! are stored in k contiguous columns of z.
           ! done is the number of eigenvectors already computed
           done = 0
           ibegin = 1
           wbegin = 1
           loop_170: do jblk = 1, iblock( m )
              iend = isplit( jblk )
              sigma = l( iend )
              ! find the eigenvectors of the submatrix indexed ibegin
              ! through iend.
              wend = wbegin - 1
              15 continue
              if( wend<m ) then
                 if( iblock( wend+1 )==jblk ) then
                    wend = wend + 1
                    go to 15
                 end if
              end if
              if( wend<wbegin ) then
                 ibegin = iend + 1
                 cycle loop_170
              elseif( (wend<dol).or.(wbegin>dou) ) then
                 ibegin = iend + 1
                 wbegin = wend + 1
                 cycle loop_170
              end if
              ! find local spectral diameter of the block
              gl = gers( 2*ibegin-1 )
              gu = gers( 2*ibegin )
              do i = ibegin+1 , iend
                 gl = min( gers( 2*i-1 ), gl )
                 gu = max( gers( 2*i ), gu )
              end do
              spdiam = gu - gl
              ! oldien is the last index of the previous block
              oldien = ibegin - 1
              ! calculate the size of the current block
              in = iend - ibegin + 1
              ! the number of eigenvalues in the current block
              im = wend - wbegin + 1
              ! this is for a 1x1 block
              if( ibegin==iend ) then
                 done = done+1
                 z( ibegin, wbegin ) = cmplx( one, zero,KIND=sp)
                 isuppz( 2*wbegin-1 ) = ibegin
                 isuppz( 2*wbegin ) = ibegin
                 w( wbegin ) = w( wbegin ) + sigma
                 work( wbegin ) = w( wbegin )
                 ibegin = iend + 1
                 wbegin = wbegin + 1
                 cycle loop_170
              end if
              ! the desired (shifted) eigenvalues are stored in w(wbegin:wend)
              ! note that these can be approximations, in this case, the corresp.
              ! entries of werr give the size of the uncertainty interval.
              ! the eigenvalue approximations will be refined when necessary as
              ! high relative accuracy is required for the computation of the
              ! corresponding eigenvectors.
              call stdlib_scopy( im, w( wbegin ), 1,work( wbegin ), 1 )
              ! we store in w the eigenvalue approximations w.r.t. the original
              ! matrix t.
              do i=1,im
                 w(wbegin+i-1) = w(wbegin+i-1)+sigma
              end do
              ! ndepth is the current depth of the representation tree
              ndepth = 0
              ! parity is either 1 or 0
              parity = 1
              ! nclus is the number of clusters for the next level of the
              ! representation tree, we start with nclus = 1 for the root
              nclus = 1
              iwork( iindc1+1 ) = 1
              iwork( iindc1+2 ) = im
              ! idone is the number of eigenvectors already computed in the current
              ! block
              idone = 0
              ! loop while( idone<im )
              ! generate the representation tree for the current block and
              ! compute the eigenvectors
              40 continue
              if( idone<im ) then
                 ! this is a crude protection against infinitely deep trees
                 if( ndepth>m ) then
                    info = -2
                    return
                 endif
                 ! breadth first processing of the current level of the representation
                 ! tree: oldncl = number of clusters on current level
                 oldncl = nclus
                 ! reset nclus to count the number of child clusters
                 nclus = 0
                 parity = 1 - parity
                 if( parity==0 ) then
                    oldcls = iindc1
                    newcls = iindc2
                 else
                    oldcls = iindc2
                    newcls = iindc1
                 end if
                 ! process the clusters on the current level
                 loop_150: do i = 1, oldncl
                    j = oldcls + 2*i
                    ! oldfst, oldlst = first, last index of current cluster.
                                     ! cluster indices start with 1 and are relative
                                     ! to wbegin when accessing w, wgap, werr, z
                    oldfst = iwork( j-1 )
                    oldlst = iwork( j )
                    if( ndepth>0 ) then
                       ! retrieve relatively robust representation (rrr) of cluster
                       ! that has been computed at the previous level
                       ! the rrr is stored in z and overwritten once the eigenvectors
                       ! have been computed or when the cluster is refined
                       if((dol==1).and.(dou==m)) then
                          ! get representation from location of the leftmost evalue
                          ! of the cluster
                          j = wbegin + oldfst - 1
                       else
                          if(wbegin+oldfst-1<dol) then
                             ! get representation from the left end of z array
                             j = dol - 1
                          elseif(wbegin+oldfst-1>dou) then
                             ! get representation from the right end of z array
                             j = dou
                          else
                             j = wbegin + oldfst - 1
                          endif
                       endif
                       do k = 1, in - 1
                          d( ibegin+k-1 ) = real( z( ibegin+k-1,j ),KIND=sp)
                          l( ibegin+k-1 ) = real( z( ibegin+k-1,j+1 ),KIND=sp)
                       end do
                       d( iend ) = real( z( iend, j ),KIND=sp)
                       sigma = real( z( iend, j+1 ),KIND=sp)
                       ! set the corresponding entries in z to zero
                       call stdlib_claset( 'FULL', in, 2, czero, czero,z( ibegin, j), ldz )
                                 
                    end if
                    ! compute dl and dll of current rrr
                    do j = ibegin, iend-1
                       tmp = d( j )*l( j )
                       work( indld-1+j ) = tmp
                       work( indlld-1+j ) = tmp*l( j )
                    end do
                    if( ndepth>0 ) then
                       ! p and q are index of the first and last eigenvalue to compute
                       ! within the current block
                       p = indexw( wbegin-1+oldfst )
                       q = indexw( wbegin-1+oldlst )
                       ! offset for the arrays work, wgap and werr, i.e., the p-offset
                       ! through the q-offset elements of these arrays are to be used.
                        ! offset = p-oldfst
                       offset = indexw( wbegin ) - 1
                       ! perform limited bisection (if necessary) to get approximate
                       ! eigenvalues to the precision needed.
                       call stdlib_slarrb( in, d( ibegin ),work(indlld+ibegin-1),p, q, rtol1, &
                       rtol2, offset,work(wbegin),wgap(wbegin),werr(wbegin),work( indwrk ), iwork(&
                                  iindwk ),pivmin, spdiam, in, iinfo )
                       if( iinfo/=0 ) then
                          info = -1
                          return
                       endif
                       ! we also recompute the extremal gaps. w holds all eigenvalues
                       ! of the unshifted matrix and must be used for computation
                       ! of wgap, the entries of work might stem from rrrs with
                       ! different shifts. the gaps from wbegin-1+oldfst to
                       ! wbegin-1+oldlst are correctly computed in stdlib_slarrb.
                       ! however, we only allow the gaps to become greater since
                       ! this is what should happen when we decrease werr
                       if( oldfst>1) then
                          wgap( wbegin+oldfst-2 ) =max(wgap(wbegin+oldfst-2),w(wbegin+oldfst-1)-&
                          werr(wbegin+oldfst-1)- w(wbegin+oldfst-2)-werr(wbegin+oldfst-2) )
                                    
                       endif
                       if( wbegin + oldlst -1 < wend ) then
                          wgap( wbegin+oldlst-1 ) =max(wgap(wbegin+oldlst-1),w(wbegin+oldlst)-&
                                    werr(wbegin+oldlst)- w(wbegin+oldlst-1)-werr(wbegin+oldlst-1) )
                       endif
                       ! each time the eigenvalues in work get refined, we store
                       ! the newly found approximation with all shifts applied in w
                       do j=oldfst,oldlst
                          w(wbegin+j-1) = work(wbegin+j-1)+sigma
                       end do
                    end if
                    ! process the current node.
                    newfst = oldfst
                    loop_140: do j = oldfst, oldlst
                       if( j==oldlst ) then
                          ! we are at the right end of the cluster, this is also the
                          ! boundary of the child cluster
                          newlst = j
                       else if ( wgap( wbegin + j -1)>=minrgp* abs( work(wbegin + j -1) ) ) &
                                 then
                          ! the right relative gap is big enough, the child cluster
                          ! (newfst,..,newlst) is well separated from the following
                          newlst = j
                        else
                          ! inside a child cluster, the relative gap is not
                          ! big enough.
                          cycle loop_140
                       end if
                       ! compute size of child cluster found
                       newsiz = newlst - newfst + 1
                       ! newftt is the place in z where the new rrr or the computed
                       ! eigenvector is to be stored
                       if((dol==1).and.(dou==m)) then
                          ! store representation at location of the leftmost evalue
                          ! of the cluster
                          newftt = wbegin + newfst - 1
                       else
                          if(wbegin+newfst-1<dol) then
                             ! store representation at the left end of z array
                             newftt = dol - 1
                          elseif(wbegin+newfst-1>dou) then
                             ! store representation at the right end of z array
                             newftt = dou
                          else
                             newftt = wbegin + newfst - 1
                          endif
                       endif
                       if( newsiz>1) then
                          ! current child is not a singleton but a cluster.
                          ! compute and store new representation of child.
                          ! compute left and right cluster gap.
                          ! lgap and rgap are not computed from work because
                          ! the eigenvalue approximations may stem from rrrs
                          ! different shifts. however, w hold all eigenvalues
                          ! of the unshifted matrix. still, the entries in wgap
                          ! have to be computed from work since the entries
                          ! in w might be of the same order so that gaps are not
                          ! exhibited correctly for very close eigenvalues.
                          if( newfst==1 ) then
                             lgap = max( zero,w(wbegin)-werr(wbegin) - vl )
                         else
                             lgap = wgap( wbegin+newfst-2 )
                          endif
                          rgap = wgap( wbegin+newlst-1 )
                          ! compute left- and rightmost eigenvalue of child
                          ! to high precision in order to shift as close
                          ! as possible and obtain as large relative gaps
                          ! as possible
                          do k =1,2
                             if(k==1) then
                                p = indexw( wbegin-1+newfst )
                             else
                                p = indexw( wbegin-1+newlst )
                             endif
                             offset = indexw( wbegin ) - 1
                             call stdlib_slarrb( in, d(ibegin),work( indlld+ibegin-1 ),p,p,rqtol, &
                             rqtol, offset,work(wbegin),wgap(wbegin),werr(wbegin),work( indwrk ),&
                                       iwork( iindwk ), pivmin, spdiam,in, iinfo )
                          end do
                          if((wbegin+newlst-1<dol).or.(wbegin+newfst-1>dou)) then
                             ! if the cluster contains no desired eigenvalues
                             ! skip the computation of that branch of the rep. tree
                             ! we could skip before the refinement of the extremal
                             ! eigenvalues of the child, but then the representation
                             ! tree could be different from the one when nothing is
                             ! skipped. for this reason we skip at this place.
                             idone = idone + newlst - newfst + 1
                             goto 139
                          endif
                          ! compute rrr of child cluster.
                          ! note that the new rrr is stored in z
                          ! stdlib_slarrf needs lwork = 2*n
                          call stdlib_slarrf( in, d( ibegin ), l( ibegin ),work(indld+ibegin-1),&
                          newfst, newlst, work(wbegin),wgap(wbegin), werr(wbegin),spdiam, lgap, &
                          rgap, pivmin, tau,work( indin1 ), work( indin2 ),work( indwrk ), iinfo )
                                    
                          ! in the complex case, stdlib_slarrf cannot write
                          ! the new rrr directly into z and needs an intermediate
                          ! workspace
                          do k = 1, in-1
                             z( ibegin+k-1, newftt ) =cmplx( work( indin1+k-1 ), zero,KIND=sp)
                                       
                             z( ibegin+k-1, newftt+1 ) =cmplx( work( indin2+k-1 ), zero,KIND=sp)
                                       
                          end do
                          z( iend, newftt ) =cmplx( work( indin1+in-1 ), zero,KIND=sp)
                          if( iinfo==0 ) then
                             ! a new rrr for the cluster was found by stdlib_slarrf
                             ! update shift and store it
                             ssigma = sigma + tau
                             z( iend, newftt+1 ) = cmplx( ssigma, zero,KIND=sp)
                             ! work() are the midpoints and werr() the semi-width
                             ! note that the entries in w are unchanged.
                             do k = newfst, newlst
                                fudge =three*eps*abs(work(wbegin+k-1))
                                work( wbegin + k - 1 ) =work( wbegin + k - 1) - tau
                                fudge = fudge +four*eps*abs(work(wbegin+k-1))
                                ! fudge errors
                                werr( wbegin + k - 1 ) =werr( wbegin + k - 1 ) + fudge
                                ! gaps are not fudged. provided that werr is small
                                ! when eigenvalues are close, a zero gap indicates
                                ! that a new representation is needed for resolving
                                ! the cluster. a fudge could lead to a wrong decision
                                ! of judging eigenvalues 'separated' which in
                                ! reality are not. this could have a negative impact
                                ! on the orthogonality of the computed eigenvectors.
                             end do
                             nclus = nclus + 1
                             k = newcls + 2*nclus
                             iwork( k-1 ) = newfst
                             iwork( k ) = newlst
                          else
                             info = -2
                             return
                          endif
                       else
                          ! compute eigenvector of singleton
                          iter = 0
                          tol = four * log(real(in,KIND=sp)) * eps
                          k = newfst
                          windex = wbegin + k - 1
                          windmn = max(windex - 1,1)
                          windpl = min(windex + 1,m)
                          lambda = work( windex )
                          done = done + 1
                          ! check if eigenvector computation is to be skipped
                          if((windex<dol).or.(windex>dou)) then
                             eskip = .true.
                             goto 125
                          else
                             eskip = .false.
                          endif
                          left = work( windex ) - werr( windex )
                          right = work( windex ) + werr( windex )
                          indeig = indexw( windex )
                          ! note that since we compute the eigenpairs for a child,
                          ! all eigenvalue approximations are w.r.t the same shift.
                          ! in this case, the entries in work should be used for
                          ! computing the gaps since they exhibit even very small
                          ! differences in the eigenvalues, as opposed to the
                          ! entries in w which might "look" the same.
                          if( k == 1) then
                             ! in the case range='i' and with not much initial
                             ! accuracy in lambda and vl, the formula
                             ! lgap = max( zero, (sigma - vl) + lambda )
                             ! can lead to an overestimation of the left gap and
                             ! thus to inadequately early rqi 'convergence'.
                             ! prevent this by forcing a small left gap.
                             lgap = eps*max(abs(left),abs(right))
                          else
                             lgap = wgap(windmn)
                          endif
                          if( k == im) then
                             ! in the case range='i' and with not much initial
                             ! accuracy in lambda and vu, the formula
                             ! can lead to an overestimation of the right gap and
                             ! thus to inadequately early rqi 'convergence'.
                             ! prevent this by forcing a small right gap.
                             rgap = eps*max(abs(left),abs(right))
                          else
                             rgap = wgap(windex)
                          endif
                          gap = min( lgap, rgap )
                          if(( k == 1).or.(k == im)) then
                             ! the eigenvector support can become wrong
                             ! because significant entries could be cut off due to a
                             ! large gaptol parameter in lar1v. prevent this.
                             gaptol = zero
                          else
                             gaptol = gap * eps
                          endif
                          isupmn = in
                          isupmx = 1
                          ! update wgap so that it holds the minimum gap
                          ! to the left or the right. this is crucial in the
                          ! case where bisection is used to ensure that the
                          ! eigenvalue is refined up to the required precision.
                          ! the correct value is restored afterwards.
                          savgap = wgap(windex)
                          wgap(windex) = gap
                          ! we want to use the rayleigh quotient correction
                          ! as often as possible since it converges quadratically
                          ! when we are close enough to the desired eigenvalue.
                          ! however, the rayleigh quotient can have the wrong sign
                          ! and lead us away from the desired eigenvalue. in this
                          ! case, the best we can do is to use bisection.
                          usedbs = .false.
                          usedrq = .false.
                          ! bisection is initially turned off unless it is forced
                          needbs =  .not.tryrqc
                          120 continue
                          ! check if bisection should be used to refine eigenvalue
                          if(needbs) then
                             ! take the bisection as new iterate
                             usedbs = .true.
                             itmp1 = iwork( iindr+windex )
                             offset = indexw( wbegin ) - 1
                             call stdlib_slarrb( in, d(ibegin),work(indlld+ibegin-1),indeig,&
                             indeig,zero, two*eps, offset,work(wbegin),wgap(wbegin),werr(wbegin),&
                                       work( indwrk ),iwork( iindwk ), pivmin, spdiam,itmp1, iinfo )
                             if( iinfo/=0 ) then
                                info = -3
                                return
                             endif
                             lambda = work( windex )
                             ! reset twist index from inaccurate lambda to
                             ! force computation of true mingma
                             iwork( iindr+windex ) = 0
                          endif
                          ! given lambda, compute the eigenvector.
                          call stdlib_clar1v( in, 1, in, lambda, d( ibegin ),l( ibegin ), work(&
                          indld+ibegin-1),work(indlld+ibegin-1),pivmin, gaptol, z( ibegin, windex &
                          ),.not.usedbs, negcnt, ztz, mingma,iwork( iindr+windex ), isuppz( &
                                    2*windex-1 ),nrminv, resid, rqcorr, work( indwrk ) )
                          if(iter == 0) then
                             bstres = resid
                             bstw = lambda
                          elseif(resid<bstres) then
                             bstres = resid
                             bstw = lambda
                          endif
                          isupmn = min(isupmn,isuppz( 2*windex-1 ))
                          isupmx = max(isupmx,isuppz( 2*windex ))
                          iter = iter + 1
                          ! sin alpha <= |resid|/gap
                          ! note that both the residual and the gap are
                          ! proportional to the matrix, so ||t|| doesn't play
                          ! a role in the quotient
                          ! convergence test for rayleigh-quotient iteration
                          ! (omitted when bisection has been used)
                          if( resid>tol*gap .and. abs( rqcorr )>rqtol*abs( lambda ) .and. .not. &
                                    usedbs)then
                             ! we need to check that the rqcorr update doesn't
                             ! move the eigenvalue away from the desired one and
                             ! towards a neighbor. -> protection with bisection
                             if(indeig<=negcnt) then
                                ! the wanted eigenvalue lies to the left
                                sgndef = -one
                             else
                                ! the wanted eigenvalue lies to the right
                                sgndef = one
                             endif
                             ! we only use the rqcorr if it improves the
                             ! the iterate reasonably.
                             if( ( rqcorr*sgndef>=zero ).and.( lambda + rqcorr<= right).and.( &
                                       lambda + rqcorr>= left)) then
                                usedrq = .true.
                                ! store new midpoint of bisection interval in work
                                if(sgndef==one) then
                                   ! the current lambda is on the left of the true
                                   ! eigenvalue
                                   left = lambda
                                   ! we prefer to assume that the error estimate
                                   ! is correct. we could make the interval not
                                   ! as a bracket but to be modified if the rqcorr
                                   ! chooses to. in this case, the right side should
                                   ! be modified as follows:
                                    ! right = max(right, lambda + rqcorr)
                                else
                                   ! the current lambda is on the right of the true
                                   ! eigenvalue
                                   right = lambda
                                   ! see comment about assuming the error estimate is
                                   ! correct above.
                                    ! left = min(left, lambda + rqcorr)
                                endif
                                work( windex ) =half * (right + left)
                                ! take rqcorr since it has the correct sign and
                                ! improves the iterate reasonably
                                lambda = lambda + rqcorr
                                ! update width of error interval
                                werr( windex ) =half * (right-left)
                             else
                                needbs = .true.
                             endif
                             if(right-left<rqtol*abs(lambda)) then
                                   ! the eigenvalue is computed to bisection accuracy
                                   ! compute eigenvector and stop
                                usedbs = .true.
                                goto 120
                             elseif( iter<maxitr ) then
                                goto 120
                             elseif( iter==maxitr ) then
                                needbs = .true.
                                goto 120
                             else
                                info = 5
                                return
                             end if
                          else
                             stp2ii = .false.
             if(usedrq .and. usedbs .and.bstres<=resid) then
                                lambda = bstw
                                stp2ii = .true.
                             endif
                             if (stp2ii) then
                                ! improve error angle by second step
                                call stdlib_clar1v( in, 1, in, lambda,d( ibegin ), l( ibegin ),&
                                work(indld+ibegin-1),work(indlld+ibegin-1),pivmin, gaptol, z( &
                                ibegin, windex ),.not.usedbs, negcnt, ztz, mingma,iwork( iindr+&
                                windex ),isuppz( 2*windex-1 ),nrminv, resid, rqcorr, work( indwrk &
                                          ) )
                             endif
                             work( windex ) = lambda
                          end if
                          ! compute fp-vector support w.r.t. whole matrix
                          isuppz( 2*windex-1 ) = isuppz( 2*windex-1 )+oldien
                          isuppz( 2*windex ) = isuppz( 2*windex )+oldien
                          zfrom = isuppz( 2*windex-1 )
                          zto = isuppz( 2*windex )
                          isupmn = isupmn + oldien
                          isupmx = isupmx + oldien
                          ! ensure vector is ok if support in the rqi has changed
                          if(isupmn<zfrom) then
                             do ii = isupmn,zfrom-1
                                z( ii, windex ) = zero
                             end do
                          endif
                          if(isupmx>zto) then
                             do ii = zto+1,isupmx
                                z( ii, windex ) = zero
                             end do
                          endif
                          call stdlib_csscal( zto-zfrom+1, nrminv,z( zfrom, windex ), 1 )
                          125 continue
                          ! update w
                          w( windex ) = lambda+sigma
                          ! recompute the gaps on the left and right
                          ! but only allow them to become larger and not
                          ! smaller (which can only happen through "bad"
                          ! cancellation and doesn't reflect the theory
                          ! where the initial gaps are underestimated due
                          ! to werr being too crude.)
                          if(.not.eskip) then
                             if( k>1) then
                                wgap( windmn ) = max( wgap(windmn),w(windex)-werr(windex)- w(&
                                          windmn)-werr(windmn) )
                             endif
                             if( windex<wend ) then
                                wgap( windex ) = max( savgap,w( windpl )-werr( windpl )- w( &
                                          windex )-werr( windex) )
                             endif
                          endif
                          idone = idone + 1
                       endif
                       ! here ends the code for the current child
                       139 continue
                       ! proceed to any remaining child nodes
                       newfst = j + 1
                    end do loop_140
                 end do loop_150
                 ndepth = ndepth + 1
                 go to 40
              end if
              ibegin = iend + 1
              wbegin = wend + 1
           end do loop_170
           return
     end subroutine stdlib_clarrv


     pure subroutine stdlib_clatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,jpiv )
     !! CLATDF computes the contribution to the reciprocal Dif-estimate
     !! by solving for x in Z * x = b, where b is chosen such that the norm
     !! of x is as large as possible. It is assumed that LU decomposition
     !! of Z has been computed by CGETC2. On entry RHS = f holds the
     !! contribution from earlier solved sub-systems, and on return RHS = x.
     !! The factorization of Z returned by CGETC2 has the form
     !! Z = P * L * U * Q, where P and Q are permutation matrices. L is lower
     !! triangular with unit diagonal elements and U is upper triangular.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ijob, ldz, n
           real(sp), intent(inout) :: rdscal, rdsum
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*), jpiv(*)
           complex(sp), intent(inout) :: rhs(*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxdim = 2
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, info, j, k
           real(sp) :: rtemp, scale, sminu, splus
           complex(sp) :: bm, bp, pmone, temp
           ! Local Arrays 
           real(sp) :: rwork(maxdim)
           complex(sp) :: work(4*maxdim), xm(maxdim), xp(maxdim)
           ! Intrinsic Functions 
           intrinsic :: abs,real,sqrt
           ! Executable Statements 
           if( ijob/=2 ) then
              ! apply permutations ipiv to rhs
              call stdlib_claswp( 1, rhs, ldz, 1, n-1, ipiv, 1 )
              ! solve for l-part choosing rhs either to +1 or -1.
              pmone = -cone
              loop_10: do j = 1, n - 1
                 bp = rhs( j ) + cone
                 bm = rhs( j ) - cone
                 splus = one
                 ! lockahead for l- part rhs(1:n-1) = +-1
                 ! splus and smin computed more efficiently than in bsolve[1].
                 splus = splus + real( stdlib_cdotc( n-j, z( j+1, j ), 1, z( j+1,j ), 1 ),KIND=sp)
                           
                 sminu = real( stdlib_cdotc( n-j, z( j+1, j ), 1, rhs( j+1 ), 1 ),KIND=sp)
                 splus = splus*real( rhs( j ),KIND=sp)
                 if( splus>sminu ) then
                    rhs( j ) = bp
                 else if( sminu>splus ) then
                    rhs( j ) = bm
                 else
                    ! in this case the updating sums are equal and we can
                    ! choose rhs(j) +1 or -1. the first time this happens we
                    ! choose -1, thereafter +1. this is a simple way to get
                    ! good estimates of matrices like byers well-known example
                    ! (see [1]). (not done in bsolve.)
                    rhs( j ) = rhs( j ) + pmone
                    pmone = cone
                 end if
                 ! compute the remaining r.h.s.
                 temp = -rhs( j )
                 call stdlib_caxpy( n-j, temp, z( j+1, j ), 1, rhs( j+1 ), 1 )
              end do loop_10
              ! solve for u- part, lockahead for rhs(n) = +-1. this is not done
              ! in bsolve and will hopefully give us a better estimate because
              ! any ill-conditioning of the original matrix is transferred to u
              ! and not to l. u(n, n) is an approximation to sigma_min(lu).
              call stdlib_ccopy( n-1, rhs, 1, work, 1 )
              work( n ) = rhs( n ) + cone
              rhs( n ) = rhs( n ) - cone
              splus = zero
              sminu = zero
              do i = n, 1, -1
                 temp = cone / z( i, i )
                 work( i ) = work( i )*temp
                 rhs( i ) = rhs( i )*temp
                 do k = i + 1, n
                    work( i ) = work( i ) - work( k )*( z( i, k )*temp )
                    rhs( i ) = rhs( i ) - rhs( k )*( z( i, k )*temp )
                 end do
                 splus = splus + abs( work( i ) )
                 sminu = sminu + abs( rhs( i ) )
              end do
              if( splus>sminu )call stdlib_ccopy( n, work, 1, rhs, 1 )
              ! apply the permutations jpiv to the computed solution (rhs)
              call stdlib_claswp( 1, rhs, ldz, 1, n-1, jpiv, -1 )
              ! compute the sum of squares
              call stdlib_classq( n, rhs, 1, rdscal, rdsum )
              return
           end if
           ! entry ijob = 2
           ! compute approximate nullvector xm of z
           call stdlib_cgecon( 'I', n, z, ldz, one, rtemp, work, rwork, info )
           call stdlib_ccopy( n, work( n+1 ), 1, xm, 1 )
           ! compute rhs
           call stdlib_claswp( 1, xm, ldz, 1, n-1, ipiv, -1 )
           temp = cone / sqrt( stdlib_cdotc( n, xm, 1, xm, 1 ) )
           call stdlib_cscal( n, temp, xm, 1 )
           call stdlib_ccopy( n, xm, 1, xp, 1 )
           call stdlib_caxpy( n, cone, rhs, 1, xp, 1 )
           call stdlib_caxpy( n, -cone, xm, 1, rhs, 1 )
           call stdlib_cgesc2( n, z, ldz, rhs, ipiv, jpiv, scale )
           call stdlib_cgesc2( n, z, ldz, xp, ipiv, jpiv, scale )
           if( stdlib_scasum( n, xp, 1 )>stdlib_scasum( n, rhs, 1 ) )call stdlib_ccopy( n, xp, 1, &
                     rhs, 1 )
           ! compute the sum of squares
           call stdlib_classq( n, rhs, 1, rdscal, rdsum )
           return
     end subroutine stdlib_clatdf


     pure subroutine stdlib_claunhr_col_getrfnp( m, n, a, lda, d, info )
     !! CLAUNHR_COL_GETRFNP computes the modified LU factorization without
     !! pivoting of a complex general M-by-N matrix A. The factorization has
     !! the form:
     !! A - S = L * U,
     !! where:
     !! S is a m-by-n diagonal sign matrix with the diagonal D, so that
     !! D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
     !! as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
     !! i-1 steps of Gaussian elimination. This means that the diagonal
     !! element at each step of "modified" Gaussian elimination is
     !! at least one in absolute value (so that division-by-zero not
     !! not possible during the division by the diagonal element);
     !! L is a M-by-N lower triangular matrix with unit diagonal elements
     !! (lower trapezoidal if M > N);
     !! and U is a M-by-N upper triangular matrix
     !! (upper trapezoidal if M < N).
     !! This routine is an auxiliary routine used in the Householder
     !! reconstruction routine CUNHR_COL. In CUNHR_COL, this routine is
     !! applied to an M-by-N matrix A with orthonormal columns, where each
     !! element is bounded by one in absolute value. With the choice of
     !! the matrix S above, one can show that the diagonal element at each
     !! step of Gaussian elimination is the largest (in absolute value) in
     !! the column on or below the diagonal, so that no pivoting is required
     !! for numerical stability [1].
     !! For more details on the Householder reconstruction algorithm,
     !! including the modified LU factorization, see [1].
     !! This is the blocked right-looking version of the algorithm,
     !! calling Level 3 BLAS to update the submatrix. To factorize a block,
     !! this routine calls the recursive routine CLAUNHR_COL_GETRFNP2.
     !! [1] "Reconstructing Householder vectors from tall-skinny QR",
     !! G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
     !! E. Solomonik, J. Parallel Distrib. Comput.,
     !! vol. 85, pp. 3-31, 2015.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: d(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: iinfo, j, jb, nb
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAUNHR_COL_GETRFNP', -info )
              return
           end if
           ! quick return if possible
           if( min( m, n )==0 )return
           ! determine the block size for this environment.
           nb = stdlib_ilaenv( 1, 'CLAUNHR_COL_GETRFNP', ' ', m, n, -1, -1 )
           if( nb<=1 .or. nb>=min( m, n ) ) then
              ! use unblocked code.
              call stdlib_claunhr_col_getrfnp2( m, n, a, lda, d, info )
           else
              ! use blocked code.
              do j = 1, min( m, n ), nb
                 jb = min( min( m, n )-j+1, nb )
                 ! factor diagonal and subdiagonal blocks.
                 call stdlib_claunhr_col_getrfnp2( m-j+1, jb, a( j, j ), lda,d( j ), iinfo )
                           
                 if( j+jb<=n ) then
                    ! compute block row of u.
                    call stdlib_ctrsm( 'LEFT', 'LOWER', 'NO TRANSPOSE', 'UNIT', jb,n-j-jb+1, cone,&
                               a( j, j ), lda, a( j, j+jb ),lda )
                    if( j+jb<=m ) then
                       ! update trailing submatrix.
                       call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', m-j-jb+1,n-j-jb+1, jb, -&
                       cone, a( j+jb, j ), lda,a( j, j+jb ), lda, cone, a( j+jb, j+jb ),lda )
                                 
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_claunhr_col_getrfnp


     pure subroutine stdlib_cpbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,rwork, info )
     !! CPBCON estimates the reciprocal of the condition number (in the
     !! 1-norm) of a complex Hermitian positive definite band matrix using
     !! the Cholesky factorization A = U**H*U or A = L*L**H computed by
     !! CPBTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(in) :: ab(ldab,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           character :: normin
           integer(ilp) :: ix, kase
           real(sp) :: ainvnm, scale, scalel, scaleu, smlnum
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( ldab<kd+1 ) then
              info = -5
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPBCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm==zero ) then
              return
           end if
           smlnum = stdlib_slamch( 'SAFE MINIMUM' )
           ! estimate the 1-norm of the inverse.
           kase = 0
           normin = 'N'
           10 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( upper ) then
                 ! multiply by inv(u**h).
                 call stdlib_clatbs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',normin, n, kd, ab,&
                            ldab, work, scalel, rwork,info )
                 normin = 'Y'
                 ! multiply by inv(u).
                 call stdlib_clatbs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', normin, n,kd, ab, ldab, &
                           work, scaleu, rwork, info )
              else
                 ! multiply by inv(l).
                 call stdlib_clatbs( 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', normin, n,kd, ab, ldab, &
                           work, scalel, rwork, info )
                 normin = 'Y'
                 ! multiply by inv(l**h).
                 call stdlib_clatbs( 'LOWER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',normin, n, kd, ab,&
                            ldab, work, scaleu, rwork,info )
              end if
              ! multiply by 1/scale if doing so will not cause overflow.
              scale = scalel*scaleu
              if( scale/=one ) then
                 ix = stdlib_icamax( n, work, 1 )
                 if( scale<cabs1( work( ix ) )*smlnum .or. scale==zero )go to 20
                 call stdlib_csrscl( n, scale, work, 1 )
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           20 continue
           return
     end subroutine stdlib_cpbcon


     pure subroutine stdlib_cpbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,ldb, x, ldx, ferr, &
     !! CPBRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is Hermitian positive definite
     !! and banded, and provides error bounds and backward error estimates
     !! for the solution.
               berr, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldafb, ldb, ldx, n, nrhs
           ! Array Arguments 
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: ab(ldab,*), afb(ldafb,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, j, k, kase, l, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,min,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldab<kd+1 ) then
              info = -6
           else if( ldafb<kd+1 ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPBRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = min( n+1, 2*kd+2 )
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_ccopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_chbmv( uplo, n, kd, -cone, ab, ldab, x( 1, j ), 1, cone,work, 1 )
                        
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    l = kd + 1 - k
                    do i = max( 1, k-kd ), k - 1
                       rwork( i ) = rwork( i ) + cabs1( ab( l+i, k ) )*xk
                       s = s + cabs1( ab( l+i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + abs( real( ab( kd+1, k ),KIND=sp) )*xk + s
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + abs( real( ab( 1, k ),KIND=sp) )*xk
                    l = 1 - k
                    do i = k + 1, min( n, k+kd )
                       rwork( i ) = rwork( i ) + cabs1( ab( l+i, k ) )*xk
                       s = s + cabs1( ab( l+i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_cpbtrs( uplo, n, kd, 1, afb, ldafb, work, n, info )
                 call stdlib_caxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**h).
                    call stdlib_cpbtrs( uplo, n, kd, 1, afb, ldafb, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_cpbtrs( uplo, n, kd, 1, afb, ldafb, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_cpbrfs


     pure subroutine stdlib_cpbtrf( uplo, n, kd, ab, ldab, info )
     !! CPBTRF computes the Cholesky factorization of a complex Hermitian
     !! positive definite band matrix A.
     !! The factorization has the form
     !! A = U**H * U,  if UPLO = 'U', or
     !! A = L  * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is lower triangular.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, n
           ! Array Arguments 
           complex(sp), intent(inout) :: ab(ldab,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 32
           integer(ilp), parameter :: ldwork = nbmax+1
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, i2, i3, ib, ii, j, jj, nb
           ! Local Arrays 
           complex(sp) :: work(ldwork,nbmax)
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( ( .not.stdlib_lsame( uplo, 'U' ) ) .and.( .not.stdlib_lsame( uplo, 'L' ) ) ) &
                     then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( ldab<kd+1 ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPBTRF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine the block size for this environment
           nb = stdlib_ilaenv( 1, 'CPBTRF', uplo, n, kd, -1, -1 )
           ! the block size must not exceed the semi-bandwidth kd, and must not
           ! exceed the limit set by the size of the local array work.
           nb = min( nb, nbmax )
           if( nb<=1 .or. nb>kd ) then
              ! use unblocked code
              call stdlib_cpbtf2( uplo, n, kd, ab, ldab, info )
           else
              ! use blocked code
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! compute the cholesky factorization of a hermitian band
                 ! matrix, given the upper triangle of the matrix in band
                 ! storage.
                 ! zero the upper triangle of the work array.
                 do j = 1, nb
                    do i = 1, j - 1
                       work( i, j ) = zero
                    end do
                 end do
                 ! process the band matrix one diagonal block at a time.
                 loop_70: do i = 1, n, nb
                    ib = min( nb, n-i+1 )
                    ! factorize the diagonal block
                    call stdlib_cpotf2( uplo, ib, ab( kd+1, i ), ldab-1, ii )
                    if( ii/=0 ) then
                       info = i + ii - 1
                       go to 150
                    end if
                    if( i+ib<=n ) then
                       ! update the relevant part of the trailing submatrix.
                       ! if a11 denotes the diagonal block which has just been
                       ! factorized, then we need to update the remaining
                       ! blocks in the diagram:
                          ! a11   a12   a13
                                ! a22   a23
                                      ! a33
                       ! the numbers of rows and columns in the partitioning
                       ! are ib, i2, i3 respectively. the blocks a12, a22 and
                       ! a23 are empty if ib = kd. the upper triangle of a13
                       ! lies outside the band.
                       i2 = min( kd-ib, n-i-ib+1 )
                       i3 = min( ib, n-i-kd+1 )
                       if( i2>0 ) then
                          ! update a12
                          call stdlib_ctrsm( 'LEFT', 'UPPER', 'CONJUGATE TRANSPOSE','NON-UNIT', &
                                    ib, i2, cone,ab( kd+1, i ), ldab-1,ab( kd+1-ib, i+ib ), ldab-1 )
                          ! update a22
                          call stdlib_cherk( 'UPPER', 'CONJUGATE TRANSPOSE', i2, ib,-one, ab( kd+&
                                    1-ib, i+ib ), ldab-1, one,ab( kd+1, i+ib ), ldab-1 )
                       end if
                       if( i3>0 ) then
                          ! copy the lower triangle of a13 into the work array.
                          do jj = 1, i3
                             do ii = jj, ib
                                work( ii, jj ) = ab( ii-jj+1, jj+i+kd-1 )
                             end do
                          end do
                          ! update a13 (in the work array).
                          call stdlib_ctrsm( 'LEFT', 'UPPER', 'CONJUGATE TRANSPOSE','NON-UNIT', &
                                    ib, i3, cone,ab( kd+1, i ), ldab-1, work, ldwork )
                          ! update a23
                          if( i2>0 )call stdlib_cgemm( 'CONJUGATE TRANSPOSE','NO TRANSPOSE', i2, &
                          i3, ib, -cone,ab( kd+1-ib, i+ib ), ldab-1, work,ldwork, cone, ab( 1+ib, &
                                    i+kd ),ldab-1 )
                          ! update a33
                          call stdlib_cherk( 'UPPER', 'CONJUGATE TRANSPOSE', i3, ib,-one, work, &
                                    ldwork, one,ab( kd+1, i+kd ), ldab-1 )
                          ! copy the lower triangle of a13 back into place.
                          do jj = 1, i3
                             do ii = jj, ib
                                ab( ii-jj+1, jj+i+kd-1 ) = work( ii, jj )
                             end do
                          end do
                       end if
                    end if
                 end do loop_70
              else
                 ! compute the cholesky factorization of a hermitian band
                 ! matrix, given the lower triangle of the matrix in band
                 ! storage.
                 ! zero the lower triangle of the work array.
                 do j = 1, nb
                    do i = j + 1, nb
                       work( i, j ) = zero
                    end do
                 end do
                 ! process the band matrix one diagonal block at a time.
                 loop_140: do i = 1, n, nb
                    ib = min( nb, n-i+1 )
                    ! factorize the diagonal block
                    call stdlib_cpotf2( uplo, ib, ab( 1, i ), ldab-1, ii )
                    if( ii/=0 ) then
                       info = i + ii - 1
                       go to 150
                    end if
                    if( i+ib<=n ) then
                       ! update the relevant part of the trailing submatrix.
                       ! if a11 denotes the diagonal block which has just been
                       ! factorized, then we need to update the remaining
                       ! blocks in the diagram:
                          ! a11
                          ! a21   a22
                          ! a31   a32   a33
                       ! the numbers of rows and columns in the partitioning
                       ! are ib, i2, i3 respectively. the blocks a21, a22 and
                       ! a32 are empty if ib = kd. the lower triangle of a31
                       ! lies outside the band.
                       i2 = min( kd-ib, n-i-ib+1 )
                       i3 = min( ib, n-i-kd+1 )
                       if( i2>0 ) then
                          ! update a21
                          call stdlib_ctrsm( 'RIGHT', 'LOWER','CONJUGATE TRANSPOSE', 'NON-UNIT', &
                                    i2,ib, cone, ab( 1, i ), ldab-1,ab( 1+ib, i ), ldab-1 )
                          ! update a22
                          call stdlib_cherk( 'LOWER', 'NO TRANSPOSE', i2, ib, -one,ab( 1+ib, i ), &
                                    ldab-1, one,ab( 1, i+ib ), ldab-1 )
                       end if
                       if( i3>0 ) then
                          ! copy the upper triangle of a31 into the work array.
                          do jj = 1, ib
                             do ii = 1, min( jj, i3 )
                                work( ii, jj ) = ab( kd+1-jj+ii, jj+i-1 )
                             end do
                          end do
                          ! update a31 (in the work array).
                          call stdlib_ctrsm( 'RIGHT', 'LOWER','CONJUGATE TRANSPOSE', 'NON-UNIT', &
                                    i3,ib, cone, ab( 1, i ), ldab-1, work,ldwork )
                          ! update a32
                          if( i2>0 )call stdlib_cgemm( 'NO TRANSPOSE','CONJUGATE TRANSPOSE', i3, &
                          i2, ib,-cone, work, ldwork, ab( 1+ib, i ),ldab-1, cone, ab( 1+kd-ib, i+&
                                    ib ),ldab-1 )
                          ! update a33
                          call stdlib_cherk( 'LOWER', 'NO TRANSPOSE', i3, ib, -one,work, ldwork, &
                                    one, ab( 1, i+kd ),ldab-1 )
                          ! copy the upper triangle of a31 back into place.
                          do jj = 1, ib
                             do ii = 1, min( jj, i3 )
                                ab( kd+1-jj+ii, jj+i-1 ) = work( ii, jj )
                             end do
                          end do
                       end if
                    end if
                 end do loop_140
              end if
           end if
           return
           150 continue
           return
     end subroutine stdlib_cpbtrf


     pure subroutine stdlib_cpftrs( transr, uplo, n, nrhs, a, b, ldb, info )
     !! CPFTRS solves a system of linear equations A*X = B with a Hermitian
     !! positive definite matrix A using the Cholesky factorization
     !! A = U**H*U or A = L*L**H computed by CPFTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           complex(sp), intent(in) :: a(0:*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lower, normaltransr
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'C' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPFTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! start execution: there are two triangular solves
           if( lower ) then
              call stdlib_ctfsm( transr, 'L', uplo, 'N', 'N', n, nrhs, cone, a, b,ldb )
              call stdlib_ctfsm( transr, 'L', uplo, 'C', 'N', n, nrhs, cone, a, b,ldb )
           else
              call stdlib_ctfsm( transr, 'L', uplo, 'C', 'N', n, nrhs, cone, a, b,ldb )
              call stdlib_ctfsm( transr, 'L', uplo, 'N', 'N', n, nrhs, cone, a, b,ldb )
           end if
           return
     end subroutine stdlib_cpftrs


     pure subroutine stdlib_cpocon( uplo, n, a, lda, anorm, rcond, work, rwork,info )
     !! CPOCON estimates the reciprocal of the condition number (in the
     !! 1-norm) of a complex Hermitian positive definite matrix using the
     !! Cholesky factorization A = U**H*U or A = L*L**H computed by CPOTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           character :: normin
           integer(ilp) :: ix, kase
           real(sp) :: ainvnm, scale, scalel, scaleu, smlnum
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPOCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm==zero ) then
              return
           end if
           smlnum = stdlib_slamch( 'SAFE MINIMUM' )
           ! estimate the 1-norm of inv(a).
           kase = 0
           normin = 'N'
           10 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( upper ) then
                 ! multiply by inv(u**h).
                 call stdlib_clatrs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',normin, n, a, lda,&
                            work, scalel, rwork, info )
                 normin = 'Y'
                 ! multiply by inv(u).
                 call stdlib_clatrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', normin, n,a, lda, work, &
                           scaleu, rwork, info )
              else
                 ! multiply by inv(l).
                 call stdlib_clatrs( 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', normin, n,a, lda, work, &
                           scalel, rwork, info )
                 normin = 'Y'
                 ! multiply by inv(l**h).
                 call stdlib_clatrs( 'LOWER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',normin, n, a, lda,&
                            work, scaleu, rwork, info )
              end if
              ! multiply by 1/scale if doing so will not cause overflow.
              scale = scalel*scaleu
              if( scale/=one ) then
                 ix = stdlib_icamax( n, work, 1 )
                 if( scale<cabs1( work( ix ) )*smlnum .or. scale==zero )go to 20
                 call stdlib_csrscl( n, scale, work, 1 )
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           20 continue
           return
     end subroutine stdlib_cpocon


     pure subroutine stdlib_cporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,ldx, ferr, berr, &
     !! CPORFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is Hermitian positive definite,
     !! and provides error bounds and backward error estimates for the
     !! solution.
               work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           ! Array Arguments 
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! ====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, j, k, kase, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldaf<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPORFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_ccopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_chemv( uplo, n, -cone, a, lda, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + abs( real( a( k, k ),KIND=sp) )*xk + s
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + abs( real( a( k, k ),KIND=sp) )*xk
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_cpotrs( uplo, n, 1, af, ldaf, work, n, info )
                 call stdlib_caxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**h).
                    call stdlib_cpotrs( uplo, n, 1, af, ldaf, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_cpotrs( uplo, n, 1, af, ldaf, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_cporfs


     pure subroutine stdlib_cpotrf( uplo, n, a, lda, info )
     !! CPOTRF computes the Cholesky factorization of a complex Hermitian
     !! positive definite matrix A.
     !! The factorization has the form
     !! A = U**H * U,  if UPLO = 'U', or
     !! A = L  * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is lower triangular.
     !! This is the block version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, jb, nb
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPOTRF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine the block size for this environment.
           nb = stdlib_ilaenv( 1, 'CPOTRF', uplo, n, -1, -1, -1 )
           if( nb<=1 .or. nb>=n ) then
              ! use unblocked code.
              call stdlib_cpotrf2( uplo, n, a, lda, info )
           else
              ! use blocked code.
              if( upper ) then
                 ! compute the cholesky factorization a = u**h *u.
                 do j = 1, n, nb
                    ! update and factorize the current diagonal block and test
                    ! for non-positive-definiteness.
                    jb = min( nb, n-j+1 )
                    call stdlib_cherk( 'UPPER', 'CONJUGATE TRANSPOSE', jb, j-1,-one, a( 1, j ), &
                              lda, one, a( j, j ), lda )
                    call stdlib_cpotrf2( 'UPPER', jb, a( j, j ), lda, info )
                    if( info/=0 )go to 30
                    if( j+jb<=n ) then
                       ! compute the current block row.
                       call stdlib_cgemm( 'CONJUGATE TRANSPOSE', 'NO TRANSPOSE', jb,n-j-jb+1, j-1,&
                                  -cone, a( 1, j ), lda,a( 1, j+jb ), lda, cone, a( j, j+jb ),lda )
                       call stdlib_ctrsm( 'LEFT', 'UPPER', 'CONJUGATE TRANSPOSE','NON-UNIT', jb, &
                                 n-j-jb+1, cone, a( j, j ),lda, a( j, j+jb ), lda )
                    end if
                 end do
              else
                 ! compute the cholesky factorization a = l*l**h.
                 do j = 1, n, nb
                    ! update and factorize the current diagonal block and test
                    ! for non-positive-definiteness.
                    jb = min( nb, n-j+1 )
                    call stdlib_cherk( 'LOWER', 'NO TRANSPOSE', jb, j-1, -one,a( j, 1 ), lda, one,&
                               a( j, j ), lda )
                    call stdlib_cpotrf2( 'LOWER', jb, a( j, j ), lda, info )
                    if( info/=0 )go to 30
                    if( j+jb<=n ) then
                       ! compute the current block column.
                       call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',n-j-jb+1, jb, j-1,&
                                  -cone, a( j+jb, 1 ),lda, a( j, 1 ), lda, cone, a( j+jb, j ),lda )
                       call stdlib_ctrsm( 'RIGHT', 'LOWER', 'CONJUGATE TRANSPOSE','NON-UNIT', n-j-&
                                 jb+1, jb, cone, a( j, j ),lda, a( j+jb, j ), lda )
                    end if
                 end do
              end if
           end if
           go to 40
           30 continue
           info = info + j - 1
           40 continue
           return
     end subroutine stdlib_cpotrf


     pure subroutine stdlib_cpotri( uplo, n, a, lda, info )
     !! CPOTRI computes the inverse of a complex Hermitian positive definite
     !! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
     !! computed by CPOTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPOTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! invert the triangular cholesky factor u or l.
           call stdlib_ctrtri( uplo, 'NON-UNIT', n, a, lda, info )
           if( info>0 )return
           ! form inv(u) * inv(u)**h or inv(l)**h * inv(l).
           call stdlib_clauum( uplo, n, a, lda, info )
           return
     end subroutine stdlib_cpotri


     pure subroutine stdlib_cppcon( uplo, n, ap, anorm, rcond, work, rwork, info )
     !! CPPCON estimates the reciprocal of the condition number (in the
     !! 1-norm) of a complex Hermitian positive definite packed matrix using
     !! the Cholesky factorization A = U**H*U or A = L*L**H computed by
     !! CPPTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(in) :: ap(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           character :: normin
           integer(ilp) :: ix, kase
           real(sp) :: ainvnm, scale, scalel, scaleu, smlnum
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( anorm<zero ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPPCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm==zero ) then
              return
           end if
           smlnum = stdlib_slamch( 'SAFE MINIMUM' )
           ! estimate the 1-norm of the inverse.
           kase = 0
           normin = 'N'
           10 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( upper ) then
                 ! multiply by inv(u**h).
                 call stdlib_clatps( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',normin, n, ap, &
                           work, scalel, rwork, info )
                 normin = 'Y'
                 ! multiply by inv(u).
                 call stdlib_clatps( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', normin, n,ap, work, &
                           scaleu, rwork, info )
              else
                 ! multiply by inv(l).
                 call stdlib_clatps( 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', normin, n,ap, work, &
                           scalel, rwork, info )
                 normin = 'Y'
                 ! multiply by inv(l**h).
                 call stdlib_clatps( 'LOWER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',normin, n, ap, &
                           work, scaleu, rwork, info )
              end if
              ! multiply by 1/scale if doing so will not cause overflow.
              scale = scalel*scaleu
              if( scale/=one ) then
                 ix = stdlib_icamax( n, work, 1 )
                 if( scale<cabs1( work( ix ) )*smlnum .or. scale==zero )go to 20
                 call stdlib_csrscl( n, scale, work, 1 )
              end if
              go to 10
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           20 continue
           return
     end subroutine stdlib_cppcon


     pure subroutine stdlib_cpprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,berr, work, &
     !! CPPRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is Hermitian positive definite
     !! and packed, and provides error bounds and backward error estimates
     !! for the solution.
               rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: afp(*), ap(*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! ====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, ik, j, k, kase, kk, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldx<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPPRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_ccopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_chpmv( uplo, n, -cone, ap, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              kk = 1
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    ik = kk
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + abs( real( ap( kk+k-1 ),KIND=sp) )*xk + s
                    kk = kk + k
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + abs( real( ap( kk ),KIND=sp) )*xk
                    ik = kk + 1
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + s
                    kk = kk + ( n-k+1 )
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_cpptrs( uplo, n, 1, afp, work, n, info )
                 call stdlib_caxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**h).
                    call stdlib_cpptrs( uplo, n, 1, afp, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_cpptrs( uplo, n, 1, afp, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_cpprfs


     pure subroutine stdlib_cppsv( uplo, n, nrhs, ap, b, ldb, info )
     !! CPPSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian positive definite matrix stored in
     !! packed format and X and B are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**H * U,  if UPLO = 'U', or
     !! A = L * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is a lower triangular
     !! matrix.  The factored form of A is then used to solve the system of
     !! equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           complex(sp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPPSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**h *u or a = l*l**h.
           call stdlib_cpptrf( uplo, n, ap, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_cpptrs( uplo, n, nrhs, ap, b, ldb, info )
           end if
           return
     end subroutine stdlib_cppsv


     subroutine stdlib_cppsvx( fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb,x, ldx, rcond, ferr,&
     !! CPPSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
     !! compute the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian positive definite matrix stored in
     !! packed format and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
                berr, work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(inout) :: equed
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           real(sp), intent(inout) :: s(*)
           complex(sp), intent(inout) :: afp(*), ap(*), b(ldb,*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: equil, nofact, rcequ
           integer(ilp) :: i, infequ, j
           real(sp) :: amax, anorm, bignum, scond, smax, smin, smlnum
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           equil = stdlib_lsame( fact, 'E' )
           if( nofact .or. equil ) then
              equed = 'N'
              rcequ = .false.
           else
              rcequ = stdlib_lsame( equed, 'Y' )
              smlnum = stdlib_slamch( 'SAFE MINIMUM' )
              bignum = one / smlnum
           end if
           ! test the input parameters.
           if( .not.nofact .and. .not.equil .and. .not.stdlib_lsame( fact, 'F' ) )then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( stdlib_lsame( fact, 'F' ) .and. .not.( rcequ .or. stdlib_lsame( equed, 'N' ) )&
                      ) then
              info = -7
           else
              if( rcequ ) then
                 smin = bignum
                 smax = zero
                 do j = 1, n
                    smin = min( smin, s( j ) )
                    smax = max( smax, s( j ) )
                 end do
                 if( smin<=zero ) then
                    info = -8
                 else if( n>0 ) then
                    scond = max( smin, smlnum ) / min( smax, bignum )
                 else
                    scond = one
                 end if
              end if
              if( info==0 ) then
                 if( ldb<max( 1, n ) ) then
                    info = -10
                 else if( ldx<max( 1, n ) ) then
                    info = -12
                 end if
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPPSVX', -info )
              return
           end if
           if( equil ) then
              ! compute row and column scalings to equilibrate the matrix a.
              call stdlib_cppequ( uplo, n, ap, s, scond, amax, infequ )
              if( infequ==0 ) then
                 ! equilibrate the matrix.
                 call stdlib_claqhp( uplo, n, ap, s, scond, amax, equed )
                 rcequ = stdlib_lsame( equed, 'Y' )
              end if
           end if
           ! scale the right-hand side.
           if( rcequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    b( i, j ) = s( i )*b( i, j )
                 end do
              end do
           end if
           if( nofact .or. equil ) then
              ! compute the cholesky factorization a = u**h * u or a = l * l**h.
              call stdlib_ccopy( n*( n+1 ) / 2, ap, 1, afp, 1 )
              call stdlib_cpptrf( uplo, n, afp, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_clanhp( 'I', uplo, n, ap, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_cppcon( uplo, n, afp, anorm, rcond, work, rwork, info )
           ! compute the solution matrix x.
           call stdlib_clacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_cpptrs( uplo, n, nrhs, afp, x, ldx, info )
           ! use iterative refinement to improve the computed solution and
           ! compute error bounds and backward error estimates for it.
           call stdlib_cpprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr,work, rwork, &
                     info )
           ! transform the solution matrix x to a solution of the original
           ! system.
           if( rcequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    x( i, j ) = s( i )*x( i, j )
                 end do
              end do
              do j = 1, nrhs
                 ferr( j ) = ferr( j ) / scond
              end do
           end if
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_cppsvx


     pure subroutine stdlib_cpptri( uplo, n, ap, info )
     !! CPPTRI computes the inverse of a complex Hermitian positive definite
     !! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
     !! computed by CPPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           complex(sp), intent(inout) :: ap(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, jc, jj, jjn
           real(sp) :: ajj
           ! Intrinsic Functions 
           intrinsic :: real
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPPTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! invert the triangular cholesky factor u or l.
           call stdlib_ctptri( uplo, 'NON-UNIT', n, ap, info )
           if( info>0 )return
           if( upper ) then
              ! compute the product inv(u) * inv(u)**h.
              jj = 0
              do j = 1, n
                 jc = jj + 1
                 jj = jj + j
                 if( j>1 )call stdlib_chpr( 'UPPER', j-1, one, ap( jc ), 1, ap )
                 ajj = real( ap( jj ),KIND=sp)
                 call stdlib_csscal( j, ajj, ap( jc ), 1 )
              end do
           else
              ! compute the product inv(l)**h * inv(l).
              jj = 1
              do j = 1, n
                 jjn = jj + n - j + 1
                 ap( jj ) = real( stdlib_cdotc( n-j+1, ap( jj ), 1, ap( jj ), 1 ),KIND=sp)
                 if( j<n )call stdlib_ctpmv( 'LOWER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',n-j, ap( &
                           jjn ), ap( jj+1 ), 1 )
                 jj = jjn
              end do
           end if
           return
     end subroutine stdlib_cpptri


     pure subroutine stdlib_cpteqr( compz, n, d, e, z, ldz, work, info )
     !! CPTEQR computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric positive definite tridiagonal matrix by first factoring the
     !! matrix using SPTTRF and then calling CBDSQR to compute the singular
     !! values of the bidiagonal factor.
     !! This routine computes the eigenvalues of the positive definite
     !! tridiagonal matrix to high relative accuracy.  This means that if the
     !! eigenvalues range over many orders of magnitude in size, then the
     !! small eigenvalues and corresponding eigenvectors will be computed
     !! more accurately than, for example, with the standard QR method.
     !! The eigenvectors of a full or band positive definite Hermitian matrix
     !! can also be found if CHETRD, CHPTRD, or CHBTRD has been used to
     !! reduce this matrix to tridiagonal form.  (The reduction to
     !! tridiagonal form, however, may preclude the possibility of obtaining
     !! high relative accuracy in the small eigenvalues of the original
     !! matrix, if these eigenvalues range over many orders of magnitude.)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: z(ldz,*)
        ! ====================================================================
           
           ! Local Arrays 
           complex(sp) :: c(1,1), vt(1,1)
           ! Local Scalars 
           integer(ilp) :: i, icompz, nru
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or. ( icompz>0 .and. ldz<max( 1,n ) ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPTEQR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz>0 )z( 1, 1 ) = cone
              return
           end if
           if( icompz==2 )call stdlib_claset( 'FULL', n, n, czero, cone, z, ldz )
           ! call stdlib_spttrf to factor the matrix.
           call stdlib_spttrf( n, d, e, info )
           if( info/=0 )return
           do i = 1, n
              d( i ) = sqrt( d( i ) )
           end do
           do i = 1, n - 1
              e( i ) = e( i )*d( i )
           end do
           ! call stdlib_cbdsqr to compute the singular values/vectors of the
           ! bidiagonal factor.
           if( icompz>0 ) then
              nru = n
           else
              nru = 0
           end if
           call stdlib_cbdsqr( 'LOWER', n, 0, nru, 0, d, e, vt, 1, z, ldz, c, 1,work, info )
                     
           ! square the singular values.
           if( info==0 ) then
              do i = 1, n
                 d( i ) = d( i )*d( i )
              end do
           else
              info = n + info
           end if
           return
     end subroutine stdlib_cpteqr


     pure subroutine stdlib_cpttrs( uplo, n, nrhs, d, e, b, ldb, info )
     !! CPTTRS solves a tridiagonal system of the form
     !! A * X = B
     !! using the factorization A = U**H*D*U or A = L*D*L**H computed by CPTTRF.
     !! D is a diagonal matrix specified in the vector D, U (or L) is a unit
     !! bidiagonal matrix whose superdiagonal (subdiagonal) is specified in
     !! the vector E, and X and B are N by NRHS matrices.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(sp), intent(in) :: d(*)
           complex(sp), intent(inout) :: b(ldb,*)
           complex(sp), intent(in) :: e(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: iuplo, j, jb, nb
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments.
           info = 0
           upper = ( uplo=='U' .or. uplo=='U' )
           if( .not.upper .and. .not.( uplo=='L' .or. uplo=='L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPTTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! determine the number of right-hand sides to solve at a time.
           if( nrhs==1 ) then
              nb = 1
           else
              nb = max( 1, stdlib_ilaenv( 1, 'CPTTRS', uplo, n, nrhs, -1, -1 ) )
           end if
           ! decode uplo
           if( upper ) then
              iuplo = 1
           else
              iuplo = 0
           end if
           if( nb>=nrhs ) then
              call stdlib_cptts2( iuplo, n, nrhs, d, e, b, ldb )
           else
              do j = 1, nrhs, nb
                 jb = min( nrhs-j+1, nb )
                 call stdlib_cptts2( iuplo, n, jb, d, e, b( 1, j ), ldb )
              end do
           end if
           return
     end subroutine stdlib_cpttrs


     pure subroutine stdlib_cspcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
     !! CSPCON estimates the reciprocal of the condition number (in the
     !! 1-norm) of a complex symmetric packed matrix A using the
     !! factorization A = U*D*U**T or A = L*D*L**T computed by CSPTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: ap(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, ip, kase
           real(sp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( anorm<zero ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              ip = n*( n+1 ) / 2
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip - i
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              ip = 1
              do i = 1, n
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip + n - i + 1
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_csptrs( uplo, n, 1, ap, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_cspcon


     pure subroutine stdlib_csprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, work,&
     !! CSPRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric indefinite
     !! and packed, and provides error bounds and backward error estimates
     !! for the solution.
                rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: afp(*), ap(*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, ik, j, k, kase, kk, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( ldx<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_ccopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_cspmv( uplo, n, -cone, ap, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              kk = 1
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    ik = kk
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + cabs1( ap( kk+k-1 ) )*xk + s
                    kk = kk + k
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + cabs1( ap( kk ) )*xk
                    ik = kk + 1
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + s
                    kk = kk + ( n-k+1 )
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_csptrs( uplo, n, 1, afp, ipiv, work, n, info )
                 call stdlib_caxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_csptrs( uplo, n, 1, afp, ipiv, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_csptrs( uplo, n, 1, afp, ipiv, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_csprfs


     pure subroutine stdlib_cspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! CSPSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is symmetric and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_csptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_csptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_cspsv


     subroutine stdlib_cspsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,ldx, rcond, ferr, &
     !! CSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
     !! A = L*D*L**T to compute the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix stored
     !! in packed format and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               berr, work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(inout) :: afp(*)
           complex(sp), intent(in) :: ap(*), b(ldb,*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(sp) :: anorm
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**t or a = l*d*l**t.
              call stdlib_ccopy( n*( n+1 ) / 2, ap, 1, afp, 1 )
              call stdlib_csptrf( uplo, n, afp, ipiv, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_clansp( 'I', uplo, n, ap, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_cspcon( uplo, n, afp, ipiv, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_clacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_csptrs( uplo, n, nrhs, afp, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_csprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr,berr, work, &
                     rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_cspsvx


     pure subroutine stdlib_cstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
     !! CSTEMR computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     !! a well defined set of pairwise different real eigenvalues, the corresponding
     !! real eigenvectors are pairwise orthogonal.
     !! The spectrum may be computed either completely or partially by specifying
     !! either an interval (VL,VU] or a range of indices IL:IU for the desired
     !! eigenvalues.
     !! Depending on the number of desired eigenvalues, these are computed either
     !! by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
     !! computed by the use of various suitable L D L^T factorizations near clusters
     !! of close eigenvalues (referred to as RRRs, Relatively Robust
     !! Representations). An informal sketch of the algorithm follows.
     !! For each unreduced block (submatrix) of T,
     !! (a) Compute T - sigma I  = L D L^T, so that L and D
     !! define all the wanted eigenvalues to high relative accuracy.
     !! This means that small relative changes in the entries of D and L
     !! cause only small relative changes in the eigenvalues and
     !! eigenvectors. The standard (unfactored) representation of the
     !! tridiagonal matrix T does not have this property in general.
     !! (b) Compute the eigenvalues to suitable accuracy.
     !! If the eigenvectors are desired, the algorithm attains full
     !! accuracy of the computed eigenvalues only right before
     !! the corresponding vectors have to be computed, see steps c) and d).
     !! (c) For each cluster of close eigenvalues, select a new
     !! shift close to the cluster, find a new factorization, and refine
     !! the shifted eigenvalues to suitable accuracy.
     !! (d) For each eigenvalue with a large enough relative separation compute
     !! the corresponding eigenvector by forming a rank revealing twisted
     !! factorization. Go back to (c) for any clusters that remain.
     !! For more details, see:
     !! - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
     !! to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
     !! Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
     !! - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
     !! Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
     !! 2004.  Also LAPACK Working Note 154.
     !! - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
     !! tridiagonal eigenvalue/eigenvector problem",
     !! Computer Science Division Technical Report No. UCB/CSD-97-971,
     !! UC Berkeley, May 1997.
     !! Further Details
     !! 1.CSTEMR works only on machines which follow IEEE-754
     !! floating-point standard in their handling of infinities and NaNs.
     !! This permits the use of efficient inner loops avoiding a check for
     !! zero divisors.
     !! 2. LAPACK routines can be used to reduce a complex Hermitean matrix to
     !! real symmetric tridiagonal form.
     !! (Any complex Hermitean tridiagonal matrix has real values on its diagonal
     !! and potentially complex numbers on its off-diagonals. By applying a
     !! similarity transform with an appropriate diagonal matrix
     !! diag(1,e^{i \phy_1}, ... , e^{i \phy_{n-1}}), the complex Hermitean
     !! matrix can be transformed into a real symmetric matrix and complex
     !! arithmetic can be entirely avoided.)
     !! While the eigenvectors of the real symmetric tridiagonal matrix are real,
     !! the eigenvectors of original complex Hermitean matrix have complex entries
     !! in general.
     !! Since LAPACK drivers overwrite the matrix data with the eigenvectors,
     !! CSTEMR accepts complex workspace to facilitate interoperability
     !! with CUNMTR or CUPMTR.
               isuppz, tryrac, work, lwork,iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           logical(lk), intent(inout) :: tryrac
           integer(ilp), intent(in) :: il, iu, ldz, nzc, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: w(*), work(*)
           complex(sp), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: minrgp = 3.0e-3_sp
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, lquery, valeig, wantz, zquery
           integer(ilp) :: i, ibegin, iend, ifirst, iil, iindbl, iindw, iindwk, iinfo, iinspl, &
           iiu, ilast, in, indd, inde2, inderr, indgp, indgrs, indwrk, itmp, itmp2, j, jblk, jj, &
                     liwmin, lwmin, nsplit, nzcmin, offset, wbegin, wend
           real(sp) :: bignum, cs, eps, pivmin, r1, r2, rmax, rmin, rtol1, rtol2, safmin, scale, &
                     smlnum, sn, thresh, tmp, tnrm, wl, wu
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( ( lwork==-1 ).or.( liwork==-1 ) )
           zquery = ( nzc==-1 )
           ! stdlib_sstemr needs work of size 6*n, iwork of size 3*n.
           ! in addition, stdlib_slarre needs work of size 6*n, iwork of size 5*n.
           ! furthermore, stdlib_clarrv needs work of size 12*n, iwork of size 7*n.
           if( wantz ) then
              lwmin = 18*n
              liwmin = 10*n
           else
              ! need less workspace if only the eigenvalues are wanted
              lwmin = 12*n
              liwmin = 8*n
           endif
           wl = zero
           wu = zero
           iil = 0
           iiu = 0
           nsplit = 0
           if( valeig ) then
              ! we do not reference vl, vu in the cases range = 'i','a'
              ! the interval (wl, wu] contains all the wanted eigenvalues.
              ! it is either given by the user or computed in stdlib_slarre.
              wl = vl
              wu = vu
           elseif( indeig ) then
              ! we do not reference il, iu in the cases range = 'v','a'
              iil = il
              iiu = iu
           endif
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( valeig .and. n>0 .and. wu<=wl ) then
              info = -7
           else if( indeig .and. ( iil<1 .or. iil>n ) ) then
              info = -8
           else if( indeig .and. ( iiu<iil .or. iiu>n ) ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -13
           else if( lwork<lwmin .and. .not.lquery ) then
              info = -17
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -19
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( wantz .and. alleig ) then
                 nzcmin = n
              else if( wantz .and. valeig ) then
                 call stdlib_slarrc( 'T', n, vl, vu, d, e, safmin,nzcmin, itmp, itmp2, info )
                           
              else if( wantz .and. indeig ) then
                 nzcmin = iiu-iil+1
              else
                 ! wantz == false.
                 nzcmin = 0
              endif
              if( zquery .and. info==0 ) then
                 z( 1,1 ) = nzcmin
              else if( nzc<nzcmin .and. .not.zquery ) then
                 info = -14
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSTEMR', -info )
              return
           else if( lquery .or. zquery ) then
              return
           end if
           ! handle n = 0, 1, and 2 cases immediately
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = d( 1 )
              else
                 if( wl<d( 1 ) .and. wu>=d( 1 ) ) then
                    m = 1
                    w( 1 ) = d( 1 )
                 end if
              end if
              if( wantz.and.(.not.zquery) ) then
                 z( 1, 1 ) = one
                 isuppz(1) = 1
                 isuppz(2) = 1
              end if
              return
           end if
           if( n==2 ) then
              if( .not.wantz ) then
                 call stdlib_slae2( d(1), e(1), d(2), r1, r2 )
              else if( wantz.and.(.not.zquery) ) then
                 call stdlib_slaev2( d(1), e(1), d(2), r1, r2, cs, sn )
              end if
              if( alleig.or.(valeig.and.(r2>wl).and.(r2<=wu)).or.(indeig.and.(iil==1)) ) &
                        then
                 m = m+1
                 w( m ) = r2
                 if( wantz.and.(.not.zquery) ) then
                    z( 1, m ) = -sn
                    z( 2, m ) = cs
                    ! note: at most one of sn and cs can be zero.
                    if (sn/=zero) then
                       if (cs/=zero) then
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 2
                       else
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 1
                       end if
                    else
                       isuppz(2*m-1) = 2
                       isuppz(2*m) = 2
                    end if
                 endif
              endif
              if( alleig.or.(valeig.and.(r1>wl).and.(r1<=wu)).or.(indeig.and.(iiu==2)) ) &
                        then
                 m = m+1
                 w( m ) = r1
                 if( wantz.and.(.not.zquery) ) then
                    z( 1, m ) = cs
                    z( 2, m ) = sn
                    ! note: at most one of sn and cs can be zero.
                    if (sn/=zero) then
                       if (cs/=zero) then
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 2
                       else
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 1
                       end if
                    else
                       isuppz(2*m-1) = 2
                       isuppz(2*m) = 2
                    end if
                 endif
              endif
           else
              ! continue with general n
              indgrs = 1
              inderr = 2*n + 1
              indgp = 3*n + 1
              indd = 4*n + 1
              inde2 = 5*n + 1
              indwrk = 6*n + 1
              iinspl = 1
              iindbl = n + 1
              iindw = 2*n + 1
              iindwk = 3*n + 1
              ! scale matrix to allowable range, if necessary.
              ! the allowable range is related to the pivmin parameter; see the
              ! comments in stdlib_slarrd.  the preference for scaling small values
              ! up is heuristic; we expect users' matrices not to be close to the
              ! rmax threshold.
              scale = one
              tnrm = stdlib_slanst( 'M', n, d, e )
              if( tnrm>zero .and. tnrm<rmin ) then
                 scale = rmin / tnrm
              else if( tnrm>rmax ) then
                 scale = rmax / tnrm
              end if
              if( scale/=one ) then
                 call stdlib_sscal( n, scale, d, 1 )
                 call stdlib_sscal( n-1, scale, e, 1 )
                 tnrm = tnrm*scale
                 if( valeig ) then
                    ! if eigenvalues in interval have to be found,
                    ! scale (wl, wu] accordingly
                    wl = wl*scale
                    wu = wu*scale
                 endif
              end if
              ! compute the desired eigenvalues of the tridiagonal after splitting
              ! into smaller subblocks if the corresponding off-diagonal elements
              ! are small
              ! thresh is the splitting parameter for stdlib_slarre
              ! a negative thresh forces the old splitting criterion based on the
              ! size of the off-diagonal. a positive thresh switches to splitting
              ! which preserves relative accuracy.
              if( tryrac ) then
                 ! test whether the matrix warrants the more expensive relative approach.
                 call stdlib_slarrr( n, d, e, iinfo )
              else
                 ! the user does not care about relative accurately eigenvalues
                 iinfo = -1
              endif
              ! set the splitting criterion
              if (iinfo==0) then
                 thresh = eps
              else
                 thresh = -eps
                 ! relative accuracy is desired but t does not guarantee it
                 tryrac = .false.
              endif
              if( tryrac ) then
                 ! copy original diagonal, needed to guarantee relative accuracy
                 call stdlib_scopy(n,d,1,work(indd),1)
              endif
              ! store the squares of the offdiagonal values of t
              do j = 1, n-1
                 work( inde2+j-1 ) = e(j)**2
              end do
              ! set the tolerance parameters for bisection
              if( .not.wantz ) then
                 ! stdlib_slarre computes the eigenvalues to full precision.
                 rtol1 = four * eps
                 rtol2 = four * eps
              else
                 ! stdlib_slarre computes the eigenvalues to less than full precision.
                 ! stdlib_clarrv will refine the eigenvalue approximations, and we only
                 ! need less accurate initial bisection in stdlib_slarre.
                 ! note: these settings do only affect the subset case and stdlib_slarre
                 rtol1 = max( sqrt(eps)*5.0e-2_sp, four * eps )
                 rtol2 = max( sqrt(eps)*5.0e-3_sp, four * eps )
              endif
              call stdlib_slarre( range, n, wl, wu, iil, iiu, d, e,work(inde2), rtol1, rtol2, &
              thresh, nsplit,iwork( iinspl ), m, w, work( inderr ),work( indgp ), iwork( iindbl ),&
              iwork( iindw ), work( indgrs ), pivmin,work( indwrk ), iwork( iindwk ), iinfo )
                        
              if( iinfo/=0 ) then
                 info = 10 + abs( iinfo )
                 return
              end if
              ! note that if range /= 'v', stdlib_slarre computes bounds on the desired
              ! part of the spectrum. all desired eigenvalues are contained in
              ! (wl,wu]
              if( wantz ) then
                 ! compute the desired eigenvectors corresponding to the computed
                 ! eigenvalues
                 call stdlib_clarrv( n, wl, wu, d, e,pivmin, iwork( iinspl ), m,1, m, minrgp, &
                 rtol1, rtol2,w, work( inderr ), work( indgp ), iwork( iindbl ),iwork( iindw ), &
                           work( indgrs ), z, ldz,isuppz, work( indwrk ), iwork( iindwk ), iinfo )
                 if( iinfo/=0 ) then
                    info = 20 + abs( iinfo )
                    return
                 end if
              else
                 ! stdlib_slarre computes eigenvalues of the (shifted) root representation
                 ! stdlib_clarrv returns the eigenvalues of the unshifted matrix.
                 ! however, if the eigenvectors are not desired by the user, we need
                 ! to apply the corresponding shifts from stdlib_slarre to obtain the
                 ! eigenvalues of the original matrix.
                 do j = 1, m
                    itmp = iwork( iindbl+j-1 )
                    w( j ) = w( j ) + e( iwork( iinspl+itmp-1 ) )
                 end do
              end if
              if ( tryrac ) then
                 ! refine computed eigenvalues so that they are relatively accurate
                 ! with respect to the original matrix t.
                 ibegin = 1
                 wbegin = 1
                 loop_39: do jblk = 1, iwork( iindbl+m-1 )
                    iend = iwork( iinspl+jblk-1 )
                    in = iend - ibegin + 1
                    wend = wbegin - 1
                    ! check if any eigenvalues have to be refined in this block
                    36 continue
                    if( wend<m ) then
                       if( iwork( iindbl+wend )==jblk ) then
                          wend = wend + 1
                          go to 36
                       end if
                    end if
                    if( wend<wbegin ) then
                       ibegin = iend + 1
                       cycle loop_39
                    end if
                    offset = iwork(iindw+wbegin-1)-1
                    ifirst = iwork(iindw+wbegin-1)
                    ilast = iwork(iindw+wend-1)
                    rtol2 = four * eps
                    call stdlib_slarrj( in,work(indd+ibegin-1), work(inde2+ibegin-1),ifirst, &
                    ilast, rtol2, offset, w(wbegin),work( inderr+wbegin-1 ),work( indwrk ), iwork(&
                               iindwk ), pivmin,tnrm, iinfo )
                    ibegin = iend + 1
                    wbegin = wend + 1
                 end do loop_39
              endif
              ! if matrix was scaled, then rescale eigenvalues appropriately.
              if( scale/=one ) then
                 call stdlib_sscal( m, one / scale, w, 1 )
              end if
           end if
           ! if eigenvalues are not in increasing order, then sort them,
           ! possibly along with eigenvectors.
           if( nsplit>1 .or. n==2 ) then
              if( .not. wantz ) then
                 call stdlib_slasrt( 'I', m, w, iinfo )
                 if( iinfo/=0 ) then
                    info = 3
                    return
                 end if
              else
                 do j = 1, m - 1
                    i = 0
                    tmp = w( j )
                    do jj = j + 1, m
                       if( w( jj )<tmp ) then
                          i = jj
                          tmp = w( jj )
                       end if
                    end do
                    if( i/=0 ) then
                       w( i ) = w( j )
                       w( j ) = tmp
                       if( wantz ) then
                          call stdlib_cswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                          itmp = isuppz( 2*i-1 )
                          isuppz( 2*i-1 ) = isuppz( 2*j-1 )
                          isuppz( 2*j-1 ) = itmp
                          itmp = isuppz( 2*i )
                          isuppz( 2*i ) = isuppz( 2*j )
                          isuppz( 2*j ) = itmp
                       end if
                    end if
                 end do
              end if
           endif
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_cstemr


     pure subroutine stdlib_csycon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
     !! CSYCON estimates the reciprocal of the condition number (in the
     !! 1-norm) of a complex symmetric matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by CSYTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(sp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_csytrs( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_csycon


     pure subroutine stdlib_csycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
     !! CSYCON_ROOK estimates the reciprocal of the condition number (in the
     !! 1-norm) of a complex symmetric matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by CSYTRF_ROOK.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(sp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYCON_ROOK', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==czero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_csytrs_rook( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_csycon_rook


     pure subroutine stdlib_csyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr, &
     !! CSYRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric indefinite, and
     !! provides error bounds and backward error estimates for the solution.
               berr, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, j, k, kase, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldaf<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_ccopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_csymv( uplo, n, -cone, a, lda, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + cabs1( a( k, k ) )*xk + s
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + cabs1( a( k, k ) )*xk
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_csytrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                 call stdlib_caxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_csytrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_csytrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_csyrfs


     pure subroutine stdlib_csysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CSYSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_csytrf( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=sp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYSV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_csytrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_csytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_csytrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csysv


     pure subroutine stdlib_csysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info )
     !! CSYSV_RK computes the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! CSYTRF_RK is called to compute the factorization of a complex
     !! symmetric matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine CSYTRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_csytrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=sp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYSV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_csytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_csytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csysv_rk


     pure subroutine stdlib_csysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CSYSV_ROOK computes the solution to a complex system of linear
     !! equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! CSYTRF_ROOK is called to compute the factorization of a complex
     !! symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling CSYTRS_ROOK.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_csytrf_rook( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=sp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYSV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_csytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs_rook ( use level 2 blas)
              call stdlib_csytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csysv_rook


     subroutine stdlib_csysvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,ldb, x, ldx, rcond, &
     !! CSYSVX uses the diagonal pivoting factorization to compute the
     !! solution to a complex system of linear equations A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               ferr, berr, work, lwork,rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, lwork, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: a(lda,*), b(ldb,*)
           complex(sp), intent(inout) :: af(ldaf,*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, nofact
           integer(ilp) :: lwkopt, nb
           real(sp) :: anorm
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           lquery = ( lwork==-1 )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldaf<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -11
           else if( ldx<max( 1, n ) ) then
              info = -13
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info==0 ) then
              lwkopt = max( 1, 2*n )
              if( nofact ) then
                 nb = stdlib_ilaenv( 1, 'CSYTRF', uplo, n, -1, -1, -1 )
                 lwkopt = max( lwkopt, n*nb )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYSVX', -info )
              return
           else if( lquery ) then
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**t or a = l*d*l**t.
              call stdlib_clacpy( uplo, n, n, a, lda, af, ldaf )
              call stdlib_csytrf( uplo, n, af, ldaf, ipiv, work, lwork, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_clansy( 'I', uplo, n, a, lda, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_csycon( uplo, n, af, ldaf, ipiv, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_clacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_csytrs( uplo, n, nrhs, af, ldaf, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_csyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x,ldx, ferr, berr, &
                     work, rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csysvx


     subroutine stdlib_ctbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,rwork, info )
     !! CTBCON estimates the reciprocal of the condition number of a
     !! triangular band matrix A, in either the 1-norm or the infinity-norm.
     !! The norm of A is computed and an estimate is obtained for
     !! norm(inv(A)), then the reciprocal of the condition number is
     !! computed as
     !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, norm, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, n
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(in) :: ab(ldab,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit, onenrm, upper
           character :: normin
           integer(ilp) :: ix, kase, kase1
           real(sp) :: ainvnm, anorm, scale, smlnum, xnorm
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           onenrm = norm=='1' .or. stdlib_lsame( norm, 'O' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.onenrm .and. .not.stdlib_lsame( norm, 'I' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( kd<0 ) then
              info = -5
           else if( ldab<kd+1 ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTBCON', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              rcond = one
              return
           end if
           rcond = zero
           smlnum = stdlib_slamch( 'SAFE MINIMUM' )*real( max( n, 1 ),KIND=sp)
           ! compute the 1-norm of the triangular matrix a or a**h.
           anorm = stdlib_clantb( norm, uplo, diag, n, kd, ab, ldab, rwork )
           ! continue only if anorm > 0.
           if( anorm>zero ) then
              ! estimate the 1-norm of the inverse of a.
              ainvnm = zero
              normin = 'N'
              if( onenrm ) then
                 kase1 = 1
              else
                 kase1 = 2
              end if
              kase = 0
              10 continue
              call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
              if( kase/=0 ) then
                 if( kase==kase1 ) then
                    ! multiply by inv(a).
                    call stdlib_clatbs( uplo, 'NO TRANSPOSE', diag, normin, n, kd,ab, ldab, work, &
                              scale, rwork, info )
                 else
                    ! multiply by inv(a**h).
                    call stdlib_clatbs( uplo, 'CONJUGATE TRANSPOSE', diag, normin,n, kd, ab, ldab,&
                               work, scale, rwork, info )
                 end if
                 normin = 'Y'
                 ! multiply by 1/scale if doing so will not cause overflow.
                 if( scale/=one ) then
                    ix = stdlib_icamax( n, work, 1 )
                    xnorm = cabs1( work( ix ) )
                    if( scale<xnorm*smlnum .or. scale==zero )go to 20
                    call stdlib_csrscl( n, scale, work, 1 )
                 end if
                 go to 10
              end if
              ! compute the estimate of the reciprocal condition number.
              if( ainvnm/=zero )rcond = ( one / anorm ) / ainvnm
           end if
           20 continue
           return
     end subroutine stdlib_ctbcon


     pure subroutine stdlib_ctftri( transr, uplo, diag, n, a, info )
     !! CTFTRI computes the inverse of a triangular matrix A stored in RFP
     !! format.
     !! This is a Level 3 BLAS version of the algorithm.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, uplo, diag
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(0:*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lower, nisodd, normaltransr
           integer(ilp) :: n1, n2, k
           ! Intrinsic Functions 
           intrinsic :: mod
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'C' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( .not.stdlib_lsame( diag, 'N' ) .and. .not.stdlib_lsame( diag, 'U' ) )&
                     then
              info = -3
           else if( n<0 ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTFTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! if n is odd, set nisodd = .true.
           ! if n is even, set k = n/2 and nisodd = .false.
           if( mod( n, 2 )==0 ) then
              k = n / 2
              nisodd = .false.
           else
              nisodd = .true.
           end if
           ! set n1 and n2 depending on lower
           if( lower ) then
              n2 = n / 2
              n1 = n - n2
           else
              n1 = n / 2
              n2 = n - n1
           end if
           ! start execution: there are eight cases
           if( nisodd ) then
              ! n is odd
              if( normaltransr ) then
                 ! n is odd and transr = 'n'
                 if( lower ) then
                   ! srpa for lower, normal and n is odd ( a(0:n-1,0:n1-1) )
                   ! t1 -> a(0,0), t2 -> a(0,1), s -> a(n1,0)
                   ! t1 -> a(0), t2 -> a(n), s -> a(n1)
                    call stdlib_ctrtri( 'L', diag, n1, a( 0 ), n, info )
                    if( info>0 )return
                    call stdlib_ctrmm( 'R', 'L', 'N', diag, n2, n1, -cone, a( 0 ),n, a( n1 ), n )
                              
                    call stdlib_ctrtri( 'U', diag, n2, a( n ), n, info )
                    if( info>0 )info = info + n1
                    if( info>0 )return
                    call stdlib_ctrmm( 'L', 'U', 'C', diag, n2, n1, cone, a( n ), n,a( n1 ), n )
                              
                 else
                   ! srpa for upper, normal and n is odd ( a(0:n-1,0:n2-1)
                   ! t1 -> a(n1+1,0), t2 -> a(n1,0), s -> a(0,0)
                   ! t1 -> a(n2), t2 -> a(n1), s -> a(0)
                    call stdlib_ctrtri( 'L', diag, n1, a( n2 ), n, info )
                    if( info>0 )return
                    call stdlib_ctrmm( 'L', 'L', 'C', diag, n1, n2, -cone, a( n2 ),n, a( 0 ), n )
                              
                    call stdlib_ctrtri( 'U', diag, n2, a( n1 ), n, info )
                    if( info>0 )info = info + n1
                    if( info>0 )return
                    call stdlib_ctrmm( 'R', 'U', 'N', diag, n1, n2, cone, a( n1 ),n, a( 0 ), n )
                              
                 end if
              else
                 ! n is odd and transr = 'c'
                 if( lower ) then
                    ! srpa for lower, transpose and n is odd
                    ! t1 -> a(0), t2 -> a(1), s -> a(0+n1*n1)
                    call stdlib_ctrtri( 'U', diag, n1, a( 0 ), n1, info )
                    if( info>0 )return
                    call stdlib_ctrmm( 'L', 'U', 'N', diag, n1, n2, -cone, a( 0 ),n1, a( n1*n1 ), &
                              n1 )
                    call stdlib_ctrtri( 'L', diag, n2, a( 1 ), n1, info )
                    if( info>0 )info = info + n1
                    if( info>0 )return
                    call stdlib_ctrmm( 'R', 'L', 'C', diag, n1, n2, cone, a( 1 ),n1, a( n1*n1 ), &
                              n1 )
                 else
                    ! srpa for upper, transpose and n is odd
                    ! t1 -> a(0+n2*n2), t2 -> a(0+n1*n2), s -> a(0)
                    call stdlib_ctrtri( 'U', diag, n1, a( n2*n2 ), n2, info )
                    if( info>0 )return
                    call stdlib_ctrmm( 'R', 'U', 'C', diag, n2, n1, -cone,a( n2*n2 ), n2, a( 0 ), &
                              n2 )
                    call stdlib_ctrtri( 'L', diag, n2, a( n1*n2 ), n2, info )
                    if( info>0 )info = info + n1
                    if( info>0 )return
                    call stdlib_ctrmm( 'L', 'L', 'N', diag, n2, n1, cone,a( n1*n2 ), n2, a( 0 ), &
                              n2 )
                 end if
              end if
           else
              ! n is even
              if( normaltransr ) then
                 ! n is even and transr = 'n'
                 if( lower ) then
                    ! srpa for lower, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(1,0), t2 -> a(0,0), s -> a(k+1,0)
                    ! t1 -> a(1), t2 -> a(0), s -> a(k+1)
                    call stdlib_ctrtri( 'L', diag, k, a( 1 ), n+1, info )
                    if( info>0 )return
                    call stdlib_ctrmm( 'R', 'L', 'N', diag, k, k, -cone, a( 1 ),n+1, a( k+1 ), n+&
                              1 )
                    call stdlib_ctrtri( 'U', diag, k, a( 0 ), n+1, info )
                    if( info>0 )info = info + k
                    if( info>0 )return
                    call stdlib_ctrmm( 'L', 'U', 'C', diag, k, k, cone, a( 0 ), n+1,a( k+1 ), n+1 &
                              )
                 else
                    ! srpa for upper, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(k+1,0) ,  t2 -> a(k,0),   s -> a(0,0)
                    ! t1 -> a(k+1), t2 -> a(k), s -> a(0)
                    call stdlib_ctrtri( 'L', diag, k, a( k+1 ), n+1, info )
                    if( info>0 )return
                    call stdlib_ctrmm( 'L', 'L', 'C', diag, k, k, -cone, a( k+1 ),n+1, a( 0 ), n+&
                              1 )
                    call stdlib_ctrtri( 'U', diag, k, a( k ), n+1, info )
                    if( info>0 )info = info + k
                    if( info>0 )return
                    call stdlib_ctrmm( 'R', 'U', 'N', diag, k, k, cone, a( k ), n+1,a( 0 ), n+1 )
                              
                 end if
              else
                 ! n is even and transr = 'c'
                 if( lower ) then
                    ! srpa for lower, transpose and n is even (see paper)
                    ! t1 -> b(0,1), t2 -> b(0,0), s -> b(0,k+1)
                    ! t1 -> a(0+k), t2 -> a(0+0), s -> a(0+k*(k+1)); lda=k
                    call stdlib_ctrtri( 'U', diag, k, a( k ), k, info )
                    if( info>0 )return
                    call stdlib_ctrmm( 'L', 'U', 'N', diag, k, k, -cone, a( k ), k,a( k*( k+1 ) ),&
                               k )
                    call stdlib_ctrtri( 'L', diag, k, a( 0 ), k, info )
                    if( info>0 )info = info + k
                    if( info>0 )return
                    call stdlib_ctrmm( 'R', 'L', 'C', diag, k, k, cone, a( 0 ), k,a( k*( k+1 ) ), &
                              k )
                 else
                    ! srpa for upper, transpose and n is even (see paper)
                    ! t1 -> b(0,k+1),     t2 -> b(0,k),   s -> b(0,0)
                    ! t1 -> a(0+k*(k+1)), t2 -> a(0+k*k), s -> a(0+0)); lda=k
                    call stdlib_ctrtri( 'U', diag, k, a( k*( k+1 ) ), k, info )
                    if( info>0 )return
                    call stdlib_ctrmm( 'R', 'U', 'C', diag, k, k, -cone,a( k*( k+1 ) ), k, a( 0 ),&
                               k )
                    call stdlib_ctrtri( 'L', diag, k, a( k*k ), k, info )
                    if( info>0 )info = info + k
                    if( info>0 )return
                    call stdlib_ctrmm( 'L', 'L', 'N', diag, k, k, cone, a( k*k ), k,a( 0 ), k )
                              
                 end if
              end if
           end if
           return
     end subroutine stdlib_ctftri


     pure subroutine stdlib_ctgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb, &
     !! CTGSJA computes the generalized singular value decomposition (GSVD)
     !! of two complex upper triangular (or trapezoidal) matrices A and B.
     !! On entry, it is assumed that matrices A and B have the following
     !! forms, which may be obtained by the preprocessing subroutine CGGSVP
     !! from a general M-by-N matrix A and P-by-N matrix B:
     !! N-K-L  K    L
     !! A =    K ( 0    A12  A13 ) if M-K-L >= 0;
     !! L ( 0     0   A23 )
     !! M-K-L ( 0     0    0  )
     !! N-K-L  K    L
     !! A =  K ( 0    A12  A13 ) if M-K-L < 0;
     !! M-K ( 0     0   A23 )
     !! N-K-L  K    L
     !! B =  L ( 0     0   B13 )
     !! P-L ( 0     0    0  )
     !! where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
     !! upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
     !! otherwise A23 is (M-K)-by-L upper trapezoidal.
     !! On exit,
     !! U**H *A*Q = D1*( 0 R ),    V**H *B*Q = D2*( 0 R ),
     !! where U, V and Q are unitary matrices.
     !! R is a nonsingular upper triangular matrix, and D1
     !! and D2 are ``diagonal'' matrices, which are of the following
     !! structures:
     !! If M-K-L >= 0,
     !! K  L
     !! D1 =     K ( I  0 )
     !! L ( 0  C )
     !! M-K-L ( 0  0 )
     !! K  L
     !! D2 = L   ( 0  S )
     !! P-L ( 0  0 )
     !! N-K-L  K    L
     !! ( 0 R ) = K (  0   R11  R12 ) K
     !! L (  0    0   R22 ) L
     !! where
     !! C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
     !! S = diag( BETA(K+1),  ... , BETA(K+L) ),
     !! C**2 + S**2 = I.
     !! R is stored in A(1:K+L,N-K-L+1:N) on exit.
     !! If M-K-L < 0,
     !! K M-K K+L-M
     !! D1 =   K ( I  0    0   )
     !! M-K ( 0  C    0   )
     !! K M-K K+L-M
     !! D2 =   M-K ( 0  S    0   )
     !! K+L-M ( 0  0    I   )
     !! P-L ( 0  0    0   )
     !! N-K-L  K   M-K  K+L-M
     !! ( 0 R ) =    K ( 0    R11  R12  R13  )
     !! M-K ( 0     0   R22  R23  )
     !! K+L-M ( 0     0    0   R33  )
     !! where
     !! C = diag( ALPHA(K+1), ... , ALPHA(M) ),
     !! S = diag( BETA(K+1),  ... , BETA(M) ),
     !! C**2 + S**2 = I.
     !! R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
     !! (  0  R22 R23 )
     !! in B(M-K+1:L,N+M-K-L+1:N) on exit.
     !! The computation of the unitary transformation matrices U, V or Q
     !! is optional.  These matrices may either be formed explicitly, or they
     !! may be postmultiplied into input matrices U1, V1, or Q1.
               alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobq, jobu, jobv
           integer(ilp), intent(out) :: info, ncycle
           integer(ilp), intent(in) :: k, l, lda, ldb, ldq, ldu, ldv, m, n, p
           real(sp), intent(in) :: tola, tolb
           ! Array Arguments 
           real(sp), intent(out) :: alpha(*), beta(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), u(ldu,*), v(ldv,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 40
           real(sp), parameter :: hugenum = huge(zero)
           
           
           
           ! Local Scalars 
           logical(lk) :: initq, initu, initv, upper, wantq, wantu, wantv
           integer(ilp) :: i, j, kcycle
           real(sp) :: a1, a3, b1, b3, csq, csu, csv, error, gamma, rwk, ssmin
           complex(sp) :: a2, b2, snq, snu, snv
           ! Intrinsic Functions 
           intrinsic :: abs,conjg,max,min,real,huge
           ! Executable Statements 
           ! decode and test the input parameters
           initu = stdlib_lsame( jobu, 'I' )
           wantu = initu .or. stdlib_lsame( jobu, 'U' )
           initv = stdlib_lsame( jobv, 'I' )
           wantv = initv .or. stdlib_lsame( jobv, 'V' )
           initq = stdlib_lsame( jobq, 'I' )
           wantq = initq .or. stdlib_lsame( jobq, 'Q' )
           info = 0
           if( .not.( initu .or. wantu .or. stdlib_lsame( jobu, 'N' ) ) ) then
              info = -1
           else if( .not.( initv .or. wantv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -2
           else if( .not.( initq .or. wantq .or. stdlib_lsame( jobq, 'N' ) ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( p<0 ) then
              info = -5
           else if( n<0 ) then
              info = -6
           else if( lda<max( 1, m ) ) then
              info = -10
           else if( ldb<max( 1, p ) ) then
              info = -12
           else if( ldu<1 .or. ( wantu .and. ldu<m ) ) then
              info = -18
           else if( ldv<1 .or. ( wantv .and. ldv<p ) ) then
              info = -20
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -22
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGSJA', -info )
              return
           end if
           ! initialize u, v and q, if necessary
           if( initu )call stdlib_claset( 'FULL', m, m, czero, cone, u, ldu )
           if( initv )call stdlib_claset( 'FULL', p, p, czero, cone, v, ldv )
           if( initq )call stdlib_claset( 'FULL', n, n, czero, cone, q, ldq )
           ! loop until convergence
           upper = .false.
           loop_40: do kcycle = 1, maxit
              upper = .not.upper
              loop_20: do i = 1, l - 1
                 loop_10: do j = i + 1, l
                    a1 = zero
                    a2 = czero
                    a3 = zero
                    if( k+i<=m )a1 = real( a( k+i, n-l+i ),KIND=sp)
                    if( k+j<=m )a3 = real( a( k+j, n-l+j ),KIND=sp)
                    b1 = real( b( i, n-l+i ),KIND=sp)
                    b3 = real( b( j, n-l+j ),KIND=sp)
                    if( upper ) then
                       if( k+i<=m )a2 = a( k+i, n-l+j )
                       b2 = b( i, n-l+j )
                    else
                       if( k+j<=m )a2 = a( k+j, n-l+i )
                       b2 = b( j, n-l+i )
                    end if
                    call stdlib_clags2( upper, a1, a2, a3, b1, b2, b3, csu, snu,csv, snv, csq, &
                              snq )
                    ! update (k+i)-th and (k+j)-th rows of matrix a: u**h *a
                    if( k+j<=m )call stdlib_crot( l, a( k+j, n-l+1 ), lda, a( k+i, n-l+1 ),lda, &
                              csu, conjg( snu ) )
                    ! update i-th and j-th rows of matrix b: v**h *b
                    call stdlib_crot( l, b( j, n-l+1 ), ldb, b( i, n-l+1 ), ldb,csv, conjg( snv ) &
                              )
                    ! update (n-l+i)-th and (n-l+j)-th columns of matrices
                    ! a and b: a*q and b*q
                    call stdlib_crot( min( k+l, m ), a( 1, n-l+j ), 1,a( 1, n-l+i ), 1, csq, snq )
                              
                    call stdlib_crot( l, b( 1, n-l+j ), 1, b( 1, n-l+i ), 1, csq,snq )
                    if( upper ) then
                       if( k+i<=m )a( k+i, n-l+j ) = czero
                       b( i, n-l+j ) = czero
                    else
                       if( k+j<=m )a( k+j, n-l+i ) = czero
                       b( j, n-l+i ) = czero
                    end if
                    ! ensure that the diagonal elements of a and b are real.
                    if( k+i<=m )a( k+i, n-l+i ) = real( a( k+i, n-l+i ),KIND=sp)
                    if( k+j<=m )a( k+j, n-l+j ) = real( a( k+j, n-l+j ),KIND=sp)
                    b( i, n-l+i ) = real( b( i, n-l+i ),KIND=sp)
                    b( j, n-l+j ) = real( b( j, n-l+j ),KIND=sp)
                    ! update unitary matrices u, v, q, if desired.
                    if( wantu .and. k+j<=m )call stdlib_crot( m, u( 1, k+j ), 1, u( 1, k+i ), 1, &
                              csu,snu )
                    if( wantv )call stdlib_crot( p, v( 1, j ), 1, v( 1, i ), 1, csv, snv )
                    if( wantq )call stdlib_crot( n, q( 1, n-l+j ), 1, q( 1, n-l+i ), 1, csq,snq )
                              
                 end do loop_10
              end do loop_20
              if( .not.upper ) then
                 ! the matrices a13 and b13 were lower triangular at the start
                 ! of the cycle, and are now upper triangular.
                 ! convergence test: test the parallelism of the corresponding
                 ! rows of a and b.
                 error = zero
                 do i = 1, min( l, m-k )
                    call stdlib_ccopy( l-i+1, a( k+i, n-l+i ), lda, work, 1 )
                    call stdlib_ccopy( l-i+1, b( i, n-l+i ), ldb, work( l+1 ), 1 )
                    call stdlib_clapll( l-i+1, work, 1, work( l+1 ), 1, ssmin )
                    error = max( error, ssmin )
                 end do
                 if( abs( error )<=min( tola, tolb ) )go to 50
              end if
              ! end of cycle loop
           end do loop_40
           ! the algorithm has not converged after maxit cycles.
           info = 1
           go to 100
           50 continue
           ! if error <= min(tola,tolb), then the algorithm has converged.
           ! compute the generalized singular value pairs (alpha, beta), and
           ! set the triangular matrix r to array a.
           do i = 1, k
              alpha( i ) = one
              beta( i ) = zero
           end do
           do i = 1, min( l, m-k )
              a1 = real( a( k+i, n-l+i ),KIND=sp)
              b1 = real( b( i, n-l+i ),KIND=sp)
              gamma = b1 / a1
              if( (gamma<=hugenum).and.(gamma>=-hugenum) ) then
                 if( gamma<zero ) then
                    call stdlib_csscal( l-i+1, -one, b( i, n-l+i ), ldb )
                    if( wantv )call stdlib_csscal( p, -one, v( 1, i ), 1 )
                 end if
                 call stdlib_slartg( abs( gamma ), one, beta( k+i ), alpha( k+i ),rwk )
                 if( alpha( k+i )>=beta( k+i ) ) then
                    call stdlib_csscal( l-i+1, one / alpha( k+i ), a( k+i, n-l+i ),lda )
                 else
                    call stdlib_csscal( l-i+1, one / beta( k+i ), b( i, n-l+i ),ldb )
                    call stdlib_ccopy( l-i+1, b( i, n-l+i ), ldb, a( k+i, n-l+i ),lda )
                 end if
              else
                 alpha( k+i ) = zero
                 beta( k+i ) = one
                 call stdlib_ccopy( l-i+1, b( i, n-l+i ), ldb, a( k+i, n-l+i ),lda )
              end if
           end do
           ! post-assignment
           do i = m + 1, k + l
              alpha( i ) = zero
              beta( i ) = one
           end do
           if( k+l<n ) then
              do i = k + l + 1, n
                 alpha( i ) = zero
                 beta( i ) = zero
              end do
           end if
           100 continue
           ncycle = kcycle
           return
     end subroutine stdlib_ctgsja


     pure subroutine stdlib_ctgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! CTGSY2 solves the generalized Sylvester equation
     !! A * R - L * B = scale *  C               (1)
     !! D * R - L * E = scale * F
     !! using Level 1 and 2 BLAS, where R and L are unknown M-by-N matrices,
     !! (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
     !! N-by-N and M-by-N, respectively. A, B, D and E are upper triangular
     !! (i.e., (A,D) and (B,E) in generalized Schur form).
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
     !! scaling factor chosen to avoid overflow.
     !! In matrix notation solving equation (1) corresponds to solve
     !! Zx = scale * b, where Z is defined as
     !! Z = [ kron(In, A)  -kron(B**H, Im) ]             (2)
     !! [ kron(In, D)  -kron(E**H, Im) ],
     !! Ik is the identity matrix of size k and X**H is the transpose of X.
     !! kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! If TRANS = 'C', y in the conjugate transposed system Z**H*y = scale*b
     !! is solved for, which is equivalent to solve for R and L in
     !! A**H * R  + D**H * L   = scale * C           (3)
     !! R  * B**H + L  * E**H  = scale * -F
     !! This case is used to compute an estimate of Dif[(A, D), (B, E)] =
     !! = sigma_min(Z) using reverse communication with CLACON.
     !! CTGSY2 also (IJOB >= 1) contributes to the computation in CTGSYL
     !! of an upper bound on the separation between to matrix pairs. Then
     !! the input (A, D), (B, E) are sub-pencils of two matrix pairs in
     !! CTGSYL.
               ldf, scale, rdsum, rdscal,info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(ilp), intent(out) :: info
           real(sp), intent(inout) :: rdscal, rdsum
           real(sp), intent(out) :: scale
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(sp), intent(inout) :: c(ldc,*), f(ldf,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ldz = 2
           
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ierr, j, k
           real(sp) :: scaloc
           complex(sp) :: alpha
           ! Local Arrays 
           integer(ilp) :: ipiv(ldz), jpiv(ldz)
           complex(sp) :: rhs(ldz), z(ldz,ldz)
           ! Intrinsic Functions 
           intrinsic :: cmplx,conjg,max
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           ierr = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>2 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGSY2', -info )
              return
           end if
           if( notran ) then
              ! solve (i, j) - system
                 ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                 ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
              ! for i = m, m - 1, ..., 1; j = 1, 2, ..., n
              scale = one
              scaloc = one
              loop_30: do j = 1, n
                 loop_20: do i = m, 1, -1
                    ! build 2 by 2 system
                    z( 1, 1 ) = a( i, i )
                    z( 2, 1 ) = d( i, i )
                    z( 1, 2 ) = -b( j, j )
                    z( 2, 2 ) = -e( j, j )
                    ! set up right hand side(s)
                    rhs( 1 ) = c( i, j )
                    rhs( 2 ) = f( i, j )
                    ! solve z * x = rhs
                    call stdlib_cgetc2( ldz, z, ldz, ipiv, jpiv, ierr )
                    if( ierr>0 )info = ierr
                    if( ijob==0 ) then
                       call stdlib_cgesc2( ldz, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                       
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                       
                          end do
                          scale = scale*scaloc
                       end if
                    else
                       call stdlib_clatdf( ijob, ldz, z, ldz, rhs, rdsum, rdscal,ipiv, jpiv )
                                 
                    end if
                    ! unpack solution vector(s)
                    c( i, j ) = rhs( 1 )
                    f( i, j ) = rhs( 2 )
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    if( i>1 ) then
                       alpha = -rhs( 1 )
                       call stdlib_caxpy( i-1, alpha, a( 1, i ), 1, c( 1, j ), 1 )
                       call stdlib_caxpy( i-1, alpha, d( 1, i ), 1, f( 1, j ), 1 )
                    end if
                    if( j<n ) then
                       call stdlib_caxpy( n-j, rhs( 2 ), b( j, j+1 ), ldb,c( i, j+1 ), ldc )
                                 
                       call stdlib_caxpy( n-j, rhs( 2 ), e( j, j+1 ), lde,f( i, j+1 ), ldf )
                                 
                    end if
                 end do loop_20
              end do loop_30
           else
              ! solve transposed (i, j) - system:
                 ! a(i, i)**h * r(i, j) + d(i, i)**h * l(j, j) = c(i, j)
                 ! r(i, i) * b(j, j) + l(i, j) * e(j, j)   = -f(i, j)
              ! for i = 1, 2, ..., m, j = n, n - 1, ..., 1
              scale = one
              scaloc = one
              loop_80: do i = 1, m
                 loop_70: do j = n, 1, -1
                    ! build 2 by 2 system z**h
                    z( 1, 1 ) = conjg( a( i, i ) )
                    z( 2, 1 ) = -conjg( b( j, j ) )
                    z( 1, 2 ) = conjg( d( i, i ) )
                    z( 2, 2 ) = -conjg( e( j, j ) )
                    ! set up right hand side(s)
                    rhs( 1 ) = c( i, j )
                    rhs( 2 ) = f( i, j )
                    ! solve z**h * x = rhs
                    call stdlib_cgetc2( ldz, z, ldz, ipiv, jpiv, ierr )
                    if( ierr>0 )info = ierr
                    call stdlib_cgesc2( ldz, z, ldz, rhs, ipiv, jpiv, scaloc )
                    if( scaloc/=one ) then
                       do k = 1, n
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                    
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                    
                       end do
                       scale = scale*scaloc
                    end if
                    ! unpack solution vector(s)
                    c( i, j ) = rhs( 1 )
                    f( i, j ) = rhs( 2 )
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    do k = 1, j - 1
                       f( i, k ) = f( i, k ) + rhs( 1 )*conjg( b( k, j ) ) +rhs( 2 )*conjg( e( k, &
                                 j ) )
                    end do
                    do k = i + 1, m
                       c( k, j ) = c( k, j ) - conjg( a( i, k ) )*rhs( 1 ) -conjg( d( i, k ) )&
                                 *rhs( 2 )
                    end do
                 end do loop_70
              end do loop_80
           end if
           return
     end subroutine stdlib_ctgsy2


     pure subroutine stdlib_ctgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! CTGSYL solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C            (1)
     !! D * R - L * E = scale * F
     !! where R and L are unknown m-by-n matrices, (A, D), (B, E) and
     !! (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
     !! respectively, with complex entries. A, B, D and E are upper
     !! triangular (i.e., (A,D) and (B,E) in generalized Schur form).
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
     !! is an output scaling factor chosen to avoid overflow.
     !! In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
     !! is defined as
     !! Z = [ kron(In, A)  -kron(B**H, Im) ]        (2)
     !! [ kron(In, D)  -kron(E**H, Im) ],
     !! Here Ix is the identity matrix of size x and X**H is the conjugate
     !! transpose of X. Kron(X, Y) is the Kronecker product between the
     !! matrices X and Y.
     !! If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b
     !! is solved for, which is equivalent to solve for R and L in
     !! A**H * R + D**H * L = scale * C           (3)
     !! R * B**H + L * E**H = scale * -F
     !! This case (TRANS = 'C') is used to compute an one-norm-based estimate
     !! of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
     !! and (B,E), using CLACON.
     !! If IJOB >= 1, CTGSYL computes a Frobenius norm-based estimate of
     !! Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
     !! reciprocal of the smallest singular value of Z.
     !! This is a level-3 BLAS algorithm.
               ldf, scale, dif, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(ilp), intent(out) :: info
           real(sp), intent(out) :: dif, scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           complex(sp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(sp), intent(inout) :: c(ldc,*), f(ldf,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_ccopy by calls to stdlib_claset.
        ! sven hammarling, 1/5/02.
           
           
           ! Local Scalars 
           logical(lk) :: lquery, notran
           integer(ilp) :: i, ie, ifunc, iround, is, isolve, j, je, js, k, linfo, lwmin, mb, nb, &
                     p, pq, q
           real(sp) :: dscale, dsum, scale2, scaloc
           ! Intrinsic Functions 
           intrinsic :: cmplx,max,real,sqrt
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>4 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info==0 ) then
              if( notran ) then
                 if( ijob==1 .or. ijob==2 ) then
                    lwmin = max( 1, 2*m*n )
                 else
                    lwmin = 1
                 end if
              else
                 lwmin = 1
              end if
              work( 1 ) = lwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGSYL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              scale = 1
              if( notran ) then
                 if( ijob/=0 ) then
                    dif = 0
                 end if
              end if
              return
           end if
           ! determine  optimal block sizes mb and nb
           mb = stdlib_ilaenv( 2, 'CTGSYL', trans, m, n, -1, -1 )
           nb = stdlib_ilaenv( 5, 'CTGSYL', trans, m, n, -1, -1 )
           isolve = 1
           ifunc = 0
           if( notran ) then
              if( ijob>=3 ) then
                 ifunc = ijob - 2
                 call stdlib_claset( 'F', m, n, czero, czero, c, ldc )
                 call stdlib_claset( 'F', m, n, czero, czero, f, ldf )
              else if( ijob>=1 .and. notran ) then
                 isolve = 2
              end if
           end if
           if( ( mb<=1 .and. nb<=1 ) .or. ( mb>=m .and. nb>=n ) )then
              ! use unblocked level 2 solver
              loop_30: do iround = 1, isolve
                 scale = one
                 dscale = zero
                 dsum = one
                 pq = m*n
                 call stdlib_ctgsy2( trans, ifunc, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f,&
                            ldf, scale, dsum, dscale,info )
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_clacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_clacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_claset( 'F', m, n, czero, czero, c, ldc )
                    call stdlib_claset( 'F', m, n, czero, czero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_clacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_clacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_30
              return
           end if
           ! determine block structure of a
           p = 0
           i = 1
           40 continue
           if( i>m )go to 50
           p = p + 1
           iwork( p ) = i
           i = i + mb
           if( i>=m )go to 50
           go to 40
           50 continue
           iwork( p+1 ) = m + 1
           if( iwork( p )==iwork( p+1 ) )p = p - 1
           ! determine block structure of b
           q = p + 1
           j = 1
           60 continue
           if( j>n )go to 70
           q = q + 1
           iwork( q ) = j
           j = j + nb
           if( j>=n )go to 70
           go to 60
           70 continue
           iwork( q+1 ) = n + 1
           if( iwork( q )==iwork( q+1 ) )q = q - 1
           if( notran ) then
              loop_150: do iround = 1, isolve
                 ! solve (i, j) - subsystem
                     ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                     ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
                 ! for i = p, p - 1, ..., 1; j = 1, 2, ..., q
                 pq = 0
                 scale = one
                 dscale = zero
                 dsum = one
                 loop_130: do j = p + 2, q
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    loop_120: do i = p, 1, -1
                       is = iwork( i )
                       ie = iwork( i+1 ) - 1
                       mb = ie - is + 1
                       call stdlib_ctgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), &
                       ldb, c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, &
                                 scaloc, dsum, dscale,linfo )
                       if( linfo>0 )info = linfo
                       pq = pq + mb*nb
                       if( scaloc/=one ) then
                          do k = 1, js - 1
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                       
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                       
                          end do
                          do k = js, je
                             call stdlib_cscal( is-1, cmplx( scaloc, zero,KIND=sp),c( 1, k ), 1 )
                                       
                             call stdlib_cscal( is-1, cmplx( scaloc, zero,KIND=sp),f( 1, k ), 1 )
                                       
                          end do
                          do k = js, je
                             call stdlib_cscal( m-ie, cmplx( scaloc, zero,KIND=sp),c( ie+1, k ), &
                                       1 )
                             call stdlib_cscal( m-ie, cmplx( scaloc, zero,KIND=sp),f( ie+1, k ), &
                                       1 )
                          end do
                          do k = je + 1, n
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                       
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                       
                          end do
                          scale = scale*scaloc
                       end if
                       ! substitute r(i,j) and l(i,j) into remaining equation.
                       if( i>1 ) then
                          call stdlib_cgemm( 'N', 'N', is-1, nb, mb,cmplx( -one, zero,KIND=sp), a(&
                           1, is ), lda,c( is, js ), ldc, cmplx( one, zero,KIND=sp),c( 1, js ), &
                                     ldc )
                          call stdlib_cgemm( 'N', 'N', is-1, nb, mb,cmplx( -one, zero,KIND=sp), d(&
                           1, is ), ldd,c( is, js ), ldc, cmplx( one, zero,KIND=sp),f( 1, js ), &
                                     ldf )
                       end if
                       if( j<q ) then
                          call stdlib_cgemm( 'N', 'N', mb, n-je, nb,cmplx( one, zero,KIND=sp), f( &
                          is, js ), ldf,b( js, je+1 ), ldb, cmplx( one, zero,KIND=sp),c( is, je+1 &
                                    ), ldc )
                          call stdlib_cgemm( 'N', 'N', mb, n-je, nb,cmplx( one, zero,KIND=sp), f( &
                          is, js ), ldf,e( js, je+1 ), lde, cmplx( one, zero,KIND=sp),f( is, je+1 &
                                    ), ldf )
                       end if
                    end do loop_120
                 end do loop_130
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_clacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_clacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_claset( 'F', m, n, czero, czero, c, ldc )
                    call stdlib_claset( 'F', m, n, czero, czero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_clacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_clacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_150
           else
              ! solve transposed (i, j)-subsystem
                  ! a(i, i)**h * r(i, j) + d(i, i)**h * l(i, j) = c(i, j)
                  ! r(i, j) * b(j, j)  + l(i, j) * e(j, j) = -f(i, j)
              ! for i = 1,2,..., p; j = q, q-1,..., 1
              scale = one
              loop_210: do i = 1, p
                 is = iwork( i )
                 ie = iwork( i+1 ) - 1
                 mb = ie - is + 1
                 loop_200: do j = q, p + 2, -1
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    call stdlib_ctgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), ldb, &
                    c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, scaloc, &
                              dsum, dscale,linfo )
                    if( linfo>0 )info = linfo
                    if( scaloc/=one ) then
                       do k = 1, js - 1
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                    
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                    
                       end do
                       do k = js, je
                          call stdlib_cscal( is-1, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                    
                          call stdlib_cscal( is-1, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                    
                       end do
                       do k = js, je
                          call stdlib_cscal( m-ie, cmplx( scaloc, zero,KIND=sp),c( ie+1, k ), 1 )
                                    
                          call stdlib_cscal( m-ie, cmplx( scaloc, zero,KIND=sp),f( ie+1, k ), 1 )
                                    
                       end do
                       do k = je + 1, n
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                    
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                    
                       end do
                       scale = scale*scaloc
                    end if
                    ! substitute r(i,j) and l(i,j) into remaining equation.
                    if( j>p+2 ) then
                       call stdlib_cgemm( 'N', 'C', mb, js-1, nb,cmplx( one, zero,KIND=sp), c( is,&
                        js ), ldc,b( 1, js ), ldb, cmplx( one, zero,KIND=sp),f( is, 1 ), ldf )
                                  
                       call stdlib_cgemm( 'N', 'C', mb, js-1, nb,cmplx( one, zero,KIND=sp), f( is,&
                        js ), ldf,e( 1, js ), lde, cmplx( one, zero,KIND=sp),f( is, 1 ), ldf )
                                  
                    end if
                    if( i<p ) then
                       call stdlib_cgemm( 'C', 'N', m-ie, nb, mb,cmplx( -one, zero,KIND=sp), a( &
                       is, ie+1 ), lda,c( is, js ), ldc, cmplx( one, zero,KIND=sp),c( ie+1, js ), &
                                 ldc )
                       call stdlib_cgemm( 'C', 'N', m-ie, nb, mb,cmplx( -one, zero,KIND=sp), d( &
                       is, ie+1 ), ldd,f( is, js ), ldf, cmplx( one, zero,KIND=sp),c( ie+1, js ), &
                                 ldc )
                    end if
                 end do loop_200
              end do loop_210
           end if
           work( 1 ) = lwmin
           return
     end subroutine stdlib_ctgsyl


     subroutine stdlib_ctpcon( norm, uplo, diag, n, ap, rcond, work, rwork,info )
     !! CTPCON estimates the reciprocal of the condition number of a packed
     !! triangular matrix A, in either the 1-norm or the infinity-norm.
     !! The norm of A is computed and an estimate is obtained for
     !! norm(inv(A)), then the reciprocal of the condition number is
     !! computed as
     !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, norm, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(in) :: ap(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit, onenrm, upper
           character :: normin
           integer(ilp) :: ix, kase, kase1
           real(sp) :: ainvnm, anorm, scale, smlnum, xnorm
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           onenrm = norm=='1' .or. stdlib_lsame( norm, 'O' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.onenrm .and. .not.stdlib_lsame( norm, 'I' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTPCON', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              rcond = one
              return
           end if
           rcond = zero
           smlnum = stdlib_slamch( 'SAFE MINIMUM' )*real( max( 1, n ),KIND=sp)
           ! compute the norm of the triangular matrix a.
           anorm = stdlib_clantp( norm, uplo, diag, n, ap, rwork )
           ! continue only if anorm > 0.
           if( anorm>zero ) then
              ! estimate the norm of the inverse of a.
              ainvnm = zero
              normin = 'N'
              if( onenrm ) then
                 kase1 = 1
              else
                 kase1 = 2
              end if
              kase = 0
              10 continue
              call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
              if( kase/=0 ) then
                 if( kase==kase1 ) then
                    ! multiply by inv(a).
                    call stdlib_clatps( uplo, 'NO TRANSPOSE', diag, normin, n, ap,work, scale, &
                              rwork, info )
                 else
                    ! multiply by inv(a**h).
                    call stdlib_clatps( uplo, 'CONJUGATE TRANSPOSE', diag, normin,n, ap, work, &
                              scale, rwork, info )
                 end if
                 normin = 'Y'
                 ! multiply by 1/scale if doing so will not cause overflow.
                 if( scale/=one ) then
                    ix = stdlib_icamax( n, work, 1 )
                    xnorm = cabs1( work( ix ) )
                    if( scale<xnorm*smlnum .or. scale==zero )go to 20
                    call stdlib_csrscl( n, scale, work, 1 )
                 end if
                 go to 10
              end if
              ! compute the estimate of the reciprocal condition number.
              if( ainvnm/=zero )rcond = ( one / anorm ) / ainvnm
           end if
           20 continue
           return
     end subroutine stdlib_ctpcon


     pure subroutine stdlib_ctplqt( m, n, l, mb, a, lda, b, ldb, t, ldt, work,info )
     !! CTPLQT computes a blocked LQ factorization of a complex
     !! "triangular-pentagonal" matrix C, which is composed of a
     !! triangular block A and pentagonal block B, using the compact
     !! WY representation for Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldt, n, m, l, mb
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: t(ldt,*), work(*)
       ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ib, lb, nb, iinfo
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( l<0 .or. (l>min(m,n) .and. min(m,n)>=0)) then
              info = -3
           else if( mb<1 .or. (mb>m .and. m>0)) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldb<max( 1, m ) ) then
              info = -8
           else if( ldt<mb ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTPLQT', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) return
           do i = 1, m, mb
           ! compute the qr factorization of the current block
              ib = min( m-i+1, mb )
              nb = min( n-l+i+ib-1, n )
              if( i>=l ) then
                 lb = 0
              else
                 lb = nb-n+l-i+1
              end if
              call stdlib_ctplqt2( ib, nb, lb, a(i,i), lda, b( i, 1 ), ldb,t(1, i ), ldt, iinfo )
                        
           ! update by applying h**t to b(i+ib:m,:) from the right
              if( i+ib<=m ) then
                 call stdlib_ctprfb( 'R', 'N', 'F', 'R', m-i-ib+1, nb, ib, lb,b( i, 1 ), ldb, t( &
                           1, i ), ldt,a( i+ib, i ), lda, b( i+ib, 1 ), ldb,work, m-i-ib+1)
              end if
           end do
           return
     end subroutine stdlib_ctplqt


     pure subroutine stdlib_ctpmlqt( side, trans, m, n, k, l, mb, v, ldv, t, ldt,a, lda, b, ldb, &
     !! CTPMLQT applies a complex unitary matrix Q obtained from a
     !! "triangular-pentagonal" complex block reflector H to a general
     !! complex matrix C, which consists of two blocks A and B.
               work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, ldv, lda, ldb, m, n, l, mb, ldt
           ! Array Arguments 
           complex(sp), intent(in) :: v(ldv,*), t(ldt,*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, right, tran, notran
           integer(ilp) :: i, ib, nb, lb, kf, ldaq
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! Test The Input Arguments 
           info   = 0
           left   = stdlib_lsame( side,  'L' )
           right  = stdlib_lsame( side,  'R' )
           tran   = stdlib_lsame( trans, 'C' )
           notran = stdlib_lsame( trans, 'N' )
           if ( left ) then
              ldaq = max( 1, k )
           else if ( right ) then
              ldaq = max( 1, m )
           end if
           if( .not.left .and. .not.right ) then
              info = -1
           else if( .not.tran .and. .not.notran ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 ) then
              info = -5
           else if( l<0 .or. l>k ) then
              info = -6
           else if( mb<1 .or. (mb>k .and. k>0) ) then
              info = -7
           else if( ldv<k ) then
              info = -9
           else if( ldt<mb ) then
              info = -11
           else if( lda<ldaq ) then
              info = -13
           else if( ldb<max( 1, m ) ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTPMLQT', -info )
              return
           end if
           ! Quick Return If Possible 
           if( m==0 .or. n==0 .or. k==0 ) return
           if( left .and. notran ) then
              do i = 1, k, mb
                 ib = min( mb, k-i+1 )
                 nb = min( m-l+i+ib-1, m )
                 if( i>=l ) then
                    lb = 0
                 else
                    lb = 0
                 end if
                 call stdlib_ctprfb( 'L', 'C', 'F', 'R', nb, n, ib, lb,v( i, 1 ), ldv, t( 1, i ), &
                           ldt,a( i, 1 ), lda, b, ldb, work, ib )
              end do
           else if( right .and. tran ) then
              do i = 1, k, mb
                 ib = min( mb, k-i+1 )
                 nb = min( n-l+i+ib-1, n )
                 if( i>=l ) then
                    lb = 0
                 else
                    lb = nb-n+l-i+1
                 end if
                 call stdlib_ctprfb( 'R', 'N', 'F', 'R', m, nb, ib, lb,v( i, 1 ), ldv, t( 1, i ), &
                           ldt,a( 1, i ), lda, b, ldb, work, m )
              end do
           else if( left .and. tran ) then
              kf = ((k-1)/mb)*mb+1
              do i = kf, 1, -mb
                 ib = min( mb, k-i+1 )
                 nb = min( m-l+i+ib-1, m )
                 if( i>=l ) then
                    lb = 0
                 else
                    lb = 0
                 end if
                 call stdlib_ctprfb( 'L', 'N', 'F', 'R', nb, n, ib, lb,v( i, 1 ), ldv, t( 1, i ), &
                           ldt,a( i, 1 ), lda, b, ldb, work, ib )
              end do
           else if( right .and. notran ) then
              kf = ((k-1)/mb)*mb+1
              do i = kf, 1, -mb
                 ib = min( mb, k-i+1 )
                 nb = min( n-l+i+ib-1, n )
                 if( i>=l ) then
                    lb = 0
                 else
                    lb = nb-n+l-i+1
                 end if
                 call stdlib_ctprfb( 'R', 'C', 'F', 'R', m, nb, ib, lb,v( i, 1 ), ldv, t( 1, i ), &
                           ldt,a( 1, i ), lda, b, ldb, work, m )
              end do
           end if
           return
     end subroutine stdlib_ctpmlqt


     pure subroutine stdlib_ctpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,a, lda, b, ldb, &
     !! CTPMQRT applies a complex orthogonal matrix Q obtained from a
     !! "triangular-pentagonal" complex block reflector H to a general
     !! complex matrix C, which consists of two blocks A and B.
               work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, ldv, lda, ldb, m, n, l, nb, ldt
           ! Array Arguments 
           complex(sp), intent(in) :: v(ldv,*), t(ldt,*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, right, tran, notran
           integer(ilp) :: i, ib, mb, lb, kf, ldaq, ldvq
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! Test The Input Arguments 
           info   = 0
           left   = stdlib_lsame( side,  'L' )
           right  = stdlib_lsame( side,  'R' )
           tran   = stdlib_lsame( trans, 'C' )
           notran = stdlib_lsame( trans, 'N' )
           if ( left ) then
              ldvq = max( 1, m )
              ldaq = max( 1, k )
           else if ( right ) then
              ldvq = max( 1, n )
              ldaq = max( 1, m )
           end if
           if( .not.left .and. .not.right ) then
              info = -1
           else if( .not.tran .and. .not.notran ) then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( k<0 ) then
              info = -5
           else if( l<0 .or. l>k ) then
              info = -6
           else if( nb<1 .or. (nb>k .and. k>0) ) then
              info = -7
           else if( ldv<ldvq ) then
              info = -9
           else if( ldt<nb ) then
              info = -11
           else if( lda<ldaq ) then
              info = -13
           else if( ldb<max( 1, m ) ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTPMQRT', -info )
              return
           end if
           ! Quick Return If Possible 
           if( m==0 .or. n==0 .or. k==0 ) return
           if( left .and. tran ) then
              do i = 1, k, nb
                 ib = min( nb, k-i+1 )
                 mb = min( m-l+i+ib-1, m )
                 if( i>=l ) then
                    lb = 0
                 else
                    lb = mb-m+l-i+1
                 end if
                 call stdlib_ctprfb( 'L', 'C', 'F', 'C', mb, n, ib, lb,v( 1, i ), ldv, t( 1, i ), &
                           ldt,a( i, 1 ), lda, b, ldb, work, ib )
              end do
           else if( right .and. notran ) then
              do i = 1, k, nb
                 ib = min( nb, k-i+1 )
                 mb = min( n-l+i+ib-1, n )
                 if( i>=l ) then
                    lb = 0
                 else
                    lb = mb-n+l-i+1
                 end if
                 call stdlib_ctprfb( 'R', 'N', 'F', 'C', m, mb, ib, lb,v( 1, i ), ldv, t( 1, i ), &
                           ldt,a( 1, i ), lda, b, ldb, work, m )
              end do
           else if( left .and. notran ) then
              kf = ((k-1)/nb)*nb+1
              do i = kf, 1, -nb
                 ib = min( nb, k-i+1 )
                 mb = min( m-l+i+ib-1, m )
                 if( i>=l ) then
                    lb = 0
                 else
                    lb = mb-m+l-i+1
                 end if
                 call stdlib_ctprfb( 'L', 'N', 'F', 'C', mb, n, ib, lb,v( 1, i ), ldv, t( 1, i ), &
                           ldt,a( i, 1 ), lda, b, ldb, work, ib )
              end do
           else if( right .and. tran ) then
              kf = ((k-1)/nb)*nb+1
              do i = kf, 1, -nb
                 ib = min( nb, k-i+1 )
                 mb = min( n-l+i+ib-1, n )
                 if( i>=l ) then
                    lb = 0
                 else
                    lb = mb-n+l-i+1
                 end if
                 call stdlib_ctprfb( 'R', 'C', 'F', 'C', m, mb, ib, lb,v( 1, i ), ldv, t( 1, i ), &
                           ldt,a( 1, i ), lda, b, ldb, work, m )
              end do
           end if
           return
     end subroutine stdlib_ctpmqrt


     pure subroutine stdlib_ctpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,info )
     !! CTPQRT computes a blocked QR factorization of a complex
     !! "triangular-pentagonal" matrix C, which is composed of a
     !! triangular block A and pentagonal block B, using the compact
     !! WY representation for Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldt, n, m, l, nb
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: t(ldt,*), work(*)
       ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ib, lb, mb, iinfo
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( l<0 .or. (l>min(m,n) .and. min(m,n)>=0)) then
              info = -3
           else if( nb<1 .or. (nb>n .and. n>0)) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, m ) ) then
              info = -8
           else if( ldt<nb ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTPQRT', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) return
           do i = 1, n, nb
           ! compute the qr factorization of the current block
              ib = min( n-i+1, nb )
              mb = min( m-l+i+ib-1, m )
              if( i>=l ) then
                 lb = 0
              else
                 lb = mb-m+l-i+1
              end if
              call stdlib_ctpqrt2( mb, ib, lb, a(i,i), lda, b( 1, i ), ldb,t(1, i ), ldt, iinfo )
                        
           ! update by applying h**h to b(:,i+ib:n) from the left
              if( i+ib<=n ) then
                 call stdlib_ctprfb( 'L', 'C', 'F', 'C', mb, n-i-ib+1, ib, lb,b( 1, i ), ldb, t( &
                           1, i ), ldt,a( i, i+ib ), lda, b( 1, i+ib ), ldb,work, ib )
              end if
           end do
           return
     end subroutine stdlib_ctpqrt


     subroutine stdlib_ctrcon( norm, uplo, diag, n, a, lda, rcond, work,rwork, info )
     !! CTRCON estimates the reciprocal of the condition number of a
     !! triangular matrix A, in either the 1-norm or the infinity-norm.
     !! The norm of A is computed and an estimate is obtained for
     !! norm(inv(A)), then the reciprocal of the condition number is
     !! computed as
     !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: diag, norm, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nounit, onenrm, upper
           character :: normin
           integer(ilp) :: ix, kase, kase1
           real(sp) :: ainvnm, anorm, scale, smlnum, xnorm
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           onenrm = norm=='1' .or. stdlib_lsame( norm, 'O' )
           nounit = stdlib_lsame( diag, 'N' )
           if( .not.onenrm .and. .not.stdlib_lsame( norm, 'I' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.nounit .and. .not.stdlib_lsame( diag, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTRCON', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              rcond = one
              return
           end if
           rcond = zero
           smlnum = stdlib_slamch( 'SAFE MINIMUM' )*real( max( 1, n ),KIND=sp)
           ! compute the norm of the triangular matrix a.
           anorm = stdlib_clantr( norm, uplo, diag, n, n, a, lda, rwork )
           ! continue only if anorm > 0.
           if( anorm>zero ) then
              ! estimate the norm of the inverse of a.
              ainvnm = zero
              normin = 'N'
              if( onenrm ) then
                 kase1 = 1
              else
                 kase1 = 2
              end if
              kase = 0
              10 continue
              call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
              if( kase/=0 ) then
                 if( kase==kase1 ) then
                    ! multiply by inv(a).
                    call stdlib_clatrs( uplo, 'NO TRANSPOSE', diag, normin, n, a,lda, work, scale,&
                               rwork, info )
                 else
                    ! multiply by inv(a**h).
                    call stdlib_clatrs( uplo, 'CONJUGATE TRANSPOSE', diag, normin,n, a, lda, work,&
                               scale, rwork, info )
                 end if
                 normin = 'Y'
                 ! multiply by 1/scale if doing so will not cause overflow.
                 if( scale/=one ) then
                    ix = stdlib_icamax( n, work, 1 )
                    xnorm = cabs1( work( ix ) )
                    if( scale<xnorm*smlnum .or. scale==zero )go to 20
                    call stdlib_csrscl( n, scale, work, 1 )
                 end if
                 go to 10
              end if
              ! compute the estimate of the reciprocal condition number.
              if( ainvnm/=zero )rcond = ( one / anorm ) / ainvnm
           end if
           20 continue
           return
     end subroutine stdlib_ctrcon


     subroutine stdlib_ctrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
     !! CTRSYL solves the complex Sylvester matrix equation:
     !! op(A)*X + X*op(B) = scale*C or
     !! op(A)*X - X*op(B) = scale*C,
     !! where op(A) = A or A**H, and A and B are both upper triangular. A is
     !! M-by-M and B is N-by-N; the right hand side C and the solution X are
     !! M-by-N; and scale is an output scale factor, set <= 1 to avoid
     !! overflow in X.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trana, tranb
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: isgn, lda, ldb, ldc, m, n
           real(sp), intent(out) :: scale
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), b(ldb,*)
           complex(sp), intent(inout) :: c(ldc,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notrna, notrnb
           integer(ilp) :: j, k, l
           real(sp) :: bignum, da11, db, eps, scaloc, sgn, smin, smlnum
           complex(sp) :: a11, suml, sumr, vec, x11
           ! Local Arrays 
           real(sp) :: dum(1)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,conjg,max,min,real
           ! Executable Statements 
           ! decode and test input parameters
           notrna = stdlib_lsame( trana, 'N' )
           notrnb = stdlib_lsame( tranb, 'N' )
           info = 0
           if( .not.notrna .and. .not.stdlib_lsame( trana, 'C' ) ) then
              info = -1
           else if( .not.notrnb .and. .not.stdlib_lsame( tranb, 'C' ) ) then
              info = -2
           else if( isgn/=1 .and. isgn/=-1 ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, m ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldc<max( 1, m ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTRSYL', -info )
              return
           end if
           ! quick return if possible
           scale = one
           if( m==0 .or. n==0 )return
           ! set constants to control overflow
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = smlnum*real( m*n,KIND=sp) / eps
           bignum = one / smlnum
           smin = max( smlnum, eps*stdlib_clange( 'M', m, m, a, lda, dum ),eps*stdlib_clange( 'M',&
                      n, n, b, ldb, dum ) )
           sgn = isgn
           if( notrna .and. notrnb ) then
              ! solve    a*x + isgn*x*b = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! bottom-left corner column by column by
                  ! a(k,k)*x(k,l) + isgn*x(k,l)*b(l,l) = c(k,l) - r(k,l)
              ! where
                          ! m                        l-1
                ! r(k,l) = sum [a(k,i)*x(i,l)] +isgn*sum [x(k,j)*b(j,l)].
                        ! i=k+1                      j=1
              loop_30: do l = 1, n
                 do k = m, 1, -1
                    suml = stdlib_cdotu( m-k, a( k, min( k+1, m ) ), lda,c( min( k+1, m ), l ), 1 &
                              )
                    sumr = stdlib_cdotu( l-1, c( k, 1 ), ldc, b( 1, l ), 1 )
                    vec = c( k, l ) - ( suml+sgn*sumr )
                    scaloc = one
                    a11 = a( k, k ) + sgn*b( l, l )
                    da11 = abs( real( a11,KIND=sp) ) + abs( aimag( a11 ) )
                    if( da11<=smin ) then
                       a11 = smin
                       da11 = smin
                       info = 1
                    end if
                    db = abs( real( vec,KIND=sp) ) + abs( aimag( vec ) )
                    if( da11<one .and. db>one ) then
                       if( db>bignum*da11 )scaloc = one / db
                    end if
                    x11 = stdlib_cladiv( vec*cmplx( scaloc,KIND=sp), a11 )
                    if( scaloc/=one ) then
                       do j = 1, n
                          call stdlib_csscal( m, scaloc, c( 1, j ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    c( k, l ) = x11
                 end do
              end do loop_30
           else if( .not.notrna .and. notrnb ) then
              ! solve    a**h *x + isgn*x*b = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! upper-left corner column by column by
                  ! a**h(k,k)*x(k,l) + isgn*x(k,l)*b(l,l) = c(k,l) - r(k,l)
              ! where
                         ! k-1                           l-1
                ! r(k,l) = sum [a**h(i,k)*x(i,l)] + isgn*sum [x(k,j)*b(j,l)]
                         ! i=1                           j=1
              loop_60: do l = 1, n
                 do k = 1, m
                    suml = stdlib_cdotc( k-1, a( 1, k ), 1, c( 1, l ), 1 )
                    sumr = stdlib_cdotu( l-1, c( k, 1 ), ldc, b( 1, l ), 1 )
                    vec = c( k, l ) - ( suml+sgn*sumr )
                    scaloc = one
                    a11 = conjg( a( k, k ) ) + sgn*b( l, l )
                    da11 = abs( real( a11,KIND=sp) ) + abs( aimag( a11 ) )
                    if( da11<=smin ) then
                       a11 = smin
                       da11 = smin
                       info = 1
                    end if
                    db = abs( real( vec,KIND=sp) ) + abs( aimag( vec ) )
                    if( da11<one .and. db>one ) then
                       if( db>bignum*da11 )scaloc = one / db
                    end if
                    x11 = stdlib_cladiv( vec*cmplx( scaloc,KIND=sp), a11 )
                    if( scaloc/=one ) then
                       do j = 1, n
                          call stdlib_csscal( m, scaloc, c( 1, j ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    c( k, l ) = x11
                 end do
              end do loop_60
           else if( .not.notrna .and. .not.notrnb ) then
              ! solve    a**h*x + isgn*x*b**h = c.
              ! the (k,l)th block of x is determined starting from
              ! upper-right corner column by column by
                  ! a**h(k,k)*x(k,l) + isgn*x(k,l)*b**h(l,l) = c(k,l) - r(k,l)
              ! where
                          ! k-1
                 ! r(k,l) = sum [a**h(i,k)*x(i,l)] +
                          ! i=1
                                 ! n
                           ! isgn*sum [x(k,j)*b**h(l,j)].
                                ! j=l+1
              loop_90: do l = n, 1, -1
                 do k = 1, m
                    suml = stdlib_cdotc( k-1, a( 1, k ), 1, c( 1, l ), 1 )
                    sumr = stdlib_cdotc( n-l, c( k, min( l+1, n ) ), ldc,b( l, min( l+1, n ) ), &
                              ldb )
                    vec = c( k, l ) - ( suml+sgn*conjg( sumr ) )
                    scaloc = one
                    a11 = conjg( a( k, k )+sgn*b( l, l ) )
                    da11 = abs( real( a11,KIND=sp) ) + abs( aimag( a11 ) )
                    if( da11<=smin ) then
                       a11 = smin
                       da11 = smin
                       info = 1
                    end if
                    db = abs( real( vec,KIND=sp) ) + abs( aimag( vec ) )
                    if( da11<one .and. db>one ) then
                       if( db>bignum*da11 )scaloc = one / db
                    end if
                    x11 = stdlib_cladiv( vec*cmplx( scaloc,KIND=sp), a11 )
                    if( scaloc/=one ) then
                       do j = 1, n
                          call stdlib_csscal( m, scaloc, c( 1, j ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    c( k, l ) = x11
                 end do
              end do loop_90
           else if( notrna .and. .not.notrnb ) then
              ! solve    a*x + isgn*x*b**h = c.
              ! the (k,l)th block of x is determined starting from
              ! bottom-left corner column by column by
                 ! a(k,k)*x(k,l) + isgn*x(k,l)*b**h(l,l) = c(k,l) - r(k,l)
              ! where
                          ! m                          n
                ! r(k,l) = sum [a(k,i)*x(i,l)] + isgn*sum [x(k,j)*b**h(l,j)]
                        ! i=k+1                      j=l+1
              loop_120: do l = n, 1, -1
                 do k = m, 1, -1
                    suml = stdlib_cdotu( m-k, a( k, min( k+1, m ) ), lda,c( min( k+1, m ), l ), 1 &
                              )
                    sumr = stdlib_cdotc( n-l, c( k, min( l+1, n ) ), ldc,b( l, min( l+1, n ) ), &
                              ldb )
                    vec = c( k, l ) - ( suml+sgn*conjg( sumr ) )
                    scaloc = one
                    a11 = a( k, k ) + sgn*conjg( b( l, l ) )
                    da11 = abs( real( a11,KIND=sp) ) + abs( aimag( a11 ) )
                    if( da11<=smin ) then
                       a11 = smin
                       da11 = smin
                       info = 1
                    end if
                    db = abs( real( vec,KIND=sp) ) + abs( aimag( vec ) )
                    if( da11<one .and. db>one ) then
                       if( db>bignum*da11 )scaloc = one / db
                    end if
                    x11 = stdlib_cladiv( vec*cmplx( scaloc,KIND=sp), a11 )
                    if( scaloc/=one ) then
                       do j = 1, n
                          call stdlib_csscal( m, scaloc, c( 1, j ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    c( k, l ) = x11
                 end do
              end do loop_120
           end if
           return
     end subroutine stdlib_ctrsyl


     pure subroutine stdlib_cunbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
     !! CUNBDB5 orthogonalizes the column vector
     !! X = [ X1 ]
     !! [ X2 ]
     !! with respect to the columns of
     !! Q = [ Q1 ] .
     !! [ Q2 ]
     !! The columns of Q must be orthonormal.
     !! If the projection is zero according to Kahan's "twice is enough"
     !! criterion, then some other vector from the orthogonal complement
     !! is returned. This vector is chosen in an arbitrary but deterministic
     !! way.
               lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x1(*), x2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: childinfo, i, j
           ! Intrinsic Function 
           intrinsic :: max
           ! Executable Statements 
           ! test input arguments
           info = 0
           if( m1 < 0 ) then
              info = -1
           else if( m2 < 0 ) then
              info = -2
           else if( n < 0 ) then
              info = -3
           else if( incx1 < 1 ) then
              info = -5
           else if( incx2 < 1 ) then
              info = -7
           else if( ldq1 < max( 1, m1 ) ) then
              info = -9
           else if( ldq2 < max( 1, m2 ) ) then
              info = -11
           else if( lwork < n ) then
              info = -13
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'CUNBDB5', -info )
              return
           end if
           ! project x onto the orthogonal complement of q
           call stdlib_cunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2, ldq2,work, lwork, &
                     childinfo )
           ! if the projection is nonzero, then return
           if( stdlib_scnrm2(m1,x1,incx1) /= czero.or. stdlib_scnrm2(m2,x2,incx2) /= czero ) &
                     then
              return
           end if
           ! project each standard basis vector e_1,...,e_m1 in turn, stopping
           ! when a nonzero projection is found
           do i = 1, m1
              do j = 1, m1
                 x1(j) = czero
              end do
              x1(i) = cone
              do j = 1, m2
                 x2(j) = czero
              end do
              call stdlib_cunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                        lwork, childinfo )
              if( stdlib_scnrm2(m1,x1,incx1) /= czero.or. stdlib_scnrm2(m2,x2,incx2) /= czero ) &
                        then
                 return
              end if
           end do
           ! project each standard basis vector e_(m1+1),...,e_(m1+m2) in turn,
           ! stopping when a nonzero projection is found
           do i = 1, m2
              do j = 1, m1
                 x1(j) = czero
              end do
              do j = 1, m2
                 x2(j) = czero
              end do
              x2(i) = cone
              call stdlib_cunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                        lwork, childinfo )
              if( stdlib_scnrm2(m1,x1,incx1) /= czero.or. stdlib_scnrm2(m2,x2,incx2) /= czero ) &
                        then
                 return
              end if
           end do
           return
     end subroutine stdlib_cunbdb5


     recursive subroutine stdlib_cuncsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, x11, &
     !! CUNCSD computes the CS decomposition of an M-by-M partitioned
     !! unitary matrix X:
     !! [  I  0  0 |  0  0  0 ]
     !! [  0  C  0 |  0 -S  0 ]
     !! [ X11 | X12 ]   [ U1 |    ] [  0  0  0 |  0  0 -I ] [ V1 |    ]**H
     !! X = [-----------] = [---------] [---------------------] [---------]   .
     !! [ X21 | X22 ]   [    | U2 ] [  0  0  0 |  I  0  0 ] [    | V2 ]
     !! [  0  S  0 |  0  C  0 ]
     !! [  0  0  I |  0  0  0 ]
     !! X11 is P-by-Q. The unitary matrices U1, U2, V1, and V2 are P-by-P,
     !! (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
     !! R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
     !! which R = MIN(P,M-P,Q,M-Q).
     ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, ldv1t, v2t,ldv2t, &
               work, lwork, rwork, lrwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, signs, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, ldx11, ldx12, ldx21, ldx22, &
                     lrwork, lwork, m, p, q
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: theta(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(out) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*), work(*)
                     
           complex(sp), intent(inout) :: x11(ldx11,*), x12(ldx12,*), x21(ldx21,*), x22(ldx22,*)
                     
        ! ===================================================================
           
           ! Local Scalars 
           character :: transt, signst
           integer(ilp) :: childinfo, i, ib11d, ib11e, ib12d, ib12e, ib21d, ib21e, ib22d, ib22e, &
           ibbcsd, iorbdb, iorglq, iorgqr, iphi, itaup1, itaup2, itauq1, itauq2, j, lbbcsdwork, &
           lbbcsdworkmin, lbbcsdworkopt, lorbdbwork, lorbdbworkmin, lorbdbworkopt, lorglqwork, &
           lorglqworkmin, lorglqworkopt, lorgqrwork, lorgqrworkmin, lorgqrworkopt, lworkmin, &
                     lworkopt, p1, q1
           logical(lk) :: colmajor, defaultsigns, lquery, wantu1, wantu2, wantv1t, wantv2t
           integer(ilp) :: lrworkmin, lrworkopt
           logical(lk) :: lrquery
           ! Intrinsic Functions
           intrinsic :: int,max,min
           ! Executable Statements 
           ! test input arguments
           info = 0
           wantu1 = stdlib_lsame( jobu1, 'Y' )
           wantu2 = stdlib_lsame( jobu2, 'Y' )
           wantv1t = stdlib_lsame( jobv1t, 'Y' )
           wantv2t = stdlib_lsame( jobv2t, 'Y' )
           colmajor = .not. stdlib_lsame( trans, 'T' )
           defaultsigns = .not. stdlib_lsame( signs, 'O' )
           lquery = lwork == -1
           lrquery = lrwork == -1
           if( m < 0 ) then
              info = -7
           else if( p < 0 .or. p > m ) then
              info = -8
           else if( q < 0 .or. q > m ) then
              info = -9
           else if ( colmajor .and.  ldx11 < max( 1, p ) ) then
             info = -11
           else if (.not. colmajor .and. ldx11 < max( 1, q ) ) then
             info = -11
           else if (colmajor .and. ldx12 < max( 1, p ) ) then
             info = -13
           else if (.not. colmajor .and. ldx12 < max( 1, m-q ) ) then
             info = -13
           else if (colmajor .and. ldx21 < max( 1, m-p ) ) then
             info = -15
           else if (.not. colmajor .and. ldx21 < max( 1, q ) ) then
             info = -15
           else if (colmajor .and. ldx22 < max( 1, m-p ) ) then
             info = -17
           else if (.not. colmajor .and. ldx22 < max( 1, m-q ) ) then
             info = -17
           else if( wantu1 .and. ldu1 < p ) then
              info = -20
           else if( wantu2 .and. ldu2 < m-p ) then
              info = -22
           else if( wantv1t .and. ldv1t < q ) then
              info = -24
           else if( wantv2t .and. ldv2t < m-q ) then
              info = -26
           end if
           ! work with transpose if convenient
           if( info == 0 .and. min( p, m-p ) < min( q, m-q ) ) then
              if( colmajor ) then
                 transt = 'T'
              else
                 transt = 'N'
              end if
              if( defaultsigns ) then
                 signst = 'O'
              else
                 signst = 'D'
              end if
              call stdlib_cuncsd( jobv1t, jobv2t, jobu1, jobu2, transt, signst, m,q, p, x11, &
              ldx11, x21, ldx21, x12, ldx12, x22,ldx22, theta, v1t, ldv1t, v2t, ldv2t, u1, ldu1,&
                        u2, ldu2, work, lwork, rwork, lrwork, iwork,info )
              return
           end if
           ! work with permutation [ 0 i; i 0 ] * x * [ 0 i; i 0 ] if
           ! convenient
           if( info == 0 .and. m-q < q ) then
              if( defaultsigns ) then
                 signst = 'O'
              else
                 signst = 'D'
              end if
              call stdlib_cuncsd( jobu2, jobu1, jobv2t, jobv1t, trans, signst, m,m-p, m-q, x22, &
              ldx22, x21, ldx21, x12, ldx12, x11,ldx11, theta, u2, ldu2, u1, ldu1, v2t, ldv2t, &
                        v1t,ldv1t, work, lwork, rwork, lrwork, iwork, info )
              return
           end if
           ! compute workspace
           if( info == 0 ) then
              ! real workspace
              iphi = 2
              ib11d = iphi + max( 1, q - 1 )
              ib11e = ib11d + max( 1, q )
              ib12d = ib11e + max( 1, q - 1 )
              ib12e = ib12d + max( 1, q )
              ib21d = ib12e + max( 1, q - 1 )
              ib21e = ib21d + max( 1, q )
              ib22d = ib21e + max( 1, q - 1 )
              ib22e = ib22d + max( 1, q )
              ibbcsd = ib22e + max( 1, q - 1 )
              call stdlib_cbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, theta, u1, &
              ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, theta, theta, theta, theta, theta,theta, &
                        theta, theta, rwork, -1, childinfo )
              lbbcsdworkopt = int( rwork(1),KIND=ilp)
              lbbcsdworkmin = lbbcsdworkopt
              lrworkopt = ibbcsd + lbbcsdworkopt - 1
              lrworkmin = ibbcsd + lbbcsdworkmin - 1
              rwork(1) = lrworkopt
              ! complex workspace
              itaup1 = 2
              itaup2 = itaup1 + max( 1, p )
              itauq1 = itaup2 + max( 1, m - p )
              itauq2 = itauq1 + max( 1, q )
              iorgqr = itauq2 + max( 1, m - q )
              call stdlib_cungqr( m-q, m-q, m-q, u1, max(1,m-q), u1, work, -1,childinfo )
              lorgqrworkopt = int( work(1),KIND=ilp)
              lorgqrworkmin = max( 1, m - q )
              iorglq = itauq2 + max( 1, m - q )
              call stdlib_cunglq( m-q, m-q, m-q, u1, max(1,m-q), u1, work, -1,childinfo )
              lorglqworkopt = int( work(1),KIND=ilp)
              lorglqworkmin = max( 1, m - q )
              iorbdb = itauq2 + max( 1, m - q )
              call stdlib_cunbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
                        ldx22, theta, theta, u1, u2,v1t, v2t, work, -1, childinfo )
              lorbdbworkopt = int( work(1),KIND=ilp)
              lorbdbworkmin = lorbdbworkopt
              lworkopt = max( iorgqr + lorgqrworkopt, iorglq + lorglqworkopt,iorbdb + &
                        lorbdbworkopt ) - 1
              lworkmin = max( iorgqr + lorgqrworkmin, iorglq + lorglqworkmin,iorbdb + &
                        lorbdbworkmin ) - 1
              work(1) = max(lworkopt,lworkmin)
              if( lwork < lworkmin.and. .not. ( lquery .or. lrquery ) ) then
                 info = -22
              else if( lrwork < lrworkmin.and. .not. ( lquery .or. lrquery ) ) then
                 info = -24
              else
                 lorgqrwork = lwork - iorgqr + 1
                 lorglqwork = lwork - iorglq + 1
                 lorbdbwork = lwork - iorbdb + 1
                 lbbcsdwork = lrwork - ibbcsd + 1
              end if
           end if
           ! abort if any illegal arguments
           if( info /= 0 ) then
              call stdlib_xerbla( 'CUNCSD', -info )
              return
           else if( lquery .or. lrquery ) then
              return
           end if
           ! transform to bidiagonal block form
           call stdlib_cunbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21,ldx21, x22, &
           ldx22, theta, rwork(iphi), work(itaup1),work(itaup2), work(itauq1), work(itauq2),work(&
                     iorbdb), lorbdbwork, childinfo )
           ! accumulate householder reflectors
           if( colmajor ) then
              if( wantu1 .and. p > 0 ) then
                 call stdlib_clacpy( 'L', p, q, x11, ldx11, u1, ldu1 )
                 call stdlib_cungqr( p, p, q, u1, ldu1, work(itaup1), work(iorgqr),lorgqrwork, &
                           info)
              end if
              if( wantu2 .and. m-p > 0 ) then
                 call stdlib_clacpy( 'L', m-p, q, x21, ldx21, u2, ldu2 )
                 call stdlib_cungqr( m-p, m-p, q, u2, ldu2, work(itaup2),work(iorgqr), lorgqrwork,&
                            info )
              end if
              if( wantv1t .and. q > 0 ) then
                 call stdlib_clacpy( 'U', q-1, q-1, x11(1,2), ldx11, v1t(2,2),ldv1t )
                 v1t(1, 1) = cone
                 do j = 2, q
                    v1t(1,j) = czero
                    v1t(j,1) = czero
                 end do
                 call stdlib_cunglq( q-1, q-1, q-1, v1t(2,2), ldv1t, work(itauq1),work(iorglq), &
                           lorglqwork, info )
              end if
              if( wantv2t .and. m-q > 0 ) then
                 call stdlib_clacpy( 'U', p, m-q, x12, ldx12, v2t, ldv2t )
                 if( m-p > q ) then
                    call stdlib_clacpy( 'U', m-p-q, m-p-q, x22(q+1,p+1), ldx22,v2t(p+1,p+1), &
                              ldv2t )
                 end if
                 if( m > q ) then
                    call stdlib_cunglq( m-q, m-q, m-q, v2t, ldv2t, work(itauq2),work(iorglq), &
                              lorglqwork, info )
                 end if
              end if
           else
              if( wantu1 .and. p > 0 ) then
                 call stdlib_clacpy( 'U', q, p, x11, ldx11, u1, ldu1 )
                 call stdlib_cunglq( p, p, q, u1, ldu1, work(itaup1), work(iorglq),lorglqwork, &
                           info)
              end if
              if( wantu2 .and. m-p > 0 ) then
                 call stdlib_clacpy( 'U', q, m-p, x21, ldx21, u2, ldu2 )
                 call stdlib_cunglq( m-p, m-p, q, u2, ldu2, work(itaup2),work(iorglq), lorglqwork,&
                            info )
              end if
              if( wantv1t .and. q > 0 ) then
                 call stdlib_clacpy( 'L', q-1, q-1, x11(2,1), ldx11, v1t(2,2),ldv1t )
                 v1t(1, 1) = cone
                 do j = 2, q
                    v1t(1,j) = czero
                    v1t(j,1) = czero
                 end do
                 call stdlib_cungqr( q-1, q-1, q-1, v1t(2,2), ldv1t, work(itauq1),work(iorgqr), &
                           lorgqrwork, info )
              end if
              if( wantv2t .and. m-q > 0 ) then
                 p1 = min( p+1, m )
                 q1 = min( q+1, m )
                 call stdlib_clacpy( 'L', m-q, p, x12, ldx12, v2t, ldv2t )
                 if ( m > p+q ) then
                    call stdlib_clacpy( 'L', m-p-q, m-p-q, x22(p1,q1), ldx22,v2t(p+1,p+1), ldv2t )
                              
                 end if
                 call stdlib_cungqr( m-q, m-q, m-q, v2t, ldv2t, work(itauq2),work(iorgqr), &
                           lorgqrwork, info )
              end if
           end if
           ! compute the csd of the matrix in bidiagonal-block form
           call stdlib_cbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta,rwork(iphi), &
           u1, ldu1, u2, ldu2, v1t, ldv1t, v2t,ldv2t, rwork(ib11d), rwork(ib11e), rwork(ib12d),&
           rwork(ib12e), rwork(ib21d), rwork(ib21e),rwork(ib22d), rwork(ib22e), rwork(ibbcsd),&
                     lbbcsdwork, info )
           ! permute rows and columns to place identity submatrices in top-
           ! left corner of (1,1)-block and/or bottom-right corner of (1,2)-
           ! block and/or bottom-right corner of (2,1)-block and/or top-left
           ! corner of (2,2)-block
           if( q > 0 .and. wantu2 ) then
              do i = 1, q
                 iwork(i) = m - p - q + i
              end do
              do i = q + 1, m - p
                 iwork(i) = i - q
              end do
              if( colmajor ) then
                 call stdlib_clapmt( .false., m-p, m-p, u2, ldu2, iwork )
              else
                 call stdlib_clapmr( .false., m-p, m-p, u2, ldu2, iwork )
              end if
           end if
           if( m > 0 .and. wantv2t ) then
              do i = 1, p
                 iwork(i) = m - p - q + i
              end do
              do i = p + 1, m - q
                 iwork(i) = i - p
              end do
              if( .not. colmajor ) then
                 call stdlib_clapmt( .false., m-q, m-q, v2t, ldv2t, iwork )
              else
                 call stdlib_clapmr( .false., m-q, m-q, v2t, ldv2t, iwork )
              end if
           end if
           return
           ! end stdlib_cuncsd
     end subroutine stdlib_cuncsd


     pure subroutine stdlib_cunghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! CUNGHR generates a complex unitary matrix Q which is defined as the
     !! product of IHI-ILO elementary reflectors of order N, as returned by
     !! CGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, lwkopt, nb, nh
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, nh ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'CUNGQR', ' ', nh, nh, nh, -1 )
              lwkopt = max( 1, nh )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNGHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           ! shift the vectors which define the elementary reflectors cone
           ! column to the right, and set the first ilo and the last n-ihi
           ! rows and columns to those of the unit matrix
           do j = ihi, ilo + 1, -1
              do i = 1, j - 1
                 a( i, j ) = czero
              end do
              do i = j + 1, ihi
                 a( i, j ) = a( i, j-1 )
              end do
              do i = ihi + 1, n
                 a( i, j ) = czero
              end do
           end do
           do j = 1, ilo
              do i = 1, n
                 a( i, j ) = czero
              end do
              a( j, j ) = cone
           end do
           do j = ihi + 1, n
              do i = 1, n
                 a( i, j ) = czero
              end do
              a( j, j ) = cone
           end do
           if( nh>0 ) then
              ! generate q(ilo+1:ihi,ilo+1:ihi)
              call stdlib_cungqr( nh, nh, nh, a( ilo+1, ilo+1 ), lda, tau( ilo ),work, lwork, &
                        iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cunghr


     pure subroutine stdlib_cungtr( uplo, n, a, lda, tau, work, lwork, info )
     !! CUNGTR generates a complex unitary matrix Q which is defined as the
     !! product of n-1 elementary reflectors of order N, as returned by
     !! CHETRD:
     !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, j, lwkopt, nb
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, n-1 ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              if ( upper ) then
                nb = stdlib_ilaenv( 1, 'CUNGQL', ' ', n-1, n-1, n-1, -1 )
              else
                nb = stdlib_ilaenv( 1, 'CUNGQR', ' ', n-1, n-1, n-1, -1 )
              end if
              lwkopt = max( 1, n-1 )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNGTR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           if( upper ) then
              ! q was determined by a call to stdlib_chetrd with uplo = 'u'
              ! shift the vectors which define the elementary reflectors cone
              ! column to the left, and set the last row and column of q to
              ! those of the unit matrix
              do j = 1, n - 1
                 do i = 1, j - 1
                    a( i, j ) = a( i, j+1 )
                 end do
                 a( n, j ) = czero
              end do
              do i = 1, n - 1
                 a( i, n ) = czero
              end do
              a( n, n ) = cone
              ! generate q(1:n-1,1:n-1)
              call stdlib_cungql( n-1, n-1, n-1, a, lda, tau, work, lwork, iinfo )
           else
              ! q was determined by a call to stdlib_chetrd with uplo = 'l'.
              ! shift the vectors which define the elementary reflectors cone
              ! column to the right, and set the first row and column of q to
              ! those of the unit matrix
              do j = n, 2, -1
                 a( 1, j ) = czero
                 do i = j + 1, n
                    a( i, j ) = a( i, j-1 )
                 end do
              end do
              a( 1, 1 ) = cone
              do i = 2, n
                 a( i, 1 ) = czero
              end do
              if( n>1 ) then
                 ! generate q(2:n,2:n)
                 call stdlib_cungqr( n-1, n-1, n-1, a( 2, 2 ), lda, tau, work,lwork, iinfo )
                           
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cungtr


     pure subroutine stdlib_cunhr_col( m, n, nb, a, lda, t, ldt, d, info )
     !! CUNHR_COL takes an M-by-N complex matrix Q_in with orthonormal columns
     !! as input, stored in A, and performs Householder Reconstruction (HR),
     !! i.e. reconstructs Householder vectors V(i) implicitly representing
     !! another M-by-N matrix Q_out, with the property that Q_in = Q_out*S,
     !! where S is an N-by-N diagonal matrix with diagonal entries
     !! equal to +1 or -1. The Householder vectors (columns V(i) of V) are
     !! stored in A on output, and the diagonal entries of S are stored in D.
     !! Block reflectors are also returned in T
     !! (same output format as CGEQRT).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldt, m, n, nb
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: d(*), t(ldt,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, iinfo, j, jb, jbtemp1, jbtemp2, jnb, nplusone
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 .or. n>m ) then
              info = -2
           else if( nb<1 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldt<max( 1, min( nb, n ) ) ) then
              info = -7
           end if
           ! handle error in the input parameters.
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNHR_COL', -info )
              return
           end if
           ! quick return if possible
           if( min( m, n )==0 ) then
              return
           end if
           ! on input, the m-by-n matrix a contains the unitary
           ! m-by-n matrix q_in.
           ! (1) compute the unit lower-trapezoidal v (ones on the diagonal
           ! are not stored) by performing the "modified" lu-decomposition.
           ! q_in - ( s ) = v * u = ( v1 ) * u,
                  ! ( 0 )           ( v2 )
           ! where 0 is an (m-n)-by-n zero matrix.
           ! (1-1) factor v1 and u.
           call stdlib_claunhr_col_getrfnp( n, n, a, lda, d, iinfo )
           ! (1-2) solve for v2.
           if( m>n ) then
              call stdlib_ctrsm( 'R', 'U', 'N', 'N', m-n, n, cone, a, lda,a( n+1, 1 ), lda )
                        
           end if
           ! (2) reconstruct the block reflector t stored in t(1:nb, 1:n)
           ! as a sequence of upper-triangular blocks with nb-size column
           ! blocking.
           ! loop over the column blocks of size nb of the array a(1:m,1:n)
           ! and the array t(1:nb,1:n), jb is the column index of a column
           ! block, jnb is the column block size at each step jb.
           nplusone = n + 1
           do jb = 1, n, nb
              ! (2-0) determine the column block size jnb.
              jnb = min( nplusone-jb, nb )
              ! (2-1) copy the upper-triangular part of the current jnb-by-jnb
              ! diagonal block u(jb) (of the n-by-n matrix u) stored
              ! in a(jb:jb+jnb-1,jb:jb+jnb-1) into the upper-triangular part
              ! of the current jnb-by-jnb block t(1:jnb,jb:jb+jnb-1)
              ! column-by-column, total jnb*(jnb+1)/2 elements.
              jbtemp1 = jb - 1
              do j = jb, jb+jnb-1
                 call stdlib_ccopy( j-jbtemp1, a( jb, j ), 1, t( 1, j ), 1 )
              end do
              ! (2-2) perform on the upper-triangular part of the current
              ! jnb-by-jnb diagonal block u(jb) (of the n-by-n matrix u) stored
              ! in t(1:jnb,jb:jb+jnb-1) the following operation in place:
              ! (-1)*u(jb)*s(jb), i.e the result will be stored in the upper-
              ! triangular part of t(1:jnb,jb:jb+jnb-1). this multiplication
              ! of the jnb-by-jnb diagonal block u(jb) by the jnb-by-jnb
              ! diagonal block s(jb) of the n-by-n sign matrix s from the
              ! right means changing the sign of each j-th column of the block
              ! u(jb) according to the sign of the diagonal element of the block
              ! s(jb), i.e. s(j,j) that is stored in the array element d(j).
              do j = jb, jb+jnb-1
                 if( d( j )==cone ) then
                    call stdlib_cscal( j-jbtemp1, -cone, t( 1, j ), 1 )
                 end if
              end do
              ! (2-3) perform the triangular solve for the current block
              ! matrix x(jb):
                     ! x(jb) * (a(jb)**t) = b(jb), where:
                     ! a(jb)**t  is a jnb-by-jnb unit upper-triangular
                               ! coefficient block, and a(jb)=v1(jb), which
                               ! is a jnb-by-jnb unit lower-triangular block
                               ! stored in a(jb:jb+jnb-1,jb:jb+jnb-1).
                               ! the n-by-n matrix v1 is the upper part
                               ! of the m-by-n lower-trapezoidal matrix v
                               ! stored in a(1:m,1:n);
                     ! b(jb)     is a jnb-by-jnb  upper-triangular right-hand
                               ! side block, b(jb) = (-1)*u(jb)*s(jb), and
                               ! b(jb) is stored in t(1:jnb,jb:jb+jnb-1);
                     ! x(jb)     is a jnb-by-jnb upper-triangular solution
                               ! block, x(jb) is the upper-triangular block
                               ! reflector t(jb), and x(jb) is stored
                               ! in t(1:jnb,jb:jb+jnb-1).
                   ! in other words, we perform the triangular solve for the
                   ! upper-triangular block t(jb):
                     ! t(jb) * (v1(jb)**t) = (-1)*u(jb)*s(jb).
                   ! even though the blocks x(jb) and b(jb) are upper-
                   ! triangular, the routine stdlib_ctrsm will access all jnb**2
                   ! elements of the square t(1:jnb,jb:jb+jnb-1). therefore,
                   ! we need to set to zero the elements of the block
                   ! t(1:jnb,jb:jb+jnb-1) below the diagonal before the call
                   ! to stdlib_ctrsm.
              ! (2-3a) set the elements to zero.
              jbtemp2 = jb - 2
              do j = jb, jb+jnb-2
                 do i = j-jbtemp2, nb
                    t( i, j ) = czero
                 end do
              end do
              ! (2-3b) perform the triangular solve.
              call stdlib_ctrsm( 'R', 'L', 'C', 'U', jnb, jnb, cone,a( jb, jb ), lda, t( 1, jb ), &
                        ldt )
           end do
           return
     end subroutine stdlib_cunhr_col


     pure subroutine stdlib_cunmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
     !! CUNMHR overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! IHI-ILO elementary reflectors, as returned by CGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           left = stdlib_lsame( side, 'L' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'C' ) )&
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 .or. ilo>max( 1, nq ) ) then
              info = -5
           else if( ihi<min( ilo, nq ) .or. ihi>nq ) then
              info = -6
           else if( lda<max( 1, nq ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              if( left ) then
                 nb = stdlib_ilaenv( 1, 'CUNMQR', side // trans, nh, n, nh, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'CUNMQR', side // trans, m, nh, nh, -1 )
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNMHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nh==0 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = nh
              ni = n
              i1 = ilo + 1
              i2 = 1
           else
              mi = m
              ni = nh
              i1 = 1
              i2 = ilo + 1
           end if
           call stdlib_cunmqr( side, trans, mi, ni, nh, a( ilo+1, ilo ), lda,tau( ilo ), c( i1, &
                     i2 ), ldc, work, lwork, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cunmhr


     pure subroutine stdlib_cunmtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
     !! CUNMTR overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! nq-1 elementary reflectors, as returned by CHETRD:
     !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldc, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery, upper
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, ni, nq, nw
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'C' ) )&
                     then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, nq ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              if( upper ) then
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'CUNMQL', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'CUNMQL', side // trans, m, n-1, n-1,-1 )
                 end if
              else
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'CUNMQR', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'CUNMQR', side // trans, m, n-1, n-1,-1 )
                 end if
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNMTR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nq==1 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = m - 1
              ni = n
           else
              mi = m
              ni = n - 1
           end if
           if( upper ) then
              ! q was determined by a call to stdlib_chetrd with uplo = 'u'
              call stdlib_cunmql( side, trans, mi, ni, nq-1, a( 1, 2 ), lda, tau, c,ldc, work, &
                        lwork, iinfo )
           else
              ! q was determined by a call to stdlib_chetrd with uplo = 'l'
              if( left ) then
                 i1 = 2
                 i2 = 1
              else
                 i1 = 1
                 i2 = 2
              end if
              call stdlib_cunmqr( side, trans, mi, ni, nq-1, a( 2, 1 ), lda, tau,c( i1, i2 ), ldc,&
                         work, lwork, iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cunmtr


     pure subroutine stdlib_cupgtr( uplo, n, ap, tau, q, ldq, work, info )
     !! CUPGTR generates a complex unitary matrix Q which is defined as the
     !! product of n-1 elementary reflectors H(i) of order n, as returned by
     !! CHPTRD using packed storage:
     !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldq, n
           ! Array Arguments 
           complex(sp), intent(in) :: ap(*), tau(*)
           complex(sp), intent(out) :: q(ldq,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, ij, j
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUPGTR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! q was determined by a call to stdlib_chptrd with uplo = 'u'
              ! unpack the vectors which define the elementary reflectors and
              ! set the last row and column of q equal to those of the unit
              ! matrix
              ij = 2
              do j = 1, n - 1
                 do i = 1, j - 1
                    q( i, j ) = ap( ij )
                    ij = ij + 1
                 end do
                 ij = ij + 2
                 q( n, j ) = czero
              end do
              do i = 1, n - 1
                 q( i, n ) = czero
              end do
              q( n, n ) = cone
              ! generate q(1:n-1,1:n-1)
              call stdlib_cung2l( n-1, n-1, n-1, q, ldq, tau, work, iinfo )
           else
              ! q was determined by a call to stdlib_chptrd with uplo = 'l'.
              ! unpack the vectors which define the elementary reflectors and
              ! set the first row and column of q equal to those of the unit
              ! matrix
              q( 1, 1 ) = cone
              do i = 2, n
                 q( i, 1 ) = czero
              end do
              ij = 3
              do j = 2, n
                 q( 1, j ) = czero
                 do i = j + 1, n
                    q( i, j ) = ap( ij )
                    ij = ij + 1
                 end do
                 ij = ij + 2
              end do
              if( n>1 ) then
                 ! generate q(2:n,2:n)
                 call stdlib_cung2r( n-1, n-1, n-1, q( 2, 2 ), ldq, tau, work,iinfo )
              end if
           end if
           return
     end subroutine stdlib_cupgtr


     pure subroutine stdlib_cupmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
     !! CUPMTR overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! nq-1 elementary reflectors, as returned by CHPTRD using packed
     !! storage:
     !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: ap(*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: forwrd, left, notran, upper
           integer(ilp) :: i, i1, i2, i3, ic, ii, jc, mi, ni, nq
           complex(sp) :: aii, taui
           ! Intrinsic Functions 
           intrinsic :: conjg,max
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           upper = stdlib_lsame( uplo, 'U' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( ldc<max( 1, m ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUPMTR', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           if( upper ) then
              ! q was determined by a call to stdlib_chptrd with uplo = 'u'
              forwrd = ( left .and. notran ) .or.( .not.left .and. .not.notran )
              if( forwrd ) then
                 i1 = 1
                 i2 = nq - 1
                 i3 = 1
                 ii = 2
              else
                 i1 = nq - 1
                 i2 = 1
                 i3 = -1
                 ii = nq*( nq+1 ) / 2 - 1
              end if
              if( left ) then
                 ni = n
              else
                 mi = m
              end if
              do i = i1, i2, i3
                 if( left ) then
                    ! h(i) or h(i)**h is applied to c(1:i,1:n)
                    mi = i
                 else
                    ! h(i) or h(i)**h is applied to c(1:m,1:i)
                    ni = i
                 end if
                 ! apply h(i) or h(i)**h
                 if( notran ) then
                    taui = tau( i )
                 else
                    taui = conjg( tau( i ) )
                 end if
                 aii = ap( ii )
                 ap( ii ) = cone
                 call stdlib_clarf( side, mi, ni, ap( ii-i+1 ), 1, taui, c, ldc,work )
                 ap( ii ) = aii
                 if( forwrd ) then
                    ii = ii + i + 2
                 else
                    ii = ii - i - 1
                 end if
              end do
           else
              ! q was determined by a call to stdlib_chptrd with uplo = 'l'.
              forwrd = ( left .and. .not.notran ) .or.( .not.left .and. notran )
              if( forwrd ) then
                 i1 = 1
                 i2 = nq - 1
                 i3 = 1
                 ii = 2
              else
                 i1 = nq - 1
                 i2 = 1
                 i3 = -1
                 ii = nq*( nq+1 ) / 2 - 1
              end if
              if( left ) then
                 ni = n
                 jc = 1
              else
                 mi = m
                 ic = 1
              end if
              loop_20: do i = i1, i2, i3
                 aii = ap( ii )
                 ap( ii ) = cone
                 if( left ) then
                    ! h(i) or h(i)**h is applied to c(i+1:m,1:n)
                    mi = m - i
                    ic = i + 1
                 else
                    ! h(i) or h(i)**h is applied to c(1:m,i+1:n)
                    ni = n - i
                    jc = i + 1
                 end if
                 ! apply h(i) or h(i)**h
                 if( notran ) then
                    taui = tau( i )
                 else
                    taui = conjg( tau( i ) )
                 end if
                 call stdlib_clarf( side, mi, ni, ap( ii ), 1, taui, c( ic, jc ),ldc, work )
                           
                 ap( ii ) = aii
                 if( forwrd ) then
                    ii = ii + nq - i + 1
                 else
                    ii = ii - nq + i - 2
                 end if
              end do loop_20
           end if
           return
     end subroutine stdlib_cupmtr


     pure subroutine stdlib_cgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, c, &
     !! CGBBRD reduces a complex general m-by-n band matrix A to real upper
     !! bidiagonal form B by a unitary transformation: Q**H * A * P = B.
     !! The routine computes B, and optionally forms Q or P**H, or computes
     !! Q**H*C for a given matrix C.
               ldc, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: vect
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, ldc, ldpt, ldq, m, n, ncc
           ! Array Arguments 
           real(sp), intent(out) :: d(*), e(*), rwork(*)
           complex(sp), intent(inout) :: ab(ldab,*), c(ldc,*)
           complex(sp), intent(out) :: pt(ldpt,*), q(ldq,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: wantb, wantc, wantpt, wantq
           integer(ilp) :: i, inca, j, j1, j2, kb, kb1, kk, klm, klu1, kun, l, minmn, ml, ml0, mu,&
                      mu0, nr, nrt
           real(sp) :: abst, rc
           complex(sp) :: ra, rb, rs, t
           ! Intrinsic Functions 
           intrinsic :: abs,conjg,max,min
           ! Executable Statements 
           ! test the input parameters
           wantb = stdlib_lsame( vect, 'B' )
           wantq = stdlib_lsame( vect, 'Q' ) .or. wantb
           wantpt = stdlib_lsame( vect, 'P' ) .or. wantb
           wantc = ncc>0
           klu1 = kl + ku + 1
           info = 0
           if( .not.wantq .and. .not.wantpt .and. .not.stdlib_lsame( vect, 'N' ) )then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ncc<0 ) then
              info = -4
           else if( kl<0 ) then
              info = -5
           else if( ku<0 ) then
              info = -6
           else if( ldab<klu1 ) then
              info = -8
           else if( ldq<1 .or. wantq .and. ldq<max( 1, m ) ) then
              info = -12
           else if( ldpt<1 .or. wantpt .and. ldpt<max( 1, n ) ) then
              info = -14
           else if( ldc<1 .or. wantc .and. ldc<max( 1, m ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGBBRD', -info )
              return
           end if
           ! initialize q and p**h to the unit matrix, if needed
           if( wantq )call stdlib_claset( 'FULL', m, m, czero, cone, q, ldq )
           if( wantpt )call stdlib_claset( 'FULL', n, n, czero, cone, pt, ldpt )
           ! quick return if possible.
           if( m==0 .or. n==0 )return
           minmn = min( m, n )
           if( kl+ku>1 ) then
              ! reduce to upper bidiagonal form if ku > 0; if ku = 0, reduce
              ! first to lower bidiagonal form and then transform to upper
              ! bidiagonal
              if( ku>0 ) then
                 ml0 = 1
                 mu0 = 2
              else
                 ml0 = 2
                 mu0 = 1
              end if
              ! wherever possible, plane rotations are generated and applied in
              ! vector operations of length nr over the index set j1:j2:klu1.
              ! the complex sines of the plane rotations are stored in work,
              ! and the real cosines in rwork.
              klm = min( m-1, kl )
              kun = min( n-1, ku )
              kb = klm + kun
              kb1 = kb + 1
              inca = kb1*ldab
              nr = 0
              j1 = klm + 2
              j2 = 1 - kun
              loop_90: do i = 1, minmn
                 ! reduce i-th column and i-th row of matrix to bidiagonal form
                 ml = klm + 1
                 mu = kun + 1
                 loop_80: do kk = 1, kb
                    j1 = j1 + kb
                    j2 = j2 + kb
                    ! generate plane rotations to annihilate nonzero elements
                    ! which have been created below the band
                    if( nr>0 )call stdlib_clargv( nr, ab( klu1, j1-klm-1 ), inca,work( j1 ), kb1, &
                              rwork( j1 ), kb1 )
                    ! apply plane rotations from the left
                    do l = 1, kb
                       if( j2-klm+l-1>n ) then
                          nrt = nr - 1
                       else
                          nrt = nr
                       end if
                       if( nrt>0 )call stdlib_clartv( nrt, ab( klu1-l, j1-klm+l-1 ), inca,ab( &
                                 klu1-l+1, j1-klm+l-1 ), inca,rwork( j1 ), work( j1 ), kb1 )
                    end do
                    if( ml>ml0 ) then
                       if( ml<=m-i+1 ) then
                          ! generate plane rotation to annihilate a(i+ml-1,i)
                          ! within the band, and apply rotation from the left
                          call stdlib_clartg( ab( ku+ml-1, i ), ab( ku+ml, i ),rwork( i+ml-1 ), &
                                    work( i+ml-1 ), ra )
                          ab( ku+ml-1, i ) = ra
                          if( i<n )call stdlib_crot( min( ku+ml-2, n-i ),ab( ku+ml-2, i+1 ), ldab-&
                                    1,ab( ku+ml-1, i+1 ), ldab-1,rwork( i+ml-1 ), work( i+ml-1 ) )
                       end if
                       nr = nr + 1
                       j1 = j1 - kb1
                    end if
                    if( wantq ) then
                       ! accumulate product of plane rotations in q
                       do j = j1, j2, kb1
                          call stdlib_crot( m, q( 1, j-1 ), 1, q( 1, j ), 1,rwork( j ), conjg( &
                                    work( j ) ) )
                       end do
                    end if
                    if( wantc ) then
                       ! apply plane rotations to c
                       do j = j1, j2, kb1
                          call stdlib_crot( ncc, c( j-1, 1 ), ldc, c( j, 1 ), ldc,rwork( j ), &
                                    work( j ) )
                       end do
                    end if
                    if( j2+kun>n ) then
                       ! adjust j2 to keep within the bounds of the matrix
                       nr = nr - 1
                       j2 = j2 - kb1
                    end if
                    do j = j1, j2, kb1
                       ! create nonzero element a(j-1,j+ku) above the band
                       ! and store it in work(n+1:2*n)
                       work( j+kun ) = work( j )*ab( 1, j+kun )
                       ab( 1, j+kun ) = rwork( j )*ab( 1, j+kun )
                    end do
                    ! generate plane rotations to annihilate nonzero elements
                    ! which have been generated above the band
                    if( nr>0 )call stdlib_clargv( nr, ab( 1, j1+kun-1 ), inca,work( j1+kun ), kb1,&
                               rwork( j1+kun ),kb1 )
                    ! apply plane rotations from the right
                    do l = 1, kb
                       if( j2+l-1>m ) then
                          nrt = nr - 1
                       else
                          nrt = nr
                       end if
                       if( nrt>0 )call stdlib_clartv( nrt, ab( l+1, j1+kun-1 ), inca,ab( l, j1+&
                                 kun ), inca,rwork( j1+kun ), work( j1+kun ), kb1 )
                    end do
                    if( ml==ml0 .and. mu>mu0 ) then
                       if( mu<=n-i+1 ) then
                          ! generate plane rotation to annihilate a(i,i+mu-1)
                          ! within the band, and apply rotation from the right
                          call stdlib_clartg( ab( ku-mu+3, i+mu-2 ),ab( ku-mu+2, i+mu-1 ),rwork( &
                                    i+mu-1 ), work( i+mu-1 ), ra )
                          ab( ku-mu+3, i+mu-2 ) = ra
                          call stdlib_crot( min( kl+mu-2, m-i ),ab( ku-mu+4, i+mu-2 ), 1,ab( ku-&
                                    mu+3, i+mu-1 ), 1,rwork( i+mu-1 ), work( i+mu-1 ) )
                       end if
                       nr = nr + 1
                       j1 = j1 - kb1
                    end if
                    if( wantpt ) then
                       ! accumulate product of plane rotations in p**h
                       do j = j1, j2, kb1
                          call stdlib_crot( n, pt( j+kun-1, 1 ), ldpt,pt( j+kun, 1 ), ldpt, rwork(&
                                     j+kun ),conjg( work( j+kun ) ) )
                       end do
                    end if
                    if( j2+kb>m ) then
                       ! adjust j2 to keep within the bounds of the matrix
                       nr = nr - 1
                       j2 = j2 - kb1
                    end if
                    do j = j1, j2, kb1
                       ! create nonzero element a(j+kl+ku,j+ku-1) below the
                       ! band and store it in work(1:n)
                       work( j+kb ) = work( j+kun )*ab( klu1, j+kun )
                       ab( klu1, j+kun ) = rwork( j+kun )*ab( klu1, j+kun )
                    end do
                    if( ml>ml0 ) then
                       ml = ml - 1
                    else
                       mu = mu - 1
                    end if
                 end do loop_80
              end do loop_90
           end if
           if( ku==0 .and. kl>0 ) then
              ! a has been reduced to complex lower bidiagonal form
              ! transform lower bidiagonal form to upper bidiagonal by applying
              ! plane rotations from the left, overwriting superdiagonal
              ! elements on subdiagonal elements
              do i = 1, min( m-1, n )
                 call stdlib_clartg( ab( 1, i ), ab( 2, i ), rc, rs, ra )
                 ab( 1, i ) = ra
                 if( i<n ) then
                    ab( 2, i ) = rs*ab( 1, i+1 )
                    ab( 1, i+1 ) = rc*ab( 1, i+1 )
                 end if
                 if( wantq )call stdlib_crot( m, q( 1, i ), 1, q( 1, i+1 ), 1, rc,conjg( rs ) )
                           
                 if( wantc )call stdlib_crot( ncc, c( i, 1 ), ldc, c( i+1, 1 ), ldc, rc,rs )
                           
              end do
           else
              ! a has been reduced to complex upper bidiagonal form or is
              ! diagonal
              if( ku>0 .and. m<n ) then
                 ! annihilate a(m,m+1) by applying plane rotations from the
                 ! right
                 rb = ab( ku, m+1 )
                 do i = m, 1, -1
                    call stdlib_clartg( ab( ku+1, i ), rb, rc, rs, ra )
                    ab( ku+1, i ) = ra
                    if( i>1 ) then
                       rb = -conjg( rs )*ab( ku, i )
                       ab( ku, i ) = rc*ab( ku, i )
                    end if
                    if( wantpt )call stdlib_crot( n, pt( i, 1 ), ldpt, pt( m+1, 1 ), ldpt,rc, &
                              conjg( rs ) )
                 end do
              end if
           end if
           ! make diagonal and superdiagonal elements real, storing them in d
           ! and e
           t = ab( ku+1, 1 )
           loop_120: do i = 1, minmn
              abst = abs( t )
              d( i ) = abst
              if( abst/=zero ) then
                 t = t / abst
              else
                 t = cone
              end if
              if( wantq )call stdlib_cscal( m, t, q( 1, i ), 1 )
              if( wantc )call stdlib_cscal( ncc, conjg( t ), c( i, 1 ), ldc )
              if( i<minmn ) then
                 if( ku==0 .and. kl==0 ) then
                    e( i ) = zero
                    t = ab( 1, i+1 )
                 else
                    if( ku==0 ) then
                       t = ab( 2, i )*conjg( t )
                    else
                       t = ab( ku, i+1 )*conjg( t )
                    end if
                    abst = abs( t )
                    e( i ) = abst
                    if( abst/=zero ) then
                       t = t / abst
                    else
                       t = cone
                    end if
                    if( wantpt )call stdlib_cscal( n, t, pt( i+1, 1 ), ldpt )
                    t = ab( ku+1, i+1 )*conjg( t )
                 end if
              end if
           end do loop_120
           return
     end subroutine stdlib_cgbbrd


     pure subroutine stdlib_cgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,ipiv, b, ldb, x, &
     !! CGBRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is banded, and provides
     !! error bounds and backward error estimates for the solution.
               ldx, ferr, berr, work, rwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, ldafb, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: ab(ldab,*), afb(ldafb,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: notran
           character :: transn, transt
           integer(ilp) :: count, i, j, k, kase, kk, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,min,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( trans, &
                     'C' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kl<0 ) then
              info = -3
           else if( ku<0 ) then
              info = -4
           else if( nrhs<0 ) then
              info = -5
           else if( ldab<kl+ku+1 ) then
              info = -7
           else if( ldafb<2*kl+ku+1 ) then
              info = -9
           else if( ldb<max( 1, n ) ) then
              info = -12
           else if( ldx<max( 1, n ) ) then
              info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGBRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           if( notran ) then
              transn = 'N'
              transt = 'C'
           else
              transn = 'C'
              transt = 'N'
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = min( kl+ku+2, n+1 )
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - op(a) * x,
              ! where op(a) = a, a**t, or a**h, depending on trans.
              call stdlib_ccopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_cgbmv( trans, n, n, kl, ku, -cone, ab, ldab, x( 1, j ), 1,cone, work, 1 &
                        )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(op(a))*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(op(a))*abs(x) + abs(b).
              if( notran ) then
                 do k = 1, n
                    kk = ku + 1 - k
                    xk = cabs1( x( k, j ) )
                    do i = max( 1, k-ku ), min( n, k+kl )
                       rwork( i ) = rwork( i ) + cabs1( ab( kk+i, k ) )*xk
                    end do
                 end do
              else
                 do k = 1, n
                    s = zero
                    kk = ku + 1 - k
                    do i = max( 1, k-ku ), min( n, k+kl )
                       s = s + cabs1( ab( kk+i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_cgbtrs( trans, n, kl, ku, 1, afb, ldafb, ipiv, work, n,info )
                 call stdlib_caxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(op(a)))*
                 ! ( abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(op(a)) is the inverse of op(a)
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(op(a))*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(op(a))*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(op(a)) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(op(a)**h).
                    call stdlib_cgbtrs( transt, n, kl, ku, 1, afb, ldafb, ipiv,work, n, info )
                              
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else
                    ! multiply by inv(op(a))*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_cgbtrs( transn, n, kl, ku, 1, afb, ldafb, ipiv,work, n, info )
                              
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_cgbrfs


     pure subroutine stdlib_cgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
     !! CGBSV computes the solution to a complex system of linear equations
     !! A * X = B, where A is a band matrix of order N with KL subdiagonals
     !! and KU superdiagonals, and X and B are N-by-NRHS matrices.
     !! The LU decomposition with partial pivoting and row interchanges is
     !! used to factor A as A = L * U, where L is a product of permutation
     !! and unit lower triangular matrices with KL subdiagonals, and U is
     !! upper triangular with KL+KU superdiagonals.  The factored form of A
     !! is then used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: ab(ldab,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( kl<0 ) then
              info = -2
           else if( ku<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldab<2*kl+ku+1 ) then
              info = -6
           else if( ldb<max( n, 1 ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGBSV ', -info )
              return
           end if
           ! compute the lu factorization of the band matrix a.
           call stdlib_cgbtrf( n, n, kl, ku, ab, ldab, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_cgbtrs( 'NO TRANSPOSE', n, kl, ku, nrhs, ab, ldab, ipiv,b, ldb, info )
                        
           end if
           return
     end subroutine stdlib_cgbsv


     subroutine stdlib_cgbsvx( fact, trans, n, kl, ku, nrhs, ab, ldab, afb,ldafb, ipiv, equed, r, &
     !! CGBSVX uses the LU factorization to compute the solution to a complex
     !! system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
     !! where A is a band matrix of order N with KL subdiagonals and KU
     !! superdiagonals, and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               c, b, ldb, x, ldx,rcond, ferr, berr, work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(inout) :: equed
           character, intent(in) :: fact, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kl, ku, ldab, ldafb, ldb, ldx, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           real(sp), intent(inout) :: c(*), r(*)
           complex(sp), intent(inout) :: ab(ldab,*), afb(ldafb,*), b(ldb,*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
        ! moved setting of info = n+1 so info does not subsequently get
        ! overwritten.  sven, 17 mar 05.
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: colequ, equil, nofact, notran, rowequ
           character :: norm
           integer(ilp) :: i, infequ, j, j1, j2
           real(sp) :: amax, anorm, bignum, colcnd, rcmax, rcmin, rowcnd, rpvgrw, smlnum
           ! Intrinsic Functions 
           intrinsic :: abs,max,min
           ! Executable Statements 
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           equil = stdlib_lsame( fact, 'E' )
           notran = stdlib_lsame( trans, 'N' )
           if( nofact .or. equil ) then
              equed = 'N'
              rowequ = .false.
              colequ = .false.
           else
              rowequ = stdlib_lsame( equed, 'R' ) .or. stdlib_lsame( equed, 'B' )
              colequ = stdlib_lsame( equed, 'C' ) .or. stdlib_lsame( equed, 'B' )
              smlnum = stdlib_slamch( 'SAFE MINIMUM' )
              bignum = one / smlnum
           end if
           ! test the input parameters.
           if( .not.nofact .and. .not.equil .and. .not.stdlib_lsame( fact, 'F' ) )then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( kl<0 ) then
              info = -4
           else if( ku<0 ) then
              info = -5
           else if( nrhs<0 ) then
              info = -6
           else if( ldab<kl+ku+1 ) then
              info = -8
           else if( ldafb<2*kl+ku+1 ) then
              info = -10
           else if( stdlib_lsame( fact, 'F' ) .and. .not.( rowequ .or. colequ .or. stdlib_lsame( &
                     equed, 'N' ) ) ) then
              info = -12
           else
              if( rowequ ) then
                 rcmin = bignum
                 rcmax = zero
                 do j = 1, n
                    rcmin = min( rcmin, r( j ) )
                    rcmax = max( rcmax, r( j ) )
                 end do
                 if( rcmin<=zero ) then
                    info = -13
                 else if( n>0 ) then
                    rowcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
                 else
                    rowcnd = one
                 end if
              end if
              if( colequ .and. info==0 ) then
                 rcmin = bignum
                 rcmax = zero
                 do j = 1, n
                    rcmin = min( rcmin, c( j ) )
                    rcmax = max( rcmax, c( j ) )
                 end do
                 if( rcmin<=zero ) then
                    info = -14
                 else if( n>0 ) then
                    colcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
                 else
                    colcnd = one
                 end if
              end if
              if( info==0 ) then
                 if( ldb<max( 1, n ) ) then
                    info = -16
                 else if( ldx<max( 1, n ) ) then
                    info = -18
                 end if
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGBSVX', -info )
              return
           end if
           if( equil ) then
              ! compute row and column scalings to equilibrate the matrix a.
              call stdlib_cgbequ( n, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, infequ )
                        
              if( infequ==0 ) then
                 ! equilibrate the matrix.
                 call stdlib_claqgb( n, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, equed )
                           
                 rowequ = stdlib_lsame( equed, 'R' ) .or. stdlib_lsame( equed, 'B' )
                 colequ = stdlib_lsame( equed, 'C' ) .or. stdlib_lsame( equed, 'B' )
              end if
           end if
           ! scale the right hand side.
           if( notran ) then
              if( rowequ ) then
                 do j = 1, nrhs
                    do i = 1, n
                       b( i, j ) = r( i )*b( i, j )
                    end do
                 end do
              end if
           else if( colequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    b( i, j ) = c( i )*b( i, j )
                 end do
              end do
           end if
           if( nofact .or. equil ) then
              ! compute the lu factorization of the band matrix a.
              do j = 1, n
                 j1 = max( j-ku, 1 )
                 j2 = min( j+kl, n )
                 call stdlib_ccopy( j2-j1+1, ab( ku+1-j+j1, j ), 1,afb( kl+ku+1-j+j1, j ), 1 )
                           
              end do
              call stdlib_cgbtrf( n, n, kl, ku, afb, ldafb, ipiv, info )
              ! return if info is non-zero.
              if( info>0 ) then
                 ! compute the reciprocal pivot growth factor of the
                 ! leading rank-deficient info columns of a.
                 anorm = zero
                 do j = 1, info
                    do i = max( ku+2-j, 1 ), min( n+ku+1-j, kl+ku+1 )
                       anorm = max( anorm, abs( ab( i, j ) ) )
                    end do
                 end do
                 rpvgrw = stdlib_clantb( 'M', 'U', 'N', info, min( info-1, kl+ku ),afb( max( 1, &
                           kl+ku+2-info ), 1 ), ldafb,rwork )
                 if( rpvgrw==zero ) then
                    rpvgrw = one
                 else
                    rpvgrw = anorm / rpvgrw
                 end if
                 rwork( 1 ) = rpvgrw
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a and the
           ! reciprocal pivot growth factor rpvgrw.
           if( notran ) then
              norm = '1'
           else
              norm = 'I'
           end if
           anorm = stdlib_clangb( norm, n, kl, ku, ab, ldab, rwork )
           rpvgrw = stdlib_clantb( 'M', 'U', 'N', n, kl+ku, afb, ldafb, rwork )
           if( rpvgrw==zero ) then
              rpvgrw = one
           else
              rpvgrw = stdlib_clangb( 'M', n, kl, ku, ab, ldab, rwork ) / rpvgrw
           end if
           ! compute the reciprocal of the condition number of a.
           call stdlib_cgbcon( norm, n, kl, ku, afb, ldafb, ipiv, anorm, rcond,work, rwork, info )
                     
           ! compute the solution matrix x.
           call stdlib_clacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_cgbtrs( trans, n, kl, ku, nrhs, afb, ldafb, ipiv, x, ldx,info )
           ! use iterative refinement to improve the computed solution and
           ! compute error bounds and backward error estimates for it.
           call stdlib_cgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv,b, ldb, x, ldx, &
                     ferr, berr, work, rwork, info )
           ! transform the solution matrix x to a solution of the original
           ! system.
           if( notran ) then
              if( colequ ) then
                 do j = 1, nrhs
                    do i = 1, n
                       x( i, j ) = c( i )*x( i, j )
                    end do
                 end do
                 do j = 1, nrhs
                    ferr( j ) = ferr( j ) / colcnd
                 end do
              end if
           else if( rowequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    x( i, j ) = r( i )*x( i, j )
                 end do
              end do
              do j = 1, nrhs
                 ferr( j ) = ferr( j ) / rowcnd
              end do
           end if
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           rwork( 1 ) = rpvgrw
           return
     end subroutine stdlib_cgbsvx


     pure subroutine stdlib_cgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
     !! CGEBRD reduces a general complex M-by-N matrix A to upper or lower
     !! bidiagonal form B by a unitary transformation: Q**H * A * P = B.
     !! If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, m, n
           ! Array Arguments 
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: taup(*), tauq(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, ldwrkx, ldwrky, lwkopt, minmn, nb, nbmin, nx, ws
           ! Intrinsic Functions 
           intrinsic :: max,min,real
           ! Executable Statements 
           ! test the input parameters
           info = 0
           nb = max( 1, stdlib_ilaenv( 1, 'CGEBRD', ' ', m, n, -1, -1 ) )
           lwkopt = ( m+n )*nb
           work( 1 ) = real( lwkopt,KIND=sp)
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           else if( lwork<max( 1, m, n ) .and. .not.lquery ) then
              info = -10
           end if
           if( info<0 ) then
              call stdlib_xerbla( 'CGEBRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           minmn = min( m, n )
           if( minmn==0 ) then
              work( 1 ) = 1
              return
           end if
           ws = max( m, n )
           ldwrkx = m
           ldwrky = n
           if( nb>1 .and. nb<minmn ) then
              ! set the crossover point nx.
              nx = max( nb, stdlib_ilaenv( 3, 'CGEBRD', ' ', m, n, -1, -1 ) )
              ! determine when to switch from blocked to unblocked code.
              if( nx<minmn ) then
                 ws = ( m+n )*nb
                 if( lwork<ws ) then
                    ! not enough work space for the optimal nb, consider using
                    ! a smaller block size.
                    nbmin = stdlib_ilaenv( 2, 'CGEBRD', ' ', m, n, -1, -1 )
                    if( lwork>=( m+n )*nbmin ) then
                       nb = lwork / ( m+n )
                    else
                       nb = 1
                       nx = minmn
                    end if
                 end if
              end if
           else
              nx = minmn
           end if
           do i = 1, minmn - nx, nb
              ! reduce rows and columns i:i+ib-1 to bidiagonal form and return
              ! the matrices x and y which are needed to update the unreduced
              ! part of the matrix
              call stdlib_clabrd( m-i+1, n-i+1, nb, a( i, i ), lda, d( i ), e( i ),tauq( i ), &
                        taup( i ), work, ldwrkx,work( ldwrkx*nb+1 ), ldwrky )
              ! update the trailing submatrix a(i+ib:m,i+ib:n), using
              ! an update of the form  a := a - v*y**h - x*u**h
              call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE', m-i-nb+1,n-i-nb+1, nb, -&
              cone, a( i+nb, i ), lda,work( ldwrkx*nb+nb+1 ), ldwrky, cone,a( i+nb, i+nb ), lda )
                        
              call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', m-i-nb+1, n-i-nb+1,nb, -cone, &
                        work( nb+1 ), ldwrkx, a( i, i+nb ), lda,cone, a( i+nb, i+nb ), lda )
              ! copy diagonal and off-diagonal elements of b back into a
              if( m>=n ) then
                 do j = i, i + nb - 1
                    a( j, j ) = d( j )
                    a( j, j+1 ) = e( j )
                 end do
              else
                 do j = i, i + nb - 1
                    a( j, j ) = d( j )
                    a( j+1, j ) = e( j )
                 end do
              end if
           end do
           ! use unblocked code to reduce the remainder of the matrix
           call stdlib_cgebd2( m-i+1, n-i+1, a( i, i ), lda, d( i ), e( i ),tauq( i ), taup( i ), &
                     work, iinfo )
           work( 1 ) = ws
           return
     end subroutine stdlib_cgebrd


     pure subroutine stdlib_cgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! CGEHRD reduces a complex general matrix A to upper Hessenberg form H by
     !! an unitary similarity transformation:  Q**H * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iwt, j, ldwork, lwkopt, nb, nbmin, nh, nx
           complex(sp) :: ei
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'CGEHRD', ' ', n, ilo, ihi, -1 ) )
              lwkopt = n*nb + tsize
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEHRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! set elements 1:ilo-1 and ihi:n-1 of tau to czero
           do i = 1, ilo - 1
              tau( i ) = czero
           end do
           do i = max( 1, ihi ), n - 1
              tau( i ) = czero
           end do
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = 1
              return
           end if
           ! determine the block size
           nb = min( nbmax, stdlib_ilaenv( 1, 'CGEHRD', ' ', n, ilo, ihi, -1 ) )
           nbmin = 2
           if( nb>1 .and. nb<nh ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code)
              nx = max( nb, stdlib_ilaenv( 3, 'CGEHRD', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code
                 if( lwork<n*nb+tsize ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code
                    nbmin = max( 2, stdlib_ilaenv( 2, 'CGEHRD', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=(n*nbmin+tsize) ) then
                       nb = (lwork-tsize) / n
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           ldwork = n
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              i = ilo
           else
              ! use blocked code
              iwt = 1 + n*nb
              do i = ilo, ihi - 1 - nx, nb
                 ib = min( nb, ihi-i )
                 ! reduce columns i:i+ib-1 to hessenberg form, returning the
                 ! matrices v and t of the block reflector h = i - v*t*v**h
                 ! which performs the reduction, and also the matrix y = a*v*t
                 call stdlib_clahr2( ihi, i, ib, a( 1, i ), lda, tau( i ),work( iwt ), ldt, work, &
                           ldwork )
                 ! apply the block reflector h to a(1:ihi,i+ib:ihi) from the
                 ! right, computing  a := a - y * v**h. v(i+ib,ib-1) must be set
                 ! to 1
                 ei = a( i+ib, i+ib-1 )
                 a( i+ib, i+ib-1 ) = cone
                 call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',ihi, ihi-i-ib+1,ib, -&
                           cone, work, ldwork, a( i+ib, i ), lda, cone,a( 1, i+ib ), lda )
                 a( i+ib, i+ib-1 ) = ei
                 ! apply the block reflector h to a(1:i,i+1:i+ib-1) from the
                 ! right
                 call stdlib_ctrmm( 'RIGHT', 'LOWER', 'CONJUGATE TRANSPOSE','UNIT', i, ib-1,cone, &
                           a( i+1, i ), lda, work, ldwork )
                 do j = 0, ib-2
                    call stdlib_caxpy( i, -cone, work( ldwork*j+1 ), 1,a( 1, i+j+1 ), 1 )
                 end do
                 ! apply the block reflector h to a(i+1:ihi,i+ib:n) from the
                 ! left
                 call stdlib_clarfb( 'LEFT', 'CONJUGATE TRANSPOSE', 'FORWARD','COLUMNWISE',ihi-i, &
                 n-i-ib+1, ib, a( i+1, i ), lda,work( iwt ), ldt, a( i+1, i+ib ), lda,work, &
                           ldwork )
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           call stdlib_cgehd2( n, i, ihi, a, lda, tau, work, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cgehrd


     pure subroutine stdlib_cgelqt( m, n, mb, a, lda, t, ldt, work, info )
     !! CGELQT computes a blocked LQ factorization of a complex M-by-N matrix A
     !! using the compact WY representation of Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldt, m, n, mb
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: t(ldt,*), work(*)
       ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ib, iinfo, k
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( mb<1 .or. (mb>min(m,n) .and. min(m,n)>0 ))then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldt<mb ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGELQT', -info )
              return
           end if
           ! quick return if possible
           k = min( m, n )
           if( k==0 ) return
           ! blocked loop of length k
           do i = 1, k,  mb
              ib = min( k-i+1, mb )
           ! compute the lq factorization of the current block a(i:m,i:i+ib-1)
              call stdlib_cgelqt3( ib, n-i+1, a(i,i), lda, t(1,i), ldt, iinfo )
              if( i+ib<=m ) then
           ! update by applying h**t to a(i:m,i+ib:n) from the right
              call stdlib_clarfb( 'R', 'N', 'F', 'R', m-i-ib+1, n-i+1, ib,a( i, i ), lda, t( 1, i &
                        ), ldt,a( i+ib, i ), lda, work , m-i-ib+1 )
              end if
           end do
           return
     end subroutine stdlib_cgelqt


     subroutine stdlib_cgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
     !! CGELS solves overdetermined or underdetermined complex linear systems
     !! involving an M-by-N matrix A, or its conjugate-transpose, using a QR
     !! or LQ factorization of A.  It is assumed that A has full rank.
     !! The following options are provided:
     !! 1. If TRANS = 'N' and m >= n:  find the least squares solution of
     !! an overdetermined system, i.e., solve the least squares problem
     !! minimize || B - A*X ||.
     !! 2. If TRANS = 'N' and m < n:  find the minimum norm solution of
     !! an underdetermined system A * X = B.
     !! 3. If TRANS = 'C' and m >= n:  find the minimum norm solution of
     !! an underdetermined system A**H * X = B.
     !! 4. If TRANS = 'C' and m < n:  find the least squares solution of
     !! an overdetermined system, i.e., solve the least squares problem
     !! minimize || B - A**H * X ||.
     !! Several right hand side vectors b and solution vectors x can be
     !! handled in a single call; they are stored as the columns of the
     !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution
     !! matrix X.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, nrhs
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery, tpsd
           integer(ilp) :: brow, i, iascl, ibscl, j, mn, nb, scllen, wsize
           real(sp) :: anrm, bignum, bnrm, smlnum
           ! Local Arrays 
           real(sp) :: rwork(1)
           ! Intrinsic Functions 
           intrinsic :: max,min,real
           ! Executable Statements 
           ! test the input arguments.
           info = 0
           mn = min( m, n )
           lquery = ( lwork==-1 )
           if( .not.( stdlib_lsame( trans, 'N' ) .or. stdlib_lsame( trans, 'C' ) ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldb<max( 1, m, n ) ) then
              info = -8
           else if( lwork<max( 1, mn+max( mn, nrhs ) ) .and..not.lquery ) then
              info = -10
           end if
           ! figure out optimal block size
           if( info==0 .or. info==-10 ) then
              tpsd = .true.
              if( stdlib_lsame( trans, 'N' ) )tpsd = .false.
              if( m>=n ) then
                 nb = stdlib_ilaenv( 1, 'CGEQRF', ' ', m, n, -1, -1 )
                 if( tpsd ) then
                    nb = max( nb, stdlib_ilaenv( 1, 'CUNMQR', 'LN', m, nrhs, n,-1 ) )
                 else
                    nb = max( nb, stdlib_ilaenv( 1, 'CUNMQR', 'LC', m, nrhs, n,-1 ) )
                 end if
              else
                 nb = stdlib_ilaenv( 1, 'CGELQF', ' ', m, n, -1, -1 )
                 if( tpsd ) then
                    nb = max( nb, stdlib_ilaenv( 1, 'CUNMLQ', 'LC', n, nrhs, m,-1 ) )
                 else
                    nb = max( nb, stdlib_ilaenv( 1, 'CUNMLQ', 'LN', n, nrhs, m,-1 ) )
                 end if
              end if
              wsize = max( 1, mn + max( mn, nrhs )*nb )
              work( 1 ) = real( wsize,KIND=sp)
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGELS ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( min( m, n, nrhs )==0 ) then
              call stdlib_claset( 'FULL', max( m, n ), nrhs, czero, czero, b, ldb )
              return
           end if
           ! get machine parameters
           smlnum = stdlib_slamch( 'S' ) / stdlib_slamch( 'P' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           ! scale a, b if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', m, n, a, lda, rwork )
           iascl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_clascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, info )
              iascl = 1
           else if( anrm>bignum ) then
              ! scale matrix norm down to bignum
              call stdlib_clascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, info )
              iascl = 2
           else if( anrm==zero ) then
              ! matrix all zero. return zero solution.
              call stdlib_claset( 'F', max( m, n ), nrhs, czero, czero, b, ldb )
              go to 50
           end if
           brow = m
           if( tpsd )brow = n
           bnrm = stdlib_clange( 'M', brow, nrhs, b, ldb, rwork )
           ibscl = 0
           if( bnrm>zero .and. bnrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_clascl( 'G', 0, 0, bnrm, smlnum, brow, nrhs, b, ldb,info )
              ibscl = 1
           else if( bnrm>bignum ) then
              ! scale matrix norm down to bignum
              call stdlib_clascl( 'G', 0, 0, bnrm, bignum, brow, nrhs, b, ldb,info )
              ibscl = 2
           end if
           if( m>=n ) then
              ! compute qr factorization of a
              call stdlib_cgeqrf( m, n, a, lda, work( 1 ), work( mn+1 ), lwork-mn,info )
              ! workspace at least n, optimally n*nb
              if( .not.tpsd ) then
                 ! least-squares problem min || a * x - b ||
                 ! b(1:m,1:nrhs) := q**h * b(1:m,1:nrhs)
                 call stdlib_cunmqr( 'LEFT', 'CONJUGATE TRANSPOSE', m, nrhs, n, a,lda, work( 1 ), &
                           b, ldb, work( mn+1 ), lwork-mn,info )
                 ! workspace at least nrhs, optimally nrhs*nb
                 ! b(1:n,1:nrhs) := inv(r) * b(1:n,1:nrhs)
                 call stdlib_ctrtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n, nrhs,a, lda, b, ldb, &
                           info )
                 if( info>0 ) then
                    return
                 end if
                 scllen = n
              else
                 ! underdetermined system of equations a**t * x = b
                 ! b(1:n,1:nrhs) := inv(r**h) * b(1:n,1:nrhs)
                 call stdlib_ctrtrs( 'UPPER', 'CONJUGATE TRANSPOSE','NON-UNIT',n, nrhs, a, lda, b,&
                            ldb, info )
                 if( info>0 ) then
                    return
                 end if
                 ! b(n+1:m,1:nrhs) = zero
                 do j = 1, nrhs
                    do i = n + 1, m
                       b( i, j ) = czero
                    end do
                 end do
                 ! b(1:m,1:nrhs) := q(1:n,:) * b(1:n,1:nrhs)
                 call stdlib_cunmqr( 'LEFT', 'NO TRANSPOSE', m, nrhs, n, a, lda,work( 1 ), b, ldb,&
                            work( mn+1 ), lwork-mn,info )
                 ! workspace at least nrhs, optimally nrhs*nb
                 scllen = m
              end if
           else
              ! compute lq factorization of a
              call stdlib_cgelqf( m, n, a, lda, work( 1 ), work( mn+1 ), lwork-mn,info )
              ! workspace at least m, optimally m*nb.
              if( .not.tpsd ) then
                 ! underdetermined system of equations a * x = b
                 ! b(1:m,1:nrhs) := inv(l) * b(1:m,1:nrhs)
                 call stdlib_ctrtrs( 'LOWER', 'NO TRANSPOSE', 'NON-UNIT', m, nrhs,a, lda, b, ldb, &
                           info )
                 if( info>0 ) then
                    return
                 end if
                 ! b(m+1:n,1:nrhs) = 0
                 do j = 1, nrhs
                    do i = m + 1, n
                       b( i, j ) = czero
                    end do
                 end do
                 ! b(1:n,1:nrhs) := q(1:n,:)**h * b(1:m,1:nrhs)
                 call stdlib_cunmlq( 'LEFT', 'CONJUGATE TRANSPOSE', n, nrhs, m, a,lda, work( 1 ), &
                           b, ldb, work( mn+1 ), lwork-mn,info )
                 ! workspace at least nrhs, optimally nrhs*nb
                 scllen = n
              else
                 ! overdetermined system min || a**h * x - b ||
                 ! b(1:n,1:nrhs) := q * b(1:n,1:nrhs)
                 call stdlib_cunmlq( 'LEFT', 'NO TRANSPOSE', n, nrhs, m, a, lda,work( 1 ), b, ldb,&
                            work( mn+1 ), lwork-mn,info )
                 ! workspace at least nrhs, optimally nrhs*nb
                 ! b(1:m,1:nrhs) := inv(l**h) * b(1:m,1:nrhs)
                 call stdlib_ctrtrs( 'LOWER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',m, nrhs, a, lda, &
                           b, ldb, info )
                 if( info>0 ) then
                    return
                 end if
                 scllen = m
              end if
           end if
           ! undo scaling
           if( iascl==1 ) then
              call stdlib_clascl( 'G', 0, 0, anrm, smlnum, scllen, nrhs, b, ldb,info )
           else if( iascl==2 ) then
              call stdlib_clascl( 'G', 0, 0, anrm, bignum, scllen, nrhs, b, ldb,info )
           end if
           if( ibscl==1 ) then
              call stdlib_clascl( 'G', 0, 0, smlnum, bnrm, scllen, nrhs, b, ldb,info )
           else if( ibscl==2 ) then
              call stdlib_clascl( 'G', 0, 0, bignum, bnrm, scllen, nrhs, b, ldb,info )
           end if
           50 continue
           work( 1 ) = real( wsize,KIND=sp)
           return
     end subroutine stdlib_cgels


     pure subroutine stdlib_cgeqp3( m, n, a, lda, jpvt, tau, work, lwork, rwork,info )
     !! CGEQP3 computes a QR factorization with column pivoting of a
     !! matrix A:  A*P = Q*R  using Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: jpvt(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: inb = 1
           integer(ilp), parameter :: inbmin = 2
           integer(ilp), parameter :: ixover = 3
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: fjb, iws, j, jb, lwkopt, minmn, minws, na, nb, nbmin, nfxd, nx, sm, &
                     sminmn, sn, topbmn
           ! Intrinsic Functions 
           intrinsic :: int,max,min
           ! Executable Statements 
           ! test input arguments
        ! ====================
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info==0 ) then
              minmn = min( m, n )
              if( minmn==0 ) then
                 iws = 1
                 lwkopt = 1
              else
                 iws = n + 1
                 nb = stdlib_ilaenv( inb, 'CGEQRF', ' ', m, n, -1, -1 )
                 lwkopt = ( n + 1 )*nb
              end if
              work( 1 ) = cmplx( lwkopt,KIND=sp)
              if( ( lwork<iws ) .and. .not.lquery ) then
                 info = -8
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEQP3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! move initial columns up front.
           nfxd = 1
           do j = 1, n
              if( jpvt( j )/=0 ) then
                 if( j/=nfxd ) then
                    call stdlib_cswap( m, a( 1, j ), 1, a( 1, nfxd ), 1 )
                    jpvt( j ) = jpvt( nfxd )
                    jpvt( nfxd ) = j
                 else
                    jpvt( j ) = j
                 end if
                 nfxd = nfxd + 1
              else
                 jpvt( j ) = j
              end if
           end do
           nfxd = nfxd - 1
           ! factorize fixed columns
        ! =======================
           ! compute the qr factorization of fixed columns and update
           ! remaining columns.
           if( nfxd>0 ) then
              na = min( m, nfxd )
      ! cc      call stdlib_cgeqr2( m, na, a, lda, tau, work, info )
              call stdlib_cgeqrf( m, na, a, lda, tau, work, lwork, info )
              iws = max( iws, int( work( 1 ),KIND=ilp) )
              if( na<n ) then
      ! cc         call stdlib_cunm2r( 'left', 'conjugate transpose', m, n-na,
      ! cc  $                   na, a, lda, tau, a( 1, na+1 ), lda, work,
      ! cc  $                   info )
                 call stdlib_cunmqr( 'LEFT', 'CONJUGATE TRANSPOSE', m, n-na, na, a,lda, tau, a( 1,&
                            na+1 ), lda, work, lwork,info )
                 iws = max( iws, int( work( 1 ),KIND=ilp) )
              end if
           end if
           ! factorize free columns
        ! ======================
           if( nfxd<minmn ) then
              sm = m - nfxd
              sn = n - nfxd
              sminmn = minmn - nfxd
              ! determine the block size.
              nb = stdlib_ilaenv( inb, 'CGEQRF', ' ', sm, sn, -1, -1 )
              nbmin = 2
              nx = 0
              if( ( nb>1 ) .and. ( nb<sminmn ) ) then
                 ! determine when to cross over from blocked to unblocked code.
                 nx = max( 0, stdlib_ilaenv( ixover, 'CGEQRF', ' ', sm, sn, -1,-1 ) )
                 if( nx<sminmn ) then
                    ! determine if workspace is large enough for blocked code.
                    minws = ( sn+1 )*nb
                    iws = max( iws, minws )
                    if( lwork<minws ) then
                       ! not enough workspace to use optimal nb: reduce nb and
                       ! determine the minimum value of nb.
                       nb = lwork / ( sn+1 )
                       nbmin = max( 2, stdlib_ilaenv( inbmin, 'CGEQRF', ' ', sm, sn,-1, -1 ) )
                                 
                    end if
                 end if
              end if
              ! initialize partial column norms. the first n elements of work
              ! store the exact column norms.
              do j = nfxd + 1, n
                 rwork( j ) = stdlib_scnrm2( sm, a( nfxd+1, j ), 1 )
                 rwork( n+j ) = rwork( j )
              end do
              if( ( nb>=nbmin ) .and. ( nb<sminmn ) .and.( nx<sminmn ) ) then
                 ! use blocked code initially.
                 j = nfxd + 1
                 ! compute factorization: while loop.
                 topbmn = minmn - nx
                 30 continue
                 if( j<=topbmn ) then
                    jb = min( nb, topbmn-j+1 )
                    ! factorize jb columns among columns j:n.
                    call stdlib_claqps( m, n-j+1, j-1, jb, fjb, a( 1, j ), lda,jpvt( j ), tau( j )&
                              , rwork( j ),rwork( n+j ), work( 1 ), work( jb+1 ),n-j+1 )
                    j = j + fjb
                    go to 30
                 end if
              else
                 j = nfxd + 1
              end if
              ! use unblocked code to factor the last or only block.
              if( j<=minmn )call stdlib_claqp2( m, n-j+1, j-1, a( 1, j ), lda, jpvt( j ),tau( j ),&
                         rwork( j ), rwork( n+j ), work( 1 ) )
           end if
           work( 1 ) = cmplx( lwkopt,KIND=sp)
           return
     end subroutine stdlib_cgeqp3


     pure subroutine stdlib_cgeqrt( m, n, nb, a, lda, t, ldt, work, info )
     !! CGEQRT computes a blocked QR factorization of a complex M-by-N matrix A
     !! using the compact WY representation of Q.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldt, m, n, nb
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: t(ldt,*), work(*)
       ! =====================================================================
           ! Local Scalars 
           logical(lk), parameter :: use_recursive_qr = .true.
           integer(ilp) :: i, ib, iinfo, k
           
           ! Executable Statements 
           ! test the input arguments
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nb<1 .or. ( nb>min(m,n) .and. min(m,n)>0 ) )then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldt<nb ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEQRT', -info )
              return
           end if
           ! quick return if possible
           k = min( m, n )
           if( k==0 ) return
           ! blocked loop of length k
           do i = 1, k,  nb
              ib = min( k-i+1, nb )
           ! compute the qr factorization of the current block a(i:m,i:i+ib-1)
              if( use_recursive_qr ) then
                 call stdlib_cgeqrt3( m-i+1, ib, a(i,i), lda, t(1,i), ldt, iinfo )
              else
                 call stdlib_cgeqrt2( m-i+1, ib, a(i,i), lda, t(1,i), ldt, iinfo )
              end if
              if( i+ib<=n ) then
           ! update by applying h**h to a(i:m,i+ib:n) from the left
                 call stdlib_clarfb( 'L', 'C', 'F', 'C', m-i+1, n-i-ib+1, ib,a( i, i ), lda, t( 1,&
                            i ), ldt,a( i, i+ib ), lda, work , n-i-ib+1 )
              end if
           end do
           return
     end subroutine stdlib_cgeqrt


     pure subroutine stdlib_cgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr, &
     !! CGERFS improves the computed solution to a system of linear
     !! equations and provides error bounds and backward error estimates for
     !! the solution.
               berr, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: notran
           character :: transn, transt
           integer(ilp) :: count, i, j, k, kase, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( trans, &
                     'C' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldaf<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGERFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           if( notran ) then
              transn = 'N'
              transt = 'C'
           else
              transn = 'C'
              transt = 'N'
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - op(a) * x,
              ! where op(a) = a, a**t, or a**h, depending on trans.
              call stdlib_ccopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_cgemv( trans, n, n, -cone, a, lda, x( 1, j ), 1, cone, work,1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(op(a))*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(op(a))*abs(x) + abs(b).
              if( notran ) then
                 do k = 1, n
                    xk = cabs1( x( k, j ) )
                    do i = 1, n
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                    end do
                 end do
              else
                 do k = 1, n
                    s = zero
                    do i = 1, n
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_cgetrs( trans, n, 1, af, ldaf, ipiv, work, n, info )
                 call stdlib_caxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(op(a)))*
                 ! ( abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(op(a)) is the inverse of op(a)
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(op(a))*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(op(a))*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(op(a)) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(op(a)**h).
                    call stdlib_cgetrs( transt, n, 1, af, ldaf, ipiv, work, n,info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else
                    ! multiply by inv(op(a))*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_cgetrs( transn, n, 1, af, ldaf, ipiv, work, n,info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_cgerfs


     pure subroutine stdlib_cgetrf( m, n, a, lda, ipiv, info )
     !! CGETRF computes an LU factorization of a general M-by-N matrix A
     !! using partial pivoting with row interchanges.
     !! The factorization has the form
     !! A = P * L * U
     !! where P is a permutation matrix, L is lower triangular with unit
     !! diagonal elements (lower trapezoidal if m > n), and U is upper
     !! triangular (upper trapezoidal if m < n).
     !! This is the right-looking Level 3 BLAS version of the algorithm.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, iinfo, j, jb, nb
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, m ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGETRF', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           ! determine the block size for this environment.
           nb = stdlib_ilaenv( 1, 'CGETRF', ' ', m, n, -1, -1 )
           if( nb<=1 .or. nb>=min( m, n ) ) then
              ! use unblocked code.
              call stdlib_cgetrf2( m, n, a, lda, ipiv, info )
           else
              ! use blocked code.
              do j = 1, min( m, n ), nb
                 jb = min( min( m, n )-j+1, nb )
                 ! factor diagonal and subdiagonal blocks and test for exact
                 ! singularity.
                 call stdlib_cgetrf2( m-j+1, jb, a( j, j ), lda, ipiv( j ), iinfo )
                 ! adjust info and the pivot indices.
                 if( info==0 .and. iinfo>0 )info = iinfo + j - 1
                 do i = j, min( m, j+jb-1 )
                    ipiv( i ) = j - 1 + ipiv( i )
                 end do
                 ! apply interchanges to columns 1:j-1.
                 call stdlib_claswp( j-1, a, lda, j, j+jb-1, ipiv, 1 )
                 if( j+jb<=n ) then
                    ! apply interchanges to columns j+jb:n.
                    call stdlib_claswp( n-j-jb+1, a( 1, j+jb ), lda, j, j+jb-1,ipiv, 1 )
                    ! compute block row of u.
                    call stdlib_ctrsm( 'LEFT', 'LOWER', 'NO TRANSPOSE', 'UNIT', jb,n-j-jb+1, cone,&
                               a( j, j ), lda, a( j, j+jb ),lda )
                    if( j+jb<=m ) then
                       ! update trailing submatrix.
                       call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', m-j-jb+1,n-j-jb+1, jb, -&
                       cone, a( j+jb, j ), lda,a( j, j+jb ), lda, cone, a( j+jb, j+jb ),lda )
                                 
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_cgetrf


     pure subroutine stdlib_cggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
     !! CGGGLM solves a general Gauss-Markov linear model (GLM) problem:
     !! minimize || y ||_2   subject to   d = A*x + B*y
     !! x
     !! where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
     !! given N-vector. It is assumed that M <= N <= M+P, and
     !! rank(A) = M    and    rank( A B ) = N.
     !! Under these assumptions, the constrained equation is always
     !! consistent, and there is a unique solution x and a minimal 2-norm
     !! solution y, which is obtained using a generalized QR factorization
     !! of the matrices (A, B) given by
     !! A = Q*(R),   B = Q*T*Z.
     !! (0)
     !! In particular, if matrix B is square nonsingular, then the problem
     !! GLM is equivalent to the following weighted linear least squares
     !! problem
     !! minimize || inv(B)*(d-A*x) ||_2
     !! x
     !! where inv(B) denotes the inverse of B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), d(*)
           complex(sp), intent(out) :: work(*), x(*), y(*)
        ! ===================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, lopt, lwkmin, lwkopt, nb, nb1, nb2, nb3, nb4, np
           ! Intrinsic Functions 
           intrinsic :: int,max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           np = min( n, p )
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( m<0 .or. m>n ) then
              info = -2
           else if( p<0 .or. p<n-m ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           ! calculate workspace
           if( info==0) then
              if( n==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'CGEQRF', ' ', n, m, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'CGERQF', ' ', n, m, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'CUNMQR', ' ', n, m, p, -1 )
                 nb4 = stdlib_ilaenv( 1, 'CUNMRQ', ' ', n, m, p, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = m + n + p
                 lwkopt = m + np + max( n, p )*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGGLM', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              do i = 1, m
                 x(i) = czero
              end do
              do i = 1, p
                 y(i) = czero
              end do
              return
           end if
           ! compute the gqr factorization of matrices a and b:
                ! q**h*a = ( r11 ) m,    q**h*b*z**h = ( t11   t12 ) m
                         ! (  0  ) n-m                 (  0    t22 ) n-m
                            ! m                         m+p-n  n-m
           ! where r11 and t22 are upper triangular, and q and z are
           ! unitary.
           call stdlib_cggqrf( n, m, p, a, lda, work, b, ldb, work( m+1 ),work( m+np+1 ), lwork-m-&
                     np, info )
           lopt = real( work( m+np+1 ),KIND=sp)
           ! update left-hand-side vector d = q**h*d = ( d1 ) m
                                                     ! ( d2 ) n-m
           call stdlib_cunmqr( 'LEFT', 'CONJUGATE TRANSPOSE', n, 1, m, a, lda, work,d, max( 1, n )&
                     , work( m+np+1 ), lwork-m-np, info )
           lopt = max( lopt, int( work( m+np+1 ),KIND=ilp) )
           ! solve t22*y2 = d2 for y2
           if( n>m ) then
              call stdlib_ctrtrs( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', n-m, 1,b( m+1, m+p-n+1 ), &
                        ldb, d( m+1 ), n-m, info )
              if( info>0 ) then
                 info = 1
                 return
              end if
              call stdlib_ccopy( n-m, d( m+1 ), 1, y( m+p-n+1 ), 1 )
           end if
           ! set y1 = 0
           do i = 1, m + p - n
              y( i ) = czero
           end do
           ! update d1 = d1 - t12*y2
           call stdlib_cgemv( 'NO TRANSPOSE', m, n-m, -cone, b( 1, m+p-n+1 ), ldb,y( m+p-n+1 ), 1,&
                      cone, d, 1 )
           ! solve triangular system: r11*x = d1
           if( m>0 ) then
              call stdlib_ctrtrs( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', m, 1, a, lda,d, m, info )
                        
              if( info>0 ) then
                 info = 2
                 return
              end if
              ! copy d to x
              call stdlib_ccopy( m, d, 1, x, 1 )
           end if
           ! backward transformation y = z**h *y
           call stdlib_cunmrq( 'LEFT', 'CONJUGATE TRANSPOSE', p, 1, np,b( max( 1, n-p+1 ), 1 ), &
                     ldb, work( m+1 ), y,max( 1, p ), work( m+np+1 ), lwork-m-np, info )
           work( 1 ) = m + np + max( lopt, int( work( m+np+1 ),KIND=ilp) )
           return
     end subroutine stdlib_cggglm


     pure subroutine stdlib_cgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! CGGHD3 reduces a pair of complex matrices (A,B) to generalized upper
     !! Hessenberg form using unitary transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the unitary matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**H*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**H*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**H*x.
     !! The unitary matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
     !! Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
     !! If Q1 is the unitary matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then CGGHD3 reduces the original
     !! problem to generalized Hessenberg form.
     !! This is a blocked variant of CGGHRD, using matrix-matrix
     !! multiplications for parts of the computation to enhance performance.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: blk22, initq, initz, lquery, wantq, wantz
           character :: compq2, compz2
           integer(ilp) :: cola, i, ierr, j, j0, jcol, jj, jrow, k, kacc22, len, lwkopt, n2nb, nb,&
                      nblst, nbmin, nh, nnb, nx, ppw, ppwo, pw, top, topq
           real(sp) :: c
           complex(sp) :: c1, c2, ctemp, s, s1, s2, temp, temp1, temp2, temp3
           ! Intrinsic Functions 
           intrinsic :: real,cmplx,conjg,max
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           nb = stdlib_ilaenv( 1, 'CGGHD3', ' ', n, ilo, ihi, -1 )
           lwkopt = max( 6*n*nb, 1 )
           work( 1 ) = cmplx( lwkopt,KIND=sp)
           initq = stdlib_lsame( compq, 'I' )
           wantq = initq .or. stdlib_lsame( compq, 'V' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( wantq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( wantz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           else if( lwork<1 .and. .not.lquery ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGHD3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! initialize q and z if desired.
           if( initq )call stdlib_claset( 'ALL', n, n, czero, cone, q, ldq )
           if( initz )call stdlib_claset( 'ALL', n, n, czero, cone, z, ldz )
           ! zero out lower triangle of b.
           if( n>1 )call stdlib_claset( 'LOWER', n-1, n-1, czero, czero, b(2, 1), ldb )
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = cone
              return
           end if
           ! determine the blocksize.
           nbmin = stdlib_ilaenv( 2, 'CGGHD3', ' ', n, ilo, ihi, -1 )
           if( nb>1 .and. nb<nh ) then
              ! determine when to use unblocked instead of blocked code.
              nx = max( nb, stdlib_ilaenv( 3, 'CGGHD3', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code.
                 if( lwork<lwkopt ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code.
                    nbmin = max( 2, stdlib_ilaenv( 2, 'CGGHD3', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=6*n*nbmin ) then
                       nb = lwork / ( 6*n )
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              jcol = ilo
           else
              ! use blocked code
              kacc22 = stdlib_ilaenv( 16, 'CGGHD3', ' ', n, ilo, ihi, -1 )
              blk22 = kacc22==2
              do jcol = ilo, ihi-2, nb
                 nnb = min( nb, ihi-jcol-1 )
                 ! initialize small unitary factors that will hold the
                 ! accumulated givens rotations in workspace.
                 ! n2nb   denotes the number of 2*nnb-by-2*nnb factors
                 ! nblst  denotes the (possibly smaller) order of the last
                        ! factor.
                 n2nb = ( ihi-jcol-1 ) / nnb - 1
                 nblst = ihi - jcol - n2nb*nnb
                 call stdlib_claset( 'ALL', nblst, nblst, czero, cone, work, nblst )
                 pw = nblst * nblst + 1
                 do i = 1, n2nb
                    call stdlib_claset( 'ALL', 2*nnb, 2*nnb, czero, cone,work( pw ), 2*nnb )
                              
                    pw = pw + 4*nnb*nnb
                 end do
                 ! reduce columns jcol:jcol+nnb-1 of a to hessenberg form.
                 do j = jcol, jcol+nnb-1
                    ! reduce jth column of a. store cosines and sines in jth
                    ! column of a and b, respectively.
                    do i = ihi, j+2, -1
                       temp = a( i-1, j )
                       call stdlib_clartg( temp, a( i, j ), c, s, a( i-1, j ) )
                       a( i, j ) = cmplx( c,KIND=sp)
                       b( i, j ) = s
                    end do
                    ! accumulate givens rotations into workspace array.
                    ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                    len  = 2 + j - jcol
                    jrow = j + n2nb*nnb + 2
                    do i = ihi, jrow, -1
                       ctemp = a( i, j )
                       s = b( i, j )
                       do jj = ppw, ppw+len-1
                          temp = work( jj + nblst )
                          work( jj + nblst ) = ctemp*temp - s*work( jj )
                          work( jj ) = conjg( s )*temp + ctemp*work( jj )
                       end do
                       len = len + 1
                       ppw = ppw - nblst - 1
                    end do
                    ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                    j0 = jrow - nnb
                    do jrow = j0, j+2, -nnb
                       ppw = ppwo
                       len  = 2 + j - jcol
                       do i = jrow+nnb-1, jrow, -1
                          ctemp = a( i, j )
                          s = b( i, j )
                          do jj = ppw, ppw+len-1
                             temp = work( jj + 2*nnb )
                             work( jj + 2*nnb ) = ctemp*temp - s*work( jj )
                             work( jj ) = conjg( s )*temp + ctemp*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - 2*nnb - 1
                       end do
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    ! top denotes the number of top rows in a and b that will
                    ! not be updated during the next steps.
                    if( jcol<=2 ) then
                       top = 0
                    else
                       top = jcol
                    end if
                    ! propagate transformations through b and replace stored
                    ! left sines/cosines by right sines/cosines.
                    do jj = n, j+1, -1
                       ! update jjth column of b.
                       do i = min( jj+1, ihi ), j+2, -1
                          ctemp = a( i, j )
                          s = b( i, j )
                          temp = b( i, jj )
                          b( i, jj ) = ctemp*temp - conjg( s )*b( i-1, jj )
                          b( i-1, jj ) = s*temp + ctemp*b( i-1, jj )
                       end do
                       ! annihilate b( jj+1, jj ).
                       if( jj<ihi ) then
                          temp = b( jj+1, jj+1 )
                          call stdlib_clartg( temp, b( jj+1, jj ), c, s,b( jj+1, jj+1 ) )
                          b( jj+1, jj ) = czero
                          call stdlib_crot( jj-top, b( top+1, jj+1 ), 1,b( top+1, jj ), 1, c, s )
                                    
                          a( jj+1, j ) = cmplx( c,KIND=sp)
                          b( jj+1, j ) = -conjg( s )
                       end if
                    end do
                    ! update a by transformations from right.
                    jj = mod( ihi-j-1, 3 )
                    do i = ihi-j-3, jj+1, -3
                       ctemp = a( j+1+i, j )
                       s = -b( j+1+i, j )
                       c1 = a( j+2+i, j )
                       s1 = -b( j+2+i, j )
                       c2 = a( j+3+i, j )
                       s2 = -b( j+3+i, j )
                       do k = top+1, ihi
                          temp = a( k, j+i  )
                          temp1 = a( k, j+i+1 )
                          temp2 = a( k, j+i+2 )
                          temp3 = a( k, j+i+3 )
                          a( k, j+i+3 ) = c2*temp3 + conjg( s2 )*temp2
                          temp2 = -s2*temp3 + c2*temp2
                          a( k, j+i+2 ) = c1*temp2 + conjg( s1 )*temp1
                          temp1 = -s1*temp2 + c1*temp1
                          a( k, j+i+1 ) = ctemp*temp1 + conjg( s )*temp
                          a( k, j+i ) = -s*temp1 + ctemp*temp
                       end do
                    end do
                    if( jj>0 ) then
                       do i = jj, 1, -1
                          c = real( a( j+1+i, j ),KIND=sp)
                          call stdlib_crot( ihi-top, a( top+1, j+i+1 ), 1,a( top+1, j+i ), 1, c,-&
                                    conjg( b( j+1+i, j ) ) )
                       end do
                    end if
                    ! update (j+1)th column of a by transformations from left.
                    if ( j < jcol + nnb - 1 ) then
                       len  = 1 + j - jcol
                       ! multiply with the trailing accumulated unitary
                       ! matrix, which takes the form
                              ! [  u11  u12  ]
                          ! u = [            ],
                              ! [  u21  u22  ]
                       ! where u21 is a len-by-len matrix and u12 is lower
                       ! triangular.
                       jrow = ihi - nblst + 1
                       call stdlib_cgemv( 'CONJUGATE', nblst, len, cone, work,nblst, a( jrow, j+1 &
                                 ), 1, czero,work( pw ), 1 )
                       ppw = pw + len
                       do i = jrow, jrow+nblst-len-1
                          work( ppw ) = a( i, j+1 )
                          ppw = ppw + 1
                       end do
                       call stdlib_ctrmv( 'LOWER', 'CONJUGATE', 'NON-UNIT',nblst-len, work( &
                                 len*nblst + 1 ), nblst,work( pw+len ), 1 )
                       call stdlib_cgemv( 'CONJUGATE', len, nblst-len, cone,work( (len+1)*nblst - &
                       len + 1 ), nblst,a( jrow+nblst-len, j+1 ), 1, cone,work( pw+len ), 1 )
                                 
                       ppw = pw
                       do i = jrow, jrow+nblst-1
                          a( i, j+1 ) = work( ppw )
                          ppw = ppw + 1
                       end do
                       ! multiply with the other accumulated unitary
                       ! matrices, which take the form
                              ! [  u11  u12   0  ]
                              ! [                ]
                          ! u = [  u21  u22   0  ],
                              ! [                ]
                              ! [   0    0    i  ]
                       ! where i denotes the (nnb-len)-by-(nnb-len) identity
                       ! matrix, u21 is a len-by-len upper triangular matrix
                       ! and u12 is an nnb-by-nnb lower triangular matrix.
                       ppwo = 1 + nblst*nblst
                       j0 = jrow - nnb
                       do jrow = j0, jcol+1, -nnb
                          ppw = pw + len
                          do i = jrow, jrow+nnb-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          ppw = pw
                          do i = jrow+nnb, jrow+nnb+len-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          call stdlib_ctrmv( 'UPPER', 'CONJUGATE', 'NON-UNIT', len,work( ppwo + &
                                    nnb ), 2*nnb, work( pw ),1 )
                          call stdlib_ctrmv( 'LOWER', 'CONJUGATE', 'NON-UNIT', nnb,work( ppwo + &
                                    2*len*nnb ),2*nnb, work( pw + len ), 1 )
                          call stdlib_cgemv( 'CONJUGATE', nnb, len, cone,work( ppwo ), 2*nnb, a( &
                                    jrow, j+1 ), 1,cone, work( pw ), 1 )
                          call stdlib_cgemv( 'CONJUGATE', len, nnb, cone,work( ppwo + 2*len*nnb + &
                                    nnb ), 2*nnb,a( jrow+nnb, j+1 ), 1, cone,work( pw+len ), 1 )
                          ppw = pw
                          do i = jrow, jrow+len+nnb-1
                             a( i, j+1 ) = work( ppw )
                             ppw = ppw + 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end if
                 end do
                 ! apply accumulated unitary matrices to a.
                 cola = n - jcol - nnb + 1
                 j = ihi - nblst + 1
                 call stdlib_cgemm( 'CONJUGATE', 'NO TRANSPOSE', nblst,cola, nblst, cone, work, &
                           nblst,a( j, jcol+nnb ), lda, czero, work( pw ),nblst )
                 call stdlib_clacpy( 'ALL', nblst, cola, work( pw ), nblst,a( j, jcol+nnb ), lda )
                           
                 ppwo = nblst*nblst + 1
                 j0 = j - nnb
                 do j = j0, jcol+1, -nnb
                    if ( blk22 ) then
                       ! exploit the structure of
                              ! [  u11  u12  ]
                          ! u = [            ]
                              ! [  u21  u22  ],
                       ! where all blocks are nnb-by-nnb, u21 is upper
                       ! triangular and u12 is lower triangular.
                       call stdlib_cunm22( 'LEFT', 'CONJUGATE', 2*nnb, cola, nnb,nnb, work( ppwo )&
                                 , 2*nnb,a( j, jcol+nnb ), lda, work( pw ),lwork-pw+1, ierr )
                    else
                       ! ignore the structure of u.
                       call stdlib_cgemm( 'CONJUGATE', 'NO TRANSPOSE', 2*nnb,cola, 2*nnb, cone, &
                       work( ppwo ), 2*nnb,a( j, jcol+nnb ), lda, czero, work( pw ),2*nnb )
                                 
                       call stdlib_clacpy( 'ALL', 2*nnb, cola, work( pw ), 2*nnb,a( j, jcol+nnb ),&
                                  lda )
                    end if
                    ppwo = ppwo + 4*nnb*nnb
                 end do
                 ! apply accumulated unitary matrices to q.
                 if( wantq ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, cone, q( &
                              topq, j ), ldq,work, nblst, czero, work( pw ), nh )
                    call stdlib_clacpy( 'ALL', nh, nblst, work( pw ), nh,q( topq, j ), ldq )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_cunm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,q( topq, j ), ldq, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, &
                          cone, q( topq, j ), ldq,work( ppwo ), 2*nnb, czero, work( pw ),nh )
                                    
                          call stdlib_clacpy( 'ALL', nh, 2*nnb, work( pw ), nh,q( topq, j ), ldq )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! accumulate right givens rotations if required.
                 if ( wantz .or. top>0 ) then
                    ! initialize small unitary factors that will hold the
                    ! accumulated givens rotations in workspace.
                    call stdlib_claset( 'ALL', nblst, nblst, czero, cone, work,nblst )
                    pw = nblst * nblst + 1
                    do i = 1, n2nb
                       call stdlib_claset( 'ALL', 2*nnb, 2*nnb, czero, cone,work( pw ), 2*nnb )
                                 
                       pw = pw + 4*nnb*nnb
                    end do
                    ! accumulate givens rotations into workspace array.
                    do j = jcol, jcol+nnb-1
                       ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                       len  = 2 + j - jcol
                       jrow = j + n2nb*nnb + 2
                       do i = ihi, jrow, -1
                          ctemp = a( i, j )
                          a( i, j ) = czero
                          s = b( i, j )
                          b( i, j ) = czero
                          do jj = ppw, ppw+len-1
                             temp = work( jj + nblst )
                             work( jj + nblst ) = ctemp*temp -conjg( s )*work( jj )
                             work( jj ) = s*temp + ctemp*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - nblst - 1
                       end do
                       ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                       j0 = jrow - nnb
                       do jrow = j0, j+2, -nnb
                          ppw = ppwo
                          len  = 2 + j - jcol
                          do i = jrow+nnb-1, jrow, -1
                             ctemp = a( i, j )
                             a( i, j ) = czero
                             s = b( i, j )
                             b( i, j ) = czero
                             do jj = ppw, ppw+len-1
                                temp = work( jj + 2*nnb )
                                work( jj + 2*nnb ) = ctemp*temp -conjg( s )*work( jj )
                                work( jj ) = s*temp + ctemp*work( jj )
                             end do
                             len = len + 1
                             ppw = ppw - 2*nnb - 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end do
                 else
                    call stdlib_claset( 'LOWER', ihi - jcol - 1, nnb, czero, czero,a( jcol + 2, &
                              jcol ), lda )
                    call stdlib_claset( 'LOWER', ihi - jcol - 1, nnb, czero, czero,b( jcol + 2, &
                              jcol ), ldb )
                 end if
                 ! apply accumulated unitary matrices to a and b.
                 if ( top>0 ) then
                    j = ihi - nblst + 1
                    call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, cone, a( &
                              1, j ), lda,work, nblst, czero, work( pw ), top )
                    call stdlib_clacpy( 'ALL', top, nblst, work( pw ), top,a( 1, j ), lda )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_cunm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,a( 1, j ), lda, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                          cone, a( 1, j ), lda,work( ppwo ), 2*nnb, czero,work( pw ), top )
                                    
                          call stdlib_clacpy( 'ALL', top, 2*nnb, work( pw ), top,a( 1, j ), lda )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    j = ihi - nblst + 1
                    call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, cone, b( &
                              1, j ), ldb,work, nblst, czero, work( pw ), top )
                    call stdlib_clacpy( 'ALL', top, nblst, work( pw ), top,b( 1, j ), ldb )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_cunm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,b( 1, j ), ldb, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                          cone, b( 1, j ), ldb,work( ppwo ), 2*nnb, czero,work( pw ), top )
                                    
                          call stdlib_clacpy( 'ALL', top, 2*nnb, work( pw ), top,b( 1, j ), ldb )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! apply accumulated unitary matrices to z.
                 if( wantz ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, cone, z( &
                              topq, j ), ldz,work, nblst, czero, work( pw ), nh )
                    call stdlib_clacpy( 'ALL', nh, nblst, work( pw ), nh,z( topq, j ), ldz )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                          if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_cunm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,z( topq, j ), ldz, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, &
                          cone, z( topq, j ), ldz,work( ppwo ), 2*nnb, czero, work( pw ),nh )
                                    
                          call stdlib_clacpy( 'ALL', nh, 2*nnb, work( pw ), nh,z( topq, j ), ldz )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           ! avoid re-initialization of modified q and z.
           compq2 = compq
           compz2 = compz
           if ( jcol/=ilo ) then
              if ( wantq )compq2 = 'V'
              if ( wantz )compz2 = 'V'
           end if
           if ( jcol<ihi )call stdlib_cgghrd( compq2, compz2, n, jcol, ihi, a, lda, b, ldb, q,ldq,&
                      z, ldz, ierr )
           work( 1 ) = cmplx( lwkopt,KIND=sp)
           return
     end subroutine stdlib_cgghd3


     pure subroutine stdlib_cgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
     !! CGGLSE solves the linear equality-constrained least squares (LSE)
     !! problem:
     !! minimize || c - A*x ||_2   subject to   B*x = d
     !! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
     !! M-vector, and d is a given P-vector. It is assumed that
     !! P <= N <= M+P, and
     !! rank(B) = P and  rank( (A) ) = N.
     !! ( (B) )
     !! These conditions ensure that the LSE problem has a unique solution,
     !! which is obtained using a generalized RQ factorization of the
     !! matrices (B, A) given by
     !! B = (0 R)*Q,   A = Z*T*Q.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), c(*), d(*)
           complex(sp), intent(out) :: work(*), x(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lopt, lwkmin, lwkopt, mn, nb, nb1, nb2, nb3, nb4, nr
           ! Intrinsic Functions 
           intrinsic :: int,max,min
           ! Executable Statements 
           ! test the input parameters
           info = 0
           mn = min( m, n )
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( p<0 .or. p>n .or. p<n-m ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, p ) ) then
              info = -7
           end if
           ! calculate workspace
           if( info==0) then
              if( n==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'CGEQRF', ' ', m, n, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'CGERQF', ' ', m, n, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'CUNMQR', ' ', m, n, p, -1 )
                 nb4 = stdlib_ilaenv( 1, 'CUNMRQ', ' ', m, n, p, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = m + n + p
                 lwkopt = p + mn + max( m, n )*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGLSE', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! compute the grq factorization of matrices b and a:
                  ! b*q**h = (  0  t12 ) p   z**h*a*q**h = ( r11 r12 ) n-p
                              ! n-p  p                     (  0  r22 ) m+p-n
                                                            ! n-p  p
           ! where t12 and r11 are upper triangular, and q and z are
           ! unitary.
           call stdlib_cggrqf( p, m, n, b, ldb, work, a, lda, work( p+1 ),work( p+mn+1 ), lwork-p-&
                     mn, info )
           lopt = real( work( p+mn+1 ),KIND=sp)
           ! update c = z**h *c = ( c1 ) n-p
                             ! ( c2 ) m+p-n
           call stdlib_cunmqr( 'LEFT', 'CONJUGATE TRANSPOSE', m, 1, mn, a, lda,work( p+1 ), c, &
                     max( 1, m ), work( p+mn+1 ),lwork-p-mn, info )
           lopt = max( lopt, int( work( p+mn+1 ),KIND=ilp) )
           ! solve t12*x2 = d for x2
           if( p>0 ) then
              call stdlib_ctrtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', p, 1,b( 1, n-p+1 ), ldb, d,&
                         p, info )
              if( info>0 ) then
                 info = 1
                 return
              end if
              ! put the solution in x
           call stdlib_ccopy( p, d, 1, x( n-p+1 ), 1 )
              ! update c1
              call stdlib_cgemv( 'NO TRANSPOSE', n-p, p, -cone, a( 1, n-p+1 ), lda,d, 1, cone, c, &
                        1 )
           end if
           ! solve r11*x1 = c1 for x1
           if( n>p ) then
              call stdlib_ctrtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n-p, 1,a, lda, c, n-p, &
                        info )
              if( info>0 ) then
                 info = 2
                 return
              end if
              ! put the solutions in x
              call stdlib_ccopy( n-p, c, 1, x, 1 )
           end if
           ! compute the residual vector:
           if( m<n ) then
              nr = m + p - n
              if( nr>0 )call stdlib_cgemv( 'NO TRANSPOSE', nr, n-m, -cone, a( n-p+1, m+1 ),lda, d(&
                         nr+1 ), 1, cone, c( n-p+1 ), 1 )
           else
              nr = p
           end if
           if( nr>0 ) then
              call stdlib_ctrmv( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', nr,a( n-p+1, n-p+1 ), lda, &
                        d, 1 )
              call stdlib_caxpy( nr, -cone, d, 1, c( n-p+1 ), 1 )
           end if
           ! backward transformation x = q**h*x
           call stdlib_cunmrq( 'LEFT', 'CONJUGATE TRANSPOSE', n, 1, p, b, ldb,work( 1 ), x, n, &
                     work( p+mn+1 ), lwork-p-mn, info )
           work( 1 ) = p + mn + max( lopt, int( work( p+mn+1 ),KIND=ilp) )
           return
     end subroutine stdlib_cgglse


     pure subroutine stdlib_cgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,work, info )
     !! CGTCON estimates the reciprocal of the condition number of a complex
     !! tridiagonal matrix A using the LU factorization as computed by
     !! CGTTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: norm
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: d(*), dl(*), du(*), du2(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: onenrm
           integer(ilp) :: i, kase, kase1
           real(sp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: cmplx
           ! Executable Statements 
           ! test the input arguments.
           info = 0
           onenrm = norm=='1' .or. stdlib_lsame( norm, 'O' )
           if( .not.onenrm .and. .not.stdlib_lsame( norm, 'I' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( anorm<zero ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGTCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm==zero ) then
              return
           end if
           ! check that d(1:n) is non-zero.
           do i = 1, n
              if( d( i )==cmplx( zero,KIND=sp) )return
           end do
           ainvnm = zero
           if( onenrm ) then
              kase1 = 1
           else
              kase1 = 2
           end if
           kase = 0
           20 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              if( kase==kase1 ) then
                 ! multiply by inv(u)*inv(l).
                 call stdlib_cgttrs( 'NO TRANSPOSE', n, 1, dl, d, du, du2, ipiv,work, n, info )
                           
              else
                 ! multiply by inv(l**h)*inv(u**h).
                 call stdlib_cgttrs( 'CONJUGATE TRANSPOSE', n, 1, dl, d, du, du2,ipiv, work, n, &
                           info )
              end if
              go to 20
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_cgtcon


     pure subroutine stdlib_cgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,ipiv, b, ldb, x, &
     !! CGTRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is tridiagonal, and provides
     !! error bounds and backward error estimates for the solution.
               ldx, ferr, berr, work, rwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: b(ldb,*), d(*), df(*), dl(*), dlf(*), du(*), du2(*), duf(*)
                     
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           ! Local Scalars 
           logical(lk) :: notran
           character :: transn, transt
           integer(ilp) :: count, i, j, kase, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( trans, &
                     'C' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -13
           else if( ldx<max( 1, n ) ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGTRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           if( notran ) then
              transn = 'N'
              transt = 'C'
           else
              transn = 'C'
              transt = 'N'
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = 4
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_110: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - op(a) * x,
              ! where op(a) = a, a**t, or a**h, depending on trans.
              call stdlib_ccopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_clagtm( trans, n, 1, -one, dl, d, du, x( 1, j ), ldx, one,work, n )
                        
              ! compute abs(op(a))*abs(x) + abs(b) for use in the backward
              ! error bound.
              if( notran ) then
                 if( n==1 ) then
                    rwork( 1 ) = cabs1( b( 1, j ) ) +cabs1( d( 1 ) )*cabs1( x( 1, j ) )
                 else
                    rwork( 1 ) = cabs1( b( 1, j ) ) +cabs1( d( 1 ) )*cabs1( x( 1, j ) ) +cabs1( &
                              du( 1 ) )*cabs1( x( 2, j ) )
                    do i = 2, n - 1
                       rwork( i ) = cabs1( b( i, j ) ) +cabs1( dl( i-1 ) )*cabs1( x( i-1, j ) ) +&
                       cabs1( d( i ) )*cabs1( x( i, j ) ) +cabs1( du( i ) )*cabs1( x( i+1, j ) )
                                 
                    end do
                    rwork( n ) = cabs1( b( n, j ) ) +cabs1( dl( n-1 ) )*cabs1( x( n-1, j ) ) +&
                              cabs1( d( n ) )*cabs1( x( n, j ) )
                 end if
              else
                 if( n==1 ) then
                    rwork( 1 ) = cabs1( b( 1, j ) ) +cabs1( d( 1 ) )*cabs1( x( 1, j ) )
                 else
                    rwork( 1 ) = cabs1( b( 1, j ) ) +cabs1( d( 1 ) )*cabs1( x( 1, j ) ) +cabs1( &
                              dl( 1 ) )*cabs1( x( 2, j ) )
                    do i = 2, n - 1
                       rwork( i ) = cabs1( b( i, j ) ) +cabs1( du( i-1 ) )*cabs1( x( i-1, j ) ) +&
                       cabs1( d( i ) )*cabs1( x( i, j ) ) +cabs1( dl( i ) )*cabs1( x( i+1, j ) )
                                 
                    end do
                    rwork( n ) = cabs1( b( n, j ) ) +cabs1( du( n-1 ) )*cabs1( x( n-1, j ) ) +&
                              cabs1( d( n ) )*cabs1( x( n, j ) )
                 end if
              end if
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(op(a))*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_cgttrs( trans, n, 1, dlf, df, duf, du2, ipiv, work, n,info )
                 call stdlib_caxpy( n, cmplx( one,KIND=sp), work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(op(a)))*
                 ! ( abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(op(a)) is the inverse of op(a)
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(op(a))*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(op(a))*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(op(a)) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(op(a))*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              70 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(op(a)**h).
                    call stdlib_cgttrs( transt, n, 1, dlf, df, duf, du2, ipiv, work,n, info )
                              
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else
                    ! multiply by inv(op(a))*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_cgttrs( transn, n, 1, dlf, df, duf, du2, ipiv, work,n, info )
                              
                 end if
                 go to 70
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_110
           return
     end subroutine stdlib_cgtrfs


     pure subroutine stdlib_cgtsvx( fact, trans, n, nrhs, dl, d, du, dlf, df, duf,du2, ipiv, b, &
     !! CGTSVX uses the LU factorization to compute the solution to a complex
     !! system of linear equations A * X = B, A**T * X = B, or A**H * X = B,
     !! where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
     !! matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               ldb, x, ldx, rcond, ferr, berr,work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: fact, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: b(ldb,*), d(*), dl(*), du(*)
           complex(sp), intent(inout) :: df(*), dlf(*), du2(*), duf(*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact, notran
           character :: norm
           real(sp) :: anorm
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           notran = stdlib_lsame( trans, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -14
           else if( ldx<max( 1, n ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGTSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the lu factorization of a.
              call stdlib_ccopy( n, d, 1, df, 1 )
              if( n>1 ) then
                 call stdlib_ccopy( n-1, dl, 1, dlf, 1 )
                 call stdlib_ccopy( n-1, du, 1, duf, 1 )
              end if
              call stdlib_cgttrf( n, dlf, df, duf, du2, ipiv, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           if( notran ) then
              norm = '1'
           else
              norm = 'I'
           end if
           anorm = stdlib_clangt( norm, n, dl, d, du )
           ! compute the reciprocal of the condition number of a.
           call stdlib_cgtcon( norm, n, dlf, df, duf, du2, ipiv, anorm, rcond, work,info )
           ! compute the solution vectors x.
           call stdlib_clacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_cgttrs( trans, n, nrhs, dlf, df, duf, du2, ipiv, x, ldx,info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_cgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv,b, ldb, x, ldx, &
                     ferr, berr, work, rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_cgtsvx


     pure subroutine stdlib_chbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, rwork,&
     !! CHBGST reduces a complex Hermitian-definite banded generalized
     !! eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,
     !! such that C has the same bandwidth as A.
     !! B must have been previously factorized as S**H*S by CPBSTF, using a
     !! split Cholesky factorization. A is overwritten by C = X**H*A*X, where
     !! X = S**(-1)*Q and Q is a unitary matrix chosen to preserve the
     !! bandwidth of A.
                info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo, vect
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldx, n
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: ab(ldab,*)
           complex(sp), intent(in) :: bb(ldbb,*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: update, upper, wantx
           integer(ilp) :: i, i0, i1, i2, inca, j, j1, j1t, j2, j2t, k, ka1, kb1, kbt, l, m, nr, &
                     nrt, nx
           real(sp) :: bii
           complex(sp) :: ra, ra1, t
           ! Intrinsic Functions 
           intrinsic :: conjg,max,min,real
           ! Executable Statements 
           ! test the input parameters
           wantx = stdlib_lsame( vect, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           ka1 = ka + 1
           kb1 = kb + 1
           info = 0
           if( .not.wantx .and. .not.stdlib_lsame( vect, 'N' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldx<1 .or. wantx .and. ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHBGST', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           inca = ldab*ka1
           ! initialize x to the unit matrix, if needed
           if( wantx )call stdlib_claset( 'FULL', n, n, czero, cone, x, ldx )
           ! set m to the splitting point m. it must be the same value as is
           ! used in stdlib_cpbstf. the chosen value allows the arrays work and rwork
           ! to be of dimension (n).
           m = ( n+kb ) / 2
           ! the routine works in two phases, corresponding to the two halves
           ! of the split cholesky factorization of b as s**h*s where
           ! s = ( u    )
               ! ( m  l )
           ! with u upper triangular of order m, and l lower triangular of
           ! order n-m. s has the same bandwidth as b.
           ! s is treated as a product of elementary matrices:
           ! s = s(m)*s(m-1)*...*s(2)*s(1)*s(m+1)*s(m+2)*...*s(n-1)*s(n)
           ! where s(i) is determined by the i-th row of s.
           ! in phase 1, the index i takes the values n, n-1, ... , m+1;
           ! in phase 2, it takes the values 1, 2, ... , m.
           ! for each value of i, the current matrix a is updated by forming
           ! inv(s(i))**h*a*inv(s(i)). this creates a triangular bulge outside
           ! the band of a. the bulge is then pushed down toward the bottom of
           ! a in phase 1, and up toward the top of a in phase 2, by applying
           ! plane rotations.
           ! there are kb*(kb+1)/2 elements in the bulge, but at most 2*kb-1
           ! of them are linearly independent, so annihilating a bulge requires
           ! only 2*kb-1 plane rotations. the rotations are divided into a 1st
           ! set of kb-1 rotations, and a 2nd set of kb rotations.
           ! wherever possible, rotations are generated and applied in vector
           ! operations of length nr between the indices j1 and j2 (sometimes
           ! replaced by modified values nrt, j1t or j2t).
           ! the real cosines and complex sines of the rotations are stored in
           ! the arrays rwork and work, those of the 1st set in elements
           ! 2:m-kb-1, and those of the 2nd set in elements m-kb+1:n.
           ! the bulges are not formed explicitly; nonzero elements outside the
           ! band are created only when they are required for generating new
           ! rotations; they are stored in the array work, in positions where
           ! they are later overwritten by the sines of the rotations which
           ! annihilate them.
           ! **************************** phase 1 *****************************
           ! the logical structure of this phase is:
           ! update = .true.
           ! do i = n, m + 1, -1
              ! use s(i) to update a and create a new bulge
              ! apply rotations to push all bulges ka positions downward
           ! end do
           ! update = .false.
           ! do i = m + ka + 1, n - 1
              ! apply rotations to push all bulges ka positions downward
           ! end do
           ! to avoid duplicating code, the two loops are merged.
           update = .true.
           i = n + 1
           10 continue
           if( update ) then
              i = i - 1
              kbt = min( kb, i-1 )
              i0 = i - 1
              i1 = min( n, i+ka )
              i2 = i - kbt + ka1
              if( i<m+1 ) then
                 update = .false.
                 i = i + 1
                 i0 = m
                 if( ka==0 )go to 480
                 go to 10
              end if
           else
              i = i + ka
              if( i>n-1 )go to 480
           end if
           if( upper ) then
              ! transform a, working with the upper triangle
              if( update ) then
                 ! form  inv(s(i))**h * a * inv(s(i))
                 bii = real( bb( kb1, i ),KIND=sp)
                 ab( ka1, i ) = ( real( ab( ka1, i ),KIND=sp) / bii ) / bii
                 do j = i + 1, i1
                    ab( i-j+ka1, j ) = ab( i-j+ka1, j ) / bii
                 end do
                 do j = max( 1, i-ka ), i - 1
                    ab( j-i+ka1, i ) = ab( j-i+ka1, i ) / bii
                 end do
                 do k = i - kbt, i - 1
                    do j = i - kbt, k
                       ab( j-k+ka1, k ) = ab( j-k+ka1, k ) -bb( j-i+kb1, i )*conjg( ab( k-i+ka1, &
                       i ) ) -conjg( bb( k-i+kb1, i ) )*ab( j-i+ka1, i ) +real( ab( ka1, i ),&
                                 KIND=sp)*bb( j-i+kb1, i )*conjg( bb( k-i+kb1, i ) )
                    end do
                    do j = max( 1, i-ka ), i - kbt - 1
                       ab( j-k+ka1, k ) = ab( j-k+ka1, k ) -conjg( bb( k-i+kb1, i ) )*ab( j-i+ka1,&
                                  i )
                    end do
                 end do
                 do j = i, i1
                    do k = max( j-ka, i-kbt ), i - 1
                       ab( k-j+ka1, j ) = ab( k-j+ka1, j ) -bb( k-i+kb1, i )*ab( i-j+ka1, j )
                                 
                    end do
                 end do
                 if( wantx ) then
                    ! post-multiply x by inv(s(i))
                    call stdlib_csscal( n-m, one / bii, x( m+1, i ), 1 )
                    if( kbt>0 )call stdlib_cgerc( n-m, kbt, -cone, x( m+1, i ), 1,bb( kb1-kbt, i )&
                              , 1, x( m+1, i-kbt ),ldx )
                 end if
                 ! store a(i,i1) in ra1 for use in next loop over k
                 ra1 = ab( i-i1+ka1, i1 )
              end if
              ! generate and apply vectors of rotations to chase all the
              ! existing bulges ka positions down toward the bottom of the
              ! band
              loop_130: do k = 1, kb - 1
                 if( update ) then
                    ! determine the rotations which would annihilate the bulge
                    ! which has in theory just been created
                    if( i-k+ka<n .and. i-k>1 ) then
                       ! generate rotation to annihilate a(i,i-k+ka+1)
                       call stdlib_clartg( ab( k+1, i-k+ka ), ra1,rwork( i-k+ka-m ), work( i-k+ka-&
                                 m ), ra )
                       ! create nonzero element a(i-k,i-k+ka+1) outside the
                       ! band and store it in work(i-k)
                       t = -bb( kb1-k, i )*ra1
                       work( i-k ) = rwork( i-k+ka-m )*t -conjg( work( i-k+ka-m ) )*ab( 1, i-k+ka &
                                 )
                       ab( 1, i-k+ka ) = work( i-k+ka-m )*t +rwork( i-k+ka-m )*ab( 1, i-k+ka )
                                 
                       ra1 = ra
                    end if
                 end if
                 j2 = i - k - 1 + max( 1, k-i0+2 )*ka1
                 nr = ( n-j2+ka ) / ka1
                 j1 = j2 + ( nr-1 )*ka1
                 if( update ) then
                    j2t = max( j2, i+2*ka-k+1 )
                 else
                    j2t = j2
                 end if
                 nrt = ( n-j2t+ka ) / ka1
                 do j = j2t, j1, ka1
                    ! create nonzero element a(j-ka,j+1) outside the band
                    ! and store it in work(j-m)
                    work( j-m ) = work( j-m )*ab( 1, j+1 )
                    ab( 1, j+1 ) = rwork( j-m )*ab( 1, j+1 )
                 end do
                 ! generate rotations in 1st set to annihilate elements which
                 ! have been created outside the band
                 if( nrt>0 )call stdlib_clargv( nrt, ab( 1, j2t ), inca, work( j2t-m ), ka1,rwork(&
                            j2t-m ), ka1 )
                 if( nr>0 ) then
                    ! apply rotations in 1st set from the right
                    do l = 1, ka - 1
                       call stdlib_clartv( nr, ab( ka1-l, j2 ), inca,ab( ka-l, j2+1 ), inca, &
                                 rwork( j2-m ),work( j2-m ), ka1 )
                    end do
                    ! apply rotations in 1st set from both sides to diagonal
                    ! blocks
                    call stdlib_clar2v( nr, ab( ka1, j2 ), ab( ka1, j2+1 ),ab( ka, j2+1 ), inca, &
                              rwork( j2-m ),work( j2-m ), ka1 )
                    call stdlib_clacgv( nr, work( j2-m ), ka1 )
                 end if
                 ! start applying rotations in 1st set from the left
                 do l = ka - 1, kb - k + 1, -1
                    nrt = ( n-j2+l ) / ka1
                    if( nrt>0 )call stdlib_clartv( nrt, ab( l, j2+ka1-l ), inca,ab( l+1, j2+ka1-l &
                              ), inca, rwork( j2-m ),work( j2-m ), ka1 )
                 end do
                 if( wantx ) then
                    ! post-multiply x by product of rotations in 1st set
                    do j = j2, j1, ka1
                       call stdlib_crot( n-m, x( m+1, j ), 1, x( m+1, j+1 ), 1,rwork( j-m ), &
                                 conjg( work( j-m ) ) )
                    end do
                 end if
              end do loop_130
              if( update ) then
                 if( i2<=n .and. kbt>0 ) then
                    ! create nonzero element a(i-kbt,i-kbt+ka+1) outside the
                    ! band and store it in work(i-kbt)
                    work( i-kbt ) = -bb( kb1-kbt, i )*ra1
                 end if
              end if
              loop_170: do k = kb, 1, -1
                 if( update ) then
                    j2 = i - k - 1 + max( 2, k-i0+1 )*ka1
                 else
                    j2 = i - k - 1 + max( 1, k-i0+1 )*ka1
                 end if
                 ! finish applying rotations in 2nd set from the left
                 do l = kb - k, 1, -1
                    nrt = ( n-j2+ka+l ) / ka1
                    if( nrt>0 )call stdlib_clartv( nrt, ab( l, j2-l+1 ), inca,ab( l+1, j2-l+1 ), &
                              inca, rwork( j2-ka ),work( j2-ka ), ka1 )
                 end do
                 nr = ( n-j2+ka ) / ka1
                 j1 = j2 + ( nr-1 )*ka1
                 do j = j1, j2, -ka1
                    work( j ) = work( j-ka )
                    rwork( j ) = rwork( j-ka )
                 end do
                 do j = j2, j1, ka1
                    ! create nonzero element a(j-ka,j+1) outside the band
                    ! and store it in work(j)
                    work( j ) = work( j )*ab( 1, j+1 )
                    ab( 1, j+1 ) = rwork( j )*ab( 1, j+1 )
                 end do
                 if( update ) then
                    if( i-k<n-ka .and. k<=kbt )work( i-k+ka ) = work( i-k )
                 end if
              end do loop_170
              loop_210: do k = kb, 1, -1
                 j2 = i - k - 1 + max( 1, k-i0+1 )*ka1
                 nr = ( n-j2+ka ) / ka1
                 j1 = j2 + ( nr-1 )*ka1
                 if( nr>0 ) then
                    ! generate rotations in 2nd set to annihilate elements
                    ! which have been created outside the band
                    call stdlib_clargv( nr, ab( 1, j2 ), inca, work( j2 ), ka1,rwork( j2 ), ka1 )
                              
                    ! apply rotations in 2nd set from the right
                    do l = 1, ka - 1
                       call stdlib_clartv( nr, ab( ka1-l, j2 ), inca,ab( ka-l, j2+1 ), inca, &
                                 rwork( j2 ),work( j2 ), ka1 )
                    end do
                    ! apply rotations in 2nd set from both sides to diagonal
                    ! blocks
                    call stdlib_clar2v( nr, ab( ka1, j2 ), ab( ka1, j2+1 ),ab( ka, j2+1 ), inca, &
                              rwork( j2 ),work( j2 ), ka1 )
                    call stdlib_clacgv( nr, work( j2 ), ka1 )
                 end if
                 ! start applying rotations in 2nd set from the left
                 do l = ka - 1, kb - k + 1, -1
                    nrt = ( n-j2+l ) / ka1
                    if( nrt>0 )call stdlib_clartv( nrt, ab( l, j2+ka1-l ), inca,ab( l+1, j2+ka1-l &
                              ), inca, rwork( j2 ),work( j2 ), ka1 )
                 end do
                 if( wantx ) then
                    ! post-multiply x by product of rotations in 2nd set
                    do j = j2, j1, ka1
                       call stdlib_crot( n-m, x( m+1, j ), 1, x( m+1, j+1 ), 1,rwork( j ), conjg( &
                                 work( j ) ) )
                    end do
                 end if
              end do loop_210
              do k = 1, kb - 1
                 j2 = i - k - 1 + max( 1, k-i0+2 )*ka1
                 ! finish applying rotations in 1st set from the left
                 do l = kb - k, 1, -1
                    nrt = ( n-j2+l ) / ka1
                    if( nrt>0 )call stdlib_clartv( nrt, ab( l, j2+ka1-l ), inca,ab( l+1, j2+ka1-l &
                              ), inca, rwork( j2-m ),work( j2-m ), ka1 )
                 end do
              end do
              if( kb>1 ) then
                 do j = n - 1, j2 + ka, -1
                    rwork( j-m ) = rwork( j-ka-m )
                    work( j-m ) = work( j-ka-m )
                 end do
              end if
           else
              ! transform a, working with the lower triangle
              if( update ) then
                 ! form  inv(s(i))**h * a * inv(s(i))
                 bii = real( bb( 1, i ),KIND=sp)
                 ab( 1, i ) = ( real( ab( 1, i ),KIND=sp) / bii ) / bii
                 do j = i + 1, i1
                    ab( j-i+1, i ) = ab( j-i+1, i ) / bii
                 end do
                 do j = max( 1, i-ka ), i - 1
                    ab( i-j+1, j ) = ab( i-j+1, j ) / bii
                 end do
                 do k = i - kbt, i - 1
                    do j = i - kbt, k
                       ab( k-j+1, j ) = ab( k-j+1, j ) -bb( i-j+1, j )*conjg( ab( i-k+1,k ) ) - &
                       conjg( bb( i-k+1, k ) )*ab( i-j+1, j ) + real( ab( 1, i ),KIND=sp)*bb( i-j+&
                                 1, j )*conjg( bb( i-k+1,k ) )
                    end do
                    do j = max( 1, i-ka ), i - kbt - 1
                       ab( k-j+1, j ) = ab( k-j+1, j ) -conjg( bb( i-k+1, k ) )*ab( i-j+1, j )
                                 
                    end do
                 end do
                 do j = i, i1
                    do k = max( j-ka, i-kbt ), i - 1
                       ab( j-k+1, k ) = ab( j-k+1, k ) -bb( i-k+1, k )*ab( j-i+1, i )
                    end do
                 end do
                 if( wantx ) then
                    ! post-multiply x by inv(s(i))
                    call stdlib_csscal( n-m, one / bii, x( m+1, i ), 1 )
                    if( kbt>0 )call stdlib_cgeru( n-m, kbt, -cone, x( m+1, i ), 1,bb( kbt+1, i-&
                              kbt ), ldbb-1,x( m+1, i-kbt ), ldx )
                 end if
                 ! store a(i1,i) in ra1 for use in next loop over k
                 ra1 = ab( i1-i+1, i )
              end if
              ! generate and apply vectors of rotations to chase all the
              ! existing bulges ka positions down toward the bottom of the
              ! band
              loop_360: do k = 1, kb - 1
                 if( update ) then
                    ! determine the rotations which would annihilate the bulge
                    ! which has in theory just been created
                    if( i-k+ka<n .and. i-k>1 ) then
                       ! generate rotation to annihilate a(i-k+ka+1,i)
                       call stdlib_clartg( ab( ka1-k, i ), ra1, rwork( i-k+ka-m ),work( i-k+ka-m )&
                                 , ra )
                       ! create nonzero element a(i-k+ka+1,i-k) outside the
                       ! band and store it in work(i-k)
                       t = -bb( k+1, i-k )*ra1
                       work( i-k ) = rwork( i-k+ka-m )*t -conjg( work( i-k+ka-m ) )*ab( ka1, i-k )
                                 
                       ab( ka1, i-k ) = work( i-k+ka-m )*t +rwork( i-k+ka-m )*ab( ka1, i-k )
                                 
                       ra1 = ra
                    end if
                 end if
                 j2 = i - k - 1 + max( 1, k-i0+2 )*ka1
                 nr = ( n-j2+ka ) / ka1
                 j1 = j2 + ( nr-1 )*ka1
                 if( update ) then
                    j2t = max( j2, i+2*ka-k+1 )
                 else
                    j2t = j2
                 end if
                 nrt = ( n-j2t+ka ) / ka1
                 do j = j2t, j1, ka1
                    ! create nonzero element a(j+1,j-ka) outside the band
                    ! and store it in work(j-m)
                    work( j-m ) = work( j-m )*ab( ka1, j-ka+1 )
                    ab( ka1, j-ka+1 ) = rwork( j-m )*ab( ka1, j-ka+1 )
                 end do
                 ! generate rotations in 1st set to annihilate elements which
                 ! have been created outside the band
                 if( nrt>0 )call stdlib_clargv( nrt, ab( ka1, j2t-ka ), inca, work( j2t-m ),ka1, &
                           rwork( j2t-m ), ka1 )
                 if( nr>0 ) then
                    ! apply rotations in 1st set from the left
                    do l = 1, ka - 1
                       call stdlib_clartv( nr, ab( l+1, j2-l ), inca,ab( l+2, j2-l ), inca, rwork(&
                                  j2-m ),work( j2-m ), ka1 )
                    end do
                    ! apply rotations in 1st set from both sides to diagonal
                    ! blocks
                    call stdlib_clar2v( nr, ab( 1, j2 ), ab( 1, j2+1 ), ab( 2, j2 ),inca, rwork( &
                              j2-m ), work( j2-m ), ka1 )
                    call stdlib_clacgv( nr, work( j2-m ), ka1 )
                 end if
                 ! start applying rotations in 1st set from the right
                 do l = ka - 1, kb - k + 1, -1
                    nrt = ( n-j2+l ) / ka1
                    if( nrt>0 )call stdlib_clartv( nrt, ab( ka1-l+1, j2 ), inca,ab( ka1-l, j2+1 ),&
                               inca, rwork( j2-m ),work( j2-m ), ka1 )
                 end do
                 if( wantx ) then
                    ! post-multiply x by product of rotations in 1st set
                    do j = j2, j1, ka1
                       call stdlib_crot( n-m, x( m+1, j ), 1, x( m+1, j+1 ), 1,rwork( j-m ), work(&
                                  j-m ) )
                    end do
                 end if
              end do loop_360
              if( update ) then
                 if( i2<=n .and. kbt>0 ) then
                    ! create nonzero element a(i-kbt+ka+1,i-kbt) outside the
                    ! band and store it in work(i-kbt)
                    work( i-kbt ) = -bb( kbt+1, i-kbt )*ra1
                 end if
              end if
              loop_400: do k = kb, 1, -1
                 if( update ) then
                    j2 = i - k - 1 + max( 2, k-i0+1 )*ka1
                 else
                    j2 = i - k - 1 + max( 1, k-i0+1 )*ka1
                 end if
                 ! finish applying rotations in 2nd set from the right
                 do l = kb - k, 1, -1
                    nrt = ( n-j2+ka+l ) / ka1
                    if( nrt>0 )call stdlib_clartv( nrt, ab( ka1-l+1, j2-ka ), inca,ab( ka1-l, j2-&
                              ka+1 ), inca,rwork( j2-ka ), work( j2-ka ), ka1 )
                 end do
                 nr = ( n-j2+ka ) / ka1
                 j1 = j2 + ( nr-1 )*ka1
                 do j = j1, j2, -ka1
                    work( j ) = work( j-ka )
                    rwork( j ) = rwork( j-ka )
                 end do
                 do j = j2, j1, ka1
                    ! create nonzero element a(j+1,j-ka) outside the band
                    ! and store it in work(j)
                    work( j ) = work( j )*ab( ka1, j-ka+1 )
                    ab( ka1, j-ka+1 ) = rwork( j )*ab( ka1, j-ka+1 )
                 end do
                 if( update ) then
                    if( i-k<n-ka .and. k<=kbt )work( i-k+ka ) = work( i-k )
                 end if
              end do loop_400
              loop_440: do k = kb, 1, -1
                 j2 = i - k - 1 + max( 1, k-i0+1 )*ka1
                 nr = ( n-j2+ka ) / ka1
                 j1 = j2 + ( nr-1 )*ka1
                 if( nr>0 ) then
                    ! generate rotations in 2nd set to annihilate elements
                    ! which have been created outside the band
                    call stdlib_clargv( nr, ab( ka1, j2-ka ), inca, work( j2 ), ka1,rwork( j2 ), &
                              ka1 )
                    ! apply rotations in 2nd set from the left
                    do l = 1, ka - 1
                       call stdlib_clartv( nr, ab( l+1, j2-l ), inca,ab( l+2, j2-l ), inca, rwork(&
                                  j2 ),work( j2 ), ka1 )
                    end do
                    ! apply rotations in 2nd set from both sides to diagonal
                    ! blocks
                    call stdlib_clar2v( nr, ab( 1, j2 ), ab( 1, j2+1 ), ab( 2, j2 ),inca, rwork( &
                              j2 ), work( j2 ), ka1 )
                    call stdlib_clacgv( nr, work( j2 ), ka1 )
                 end if
                 ! start applying rotations in 2nd set from the right
                 do l = ka - 1, kb - k + 1, -1
                    nrt = ( n-j2+l ) / ka1
                    if( nrt>0 )call stdlib_clartv( nrt, ab( ka1-l+1, j2 ), inca,ab( ka1-l, j2+1 ),&
                               inca, rwork( j2 ),work( j2 ), ka1 )
                 end do
                 if( wantx ) then
                    ! post-multiply x by product of rotations in 2nd set
                    do j = j2, j1, ka1
                       call stdlib_crot( n-m, x( m+1, j ), 1, x( m+1, j+1 ), 1,rwork( j ), work( &
                                 j ) )
                    end do
                 end if
              end do loop_440
              do k = 1, kb - 1
                 j2 = i - k - 1 + max( 1, k-i0+2 )*ka1
                 ! finish applying rotations in 1st set from the right
                 do l = kb - k, 1, -1
                    nrt = ( n-j2+l ) / ka1
                    if( nrt>0 )call stdlib_clartv( nrt, ab( ka1-l+1, j2 ), inca,ab( ka1-l, j2+1 ),&
                               inca, rwork( j2-m ),work( j2-m ), ka1 )
                 end do
              end do
              if( kb>1 ) then
                 do j = n - 1, j2 + ka, -1
                    rwork( j-m ) = rwork( j-ka-m )
                    work( j-m ) = work( j-ka-m )
                 end do
              end if
           end if
           go to 10
           480 continue
           ! **************************** phase 2 *****************************
           ! the logical structure of this phase is:
           ! update = .true.
           ! do i = 1, m
              ! use s(i) to update a and create a new bulge
              ! apply rotations to push all bulges ka positions upward
           ! end do
           ! update = .false.
           ! do i = m - ka - 1, 2, -1
              ! apply rotations to push all bulges ka positions upward
           ! end do
           ! to avoid duplicating code, the two loops are merged.
           update = .true.
           i = 0
           490 continue
           if( update ) then
              i = i + 1
              kbt = min( kb, m-i )
              i0 = i + 1
              i1 = max( 1, i-ka )
              i2 = i + kbt - ka1
              if( i>m ) then
                 update = .false.
                 i = i - 1
                 i0 = m + 1
                 if( ka==0 )return
                 go to 490
              end if
           else
              i = i - ka
              if( i<2 )return
           end if
           if( i<m-kbt ) then
              nx = m
           else
              nx = n
           end if
           if( upper ) then
              ! transform a, working with the upper triangle
              if( update ) then
                 ! form  inv(s(i))**h * a * inv(s(i))
                 bii = real( bb( kb1, i ),KIND=sp)
                 ab( ka1, i ) = ( real( ab( ka1, i ),KIND=sp) / bii ) / bii
                 do j = i1, i - 1
                    ab( j-i+ka1, i ) = ab( j-i+ka1, i ) / bii
                 end do
                 do j = i + 1, min( n, i+ka )
                    ab( i-j+ka1, j ) = ab( i-j+ka1, j ) / bii
                 end do
                 do k = i + 1, i + kbt
                    do j = k, i + kbt
                       ab( k-j+ka1, j ) = ab( k-j+ka1, j ) -bb( i-j+kb1, j )*conjg( ab( i-k+ka1, &
                       k ) ) -conjg( bb( i-k+kb1, k ) )*ab( i-j+ka1, j ) +real( ab( ka1, i ),&
                                 KIND=sp)*bb( i-j+kb1, j )*conjg( bb( i-k+kb1, k ) )
                    end do
                    do j = i + kbt + 1, min( n, i+ka )
                       ab( k-j+ka1, j ) = ab( k-j+ka1, j ) -conjg( bb( i-k+kb1, k ) )*ab( i-j+ka1,&
                                  j )
                    end do
                 end do
                 do j = i1, i
                    do k = i + 1, min( j+ka, i+kbt )
                       ab( j-k+ka1, k ) = ab( j-k+ka1, k ) -bb( i-k+kb1, k )*ab( j-i+ka1, i )
                                 
                    end do
                 end do
                 if( wantx ) then
                    ! post-multiply x by inv(s(i))
                    call stdlib_csscal( nx, one / bii, x( 1, i ), 1 )
                    if( kbt>0 )call stdlib_cgeru( nx, kbt, -cone, x( 1, i ), 1,bb( kb, i+1 ), &
                              ldbb-1, x( 1, i+1 ), ldx )
                 end if
                 ! store a(i1,i) in ra1 for use in next loop over k
                 ra1 = ab( i1-i+ka1, i )
              end if
              ! generate and apply vectors of rotations to chase all the
              ! existing bulges ka positions up toward the top of the band
              loop_610: do k = 1, kb - 1
                 if( update ) then
                    ! determine the rotations which would annihilate the bulge
                    ! which has in theory just been created
                    if( i+k-ka1>0 .and. i+k<m ) then
                       ! generate rotation to annihilate a(i+k-ka-1,i)
                       call stdlib_clartg( ab( k+1, i ), ra1, rwork( i+k-ka ),work( i+k-ka ), ra )
                                 
                       ! create nonzero element a(i+k-ka-1,i+k) outside the
                       ! band and store it in work(m-kb+i+k)
                       t = -bb( kb1-k, i+k )*ra1
                       work( m-kb+i+k ) = rwork( i+k-ka )*t -conjg( work( i+k-ka ) )*ab( 1, i+k )
                                 
                       ab( 1, i+k ) = work( i+k-ka )*t +rwork( i+k-ka )*ab( 1, i+k )
                       ra1 = ra
                    end if
                 end if
                 j2 = i + k + 1 - max( 1, k+i0-m+1 )*ka1
                 nr = ( j2+ka-1 ) / ka1
                 j1 = j2 - ( nr-1 )*ka1
                 if( update ) then
                    j2t = min( j2, i-2*ka+k-1 )
                 else
                    j2t = j2
                 end if
                 nrt = ( j2t+ka-1 ) / ka1
                 do j = j1, j2t, ka1
                    ! create nonzero element a(j-1,j+ka) outside the band
                    ! and store it in work(j)
                    work( j ) = work( j )*ab( 1, j+ka-1 )
                    ab( 1, j+ka-1 ) = rwork( j )*ab( 1, j+ka-1 )
                 end do
                 ! generate rotations in 1st set to annihilate elements which
                 ! have been created outside the band
                 if( nrt>0 )call stdlib_clargv( nrt, ab( 1, j1+ka ), inca, work( j1 ), ka1,rwork( &
                           j1 ), ka1 )
                 if( nr>0 ) then
                    ! apply rotations in 1st set from the left
                    do l = 1, ka - 1
                       call stdlib_clartv( nr, ab( ka1-l, j1+l ), inca,ab( ka-l, j1+l ), inca, &
                                 rwork( j1 ),work( j1 ), ka1 )
                    end do
                    ! apply rotations in 1st set from both sides to diagonal
                    ! blocks
                    call stdlib_clar2v( nr, ab( ka1, j1 ), ab( ka1, j1-1 ),ab( ka, j1 ), inca, &
                              rwork( j1 ), work( j1 ),ka1 )
                    call stdlib_clacgv( nr, work( j1 ), ka1 )
                 end if
                 ! start applying rotations in 1st set from the right
                 do l = ka - 1, kb - k + 1, -1
                    nrt = ( j2+l-1 ) / ka1
                    j1t = j2 - ( nrt-1 )*ka1
                    if( nrt>0 )call stdlib_clartv( nrt, ab( l, j1t ), inca,ab( l+1, j1t-1 ), inca,&
                               rwork( j1t ),work( j1t ), ka1 )
                 end do
                 if( wantx ) then
                    ! post-multiply x by product of rotations in 1st set
                    do j = j1, j2, ka1
                       call stdlib_crot( nx, x( 1, j ), 1, x( 1, j-1 ), 1,rwork( j ), work( j ) )
                                 
                    end do
                 end if
              end do loop_610
              if( update ) then
                 if( i2>0 .and. kbt>0 ) then
                    ! create nonzero element a(i+kbt-ka-1,i+kbt) outside the
                    ! band and store it in work(m-kb+i+kbt)
                    work( m-kb+i+kbt ) = -bb( kb1-kbt, i+kbt )*ra1
                 end if
              end if
              loop_650: do k = kb, 1, -1
                 if( update ) then
                    j2 = i + k + 1 - max( 2, k+i0-m )*ka1
                 else
                    j2 = i + k + 1 - max( 1, k+i0-m )*ka1
                 end if
                 ! finish applying rotations in 2nd set from the right
                 do l = kb - k, 1, -1
                    nrt = ( j2+ka+l-1 ) / ka1
                    j1t = j2 - ( nrt-1 )*ka1
                    if( nrt>0 )call stdlib_clartv( nrt, ab( l, j1t+ka ), inca,ab( l+1, j1t+ka-1 ),&
                               inca,rwork( m-kb+j1t+ka ),work( m-kb+j1t+ka ), ka1 )
                 end do
                 nr = ( j2+ka-1 ) / ka1
                 j1 = j2 - ( nr-1 )*ka1
                 do j = j1, j2, ka1
                    work( m-kb+j ) = work( m-kb+j+ka )
                    rwork( m-kb+j ) = rwork( m-kb+j+ka )
                 end do
                 do j = j1, j2, ka1
                    ! create nonzero element a(j-1,j+ka) outside the band
                    ! and store it in work(m-kb+j)
                    work( m-kb+j ) = work( m-kb+j )*ab( 1, j+ka-1 )
                    ab( 1, j+ka-1 ) = rwork( m-kb+j )*ab( 1, j+ka-1 )
                 end do
                 if( update ) then
                    if( i+k>ka1 .and. k<=kbt )work( m-kb+i+k-ka ) = work( m-kb+i+k )
                 end if
              end do loop_650
              loop_690: do k = kb, 1, -1
                 j2 = i + k + 1 - max( 1, k+i0-m )*ka1
                 nr = ( j2+ka-1 ) / ka1
                 j1 = j2 - ( nr-1 )*ka1
                 if( nr>0 ) then
                    ! generate rotations in 2nd set to annihilate elements
                    ! which have been created outside the band
                    call stdlib_clargv( nr, ab( 1, j1+ka ), inca, work( m-kb+j1 ),ka1, rwork( m-&
                              kb+j1 ), ka1 )
                    ! apply rotations in 2nd set from the left
                    do l = 1, ka - 1
                       call stdlib_clartv( nr, ab( ka1-l, j1+l ), inca,ab( ka-l, j1+l ), inca, &
                                 rwork( m-kb+j1 ),work( m-kb+j1 ), ka1 )
                    end do
                    ! apply rotations in 2nd set from both sides to diagonal
                    ! blocks
                    call stdlib_clar2v( nr, ab( ka1, j1 ), ab( ka1, j1-1 ),ab( ka, j1 ), inca, &
                              rwork( m-kb+j1 ),work( m-kb+j1 ), ka1 )
                    call stdlib_clacgv( nr, work( m-kb+j1 ), ka1 )
                 end if
                 ! start applying rotations in 2nd set from the right
                 do l = ka - 1, kb - k + 1, -1
                    nrt = ( j2+l-1 ) / ka1
                    j1t = j2 - ( nrt-1 )*ka1
                    if( nrt>0 )call stdlib_clartv( nrt, ab( l, j1t ), inca,ab( l+1, j1t-1 ), inca,&
                              rwork( m-kb+j1t ), work( m-kb+j1t ),ka1 )
                 end do
                 if( wantx ) then
                    ! post-multiply x by product of rotations in 2nd set
                    do j = j1, j2, ka1
                       call stdlib_crot( nx, x( 1, j ), 1, x( 1, j-1 ), 1,rwork( m-kb+j ), work( &
                                 m-kb+j ) )
                    end do
                 end if
              end do loop_690
              do k = 1, kb - 1
                 j2 = i + k + 1 - max( 1, k+i0-m+1 )*ka1
                 ! finish applying rotations in 1st set from the right
                 do l = kb - k, 1, -1
                    nrt = ( j2+l-1 ) / ka1
                    j1t = j2 - ( nrt-1 )*ka1
                    if( nrt>0 )call stdlib_clartv( nrt, ab( l, j1t ), inca,ab( l+1, j1t-1 ), inca,&
                               rwork( j1t ),work( j1t ), ka1 )
                 end do
              end do
              if( kb>1 ) then
                 do j = 2, i2 - ka
                    rwork( j ) = rwork( j+ka )
                    work( j ) = work( j+ka )
                 end do
              end if
           else
              ! transform a, working with the lower triangle
              if( update ) then
                 ! form  inv(s(i))**h * a * inv(s(i))
                 bii = real( bb( 1, i ),KIND=sp)
                 ab( 1, i ) = ( real( ab( 1, i ),KIND=sp) / bii ) / bii
                 do j = i1, i - 1
                    ab( i-j+1, j ) = ab( i-j+1, j ) / bii
                 end do
                 do j = i + 1, min( n, i+ka )
                    ab( j-i+1, i ) = ab( j-i+1, i ) / bii
                 end do
                 do k = i + 1, i + kbt
                    do j = k, i + kbt
                       ab( j-k+1, k ) = ab( j-k+1, k ) -bb( j-i+1, i )*conjg( ab( k-i+1,i ) ) - &
                       conjg( bb( k-i+1, i ) )*ab( j-i+1, i ) + real( ab( 1, i ),KIND=sp)*bb( j-i+&
                                 1, i )*conjg( bb( k-i+1,i ) )
                    end do
                    do j = i + kbt + 1, min( n, i+ka )
                       ab( j-k+1, k ) = ab( j-k+1, k ) -conjg( bb( k-i+1, i ) )*ab( j-i+1, i )
                                 
                    end do
                 end do
                 do j = i1, i
                    do k = i + 1, min( j+ka, i+kbt )
                       ab( k-j+1, j ) = ab( k-j+1, j ) -bb( k-i+1, i )*ab( i-j+1, j )
                    end do
                 end do
                 if( wantx ) then
                    ! post-multiply x by inv(s(i))
                    call stdlib_csscal( nx, one / bii, x( 1, i ), 1 )
                    if( kbt>0 )call stdlib_cgerc( nx, kbt, -cone, x( 1, i ), 1, bb( 2, i ),1, x( &
                              1, i+1 ), ldx )
                 end if
                 ! store a(i,i1) in ra1 for use in next loop over k
                 ra1 = ab( i-i1+1, i1 )
              end if
              ! generate and apply vectors of rotations to chase all the
              ! existing bulges ka positions up toward the top of the band
              loop_840: do k = 1, kb - 1
                 if( update ) then
                    ! determine the rotations which would annihilate the bulge
                    ! which has in theory just been created
                    if( i+k-ka1>0 .and. i+k<m ) then
                       ! generate rotation to annihilate a(i,i+k-ka-1)
                       call stdlib_clartg( ab( ka1-k, i+k-ka ), ra1,rwork( i+k-ka ), work( i+k-ka &
                                 ), ra )
                       ! create nonzero element a(i+k,i+k-ka-1) outside the
                       ! band and store it in work(m-kb+i+k)
                       t = -bb( k+1, i )*ra1
                       work( m-kb+i+k ) = rwork( i+k-ka )*t -conjg( work( i+k-ka ) )*ab( ka1, i+k-&
                                 ka )
                       ab( ka1, i+k-ka ) = work( i+k-ka )*t +rwork( i+k-ka )*ab( ka1, i+k-ka )
                                 
                       ra1 = ra
                    end if
                 end if
                 j2 = i + k + 1 - max( 1, k+i0-m+1 )*ka1
                 nr = ( j2+ka-1 ) / ka1
                 j1 = j2 - ( nr-1 )*ka1
                 if( update ) then
                    j2t = min( j2, i-2*ka+k-1 )
                 else
                    j2t = j2
                 end if
                 nrt = ( j2t+ka-1 ) / ka1
                 do j = j1, j2t, ka1
                    ! create nonzero element a(j+ka,j-1) outside the band
                    ! and store it in work(j)
                    work( j ) = work( j )*ab( ka1, j-1 )
                    ab( ka1, j-1 ) = rwork( j )*ab( ka1, j-1 )
                 end do
                 ! generate rotations in 1st set to annihilate elements which
                 ! have been created outside the band
                 if( nrt>0 )call stdlib_clargv( nrt, ab( ka1, j1 ), inca, work( j1 ), ka1,rwork( &
                           j1 ), ka1 )
                 if( nr>0 ) then
                    ! apply rotations in 1st set from the right
                    do l = 1, ka - 1
                       call stdlib_clartv( nr, ab( l+1, j1 ), inca, ab( l+2, j1-1 ),inca, rwork( &
                                 j1 ), work( j1 ), ka1 )
                    end do
                    ! apply rotations in 1st set from both sides to diagonal
                    ! blocks
                    call stdlib_clar2v( nr, ab( 1, j1 ), ab( 1, j1-1 ),ab( 2, j1-1 ), inca, rwork(&
                               j1 ),work( j1 ), ka1 )
                    call stdlib_clacgv( nr, work( j1 ), ka1 )
                 end if
                 ! start applying rotations in 1st set from the left
                 do l = ka - 1, kb - k + 1, -1
                    nrt = ( j2+l-1 ) / ka1
                    j1t = j2 - ( nrt-1 )*ka1
                    if( nrt>0 )call stdlib_clartv( nrt, ab( ka1-l+1, j1t-ka1+l ), inca,ab( ka1-l, &
                              j1t-ka1+l ), inca,rwork( j1t ), work( j1t ), ka1 )
                 end do
                 if( wantx ) then
                    ! post-multiply x by product of rotations in 1st set
                    do j = j1, j2, ka1
                       call stdlib_crot( nx, x( 1, j ), 1, x( 1, j-1 ), 1,rwork( j ), conjg( work(&
                                  j ) ) )
                    end do
                 end if
              end do loop_840
              if( update ) then
                 if( i2>0 .and. kbt>0 ) then
                    ! create nonzero element a(i+kbt,i+kbt-ka-1) outside the
                    ! band and store it in work(m-kb+i+kbt)
                    work( m-kb+i+kbt ) = -bb( kbt+1, i )*ra1
                 end if
              end if
              loop_880: do k = kb, 1, -1
                 if( update ) then
                    j2 = i + k + 1 - max( 2, k+i0-m )*ka1
                 else
                    j2 = i + k + 1 - max( 1, k+i0-m )*ka1
                 end if
                 ! finish applying rotations in 2nd set from the left
                 do l = kb - k, 1, -1
                    nrt = ( j2+ka+l-1 ) / ka1
                    j1t = j2 - ( nrt-1 )*ka1
                    if( nrt>0 )call stdlib_clartv( nrt, ab( ka1-l+1, j1t+l-1 ), inca,ab( ka1-l, &
                              j1t+l-1 ), inca,rwork( m-kb+j1t+ka ),work( m-kb+j1t+ka ), ka1 )
                 end do
                 nr = ( j2+ka-1 ) / ka1
                 j1 = j2 - ( nr-1 )*ka1
                 do j = j1, j2, ka1
                    work( m-kb+j ) = work( m-kb+j+ka )
                    rwork( m-kb+j ) = rwork( m-kb+j+ka )
                 end do
                 do j = j1, j2, ka1
                    ! create nonzero element a(j+ka,j-1) outside the band
                    ! and store it in work(m-kb+j)
                    work( m-kb+j ) = work( m-kb+j )*ab( ka1, j-1 )
                    ab( ka1, j-1 ) = rwork( m-kb+j )*ab( ka1, j-1 )
                 end do
                 if( update ) then
                    if( i+k>ka1 .and. k<=kbt )work( m-kb+i+k-ka ) = work( m-kb+i+k )
                 end if
              end do loop_880
              loop_920: do k = kb, 1, -1
                 j2 = i + k + 1 - max( 1, k+i0-m )*ka1
                 nr = ( j2+ka-1 ) / ka1
                 j1 = j2 - ( nr-1 )*ka1
                 if( nr>0 ) then
                    ! generate rotations in 2nd set to annihilate elements
                    ! which have been created outside the band
                    call stdlib_clargv( nr, ab( ka1, j1 ), inca, work( m-kb+j1 ),ka1, rwork( m-kb+&
                              j1 ), ka1 )
                    ! apply rotations in 2nd set from the right
                    do l = 1, ka - 1
                       call stdlib_clartv( nr, ab( l+1, j1 ), inca, ab( l+2, j1-1 ),inca, rwork( &
                                 m-kb+j1 ), work( m-kb+j1 ),ka1 )
                    end do
                    ! apply rotations in 2nd set from both sides to diagonal
                    ! blocks
                    call stdlib_clar2v( nr, ab( 1, j1 ), ab( 1, j1-1 ),ab( 2, j1-1 ), inca, rwork(&
                               m-kb+j1 ),work( m-kb+j1 ), ka1 )
                    call stdlib_clacgv( nr, work( m-kb+j1 ), ka1 )
                 end if
                 ! start applying rotations in 2nd set from the left
                 do l = ka - 1, kb - k + 1, -1
                    nrt = ( j2+l-1 ) / ka1
                    j1t = j2 - ( nrt-1 )*ka1
                    if( nrt>0 )call stdlib_clartv( nrt, ab( ka1-l+1, j1t-ka1+l ), inca,ab( ka1-l, &
                              j1t-ka1+l ), inca,rwork( m-kb+j1t ), work( m-kb+j1t ),ka1 )
                 end do
                 if( wantx ) then
                    ! post-multiply x by product of rotations in 2nd set
                    do j = j1, j2, ka1
                       call stdlib_crot( nx, x( 1, j ), 1, x( 1, j-1 ), 1,rwork( m-kb+j ), conjg( &
                                 work( m-kb+j ) ) )
                    end do
                 end if
              end do loop_920
              do k = 1, kb - 1
                 j2 = i + k + 1 - max( 1, k+i0-m+1 )*ka1
                 ! finish applying rotations in 1st set from the left
                 do l = kb - k, 1, -1
                    nrt = ( j2+l-1 ) / ka1
                    j1t = j2 - ( nrt-1 )*ka1
                    if( nrt>0 )call stdlib_clartv( nrt, ab( ka1-l+1, j1t-ka1+l ), inca,ab( ka1-l, &
                              j1t-ka1+l ), inca,rwork( j1t ), work( j1t ), ka1 )
                 end do
              end do
              if( kb>1 ) then
                 do j = 2, i2 - ka
                    rwork( j ) = rwork( j+ka )
                    work( j ) = work( j+ka )
                 end do
              end if
           end if
           go to 490
     end subroutine stdlib_chbgst


     pure subroutine stdlib_chbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
     !! CHBTRD reduces a complex Hermitian band matrix A to real symmetric
     !! tridiagonal form T by a unitary similarity transformation:
     !! Q**H * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo, vect
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldq, n
           ! Array Arguments 
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: ab(ldab,*), q(ldq,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: initq, upper, wantq
           integer(ilp) :: i, i2, ibl, inca, incx, iqaend, iqb, iqend, j, j1, j1end, j1inc, j2, &
                     jend, jin, jinc, k, kd1, kdm1, kdn, l, last, lend, nq, nr, nrt
           real(sp) :: abst
           complex(sp) :: t, temp
           ! Intrinsic Functions 
           intrinsic :: abs,conjg,max,min,real
           ! Executable Statements 
           ! test the input parameters
           initq = stdlib_lsame( vect, 'V' )
           wantq = initq .or. stdlib_lsame( vect, 'U' )
           upper = stdlib_lsame( uplo, 'U' )
           kd1 = kd + 1
           kdm1 = kd - 1
           incx = ldab - 1
           iqend = 1
           info = 0
           if( .not.wantq .and. .not.stdlib_lsame( vect, 'N' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( kd<0 ) then
              info = -4
           else if( ldab<kd1 ) then
              info = -6
           else if( ldq<max( 1, n ) .and. wantq ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHBTRD', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! initialize q to the unit matrix, if needed
           if( initq )call stdlib_claset( 'FULL', n, n, czero, cone, q, ldq )
           ! wherever possible, plane rotations are generated and applied in
           ! vector operations of length nr over the index set j1:j2:kd1.
           ! the real cosines and complex sines of the plane rotations are
           ! stored in the arrays d and work.
           inca = kd1*ldab
           kdn = min( n-1, kd )
           if( upper ) then
              if( kd>1 ) then
                 ! reduce to complex hermitian tridiagonal form, working with
                 ! the upper triangle
                 nr = 0
                 j1 = kdn + 2
                 j2 = 1
                 ab( kd1, 1 ) = real( ab( kd1, 1 ),KIND=sp)
                 loop_90: do i = 1, n - 2
                    ! reduce i-th row of matrix to tridiagonal form
                    loop_80: do k = kdn + 1, 2, -1
                       j1 = j1 + kdn
                       j2 = j2 + kdn
                       if( nr>0 ) then
                          ! generate plane rotations to annihilate nonzero
                          ! elements which have been created outside the band
                          call stdlib_clargv( nr, ab( 1, j1-1 ), inca, work( j1 ),kd1, d( j1 ), &
                                    kd1 )
                          ! apply rotations from the right
                          ! dependent on the the number of diagonals either
                          ! stdlib_clartv or stdlib_crot is used
                          if( nr>=2*kd-1 ) then
                             do l = 1, kd - 1
                                call stdlib_clartv( nr, ab( l+1, j1-1 ), inca,ab( l, j1 ), inca, &
                                          d( j1 ),work( j1 ), kd1 )
                             end do
                          else
                             jend = j1 + ( nr-1 )*kd1
                             do jinc = j1, jend, kd1
                                call stdlib_crot( kdm1, ab( 2, jinc-1 ), 1,ab( 1, jinc ), 1, d( &
                                          jinc ),work( jinc ) )
                             end do
                          end if
                       end if
                       if( k>2 ) then
                          if( k<=n-i+1 ) then
                             ! generate plane rotation to annihilate a(i,i+k-1)
                             ! within the band
                             call stdlib_clartg( ab( kd-k+3, i+k-2 ),ab( kd-k+2, i+k-1 ), d( i+k-&
                                       1 ),work( i+k-1 ), temp )
                             ab( kd-k+3, i+k-2 ) = temp
                             ! apply rotation from the right
                             call stdlib_crot( k-3, ab( kd-k+4, i+k-2 ), 1,ab( kd-k+3, i+k-1 ), 1,&
                                        d( i+k-1 ),work( i+k-1 ) )
                          end if
                          nr = nr + 1
                          j1 = j1 - kdn - 1
                       end if
                       ! apply plane rotations from both sides to diagonal
                       ! blocks
                       if( nr>0 )call stdlib_clar2v( nr, ab( kd1, j1-1 ), ab( kd1, j1 ),ab( kd, &
                                 j1 ), inca, d( j1 ),work( j1 ), kd1 )
                       ! apply plane rotations from the left
                       if( nr>0 ) then
                          call stdlib_clacgv( nr, work( j1 ), kd1 )
                          if( 2*kd-1<nr ) then
                          ! dependent on the the number of diagonals either
                          ! stdlib_clartv or stdlib_crot is used
                             do l = 1, kd - 1
                                if( j2+l>n ) then
                                   nrt = nr - 1
                                else
                                   nrt = nr
                                end if
                                if( nrt>0 )call stdlib_clartv( nrt, ab( kd-l, j1+l ), inca,ab( kd-&
                                          l+1, j1+l ), inca,d( j1 ), work( j1 ), kd1 )
                             end do
                          else
                             j1end = j1 + kd1*( nr-2 )
                             if( j1end>=j1 ) then
                                do jin = j1, j1end, kd1
                                   call stdlib_crot( kd-1, ab( kd-1, jin+1 ), incx,ab( kd, jin+1 )&
                                             , incx,d( jin ), work( jin ) )
                                end do
                             end if
                             lend = min( kdm1, n-j2 )
                             last = j1end + kd1
                             if( lend>0 )call stdlib_crot( lend, ab( kd-1, last+1 ), incx,ab( kd, &
                                       last+1 ), incx, d( last ),work( last ) )
                          end if
                       end if
                       if( wantq ) then
                          ! accumulate product of plane rotations in q
                          if( initq ) then
                       ! take advantage of the fact that q was
                       ! initially the identity matrix
                             iqend = max( iqend, j2 )
                             i2 = max( 0, k-3 )
                             iqaend = 1 + i*kd
                             if( k==2 )iqaend = iqaend + kd
                             iqaend = min( iqaend, iqend )
                             do j = j1, j2, kd1
                                ibl = i - i2 / kdm1
                                i2 = i2 + 1
                                iqb = max( 1, j-ibl )
                                nq = 1 + iqaend - iqb
                                iqaend = min( iqaend+kd, iqend )
                                call stdlib_crot( nq, q( iqb, j-1 ), 1, q( iqb, j ),1, d( j ), &
                                          conjg( work( j ) ) )
                             end do
                          else
                             do j = j1, j2, kd1
                                call stdlib_crot( n, q( 1, j-1 ), 1, q( 1, j ), 1,d( j ), conjg( &
                                          work( j ) ) )
                             end do
                          end if
                       end if
                       if( j2+kdn>n ) then
                          ! adjust j2 to keep within the bounds of the matrix
                          nr = nr - 1
                          j2 = j2 - kdn - 1
                       end if
                       do j = j1, j2, kd1
                          ! create nonzero element a(j-1,j+kd) outside the band
                          ! and store it in work
                          work( j+kd ) = work( j )*ab( 1, j+kd )
                          ab( 1, j+kd ) = d( j )*ab( 1, j+kd )
                       end do
                    end do loop_80
                 end do loop_90
              end if
              if( kd>0 ) then
                 ! make off-diagonal elements real and copy them to e
                 do i = 1, n - 1
                    t = ab( kd, i+1 )
                    abst = abs( t )
                    ab( kd, i+1 ) = abst
                    e( i ) = abst
                    if( abst/=zero ) then
                       t = t / abst
                    else
                       t = cone
                    end if
                    if( i<n-1 )ab( kd, i+2 ) = ab( kd, i+2 )*t
                    if( wantq ) then
                       call stdlib_cscal( n, conjg( t ), q( 1, i+1 ), 1 )
                    end if
                 end do
              else
                 ! set e to zero if original matrix was diagonal
                 do i = 1, n - 1
                    e( i ) = zero
                 end do
              end if
              ! copy diagonal elements to d
              do i = 1, n
                 d( i ) = real( ab( kd1, i ),KIND=sp)
              end do
           else
              if( kd>1 ) then
                 ! reduce to complex hermitian tridiagonal form, working with
                 ! the lower triangle
                 nr = 0
                 j1 = kdn + 2
                 j2 = 1
                 ab( 1, 1 ) = real( ab( 1, 1 ),KIND=sp)
                 loop_210: do i = 1, n - 2
                    ! reduce i-th column of matrix to tridiagonal form
                    loop_200: do k = kdn + 1, 2, -1
                       j1 = j1 + kdn
                       j2 = j2 + kdn
                       if( nr>0 ) then
                          ! generate plane rotations to annihilate nonzero
                          ! elements which have been created outside the band
                          call stdlib_clargv( nr, ab( kd1, j1-kd1 ), inca,work( j1 ), kd1, d( j1 )&
                                    , kd1 )
                          ! apply plane rotations from one side
                          ! dependent on the the number of diagonals either
                          ! stdlib_clartv or stdlib_crot is used
                          if( nr>2*kd-1 ) then
                             do l = 1, kd - 1
                                call stdlib_clartv( nr, ab( kd1-l, j1-kd1+l ), inca,ab( kd1-l+1, &
                                          j1-kd1+l ), inca,d( j1 ), work( j1 ), kd1 )
                             end do
                          else
                             jend = j1 + kd1*( nr-1 )
                             do jinc = j1, jend, kd1
                                call stdlib_crot( kdm1, ab( kd, jinc-kd ), incx,ab( kd1, jinc-kd )&
                                          , incx,d( jinc ), work( jinc ) )
                             end do
                          end if
                       end if
                       if( k>2 ) then
                          if( k<=n-i+1 ) then
                             ! generate plane rotation to annihilate a(i+k-1,i)
                             ! within the band
                             call stdlib_clartg( ab( k-1, i ), ab( k, i ),d( i+k-1 ), work( i+k-1 &
                                       ), temp )
                             ab( k-1, i ) = temp
                             ! apply rotation from the left
                             call stdlib_crot( k-3, ab( k-2, i+1 ), ldab-1,ab( k-1, i+1 ), ldab-1,&
                                        d( i+k-1 ),work( i+k-1 ) )
                          end if
                          nr = nr + 1
                          j1 = j1 - kdn - 1
                       end if
                       ! apply plane rotations from both sides to diagonal
                       ! blocks
                       if( nr>0 )call stdlib_clar2v( nr, ab( 1, j1-1 ), ab( 1, j1 ),ab( 2, j1-1 ),&
                                  inca, d( j1 ),work( j1 ), kd1 )
                       ! apply plane rotations from the right
                          ! dependent on the the number of diagonals either
                          ! stdlib_clartv or stdlib_crot is used
                       if( nr>0 ) then
                          call stdlib_clacgv( nr, work( j1 ), kd1 )
                          if( nr>2*kd-1 ) then
                             do l = 1, kd - 1
                                if( j2+l>n ) then
                                   nrt = nr - 1
                                else
                                   nrt = nr
                                end if
                                if( nrt>0 )call stdlib_clartv( nrt, ab( l+2, j1-1 ), inca,ab( l+1,&
                                           j1 ), inca, d( j1 ),work( j1 ), kd1 )
                             end do
                          else
                             j1end = j1 + kd1*( nr-2 )
                             if( j1end>=j1 ) then
                                do j1inc = j1, j1end, kd1
                                   call stdlib_crot( kdm1, ab( 3, j1inc-1 ), 1,ab( 2, j1inc ), 1, &
                                             d( j1inc ),work( j1inc ) )
                                end do
                             end if
                             lend = min( kdm1, n-j2 )
                             last = j1end + kd1
                             if( lend>0 )call stdlib_crot( lend, ab( 3, last-1 ), 1,ab( 2, last ),&
                                        1, d( last ),work( last ) )
                          end if
                       end if
                       if( wantq ) then
                          ! accumulate product of plane rotations in q
                          if( initq ) then
                       ! take advantage of the fact that q was
                       ! initially the identity matrix
                             iqend = max( iqend, j2 )
                             i2 = max( 0, k-3 )
                             iqaend = 1 + i*kd
                             if( k==2 )iqaend = iqaend + kd
                             iqaend = min( iqaend, iqend )
                             do j = j1, j2, kd1
                                ibl = i - i2 / kdm1
                                i2 = i2 + 1
                                iqb = max( 1, j-ibl )
                                nq = 1 + iqaend - iqb
                                iqaend = min( iqaend+kd, iqend )
                                call stdlib_crot( nq, q( iqb, j-1 ), 1, q( iqb, j ),1, d( j ), &
                                          work( j ) )
                             end do
                          else
                             do j = j1, j2, kd1
                                call stdlib_crot( n, q( 1, j-1 ), 1, q( 1, j ), 1,d( j ), work( j &
                                          ) )
                             end do
                          end if
                       end if
                       if( j2+kdn>n ) then
                          ! adjust j2 to keep within the bounds of the matrix
                          nr = nr - 1
                          j2 = j2 - kdn - 1
                       end if
                       do j = j1, j2, kd1
                          ! create nonzero element a(j+kd,j-1) outside the
                          ! band and store it in work
                          work( j+kd ) = work( j )*ab( kd1, j )
                          ab( kd1, j ) = d( j )*ab( kd1, j )
                       end do
                    end do loop_200
                 end do loop_210
              end if
              if( kd>0 ) then
                 ! make off-diagonal elements real and copy them to e
                 do i = 1, n - 1
                    t = ab( 2, i )
                    abst = abs( t )
                    ab( 2, i ) = abst
                    e( i ) = abst
                    if( abst/=zero ) then
                       t = t / abst
                    else
                       t = cone
                    end if
                    if( i<n-1 )ab( 2, i+1 ) = ab( 2, i+1 )*t
                    if( wantq ) then
                       call stdlib_cscal( n, t, q( 1, i+1 ), 1 )
                    end if
                 end do
              else
                 ! set e to zero if original matrix was diagonal
                 do i = 1, n - 1
                    e( i ) = zero
                 end do
              end if
              ! copy diagonal elements to d
              do i = 1, n
                 d( i ) = real( ab( 1, i ),KIND=sp)
              end do
           end if
           return
     end subroutine stdlib_chbtrd


     pure subroutine stdlib_checon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
     !! CHECON estimates the reciprocal of the condition number of a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by CHETRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(sp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHECON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**h) or inv(u*d*u**h).
              call stdlib_chetrs( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_checon


     pure subroutine stdlib_checon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
     !! CHECON_ROOK estimates the reciprocal of the condition number of a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by CHETRF_ROOK.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(sp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHECON_ROOK', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**h) or inv(u*d*u**h).
              call stdlib_chetrs_rook( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_checon_rook


     subroutine stdlib_cheev( jobz, uplo, n, a, lda, w, work, lwork, rwork,info )
     !! CHEEV computes all eigenvalues and, optionally, eigenvectors of a
     !! complex Hermitian matrix A.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lower, lquery, wantz
           integer(ilp) :: iinfo, imax, inde, indtau, indwrk, iscale, llwork, lwkopt, nb
           real(sp) :: anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           lower = stdlib_lsame( uplo, 'L' )
           lquery = ( lwork==-1 )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( lower .or. stdlib_lsame( uplo, 'U' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'CHETRD', uplo, n, -1, -1, -1 )
              lwkopt = max( 1, ( nb+1 )*n )
              work( 1 ) = lwkopt
              if( lwork<max( 1, 2*n-1 ) .and. .not.lquery )info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHEEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              return
           end if
           if( n==1 ) then
              w( 1 ) = real( a( 1, 1 ),KIND=sp)
              work( 1 ) = 1
              if( wantz )a( 1, 1 ) = cone
              return
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           anrm = stdlib_clanhe( 'M', uplo, n, a, lda, rwork )
           iscale = 0
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 )call stdlib_clascl( uplo, 0, 0, one, sigma, n, n, a, lda, info )
           ! call stdlib_chetrd to reduce hermitian matrix to tridiagonal form.
           inde = 1
           indtau = 1
           indwrk = indtau + n
           llwork = lwork - indwrk + 1
           call stdlib_chetrd( uplo, n, a, lda, w, rwork( inde ), work( indtau ),work( indwrk ), &
                     llwork, iinfo )
           ! for eigenvalues only, call stdlib_ssterf.  for eigenvectors, first call
           ! stdlib_cungtr to generate the unitary matrix, then call stdlib_csteqr.
           if( .not.wantz ) then
              call stdlib_ssterf( n, w, rwork( inde ), info )
           else
              call stdlib_cungtr( uplo, n, a, lda, work( indtau ), work( indwrk ),llwork, iinfo )
                        
              indwrk = inde + n
              call stdlib_csteqr( jobz, n, w, rwork( inde ), a, lda,rwork( indwrk ), info )
                        
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = n
              else
                 imax = info - 1
              end if
              call stdlib_sscal( imax, one / sigma, w, 1 )
           end if
           ! set work(1) to optimal complex workspace size.
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cheev


     subroutine stdlib_cheevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, ldz, &
     !! CHEEVR computes selected eigenvalues and, optionally, eigenvectors
     !! of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can
     !! be selected by specifying either a range of values or a range of
     !! indices for the desired eigenvalues.
     !! CHEEVR first reduces the matrix A to tridiagonal form T with a call
     !! to CHETRD.  Then, whenever possible, CHEEVR calls CSTEMR to compute
     !! the eigenspectrum using Relatively Robust Representations.  CSTEMR
     !! computes eigenvalues by the dqds algorithm, while orthogonal
     !! eigenvectors are computed from various "good" L D L^T representations
     !! (also known as Relatively Robust Representations). Gram-Schmidt
     !! orthogonalization is avoided as far as possible. More specifically,
     !! the various steps of the algorithm are as follows.
     !! For each unreduced block (submatrix) of T,
     !! (a) Compute T - sigma I  = L D L^T, so that L and D
     !! define all the wanted eigenvalues to high relative accuracy.
     !! This means that small relative changes in the entries of D and L
     !! cause only small relative changes in the eigenvalues and
     !! eigenvectors. The standard (unfactored) representation of the
     !! tridiagonal matrix T does not have this property in general.
     !! (b) Compute the eigenvalues to suitable accuracy.
     !! If the eigenvectors are desired, the algorithm attains full
     !! accuracy of the computed eigenvalues only right before
     !! the corresponding vectors have to be computed, see steps c) and d).
     !! (c) For each cluster of close eigenvalues, select a new
     !! shift close to the cluster, find a new factorization, and refine
     !! the shifted eigenvalues to suitable accuracy.
     !! (d) For each eigenvalue with a large enough relative separation compute
     !! the corresponding eigenvector by forming a rank revealing twisted
     !! factorization. Go back to (c) for any clusters that remain.
     !! The desired accuracy of the output can be specified by the input
     !! parameter ABSTOL.
     !! For more details, see CSTEMR's documentation and:
     !! - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
     !! to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
     !! Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
     !! - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
     !! Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
     !! 2004.  Also LAPACK Working Note 154.
     !! - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
     !! tridiagonal eigenvalue/eigenvector problem",
     !! Computer Science Division Technical Report No. UCB/CSD-97-971,
     !! UC Berkeley, May 1997.
     !! Note 1 : CHEEVR calls CSTEMR when the full spectrum is requested
     !! on machines which conform to the ieee-754 floating point standard.
     !! CHEEVR calls SSTEBZ and CSTEIN on non-ieee machines and
     !! when partial spectrum requests are made.
     !! Normal execution of CSTEMR may create NaNs and infinities and
     !! hence may abort due to a floating point exception in environments
     !! which do not handle NaNs and infinities in the ieee standard default
     !! manner.
               isuppz, work, lwork,rwork, lrwork, iwork, liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, iu, lda, ldz, liwork, lrwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, lower, lquery, test, valeig, wantz, tryrac
           character :: order
           integer(ilp) :: i, ieeeok, iinfo, imax, indibl, indifl, indisp, indiwo, indrd, indrdd, &
           indre, indree, indrwk, indtau, indwk, indwkn, iscale, itmp1, j, jj, liwmin, llwork, &
                     llrwork, llwrkn, lrwmin, lwkopt, lwmin, nb, nsplit
           real(sp) :: abstll, anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum, tmp1, vll, &
                     vuu
           ! Intrinsic Functions 
           intrinsic :: max,min,real,sqrt
           ! Executable Statements 
           ! test the input parameters.
           ieeeok = stdlib_ilaenv( 10, 'CHEEVR', 'N', 1, 2, 3, 4 )
           lower = stdlib_lsame( uplo, 'L' )
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( ( lwork==-1 ) .or. ( lrwork==-1 ) .or.( liwork==-1 ) )
           lrwmin = max( 1, 24*n )
           liwmin = max( 1, 10*n )
           lwmin = max( 1, 2*n )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( .not.( lower .or. stdlib_lsame( uplo, 'U' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -8
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -9
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -10
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -15
              end if
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'CHETRD', uplo, n, -1, -1, -1 )
              nb = max( nb, stdlib_ilaenv( 1, 'CUNMTR', uplo, n, -1, -1, -1 ) )
              lwkopt = max( ( nb+1 )*n, lwmin )
              work( 1 ) = lwkopt
              rwork( 1 ) = lrwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -18
              else if( lrwork<lrwmin .and. .not.lquery ) then
                 info = -20
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -22
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHEEVR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           if( n==1 ) then
              work( 1 ) = 2
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = real( a( 1, 1 ),KIND=sp)
              else
                 if( vl<real( a( 1, 1 ),KIND=sp) .and. vu>=real( a( 1, 1 ),KIND=sp) )then
                    m = 1
                    w( 1 ) = real( a( 1, 1 ),KIND=sp)
                 end if
              end if
              if( wantz ) then
                 z( 1, 1 ) = one
                 isuppz( 1 ) = 1
                 isuppz( 2 ) = 1
              end if
              return
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           abstll = abstol
           if (valeig) then
              vll = vl
              vuu = vu
           end if
           anrm = stdlib_clansy( 'M', uplo, n, a, lda, rwork )
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 ) then
              if( lower ) then
                 do j = 1, n
                    call stdlib_csscal( n-j+1, sigma, a( j, j ), 1 )
                 end do
              else
                 do j = 1, n
                    call stdlib_csscal( j, sigma, a( 1, j ), 1 )
                 end do
              end if
              if( abstol>0 )abstll = abstol*sigma
              if( valeig ) then
                 vll = vl*sigma
                 vuu = vu*sigma
              end if
           end if
           ! initialize indices into workspaces.  note: the iwork indices are
           ! used only if stdlib_ssterf or stdlib_cstemr fail.
           ! work(indtau:indtau+n-1) stores the complex scalar factors of the
           ! elementary reflectors used in stdlib_chetrd.
           indtau = 1
           ! indwk is the starting offset of the remaining complex workspace,
           ! and llwork is the remaining complex workspace size.
           indwk = indtau + n
           llwork = lwork - indwk + 1
           ! rwork(indrd:indrd+n-1) stores the real tridiagonal's diagonal
           ! entries.
           indrd = 1
           ! rwork(indre:indre+n-1) stores the off-diagonal entries of the
           ! tridiagonal matrix from stdlib_chetrd.
           indre = indrd + n
           ! rwork(indrdd:indrdd+n-1) is a copy of the diagonal entries over
           ! -written by stdlib_cstemr (the stdlib_ssterf path copies the diagonal to w).
           indrdd = indre + n
           ! rwork(indree:indree+n-1) is a copy of the off-diagonal entries over
           ! -written while computing the eigenvalues in stdlib_ssterf and stdlib_cstemr.
           indree = indrdd + n
           ! indrwk is the starting offset of the left-over real workspace, and
           ! llrwork is the remaining workspace size.
           indrwk = indree + n
           llrwork = lrwork - indrwk + 1
           ! iwork(indibl:indibl+m-1) corresponds to iblock in stdlib_sstebz and
           ! stores the block indices of each of the m<=n eigenvalues.
           indibl = 1
           ! iwork(indisp:indisp+nsplit-1) corresponds to isplit in stdlib_sstebz and
           ! stores the starting and finishing indices of each block.
           indisp = indibl + n
           ! iwork(indifl:indifl+n-1) stores the indices of eigenvectors
           ! that corresponding to eigenvectors that fail to converge in
           ! stdlib_sstein.  this information is discarded; if any fail, the driver
           ! returns info > 0.
           indifl = indisp + n
           ! indiwo is the offset of the remaining integer workspace.
           indiwo = indifl + n
           ! call stdlib_chetrd to reduce hermitian matrix to tridiagonal form.
           call stdlib_chetrd( uplo, n, a, lda, rwork( indrd ), rwork( indre ),work( indtau ), &
                     work( indwk ), llwork, iinfo )
           ! if all eigenvalues are desired
           ! then call stdlib_ssterf or stdlib_cstemr and stdlib_cunmtr.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig.or.test ) .and. ( ieeeok==1 ) ) then
              if( .not.wantz ) then
                 call stdlib_scopy( n, rwork( indrd ), 1, w, 1 )
                 call stdlib_scopy( n-1, rwork( indre ), 1, rwork( indree ), 1 )
                 call stdlib_ssterf( n, w, rwork( indree ), info )
              else
                 call stdlib_scopy( n-1, rwork( indre ), 1, rwork( indree ), 1 )
                 call stdlib_scopy( n, rwork( indrd ), 1, rwork( indrdd ), 1 )
                 if (abstol <= two*n*eps) then
                    tryrac = .true.
                 else
                    tryrac = .false.
                 end if
                 call stdlib_cstemr( jobz, 'A', n, rwork( indrdd ),rwork( indree ), vl, vu, il, &
                 iu, m, w,z, ldz, n, isuppz, tryrac,rwork( indrwk ), llrwork,iwork, liwork, info )
                           
                 ! apply unitary matrix used in reduction to tridiagonal
                 ! form to eigenvectors returned by stdlib_cstemr.
                 if( wantz .and. info==0 ) then
                    indwkn = indwk
                    llwrkn = lwork - indwkn + 1
                    call stdlib_cunmtr( 'L', uplo, 'N', n, m, a, lda,work( indtau ), z, ldz, work(&
                               indwkn ),llwrkn, iinfo )
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 30
              end if
              info = 0
           end if
           ! otherwise, call stdlib_sstebz and, if eigenvectors are desired, stdlib_cstein.
           ! also call stdlib_sstebz and stdlib_cstein if stdlib_cstemr fails.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           call stdlib_sstebz( range, order, n, vll, vuu, il, iu, abstll,rwork( indrd ), rwork( &
           indre ), m, nsplit, w,iwork( indibl ), iwork( indisp ), rwork( indrwk ),iwork( indiwo )&
                     , info )
           if( wantz ) then
              call stdlib_cstein( n, rwork( indrd ), rwork( indre ), m, w,iwork( indibl ), iwork( &
                        indisp ), z, ldz,rwork( indrwk ), iwork( indiwo ), iwork( indifl ),info )
              ! apply unitary matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_cstein.
              indwkn = indwk
              llwrkn = lwork - indwkn + 1
              call stdlib_cunmtr( 'L', uplo, 'N', n, m, a, lda, work( indtau ), z,ldz, work( &
                        indwkn ), llwrkn, iinfo )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           30 continue
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = m
              else
                 imax = info - 1
              end if
              call stdlib_sscal( imax, one / sigma, w, 1 )
           end if
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_cswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                 end if
              end do
           end if
           ! set work(1) to optimal workspace size.
           work( 1 ) = lwkopt
           rwork( 1 ) = lrwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_cheevr


     subroutine stdlib_cheevx( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, ldz, &
     !! CHEEVX computes selected eigenvalues and, optionally, eigenvectors
     !! of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can
     !! be selected by specifying either a range of values or a range of
     !! indices for the desired eigenvalues.
               work, lwork, rwork,iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, iu, lda, ldz, lwork, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, lower, lquery, test, valeig, wantz
           character :: order
           integer(ilp) :: i, iinfo, imax, indd, inde, indee, indibl, indisp, indiwk, indrwk, &
                     indtau, indwrk, iscale, itmp1, j, jj, llwork, lwkmin, lwkopt, nb, nsplit
           real(sp) :: abstll, anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum, tmp1, vll, &
                     vuu
           ! Intrinsic Functions 
           intrinsic :: real,max,min,sqrt
           ! Executable Statements 
           ! test the input parameters.
           lower = stdlib_lsame( uplo, 'L' )
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( lwork==-1 )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( .not.( lower .or. stdlib_lsame( uplo, 'U' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -8
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -9
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -10
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -15
              end if
           end if
           if( info==0 ) then
              if( n<=1 ) then
                 lwkmin = 1
                 work( 1 ) = lwkmin
              else
                 lwkmin = 2*n
                 nb = stdlib_ilaenv( 1, 'CHETRD', uplo, n, -1, -1, -1 )
                 nb = max( nb, stdlib_ilaenv( 1, 'CUNMTR', uplo, n, -1, -1, -1 ) )
                 lwkopt = max( 1, ( nb + 1 )*n )
                 work( 1 ) = lwkopt
              end if
              if( lwork<lwkmin .and. .not.lquery )info = -17
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHEEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 ) then
              return
           end if
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = real( a( 1, 1 ),KIND=sp)
              else if( valeig ) then
                 if( vl<real( a( 1, 1 ),KIND=sp) .and. vu>=real( a( 1, 1 ),KIND=sp) )then
                    m = 1
                    w( 1 ) = real( a( 1, 1 ),KIND=sp)
                 end if
              end if
              if( wantz )z( 1, 1 ) = cone
              return
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           abstll = abstol
           if( valeig ) then
              vll = vl
              vuu = vu
           end if
           anrm = stdlib_clanhe( 'M', uplo, n, a, lda, rwork )
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 ) then
              if( lower ) then
                 do j = 1, n
                    call stdlib_csscal( n-j+1, sigma, a( j, j ), 1 )
                 end do
              else
                 do j = 1, n
                    call stdlib_csscal( j, sigma, a( 1, j ), 1 )
                 end do
              end if
              if( abstol>0 )abstll = abstol*sigma
              if( valeig ) then
                 vll = vl*sigma
                 vuu = vu*sigma
              end if
           end if
           ! call stdlib_chetrd to reduce hermitian matrix to tridiagonal form.
           indd = 1
           inde = indd + n
           indrwk = inde + n
           indtau = 1
           indwrk = indtau + n
           llwork = lwork - indwrk + 1
           call stdlib_chetrd( uplo, n, a, lda, rwork( indd ), rwork( inde ),work( indtau ), work(&
                      indwrk ), llwork, iinfo )
           ! if all eigenvalues are desired and abstol is less than or equal to
           ! zero, then call stdlib_ssterf or stdlib_cungtr and stdlib_csteqr.  if this fails for
           ! some eigenvalue, then try stdlib_sstebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ( abstol<=zero ) ) then
              call stdlib_scopy( n, rwork( indd ), 1, w, 1 )
              indee = indrwk + 2*n
              if( .not.wantz ) then
                 call stdlib_scopy( n-1, rwork( inde ), 1, rwork( indee ), 1 )
                 call stdlib_ssterf( n, w, rwork( indee ), info )
              else
                 call stdlib_clacpy( 'A', n, n, a, lda, z, ldz )
                 call stdlib_cungtr( uplo, n, z, ldz, work( indtau ),work( indwrk ), llwork, &
                           iinfo )
                 call stdlib_scopy( n-1, rwork( inde ), 1, rwork( indee ), 1 )
                 call stdlib_csteqr( jobz, n, w, rwork( indee ), z, ldz,rwork( indrwk ), info )
                           
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 40
              end if
              info = 0
           end if
           ! otherwise, call stdlib_sstebz and, if eigenvectors are desired, stdlib_cstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indibl = 1
           indisp = indibl + n
           indiwk = indisp + n
           call stdlib_sstebz( range, order, n, vll, vuu, il, iu, abstll,rwork( indd ), rwork( &
           inde ), m, nsplit, w,iwork( indibl ), iwork( indisp ), rwork( indrwk ),iwork( indiwk ),&
                      info )
           if( wantz ) then
              call stdlib_cstein( n, rwork( indd ), rwork( inde ), m, w,iwork( indibl ), iwork( &
                        indisp ), z, ldz,rwork( indrwk ), iwork( indiwk ), ifail, info )
              ! apply unitary matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_cstein.
              call stdlib_cunmtr( 'L', uplo, 'N', n, m, a, lda, work( indtau ), z,ldz, work( &
                        indwrk ), llwork, iinfo )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           40 continue
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = m
              else
                 imax = info - 1
              end if
              call stdlib_sscal( imax, one / sigma, w, 1 )
           end if
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_cswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           ! set work(1) to optimal complex workspace size.
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cheevx


     subroutine stdlib_chegv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, info )
     !! CHEGV computes all the eigenvalues, and optionally, the eigenvectors
     !! of a complex generalized Hermitian-definite eigenproblem, of the form
     !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
     !! Here A and B are assumed to be Hermitian and B is also
     !! positive definite.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: itype, lda, ldb, lwork, n
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper, wantz
           character :: trans
           integer(ilp) :: lwkopt, nb, neig
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork== -1 )
           info = 0
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -2
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'CHETRD', uplo, n, -1, -1, -1 )
              lwkopt = max( 1, ( nb + 1 )*n )
              work( 1 ) = lwkopt
              if( lwork<max( 1, 2*n-1 ) .and. .not.lquery ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHEGV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a cholesky factorization of b.
           call stdlib_cpotrf( uplo, n, b, ldb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem and solve.
           call stdlib_chegst( itype, uplo, n, a, lda, b, ldb, info )
           call stdlib_cheev( jobz, uplo, n, a, lda, w, work, lwork, rwork, info )
           if( wantz ) then
              ! backtransform eigenvectors to the original problem.
              neig = n
              if( info>0 )neig = info - 1
              if( itype==1 .or. itype==2 ) then
                 ! for a*x=(lambda)*b*x and a*b*x=(lambda)*x;
                 ! backtransform eigenvectors: x = inv(l)**h*y or inv(u)*y
                 if( upper ) then
                    trans = 'N'
                 else
                    trans = 'C'
                 end if
                 call stdlib_ctrsm( 'LEFT', uplo, trans, 'NON-UNIT', n, neig, cone,b, ldb, a, lda &
                           )
              else if( itype==3 ) then
                 ! for b*a*x=(lambda)*x;
                 ! backtransform eigenvectors: x = l*y or u**h*y
                 if( upper ) then
                    trans = 'C'
                 else
                    trans = 'N'
                 end if
                 call stdlib_ctrmm( 'LEFT', uplo, trans, 'NON-UNIT', n, neig, cone,b, ldb, a, lda &
                           )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chegv


     subroutine stdlib_chegvx( itype, jobz, range, uplo, n, a, lda, b, ldb,vl, vu, il, iu, abstol,&
     !! CHEGVX computes selected eigenvalues, and optionally, eigenvectors
     !! of a complex generalized Hermitian-definite eigenproblem, of the form
     !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
     !! B are assumed to be Hermitian and B is also positive definite.
     !! Eigenvalues and eigenvectors can be selected by specifying either a
     !! range of values or a range of indices for the desired eigenvalues.
                m, w, z, ldz, work,lwork, rwork, iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, itype, iu, lda, ldb, ldz, lwork, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, lquery, upper, valeig, wantz
           character :: trans
           integer(ilp) :: lwkopt, nb
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( lwork==-1 )
           info = 0
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -2
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -3
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -11
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -12
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -13
                 end if
              end if
           end if
           if (info==0) then
              if (ldz<1 .or. (wantz .and. ldz<n)) then
                 info = -18
              end if
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'CHETRD', uplo, n, -1, -1, -1 )
              lwkopt = max( 1, ( nb + 1 )*n )
              work( 1 ) = lwkopt
              if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHEGVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 ) then
              return
           end if
           ! form a cholesky factorization of b.
           call stdlib_cpotrf( uplo, n, b, ldb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem and solve.
           call stdlib_chegst( itype, uplo, n, a, lda, b, ldb, info )
           call stdlib_cheevx( jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol,m, w, z, ldz, &
                     work, lwork, rwork, iwork, ifail,info )
           if( wantz ) then
              ! backtransform eigenvectors to the original problem.
              if( info>0 )m = info - 1
              if( itype==1 .or. itype==2 ) then
                 ! for a*x=(lambda)*b*x and a*b*x=(lambda)*x;
                 ! backtransform eigenvectors: x = inv(l)**h*y or inv(u)*y
                 if( upper ) then
                    trans = 'N'
                 else
                    trans = 'C'
                 end if
                 call stdlib_ctrsm( 'LEFT', uplo, trans, 'NON-UNIT', n, m, cone, b,ldb, z, ldz )
                           
              else if( itype==3 ) then
                 ! for b*a*x=(lambda)*x;
                 ! backtransform eigenvectors: x = l*y or u**h*y
                 if( upper ) then
                    trans = 'C'
                 else
                    trans = 'N'
                 end if
                 call stdlib_ctrmm( 'LEFT', uplo, trans, 'NON-UNIT', n, m, cone, b,ldb, z, ldz )
                           
              end if
           end if
           ! set work(1) to optimal complex workspace size.
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chegvx


     pure subroutine stdlib_cherfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr, &
     !! CHERFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is Hermitian indefinite, and
     !! provides error bounds and backward error estimates for the solution.
               berr, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, j, k, kase, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldaf<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHERFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_ccopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_chemv( uplo, n, -cone, a, lda, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + abs( real( a( k, k ),KIND=sp) )*xk + s
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + abs( real( a( k, k ),KIND=sp) )*xk
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_chetrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                 call stdlib_caxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**h).
                    call stdlib_chetrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_chetrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_cherfs


     pure subroutine stdlib_chesv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CHESV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**H,  if UPLO = 'U', or
     !! A = L * D * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, nb
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'CHETRF', uplo, n, -1, -1, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHESV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_chetrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_chetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_chetrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chesv


     pure subroutine stdlib_chesv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info )
     !! CHESV_RK computes the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N Hermitian matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**H)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**H)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! CHETRF_RK is called to compute the factorization of a complex
     !! Hermitian matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine CHETRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_chetrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=sp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHESV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_chetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_chetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chesv_rk


     pure subroutine stdlib_chesv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CHESV_ROOK computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! The bounded Bunch-Kaufman ("rook") diagonal pivoting method is used
     !! to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! CHETRF_ROOK is called to compute the factorization of a complex
     !! Hermition matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling CHETRS_ROOK (uses BLAS 2).
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, nb
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'CHETRF_ROOK', uplo, n, -1, -1, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHESV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_chetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs ( use level blas 2)
              call stdlib_chetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chesv_rook


     subroutine stdlib_chesvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,ldb, x, ldx, rcond, &
     !! CHESVX uses the diagonal pivoting factorization to compute the
     !! solution to a complex system of linear equations A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               ferr, berr, work, lwork,rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, lwork, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: a(lda,*), b(ldb,*)
           complex(sp), intent(inout) :: af(ldaf,*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, nofact
           integer(ilp) :: lwkopt, nb
           real(sp) :: anorm
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           lquery = ( lwork==-1 )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldaf<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -11
           else if( ldx<max( 1, n ) ) then
              info = -13
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info==0 ) then
              lwkopt = max( 1, 2*n )
              if( nofact ) then
                 nb = stdlib_ilaenv( 1, 'CHETRF', uplo, n, -1, -1, -1 )
                 lwkopt = max( lwkopt, n*nb )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHESVX', -info )
              return
           else if( lquery ) then
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**h or a = l*d*l**h.
              call stdlib_clacpy( uplo, n, n, a, lda, af, ldaf )
              call stdlib_chetrf( uplo, n, af, ldaf, ipiv, work, lwork, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_clanhe( 'I', uplo, n, a, lda, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_checon( uplo, n, af, ldaf, ipiv, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_clacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_chetrs( uplo, n, nrhs, af, ldaf, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_cherfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x,ldx, ferr, berr, &
                     work, rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chesvx


     subroutine stdlib_chgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alpha, beta, q, ldq,&
     !! CHGEQZ computes the eigenvalues of a complex matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the single-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a complex matrix pair (A,B):
     !! A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
     !! as computed by CGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**H,  T = Q*P*Z**H,
     !! where Q and Z are unitary matrices and S and P are upper triangular.
     !! Optionally, the unitary matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! unitary matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the unitary matrices from CGGHRD that reduced
     !! the matrix pair (A,B) to generalized Hessenberg form, then the output
     !! matrices Q1*Q and Z1*Z are the unitary factors from the generalized
     !! Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T)
     !! (equivalently, of (A,B)) are computed as a pair of complex values
     !! (alpha,beta).  If beta is nonzero, lambda = alpha / beta is an
     !! eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! The values of alpha and beta for the i-th eigenvalue can be read
     !! directly from the generalized Schur form:  alpha = S(i,i),
     !! beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
                z, ldz, work, lwork,rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compq, compz, job
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(out) :: alpha(*), beta(*), work(*)
           complex(sp), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
        ! =====================================================================
           
           
           
           ! Local Scalars 
           logical(lk) :: ilazr2, ilazro, ilq, ilschr, ilz, lquery
           integer(ilp) :: icompq, icompz, ifirst, ifrstm, iiter, ilast, ilastm, in, ischur, &
                     istart, j, jc, jch, jiter, jr, maxit
           real(sp) :: absb, anorm, ascale, atol, bnorm, bscale, btol, c, safmin, temp, temp2, &
                     tempr, ulp
           complex(sp) :: abi22, ad11, ad12, ad21, ad22, ctemp, ctemp2, ctemp3, eshift, s, shift, &
                     signbc, u12, x, abi12, y
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,conjg,max,min,real,sqrt
           ! Statement Functions 
           real(sp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=sp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode job, compq, compz
           if( stdlib_lsame( job, 'E' ) ) then
              ilschr = .false.
              ischur = 1
           else if( stdlib_lsame( job, 'S' ) ) then
              ilschr = .true.
              ischur = 2
           else
              ilschr = .true.
              ischur = 0
           end if
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              ilq = .true.
              icompq = 0
           end if
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              ilz = .true.
              icompz = 0
           end if
           ! check argument values
           info = 0
           work( 1 ) = max( 1, n )
           lquery = ( lwork==-1 )
           if( ischur==0 ) then
              info = -1
           else if( icompq==0 ) then
              info = -2
           else if( icompz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( ldh<n ) then
              info = -8
           else if( ldt<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -14
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -16
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHGEQZ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           ! work( 1 ) = cmplx( 1,KIND=sp)
           if( n<=0 ) then
              work( 1 ) = cmplx( 1,KIND=sp)
              return
           end if
           ! initialize q and z
           if( icompq==3 )call stdlib_claset( 'FULL', n, n, czero, cone, q, ldq )
           if( icompz==3 )call stdlib_claset( 'FULL', n, n, czero, cone, z, ldz )
           ! machine constants
           in = ihi + 1 - ilo
           safmin = stdlib_slamch( 'S' )
           ulp = stdlib_slamch( 'E' )*stdlib_slamch( 'B' )
           anorm = stdlib_clanhs( 'F', in, h( ilo, ilo ), ldh, rwork )
           bnorm = stdlib_clanhs( 'F', in, t( ilo, ilo ), ldt, rwork )
           atol = max( safmin, ulp*anorm )
           btol = max( safmin, ulp*bnorm )
           ascale = one / max( safmin, anorm )
           bscale = one / max( safmin, bnorm )
           ! set eigenvalues ihi+1:n
           do j = ihi + 1, n
              absb = abs( t( j, j ) )
              if( absb>safmin ) then
                 signbc = conjg( t( j, j ) / absb )
                 t( j, j ) = absb
                 if( ilschr ) then
                    call stdlib_cscal( j-1, signbc, t( 1, j ), 1 )
                    call stdlib_cscal( j, signbc, h( 1, j ), 1 )
                 else
                    call stdlib_cscal( 1, signbc, h( j, j ), 1 )
                 end if
                 if( ilz )call stdlib_cscal( n, signbc, z( 1, j ), 1 )
              else
                 t( j, j ) = czero
              end if
              alpha( j ) = h( j, j )
              beta( j ) = t( j, j )
           end do
           ! if ihi < ilo, skip qz steps
           if( ihi<ilo )go to 190
           ! main qz iteration loop
           ! initialize dynamic indices
           ! eigenvalues ilast+1:n have been found.
              ! column operations modify rows ifrstm:whatever
              ! row operations modify columns whatever:ilastm
           ! if only eigenvalues are being computed, then
              ! ifrstm is the row of the last splitting row above row ilast;
              ! this is always at least ilo.
           ! iiter counts iterations since the last eigenvalue was found,
              ! to tell when to use an extraordinary shift.
           ! maxit is the maximum number of qz sweeps allowed.
           ilast = ihi
           if( ilschr ) then
              ifrstm = 1
              ilastm = n
           else
              ifrstm = ilo
              ilastm = ihi
           end if
           iiter = 0
           eshift = czero
           maxit = 30*( ihi-ilo+1 )
           loop_170: do jiter = 1, maxit
              ! check for too many iterations.
              if( jiter>maxit )go to 180
              ! split the matrix if possible.
              ! two tests:
                 ! 1: h(j,j-1)=0  or  j=ilo
                 ! 2: t(j,j)=0
              ! special case: j=ilast
              if( ilast==ilo ) then
                 go to 60
              else
                 if( abs1( h( ilast, ilast-1 ) )<=max( safmin, ulp*(abs1( h( ilast, ilast ) ) + &
                           abs1( h( ilast-1, ilast-1 )) ) ) ) then
                    h( ilast, ilast-1 ) = czero
                    go to 60
                 end if
              end if
              if( abs( t( ilast, ilast ) )<=max( safmin, ulp*(abs( t( ilast - 1, ilast ) ) + abs( &
                        t( ilast-1, ilast-1 )) ) ) ) then
                 t( ilast, ilast ) = czero
                 go to 50
              end if
              ! general case: j<ilast
              loop_40: do j = ilast - 1, ilo, -1
                 ! test 1: for h(j,j-1)=0 or j=ilo
                 if( j==ilo ) then
                    ilazro = .true.
                 else
                    if( abs1( h( j, j-1 ) )<=max( safmin, ulp*(abs1( h( j, j ) ) + abs1( h( j-1, &
                              j-1 ) )) ) ) then
                       h( j, j-1 ) = czero
                       ilazro = .true.
                    else
                       ilazro = .false.
                    end if
                 end if
                 ! test 2: for t(j,j)=0
                 temp = abs ( t( j, j + 1 ) )
                 if ( j > ilo )temp = temp + abs ( t( j - 1, j ) )
                 if( abs( t( j, j ) )<max( safmin,ulp*temp ) ) then
                    t( j, j ) = czero
                    ! test 1a: check for 2 consecutive small subdiagonals in a
                    ilazr2 = .false.
                    if( .not.ilazro ) then
                       if( abs1( h( j, j-1 ) )*( ascale*abs1( h( j+1,j ) ) )<=abs1( h( j, j ) )*( &
                                 ascale*atol ) )ilazr2 = .true.
                    end if
                    ! if both tests pass (1
                    ! element of b in the block is zero, split a 1x1 block off
                    ! at the top. (i.e., at the j-th row/column) the leading
                    ! diagonal element of the remainder can also be zero, so
                    ! this may have to be done repeatedly.
                    if( ilazro .or. ilazr2 ) then
                       do jch = j, ilast - 1
                          ctemp = h( jch, jch )
                          call stdlib_clartg( ctemp, h( jch+1, jch ), c, s,h( jch, jch ) )
                          h( jch+1, jch ) = czero
                          call stdlib_crot( ilastm-jch, h( jch, jch+1 ), ldh,h( jch+1, jch+1 ), &
                                    ldh, c, s )
                          call stdlib_crot( ilastm-jch, t( jch, jch+1 ), ldt,t( jch+1, jch+1 ), &
                                    ldt, c, s )
                          if( ilq )call stdlib_crot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, conjg(&
                                     s ) )
                          if( ilazr2 )h( jch, jch-1 ) = h( jch, jch-1 )*c
                          ilazr2 = .false.
                          if( abs1( t( jch+1, jch+1 ) )>=btol ) then
                             if( jch+1>=ilast ) then
                                go to 60
                             else
                                ifirst = jch + 1
                                go to 70
                             end if
                          end if
                          t( jch+1, jch+1 ) = czero
                       end do
                       go to 50
                    else
                       ! only test 2 passed -- chase the zero to t(ilast,ilast)
                       ! then process as in the case t(ilast,ilast)=0
                       do jch = j, ilast - 1
                          ctemp = t( jch, jch+1 )
                          call stdlib_clartg( ctemp, t( jch+1, jch+1 ), c, s,t( jch, jch+1 ) )
                                    
                          t( jch+1, jch+1 ) = czero
                          if( jch<ilastm-1 )call stdlib_crot( ilastm-jch-1, t( jch, jch+2 ), ldt,&
                                    t( jch+1, jch+2 ), ldt, c, s )
                          call stdlib_crot( ilastm-jch+2, h( jch, jch-1 ), ldh,h( jch+1, jch-1 ), &
                                    ldh, c, s )
                          if( ilq )call stdlib_crot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, conjg(&
                                     s ) )
                          ctemp = h( jch+1, jch )
                          call stdlib_clartg( ctemp, h( jch+1, jch-1 ), c, s,h( jch+1, jch ) )
                                    
                          h( jch+1, jch-1 ) = czero
                          call stdlib_crot( jch+1-ifrstm, h( ifrstm, jch ), 1,h( ifrstm, jch-1 ), &
                                    1, c, s )
                          call stdlib_crot( jch-ifrstm, t( ifrstm, jch ), 1,t( ifrstm, jch-1 ), 1,&
                                     c, s )
                          if( ilz )call stdlib_crot( n, z( 1, jch ), 1, z( 1, jch-1 ), 1,c, s )
                                    
                       end do
                       go to 50
                    end if
                 else if( ilazro ) then
                    ! only test 1 passed -- work on j:ilast
                    ifirst = j
                    go to 70
                 end if
                 ! neither test passed -- try next j
              end do loop_40
              ! (drop-through is "impossible")
              info = 2*n + 1
              go to 210
              ! t(ilast,ilast)=0 -- clear h(ilast,ilast-1) to split off a
              ! 1x1 block.
              50 continue
              ctemp = h( ilast, ilast )
              call stdlib_clartg( ctemp, h( ilast, ilast-1 ), c, s,h( ilast, ilast ) )
              h( ilast, ilast-1 ) = czero
              call stdlib_crot( ilast-ifrstm, h( ifrstm, ilast ), 1,h( ifrstm, ilast-1 ), 1, c, s &
                        )
              call stdlib_crot( ilast-ifrstm, t( ifrstm, ilast ), 1,t( ifrstm, ilast-1 ), 1, c, s &
                        )
              if( ilz )call stdlib_crot( n, z( 1, ilast ), 1, z( 1, ilast-1 ), 1, c, s )
              ! h(ilast,ilast-1)=0 -- standardize b, set alpha and beta
              60 continue
              absb = abs( t( ilast, ilast ) )
              if( absb>safmin ) then
                 signbc = conjg( t( ilast, ilast ) / absb )
                 t( ilast, ilast ) = absb
                 if( ilschr ) then
                    call stdlib_cscal( ilast-ifrstm, signbc, t( ifrstm, ilast ), 1 )
                    call stdlib_cscal( ilast+1-ifrstm, signbc, h( ifrstm, ilast ),1 )
                 else
                    call stdlib_cscal( 1, signbc, h( ilast, ilast ), 1 )
                 end if
                 if( ilz )call stdlib_cscal( n, signbc, z( 1, ilast ), 1 )
              else
                 t( ilast, ilast ) = czero
              end if
              alpha( ilast ) = h( ilast, ilast )
              beta( ilast ) = t( ilast, ilast )
              ! go to next block -- exit if finished.
              ilast = ilast - 1
              if( ilast<ilo )go to 190
              ! reset counters
              iiter = 0
              eshift = czero
              if( .not.ilschr ) then
                 ilastm = ilast
                 if( ifrstm>ilast )ifrstm = ilo
              end if
              go to 160
              ! qz step
              ! this iteration only involves rows/columns ifirst:ilast.  we
              ! assume ifirst < ilast, and that the diagonal of b is non-zero.
              70 continue
              iiter = iiter + 1
              if( .not.ilschr ) then
                 ifrstm = ifirst
              end if
              ! compute the shift.
              ! at this point, ifirst < ilast, and the diagonal elements of
              ! t(ifirst:ilast,ifirst,ilast) are larger than btol (in
              ! magnitude)
              if( ( iiter / 10 )*10/=iiter ) then
                 ! the wilkinson shift (aep p.512_sp), i.e., the eigenvalue of
                 ! the bottom-right 2x2 block of a inv(b) which is nearest to
                 ! the bottom-right element.
                 ! we factor b as u*d, where u has unit diagonals, and
                 ! compute (a*inv(d))*inv(u).
                 u12 = ( bscale*t( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad11 = ( ascale*h( ilast-1, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad21 = ( ascale*h( ilast, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad12 = ( ascale*h( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad22 = ( ascale*h( ilast, ilast ) ) /( bscale*t( ilast, ilast ) )
                 abi22 = ad22 - u12*ad21
                 abi12 = ad12 - u12*ad11
                 shift = abi22
                 ctemp = sqrt( abi12 )*sqrt( ad21 )
                 temp = abs1( ctemp )
                 if( ctemp/=zero ) then
                    x = half*( ad11-shift )
                    temp2 = abs1( x )
                    temp = max( temp, abs1( x ) )
                    y = temp*sqrt( ( x / temp )**2+( ctemp / temp )**2 )
                    if( temp2>zero ) then
                       if( real( x / temp2,KIND=sp)*real( y,KIND=sp)+aimag( x / temp2 )*aimag( y )&
                                 <zero )y = -y
                    end if
                    shift = shift - ctemp*stdlib_cladiv( ctemp, ( x+y ) )
                 end if
              else
                 ! exceptional shift.  chosen for no particularly good reason.
                 if( ( iiter / 20 )*20==iiter .and.bscale*abs1(t( ilast, ilast ))>safmin ) &
                           then
                    eshift = eshift + ( ascale*h( ilast,ilast ) )/( bscale*t( ilast, ilast ) )
                              
                 else
                    eshift = eshift + ( ascale*h( ilast,ilast-1 ) )/( bscale*t( ilast-1, ilast-1 )&
                               )
                 end if
                 shift = eshift
              end if
              ! now check for two consecutive small subdiagonals.
              do j = ilast - 1, ifirst + 1, -1
                 istart = j
                 ctemp = ascale*h( j, j ) - shift*( bscale*t( j, j ) )
                 temp = abs1( ctemp )
                 temp2 = ascale*abs1( h( j+1, j ) )
                 tempr = max( temp, temp2 )
                 if( tempr<one .and. tempr/=zero ) then
                    temp = temp / tempr
                    temp2 = temp2 / tempr
                 end if
                 if( abs1( h( j, j-1 ) )*temp2<=temp*atol )go to 90
              end do
              istart = ifirst
              ctemp = ascale*h( ifirst, ifirst ) -shift*( bscale*t( ifirst, ifirst ) )
              90 continue
              ! do an implicit-shift qz sweep.
              ! initial q
              ctemp2 = ascale*h( istart+1, istart )
              call stdlib_clartg( ctemp, ctemp2, c, s, ctemp3 )
              ! sweep
              loop_150: do j = istart, ilast - 1
                 if( j>istart ) then
                    ctemp = h( j, j-1 )
                    call stdlib_clartg( ctemp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                    h( j+1, j-1 ) = czero
                 end if
                 do jc = j, ilastm
                    ctemp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -conjg( s )*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = ctemp
                    ctemp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -conjg( s )*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = ctemp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       ctemp = c*q( jr, j ) + conjg( s )*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = ctemp
                    end do
                 end if
                 ctemp = t( j+1, j+1 )
                 call stdlib_clartg( ctemp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = czero
                 do jr = ifrstm, min( j+2, ilast )
                    ctemp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -conjg( s )*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = ctemp
                 end do
                 do jr = ifrstm, j
                    ctemp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -conjg( s )*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = ctemp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       ctemp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -conjg( s )*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = ctemp
                    end do
                 end if
              end do loop_150
              160 continue
           end do loop_170
           ! drop-through = non-convergence
           180 continue
           info = ilast
           go to 210
           ! successful completion of all qz steps
           190 continue
           ! set eigenvalues 1:ilo-1
           do j = 1, ilo - 1
              absb = abs( t( j, j ) )
              if( absb>safmin ) then
                 signbc = conjg( t( j, j ) / absb )
                 t( j, j ) = absb
                 if( ilschr ) then
                    call stdlib_cscal( j-1, signbc, t( 1, j ), 1 )
                    call stdlib_cscal( j, signbc, h( 1, j ), 1 )
                 else
                    call stdlib_cscal( 1, signbc, h( j, j ), 1 )
                 end if
                 if( ilz )call stdlib_cscal( n, signbc, z( 1, j ), 1 )
              else
                 t( j, j ) = czero
              end if
              alpha( j ) = h( j, j )
              beta( j ) = t( j, j )
           end do
           ! normal termination
           info = 0
           ! exit (other than argument error) -- return optimal workspace size
           210 continue
           work( 1 ) = cmplx( n,KIND=sp)
           return
     end subroutine stdlib_chgeqz


     pure subroutine stdlib_chpcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
     !! CHPCON estimates the reciprocal of the condition number of a complex
     !! Hermitian packed matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by CHPTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: ap(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, ip, kase
           real(sp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( anorm<zero ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              ip = n*( n+1 ) / 2
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip - i
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              ip = 1
              do i = 1, n
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip + n - i + 1
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**h) or inv(u*d*u**h).
              call stdlib_chptrs( uplo, n, 1, ap, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_chpcon


     subroutine stdlib_chpev( jobz, uplo, n, ap, w, z, ldz, work, rwork,info )
     !! CHPEV computes all the eigenvalues and, optionally, eigenvectors of a
     !! complex Hermitian matrix in packed storage.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: wantz
           integer(ilp) :: iinfo, imax, inde, indrwk, indtau, indwrk, iscale
           real(sp) :: anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum
           ! Intrinsic Functions 
           intrinsic :: sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( stdlib_lsame( uplo, 'L' ) .or. stdlib_lsame( uplo, 'U' ) ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPEV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              w( 1 ) = real( ap( 1 ),KIND=sp)
              rwork( 1 ) = 1
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           anrm = stdlib_clanhp( 'M', uplo, n, ap, rwork )
           iscale = 0
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 ) then
              call stdlib_csscal( ( n*( n+1 ) ) / 2, sigma, ap, 1 )
           end if
           ! call stdlib_chptrd to reduce hermitian packed matrix to tridiagonal form.
           inde = 1
           indtau = 1
           call stdlib_chptrd( uplo, n, ap, w, rwork( inde ), work( indtau ),iinfo )
           ! for eigenvalues only, call stdlib_ssterf.  for eigenvectors, first call
           ! stdlib_cupgtr to generate the orthogonal matrix, then call stdlib_csteqr.
           if( .not.wantz ) then
              call stdlib_ssterf( n, w, rwork( inde ), info )
           else
              indwrk = indtau + n
              call stdlib_cupgtr( uplo, n, ap, work( indtau ), z, ldz,work( indwrk ), iinfo )
                        
              indrwk = inde + n
              call stdlib_csteqr( jobz, n, w, rwork( inde ), z, ldz,rwork( indrwk ), info )
                        
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = n
              else
                 imax = info - 1
              end if
              call stdlib_sscal( imax, one / sigma, w, 1 )
           end if
           return
     end subroutine stdlib_chpev


     subroutine stdlib_chpevx( jobz, range, uplo, n, ap, vl, vu, il, iu,abstol, m, w, z, ldz, &
     !! CHPEVX computes selected eigenvalues and, optionally, eigenvectors
     !! of a complex Hermitian matrix A in packed storage.
     !! Eigenvalues/vectors can be selected by specifying either a range of
     !! values or a range of indices for the desired eigenvalues.
               work, rwork, iwork,ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, iu, ldz, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, valeig, wantz
           character :: order
           integer(ilp) :: i, iinfo, imax, indd, inde, indee, indibl, indisp, indiwk, indrwk, &
                     indtau, indwrk, iscale, itmp1, j, jj, nsplit
           real(sp) :: abstll, anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum, tmp1, vll, &
                     vuu
           ! Intrinsic Functions 
           intrinsic :: max,min,real,sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( .not.( stdlib_lsame( uplo, 'L' ) .or. stdlib_lsame( uplo, 'U' ) ) )&
                     then
              info = -3
           else if( n<0 ) then
              info = -4
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -7
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -8
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -9
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) )info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPEVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = real( ap( 1 ),KIND=sp)
              else
                 if( vl<real( ap( 1 ),KIND=sp) .and. vu>=real( ap( 1 ),KIND=sp) ) then
                    m = 1
                    w( 1 ) = real( ap( 1 ),KIND=sp)
                 end if
              end if
              if( wantz )z( 1, 1 ) = cone
              return
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           abstll = abstol
           if ( valeig ) then
              vll = vl
              vuu = vu
           else
              vll = zero
              vuu = zero
           endif
           anrm = stdlib_clanhp( 'M', uplo, n, ap, rwork )
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 ) then
              call stdlib_csscal( ( n*( n+1 ) ) / 2, sigma, ap, 1 )
              if( abstol>0 )abstll = abstol*sigma
              if( valeig ) then
                 vll = vl*sigma
                 vuu = vu*sigma
              end if
           end if
           ! call stdlib_chptrd to reduce hermitian packed matrix to tridiagonal form.
           indd = 1
           inde = indd + n
           indrwk = inde + n
           indtau = 1
           indwrk = indtau + n
           call stdlib_chptrd( uplo, n, ap, rwork( indd ), rwork( inde ),work( indtau ), iinfo )
                     
           ! if all eigenvalues are desired and abstol is less than or equal
           ! to zero, then call stdlib_ssterf or stdlib_cupgtr and stdlib_csteqr.  if this fails
           ! for some eigenvalue, then try stdlib_sstebz.
           test = .false.
           if (indeig) then
              if (il==1 .and. iu==n) then
                 test = .true.
              end if
           end if
           if ((alleig .or. test) .and. (abstol<=zero)) then
              call stdlib_scopy( n, rwork( indd ), 1, w, 1 )
              indee = indrwk + 2*n
              if( .not.wantz ) then
                 call stdlib_scopy( n-1, rwork( inde ), 1, rwork( indee ), 1 )
                 call stdlib_ssterf( n, w, rwork( indee ), info )
              else
                 call stdlib_cupgtr( uplo, n, ap, work( indtau ), z, ldz,work( indwrk ), iinfo )
                           
                 call stdlib_scopy( n-1, rwork( inde ), 1, rwork( indee ), 1 )
                 call stdlib_csteqr( jobz, n, w, rwork( indee ), z, ldz,rwork( indrwk ), info )
                           
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 20
              end if
              info = 0
           end if
           ! otherwise, call stdlib_sstebz and, if eigenvectors are desired, stdlib_cstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indibl = 1
           indisp = indibl + n
           indiwk = indisp + n
           call stdlib_sstebz( range, order, n, vll, vuu, il, iu, abstll,rwork( indd ), rwork( &
           inde ), m, nsplit, w,iwork( indibl ), iwork( indisp ), rwork( indrwk ),iwork( indiwk ),&
                      info )
           if( wantz ) then
              call stdlib_cstein( n, rwork( indd ), rwork( inde ), m, w,iwork( indibl ), iwork( &
                        indisp ), z, ldz,rwork( indrwk ), iwork( indiwk ), ifail, info )
              ! apply unitary matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_cstein.
              indwrk = indtau + n
              call stdlib_cupmtr( 'L', uplo, 'N', n, m, ap, work( indtau ), z, ldz,work( indwrk ),&
                         iinfo )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           20 continue
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = m
              else
                 imax = info - 1
              end if
              call stdlib_sscal( imax, one / sigma, w, 1 )
           end if
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_cswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_chpevx


     subroutine stdlib_chpgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,rwork, info )
     !! CHPGV computes all the eigenvalues and, optionally, the eigenvectors
     !! of a complex generalized Hermitian-definite eigenproblem, of the form
     !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
     !! Here A and B are assumed to be Hermitian, stored in packed format,
     !! and B is also positive definite.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: itype, ldz, n
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ap(*), bp(*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper, wantz
           character :: trans
           integer(ilp) :: j, neig
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           info = 0
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -2
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPGV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a cholesky factorization of b.
           call stdlib_cpptrf( uplo, n, bp, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem and solve.
           call stdlib_chpgst( itype, uplo, n, ap, bp, info )
           call stdlib_chpev( jobz, uplo, n, ap, w, z, ldz, work, rwork, info )
           if( wantz ) then
              ! backtransform eigenvectors to the original problem.
              neig = n
              if( info>0 )neig = info - 1
              if( itype==1 .or. itype==2 ) then
                 ! for a*x=(lambda)*b*x and a*b*x=(lambda)*x;
                 ! backtransform eigenvectors: x = inv(l)**h*y or inv(u)*y
                 if( upper ) then
                    trans = 'N'
                 else
                    trans = 'C'
                 end if
                 do j = 1, neig
                    call stdlib_ctpsv( uplo, trans, 'NON-UNIT', n, bp, z( 1, j ),1 )
                 end do
              else if( itype==3 ) then
                 ! for b*a*x=(lambda)*x;
                 ! backtransform eigenvectors: x = l*y or u**h*y
                 if( upper ) then
                    trans = 'C'
                 else
                    trans = 'N'
                 end if
                 do j = 1, neig
                    call stdlib_ctpmv( uplo, trans, 'NON-UNIT', n, bp, z( 1, j ),1 )
                 end do
              end if
           end if
           return
     end subroutine stdlib_chpgv


     subroutine stdlib_chpgvx( itype, jobz, range, uplo, n, ap, bp, vl, vu,il, iu, abstol, m, w, &
     !! CHPGVX computes selected eigenvalues and, optionally, eigenvectors
     !! of a complex generalized Hermitian-definite eigenproblem, of the form
     !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
     !! B are assumed to be Hermitian, stored in packed format, and B is also
     !! positive definite.  Eigenvalues and eigenvectors can be selected by
     !! specifying either a range of values or a range of indices for the
     !! desired eigenvalues.
               z, ldz, work, rwork,iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, itype, iu, ldz, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ap(*), bp(*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: alleig, indeig, upper, valeig, wantz
           character :: trans
           integer(ilp) :: j
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           info = 0
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -2
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -3
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl ) then
                    info = -9
                 end if
              else if( indeig ) then
                 if( il<1 ) then
                    info = -10
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -11
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPGVX', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a cholesky factorization of b.
           call stdlib_cpptrf( uplo, n, bp, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem and solve.
           call stdlib_chpgst( itype, uplo, n, ap, bp, info )
           call stdlib_chpevx( jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m,w, z, ldz, &
                     work, rwork, iwork, ifail, info )
           if( wantz ) then
              ! backtransform eigenvectors to the original problem.
              if( info>0 )m = info - 1
              if( itype==1 .or. itype==2 ) then
                 ! for a*x=(lambda)*b*x and a*b*x=(lambda)*x;
                 ! backtransform eigenvectors: x = inv(l)**h*y or inv(u)*y
                 if( upper ) then
                    trans = 'N'
                 else
                    trans = 'C'
                 end if
                 do j = 1, m
                    call stdlib_ctpsv( uplo, trans, 'NON-UNIT', n, bp, z( 1, j ),1 )
                 end do
              else if( itype==3 ) then
                 ! for b*a*x=(lambda)*x;
                 ! backtransform eigenvectors: x = l*y or u**h*y
                 if( upper ) then
                    trans = 'C'
                 else
                    trans = 'N'
                 end if
                 do j = 1, m
                    call stdlib_ctpmv( uplo, trans, 'NON-UNIT', n, bp, z( 1, j ),1 )
                 end do
              end if
           end if
           return
     end subroutine stdlib_chpgvx


     pure subroutine stdlib_chprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, work,&
     !! CHPRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is Hermitian indefinite
     !! and packed, and provides error bounds and backward error estimates
     !! for the solution.
                rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: afp(*), ap(*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, ik, j, k, kase, kk, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( ldx<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_ccopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_chpmv( uplo, n, -cone, ap, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              kk = 1
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    ik = kk
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + abs( real( ap( kk+k-1 ),KIND=sp) )*xk + s
                    kk = kk + k
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + abs( real( ap( kk ),KIND=sp) )*xk
                    ik = kk + 1
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + s
                    kk = kk + ( n-k+1 )
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_chptrs( uplo, n, 1, afp, ipiv, work, n, info )
                 call stdlib_caxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**h).
                    call stdlib_chptrs( uplo, n, 1, afp, ipiv, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_chptrs( uplo, n, 1, afp, ipiv, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_chprfs


     pure subroutine stdlib_chpsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! CHPSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**H,  if UPLO = 'U', or
     !! A = L * D * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is Hermitian and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_chptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_chptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_chpsv


     subroutine stdlib_chpsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,ldx, rcond, ferr, &
     !! CHPSVX uses the diagonal pivoting factorization A = U*D*U**H or
     !! A = L*D*L**H to compute the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N Hermitian matrix stored
     !! in packed format and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               berr, work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(inout) :: afp(*)
           complex(sp), intent(in) :: ap(*), b(ldb,*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(sp) :: anorm
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**h or a = l*d*l**h.
              call stdlib_ccopy( n*( n+1 ) / 2, ap, 1, afp, 1 )
              call stdlib_chptrf( uplo, n, afp, ipiv, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_clanhp( 'I', uplo, n, ap, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_chpcon( uplo, n, afp, ipiv, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_clacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_chptrs( uplo, n, nrhs, afp, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_chprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr,berr, work, &
                     rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_chpsvx


     subroutine stdlib_chsein( side, eigsrc, initv, select, n, h, ldh, w, vl,ldvl, vr, ldvr, mm, &
     !! CHSEIN uses inverse iteration to find specified right and/or left
     !! eigenvectors of a complex upper Hessenberg matrix H.
     !! The right eigenvector x and the left eigenvector y of the matrix H
     !! corresponding to an eigenvalue w are defined by:
     !! H * x = w * x,     y**h * H = w * y**h
     !! where y**h denotes the conjugate transpose of the vector y.
               m, work, rwork, ifaill,ifailr, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: eigsrc, initv, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldh, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: ifaill(*), ifailr(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(in) :: h(ldh,*)
           complex(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*), w(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0e+0_sp
           
           
           ! Local Scalars 
           logical(lk) :: bothv, fromqr, leftv, noinit, rightv
           integer(ilp) :: i, iinfo, k, kl, kln, kr, ks, ldwork
           real(sp) :: eps3, hnorm, smlnum, ulp, unfl
           complex(sp) :: cdum, wk
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters.
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           fromqr = stdlib_lsame( eigsrc, 'Q' )
           noinit = stdlib_lsame( initv, 'N' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           m = 0
           do k = 1, n
              if( select( k ) )m = m + 1
           end do
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.fromqr .and. .not.stdlib_lsame( eigsrc, 'N' ) ) then
              info = -2
           else if( .not.noinit .and. .not.stdlib_lsame( initv, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -10
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -12
           else if( mm<m ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHSEIN', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set machine-dependent constants.
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ldwork = n
           kl = 1
           kln = 0
           if( fromqr ) then
              kr = 0
           else
              kr = n
           end if
           ks = 1
           loop_100: do k = 1, n
              if( select( k ) ) then
                 ! compute eigenvector(s) corresponding to w(k).
                 if( fromqr ) then
                    ! if affiliation of eigenvalues is known, check whether
                    ! the matrix splits.
                    ! determine kl and kr such that 1 <= kl <= k <= kr <= n
                    ! and h(kl,kl-1) and h(kr+1,kr) are czero (or kl = 1 or
                    ! kr = n).
                    ! then inverse iteration can be performed with the
                    ! submatrix h(kl:n,kl:n) for a left eigenvector, and with
                    ! the submatrix h(1:kr,1:kr) for a right eigenvector.
                    do i = k, kl + 1, -1
                       if( h( i, i-1 )==czero )go to 30
                    end do
                    30 continue
                    kl = i
                    if( k>kr ) then
                       do i = k, n - 1
                          if( h( i+1, i )==czero )go to 50
                       end do
                       50 continue
                       kr = i
                    end if
                 end if
                 if( kl/=kln ) then
                    kln = kl
                    ! compute infinity-norm of submatrix h(kl:kr,kl:kr) if it
                    ! has not ben computed before.
                    hnorm = stdlib_clanhs( 'I', kr-kl+1, h( kl, kl ), ldh, rwork )
                    if( stdlib_sisnan( hnorm ) ) then
                       info = -6
                       return
                    else if( (hnorm>rzero) ) then
                       eps3 = hnorm*ulp
                    else
                       eps3 = smlnum
                    end if
                 end if
                 ! perturb eigenvalue if it is close to any previous
                 ! selected eigenvalues affiliated to the submatrix
                 ! h(kl:kr,kl:kr). close roots are modified by eps3.
                 wk = w( k )
                 60 continue
                 do i = k - 1, kl, -1
                    if( select( i ) .and. cabs1( w( i )-wk )<eps3 ) then
                       wk = wk + eps3
                       go to 60
                    end if
                 end do
                 w( k ) = wk
                 if( leftv ) then
                    ! compute left eigenvector.
                    call stdlib_claein( .false., noinit, n-kl+1, h( kl, kl ), ldh,wk, vl( kl, ks )&
                              , work, ldwork, rwork, eps3,smlnum, iinfo )
                    if( iinfo>0 ) then
                       info = info + 1
                       ifaill( ks ) = k
                    else
                       ifaill( ks ) = 0
                    end if
                    do i = 1, kl - 1
                       vl( i, ks ) = czero
                    end do
                 end if
                 if( rightv ) then
                    ! compute right eigenvector.
                    call stdlib_claein( .true., noinit, kr, h, ldh, wk, vr( 1, ks ),work, ldwork, &
                              rwork, eps3, smlnum, iinfo )
                    if( iinfo>0 ) then
                       info = info + 1
                       ifailr( ks ) = k
                    else
                       ifailr( ks ) = 0
                    end if
                    do i = kr + 1, n
                       vr( i, ks ) = czero
                    end do
                 end if
                 ks = ks + 1
              end if
           end do loop_100
           return
     end subroutine stdlib_chsein


     pure subroutine stdlib_claed0( qsiz, n, d, e, q, ldq, qstore, ldqs, rwork,iwork, info )
     !! Using the divide and conquer method, CLAED0: computes all eigenvalues
     !! of a symmetric tridiagonal matrix which is one diagonal block of
     !! those from reducing a dense or band Hermitian matrix and
     !! corresponding eigenvectors of the dense or band matrix.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldq, ldqs, n, qsiz
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: q(ldq,*)
           complex(sp), intent(out) :: qstore(ldqs,*)
        ! =====================================================================
        ! warning:      n could be as big as qsiz!
           
           ! Local Scalars 
           integer(ilp) :: curlvl, curprb, curr, i, igivcl, igivnm, igivpt, indxq, iperm, iprmpt, &
           iq, iqptr, iwrem, j, k, lgn, ll, matsiz, msd2, smlsiz, smm1, spm1, spm2, submat, &
                     subpbs, tlvls
           real(sp) :: temp
           ! Intrinsic Functions 
           intrinsic :: abs,int,log,max,real
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           ! if( icompq < 0 .or. icompq > 2 ) then
              ! info = -1
           ! else if( ( icompq == 1 ) .and. ( qsiz < max( 0, n ) ) )
          ! $        then
           if( qsiz<max( 0, n ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           else if( ldqs<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAED0', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           smlsiz = stdlib_ilaenv( 9, 'CLAED0', ' ', 0, 0, 0, 0 )
           ! determine the size and placement of the submatrices, and save in
           ! the leading elements of iwork.
           iwork( 1 ) = n
           subpbs = 1
           tlvls = 0
           10 continue
           if( iwork( subpbs )>smlsiz ) then
              do j = subpbs, 1, -1
                 iwork( 2*j ) = ( iwork( j )+1 ) / 2
                 iwork( 2*j-1 ) = iwork( j ) / 2
              end do
              tlvls = tlvls + 1
              subpbs = 2*subpbs
              go to 10
           end if
           do j = 2, subpbs
              iwork( j ) = iwork( j ) + iwork( j-1 )
           end do
           ! divide the matrix into subpbs submatrices of size at most smlsiz+1
           ! using rank-1 modifications (cuts).
           spm1 = subpbs - 1
           do i = 1, spm1
              submat = iwork( i ) + 1
              smm1 = submat - 1
              d( smm1 ) = d( smm1 ) - abs( e( smm1 ) )
              d( submat ) = d( submat ) - abs( e( smm1 ) )
           end do
           indxq = 4*n + 3
           ! set up workspaces for eigenvalues only/accumulate new vectors
           ! routine
           temp = log( real( n,KIND=sp) ) / log( two )
           lgn = int( temp,KIND=ilp)
           if( 2**lgn<n )lgn = lgn + 1
           if( 2**lgn<n )lgn = lgn + 1
           iprmpt = indxq + n + 1
           iperm = iprmpt + n*lgn
           iqptr = iperm + n*lgn
           igivpt = iqptr + n + 2
           igivcl = igivpt + n*lgn
           igivnm = 1
           iq = igivnm + 2*n*lgn
           iwrem = iq + n**2 + 1
           ! initialize pointers
           do i = 0, subpbs
              iwork( iprmpt+i ) = 1
              iwork( igivpt+i ) = 1
           end do
           iwork( iqptr ) = 1
           ! solve each submatrix eigenproblem at the bottom of the divide and
           ! conquer tree.
           curr = 0
           do i = 0, spm1
              if( i==0 ) then
                 submat = 1
                 matsiz = iwork( 1 )
              else
                 submat = iwork( i ) + 1
                 matsiz = iwork( i+1 ) - iwork( i )
              end if
              ll = iq - 1 + iwork( iqptr+curr )
              call stdlib_ssteqr( 'I', matsiz, d( submat ), e( submat ),rwork( ll ), matsiz, &
                        rwork, info )
              call stdlib_clacrm( qsiz, matsiz, q( 1, submat ), ldq, rwork( ll ),matsiz, qstore( &
                        1, submat ), ldqs,rwork( iwrem ) )
              iwork( iqptr+curr+1 ) = iwork( iqptr+curr ) + matsiz**2
              curr = curr + 1
              if( info>0 ) then
                 info = submat*( n+1 ) + submat + matsiz - 1
                 return
              end if
              k = 1
              do j = submat, iwork( i+1 )
                 iwork( indxq+j ) = k
                 k = k + 1
              end do
           end do
           ! successively merge eigensystems of adjacent submatrices
           ! into eigensystem for the corresponding larger matrix.
           ! while ( subpbs > 1 )
           curlvl = 1
           80 continue
           if( subpbs>1 ) then
              spm2 = subpbs - 2
              do i = 0, spm2, 2
                 if( i==0 ) then
                    submat = 1
                    matsiz = iwork( 2 )
                    msd2 = iwork( 1 )
                    curprb = 0
                 else
                    submat = iwork( i ) + 1
                    matsiz = iwork( i+2 ) - iwork( i )
                    msd2 = matsiz / 2
                    curprb = curprb + 1
                 end if
           ! merge lower order eigensystems (of size msd2 and matsiz - msd2)
           ! into an eigensystem of size matsiz.  stdlib_claed7 handles the case
           ! when the eigenvectors of a full or band hermitian matrix (which
           ! was reduced to tridiagonal form) are desired.
           ! i am free to use q as a valuable working space until loop 150.
                 call stdlib_claed7( matsiz, msd2, qsiz, tlvls, curlvl, curprb,d( submat ), &
                 qstore( 1, submat ), ldqs,e( submat+msd2-1 ), iwork( indxq+submat ),rwork( iq ), &
                 iwork( iqptr ), iwork( iprmpt ),iwork( iperm ), iwork( igivpt ),iwork( igivcl ), &
                           rwork( igivnm ),q( 1, submat ), rwork( iwrem ),iwork( subpbs+1 ), info )
                 if( info>0 ) then
                    info = submat*( n+1 ) + submat + matsiz - 1
                    return
                 end if
                 iwork( i / 2+1 ) = iwork( i+2 )
              end do
              subpbs = subpbs / 2
              curlvl = curlvl + 1
              go to 80
           end if
           ! end while
           ! re-merge the eigenvalues/vectors which were deflated at the final
           ! merge step.
           do i = 1, n
              j = iwork( indxq+i )
              rwork( i ) = d( j )
              call stdlib_ccopy( qsiz, qstore( 1, j ), 1, q( 1, i ), 1 )
           end do
           call stdlib_scopy( n, rwork, 1, d, 1 )
           return
     end subroutine stdlib_claed0


     pure subroutine stdlib_clamswlq( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, work, &
     !! CLAMSWLQ overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix defined as the product of blocked
     !! elementary reflectors computed by short wide LQ
     !! factorization (CLASWLQ)
               lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, k, mb, nb, ldt, lwork, ldc
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), t(ldt,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: c(ldc,*)
       ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, right, tran, notran, lquery
           integer(ilp) :: i, ii, kk, lw, ctr
           ! External Subroutines 
           ! Executable Statements 
           ! test the input arguments
           lquery  = lwork<0
           notran  = stdlib_lsame( trans, 'N' )
           tran    = stdlib_lsame( trans, 'C' )
           left    = stdlib_lsame( side, 'L' )
           right   = stdlib_lsame( side, 'R' )
           if (left) then
             lw = n * mb
           else
             lw = m * mb
           end if
           info = 0
           if( .not.left .and. .not.right ) then
              info = -1
           else if( .not.tran .and. .not.notran ) then
              info = -2
           else if( k<0 ) then
             info = -5
           else if( m<k ) then
             info = -3
           else if( n<0 ) then
             info = -4
           else if( k<mb .or. mb<1) then
             info = -6
           else if( lda<max( 1, k ) ) then
             info = -9
           else if( ldt<max( 1, mb) ) then
             info = -11
           else if( ldc<max( 1, m ) ) then
              info = -13
           else if(( lwork<max(1,lw)).and.(.not.lquery)) then
             info = -15
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'CLAMSWLQ', -info )
             work(1) = lw
             return
           else if (lquery) then
             work(1) = lw
             return
           end if
           ! quick return if possible
           if( min(m,n,k)==0 ) then
             return
           end if
           if((nb<=k).or.(nb>=max(m,n,k))) then
             call stdlib_cgemlqt( side, trans, m, n, k, mb, a, lda,t, ldt, c, ldc, work, info)
                       
             return
           end if
           if(left.and.tran) then
               ! multiply q to the last block of c
               kk = mod((m-k),(nb-k))
               ctr = (m-k)/(nb-k)
               if (kk>0) then
                 ii=m-kk+1
                 call stdlib_ctpmlqt('L','C',kk , n, k, 0, mb, a(1,ii), lda,t(1,ctr*k+1), ldt, c(&
                           1,1), ldc,c(ii,1), ldc, work, info )
               else
                 ii=m+1
               end if
               do i=ii-(nb-k),nb+1,-(nb-k)
               ! multiply q to the current block of c (1:m,i:i+nb)
                 ctr = ctr - 1
                 call stdlib_ctpmlqt('L','C',nb-k , n, k, 0,mb, a(1,i), lda,t(1,ctr*k+1),ldt, c(1,&
                           1), ldc,c(i,1), ldc, work, info )
               end do
               ! multiply q to the first block of c (1:m,1:nb)
               call stdlib_cgemlqt('L','C',nb , n, k, mb, a(1,1), lda, t,ldt ,c(1,1), ldc, work, &
                         info )
           else if (left.and.notran) then
               ! multiply q to the first block of c
              kk  = mod((m-k),(nb-k))
              ii  = m-kk+1
              ctr = 1
              call stdlib_cgemlqt('L','N',nb , n, k, mb, a(1,1), lda, t,ldt ,c(1,1), ldc, work, &
                        info )
              do i=nb+1,ii-nb+k,(nb-k)
               ! multiply q to the current block of c (i:i+nb,1:n)
               call stdlib_ctpmlqt('L','N',nb-k , n, k, 0,mb, a(1,i), lda,t(1, ctr *k+1), ldt, c(&
                         1,1), ldc,c(i,1), ldc, work, info )
               ctr = ctr + 1
              end do
              if(ii<=m) then
               ! multiply q to the last block of c
               call stdlib_ctpmlqt('L','N',kk , n, k, 0, mb, a(1,ii), lda,t(1, ctr*k+1), ldt, c(1,&
                         1), ldc,c(ii,1), ldc, work, info )
              end if
           else if(right.and.notran) then
               ! multiply q to the last block of c
               kk = mod((n-k),(nb-k))
               ctr = (n-k)/(nb-k)
               if (kk>0) then
                 ii=n-kk+1
                 call stdlib_ctpmlqt('R','N',m , kk, k, 0, mb, a(1, ii), lda,t(1,ctr*k+1), ldt, c(&
                           1,1), ldc,c(1,ii), ldc, work, info )
               else
                 ii=n+1
               end if
               do i=ii-(nb-k),nb+1,-(nb-k)
               ! multiply q to the current block of c (1:m,i:i+mb)
                   ctr = ctr - 1
                   call stdlib_ctpmlqt('R','N', m, nb-k, k, 0, mb, a(1, i), lda,t(1,ctr*k+1), ldt,&
                              c(1,1), ldc,c(1,i), ldc, work, info )
               end do
               ! multiply q to the first block of c (1:m,1:mb)
               call stdlib_cgemlqt('R','N',m , nb, k, mb, a(1,1), lda, t,ldt ,c(1,1), ldc, work, &
                         info )
           else if (right.and.tran) then
             ! multiply q to the first block of c
              kk = mod((n-k),(nb-k))
              ii=n-kk+1
              ctr = 1
              call stdlib_cgemlqt('R','C',m , nb, k, mb, a(1,1), lda, t,ldt ,c(1,1), ldc, work, &
                        info )
              do i=nb+1,ii-nb+k,(nb-k)
               ! multiply q to the current block of c (1:m,i:i+mb)
               call stdlib_ctpmlqt('R','C',m , nb-k, k, 0,mb, a(1,i), lda,t(1,ctr*k+1), ldt, c(1,&
                         1), ldc,c(1,i), ldc, work, info )
               ctr = ctr + 1
              end do
              if(ii<=n) then
             ! multiply q to the last block of c
               call stdlib_ctpmlqt('R','C',m , kk, k, 0,mb, a(1,ii), lda,t(1,ctr*k+1),ldt, c(1,1),&
                          ldc,c(1,ii), ldc, work, info )
              end if
           end if
           work(1) = lw
           return
     end subroutine stdlib_clamswlq


     pure subroutine stdlib_clamtsqr( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, work, &
     !! CLAMTSQR overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix defined as the product
     !! of blocked elementary reflectors computed by tall skinny
     !! QR factorization (CLATSQR)
               lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, k, mb, nb, ldt, lwork, ldc
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), t(ldt,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: c(ldc,*)
       ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, right, tran, notran, lquery
           integer(ilp) :: i, ii, kk, lw, ctr, q
           ! External Subroutines 
           ! Executable Statements 
           ! test the input arguments
           lquery  = lwork<0
           notran  = stdlib_lsame( trans, 'N' )
           tran    = stdlib_lsame( trans, 'C' )
           left    = stdlib_lsame( side, 'L' )
           right   = stdlib_lsame( side, 'R' )
           if (left) then
             lw = n * nb
             q = m
           else
             lw = m * nb
             q = n
           end if
           info = 0
           if( .not.left .and. .not.right ) then
              info = -1
           else if( .not.tran .and. .not.notran ) then
              info = -2
           else if( m<k ) then
             info = -3
           else if( n<0 ) then
             info = -4
           else if( k<0 ) then
             info = -5
           else if( k<nb .or. nb<1 ) then
             info = -7
           else if( lda<max( 1, q ) ) then
             info = -9
           else if( ldt<max( 1, nb) ) then
             info = -11
           else if( ldc<max( 1, m ) ) then
              info = -13
           else if(( lwork<max(1,lw)).and.(.not.lquery)) then
             info = -15
           end if
           ! determine the block size if it is tall skinny or short and wide
           if( info==0)  then
               work(1) = lw
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'CLAMTSQR', -info )
             return
           else if (lquery) then
            return
           end if
           ! quick return if possible
           if( min(m,n,k)==0 ) then
             return
           end if
           if((mb<=k).or.(mb>=max(m,n,k))) then
             call stdlib_cgemqrt( side, trans, m, n, k, nb, a, lda,t, ldt, c, ldc, work, info)
                       
             return
            end if
           if(left.and.notran) then
               ! multiply q to the last block of c
              kk = mod((m-k),(mb-k))
              ctr = (m-k)/(mb-k)
              if (kk>0) then
                ii=m-kk+1
                call stdlib_ctpmqrt('L','N',kk , n, k, 0, nb, a(ii,1), lda,t(1, ctr*k+1),ldt , c(&
                          1,1), ldc,c(ii,1), ldc, work, info )
              else
                ii=m+1
              end if
              do i=ii-(mb-k),mb+1,-(mb-k)
               ! multiply q to the current block of c (i:i+mb,1:n)
                ctr = ctr - 1
                call stdlib_ctpmqrt('L','N',mb-k , n, k, 0,nb, a(i,1), lda,t(1,ctr*k+1),ldt, c(1,&
                          1), ldc,c(i,1), ldc, work, info )
              end do
               ! multiply q to the first block of c (1:mb,1:n)
              call stdlib_cgemqrt('L','N',mb , n, k, nb, a(1,1), lda, t,ldt ,c(1,1), ldc, work, &
                        info )
           else if (left.and.tran) then
               ! multiply q to the first block of c
              kk = mod((m-k),(mb-k))
              ii=m-kk+1
              ctr = 1
              call stdlib_cgemqrt('L','C',mb , n, k, nb, a(1,1), lda, t,ldt ,c(1,1), ldc, work, &
                        info )
              do i=mb+1,ii-mb+k,(mb-k)
               ! multiply q to the current block of c (i:i+mb,1:n)
               call stdlib_ctpmqrt('L','C',mb-k , n, k, 0,nb, a(i,1), lda,t(1, ctr*k+1),ldt, c(1,&
                         1), ldc,c(i,1), ldc, work, info )
               ctr = ctr + 1
              end do
              if(ii<=m) then
               ! multiply q to the last block of c
               call stdlib_ctpmqrt('L','C',kk , n, k, 0,nb, a(ii,1), lda,t(1,ctr*k+1), ldt, c(1,1)&
                         , ldc,c(ii,1), ldc, work, info )
              end if
           else if(right.and.tran) then
               ! multiply q to the last block of c
               kk = mod((n-k),(mb-k))
               ctr = (n-k)/(mb-k)
               if (kk>0) then
                 ii=n-kk+1
                 call stdlib_ctpmqrt('R','C',m , kk, k, 0, nb, a(ii,1), lda,t(1, ctr*k+1), ldt, c(&
                           1,1), ldc,c(1,ii), ldc, work, info )
               else
                 ii=n+1
               end if
               do i=ii-(mb-k),mb+1,-(mb-k)
               ! multiply q to the current block of c (1:m,i:i+mb)
                 ctr = ctr - 1
                 call stdlib_ctpmqrt('R','C',m , mb-k, k, 0,nb, a(i,1), lda,t(1,ctr*k+1), ldt, c(&
                           1,1), ldc,c(1,i), ldc, work, info )
               end do
               ! multiply q to the first block of c (1:m,1:mb)
               call stdlib_cgemqrt('R','C',m , mb, k, nb, a(1,1), lda, t,ldt ,c(1,1), ldc, work, &
                         info )
           else if (right.and.notran) then
               ! multiply q to the first block of c
              kk = mod((n-k),(mb-k))
              ii=n-kk+1
              ctr = 1
              call stdlib_cgemqrt('R','N', m, mb , k, nb, a(1,1), lda, t,ldt ,c(1,1), ldc, work, &
                        info )
              do i=mb+1,ii-mb+k,(mb-k)
               ! multiply q to the current block of c (1:m,i:i+mb)
               call stdlib_ctpmqrt('R','N', m, mb-k, k, 0,nb, a(i,1), lda,t(1,ctr*k+1),ldt, c(1,1)&
                         , ldc,c(1,i), ldc, work, info )
               ctr = ctr + 1
              end do
              if(ii<=n) then
               ! multiply q to the last block of c
               call stdlib_ctpmqrt('R','N', m, kk , k, 0,nb, a(ii,1), lda,t(1,ctr*k+1),ldt, c(1,1)&
                         , ldc,c(1,ii), ldc, work, info )
              end if
           end if
           work(1) = lw
           return
     end subroutine stdlib_clamtsqr


     pure subroutine stdlib_claqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
     !! CLAQR2 is identical to CLAQR3 except that it avoids
     !! recursion by calling CLAHQR instead of CLAQR4.
     !! Aggressive early deflation:
     !! This subroutine accepts as input an upper Hessenberg matrix
     !! H and performs an unitary similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an unitary similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0_sp
           real(sp), parameter :: rone = 1.0_sp
           
           
           ! Local Scalars 
           complex(sp) :: beta, cdum, s, tau
           real(sp) :: foo, safmax, safmin, smlnum, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, kcol, kln, knt, krow, kwtop, ltop, &
                     lwk1, lwk2, lwkopt
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,conjg,int,max,min,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_cgehrd ====
              call stdlib_cgehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_cunmhr ====
              call stdlib_cunmhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = jw + max( lwk1, lwk2 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = cone
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = czero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sh( kwtop ) = h( kwtop, kwtop )
              ns = 1
              nd = 0
              if( cabs1( s )<=max( smlnum, ulp*cabs1( h( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = czero
              end if
              work( 1 ) = cone
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_clacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_ccopy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_claset( 'A', jw, jw, czero, cone, v, ldv )
           call stdlib_clahqr( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                     infqr )
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           do knt = infqr + 1, jw
              ! ==== small spike tip deflation test ====
              foo = cabs1( t( ns, ns ) )
              if( foo==rzero )foo = cabs1( s )
              if( cabs1( s )*cabs1( v( 1, ns ) )<=max( smlnum, ulp*foo ) )then
                 ! ==== cone more converged eigenvalue ====
                 ns = ns - 1
              else
                 ! ==== cone undeflatable eigenvalue.  move it up out of the
                 ! .    way.   (stdlib_ctrexc can not fail in this case.) ====
                 ifst = ns
                 call stdlib_ctrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                 ilst = ilst + 1
              end if
           end do
              ! ==== return to hessenberg form ====
           if( ns==0 )s = czero
           if( ns<jw ) then
              ! ==== sorting the diagonal of t improves accuracy for
              ! .    graded matrices.  ====
              do i = infqr + 1, ns
                 ifst = i
                 do j = i + 1, ns
                    if( cabs1( t( j, j ) )>cabs1( t( ifst, ifst ) ) )ifst = j
                 end do
                 ilst = i
                 if( ifst/=ilst )call stdlib_ctrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                           
              end do
           end if
           ! ==== restore shift/eigenvalue array from t ====
           do i = infqr + 1, jw
              sh( kwtop+i-1 ) = t( i, i )
           end do
           if( ns<jw .or. s==czero ) then
              if( ns>1 .and. s/=czero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_ccopy( ns, v, ldv, work, 1 )
                 do i = 1, ns
                    work( i ) = conjg( work( i ) )
                 end do
                 beta = work( 1 )
                 call stdlib_clarfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = cone
                 call stdlib_claset( 'L', jw-2, jw-2, czero, czero, t( 3, 1 ), ldt )
                 call stdlib_clarf( 'L', ns, jw, work, 1, conjg( tau ), t, ldt,work( jw+1 ) )
                           
                 call stdlib_clarf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_clarf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_cgehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*conjg( v( 1, 1 ) )
              call stdlib_clacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_ccopy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=czero )call stdlib_cunmhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_cgemm( 'N', 'N', kln, jw, jw, cone, h( krow, kwtop ),ldh, v, ldv, &
                           czero, wv, ldwv )
                 call stdlib_clacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_cgemm( 'C', 'N', jw, kln, jw, cone, v, ldv,h( kwtop, kcol ), ldh, &
                              czero, t, ldt )
                    call stdlib_clacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_cgemm( 'N', 'N', kln, jw, jw, cone, z( krow, kwtop ),ldz, v, ldv, &
                              czero, wv, ldwv )
                    call stdlib_clacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
     end subroutine stdlib_claqr2


     pure subroutine stdlib_claswlq( m, n, mb, nb, a, lda, t, ldt, work, lwork,info)
     !! CLASWLQ computes a blocked Tall-Skinny LQ factorization of
     !! a complex M-by-N matrix A for M <= N:
     !! A = ( L 0 ) *  Q,
     !! where:
     !! Q is a n-by-N orthogonal matrix, stored on exit in an implicit
     !! form in the elements above the diagonal of the array A and in
     !! the elements of the array T;
     !! L is a lower-triangular M-by-M matrix stored on exit in
     !! the elements on and below the diagonal of the array A.
     !! 0 is a M-by-(N-M) zero matrix, if M < N, and is not stored.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd. --
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, mb, nb, lwork, ldt
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*), t(ldt,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ii, kk, ctr
           ! External Subroutines 
           intrinsic :: max,min,mod
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
             info = -1
           else if( n<0 .or. n<m ) then
             info = -2
           else if( mb<1 .or. ( mb>m .and. m>0 )) then
             info = -3
           else if( nb<=0 ) then
             info = -4
           else if( lda<max( 1, m ) ) then
             info = -6
           else if( ldt<mb ) then
             info = -8
           else if( ( lwork<m*mb) .and. (.not.lquery) ) then
             info = -10
           end if
           if( info==0)  then
           work(1) = mb*m
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'CLASWLQ', -info )
             return
           else if (lquery) then
            return
           end if
           ! quick return if possible
           if( min(m,n)==0 ) then
               return
           end if
           ! the lq decomposition
            if((m>=n).or.(nb<=m).or.(nb>=n)) then
             call stdlib_cgelqt( m, n, mb, a, lda, t, ldt, work, info)
             return
            end if
            kk = mod((n-m),(nb-m))
            ii=n-kk+1
            ! compute the lq factorization of the first block a(1:m,1:nb)
            call stdlib_cgelqt( m, nb, mb, a(1,1), lda, t, ldt, work, info)
            ctr = 1
            do i = nb+1, ii-nb+m , (nb-m)
            ! compute the qr factorization of the current block a(1:m,i:i+nb-m)
              call stdlib_ctplqt( m, nb-m, 0, mb, a(1,1), lda, a( 1, i ),lda, t(1,ctr*m+1),ldt, &
                        work, info )
              ctr = ctr + 1
            end do
           ! compute the qr factorization of the last block a(1:m,ii:n)
            if (ii<=n) then
             call stdlib_ctplqt( m, kk, 0, mb, a(1,1), lda, a( 1, ii ),lda, t(1,ctr*m+1), ldt,&
                       work, info )
            end if
           work( 1 ) = m * mb
           return
     end subroutine stdlib_claswlq


     pure subroutine stdlib_clatsqr( m, n, mb, nb, a, lda, t, ldt, work,lwork, info)
     !! CLATSQR computes a blocked Tall-Skinny QR factorization of
     !! a complex M-by-N matrix A for M >= N:
     !! A = Q * ( R ),
     !! ( 0 )
     !! where:
     !! Q is a M-by-M orthogonal matrix, stored on exit in an implicit
     !! form in the elements below the diagonal of the array A and in
     !! the elements of the array T;
     !! R is an upper-triangular N-by-N matrix, stored on exit in
     !! the elements on and above the diagonal of the array A.
     !! 0 is a (M-N)-by-N zero matrix, and is not stored.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd. --
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, mb, nb, ldt, lwork
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*), t(ldt,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ii, kk, ctr
           ! External Subroutines 
           intrinsic :: max,min,mod
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( m<0 ) then
             info = -1
           else if( n<0 .or. m<n ) then
             info = -2
           else if( mb<1 ) then
             info = -3
           else if( nb<1 .or. ( nb>n .and. n>0 )) then
             info = -4
           else if( lda<max( 1, m ) ) then
             info = -6
           else if( ldt<nb ) then
             info = -8
           else if( lwork<(n*nb) .and. (.not.lquery) ) then
             info = -10
           end if
           if( info==0)  then
             work(1) = nb*n
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'CLATSQR', -info )
             return
           else if (lquery) then
            return
           end if
           ! quick return if possible
           if( min(m,n)==0 ) then
               return
           end if
           ! the qr decomposition
            if ((mb<=n).or.(mb>=m)) then
              call stdlib_cgeqrt( m, n, nb, a, lda, t, ldt, work, info)
              return
            end if
            kk = mod((m-n),(mb-n))
            ii=m-kk+1
            ! compute the qr factorization of the first block a(1:mb,1:n)
            call stdlib_cgeqrt( mb, n, nb, a(1,1), lda, t, ldt, work, info )
            ctr = 1
            do i = mb+1, ii-mb+n ,  (mb-n)
            ! compute the qr factorization of the current block a(i:i+mb-n,1:n)
              call stdlib_ctpqrt( mb-n, n, 0, nb, a(1,1), lda, a( i, 1 ), lda,t(1,ctr * n + 1),&
                        ldt, work, info )
              ctr = ctr + 1
            end do
            ! compute the qr factorization of the last block a(ii:m,1:n)
            if (ii<=m) then
              call stdlib_ctpqrt( kk, n, 0, nb, a(1,1), lda, a( ii, 1 ), lda,t(1, ctr * n + 1), &
                        ldt,work, info )
            end if
           work( 1 ) = n*nb
           return
     end subroutine stdlib_clatsqr


     pure subroutine stdlib_cpbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
     !! CPBSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian positive definite band matrix and X
     !! and B are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**H * U,  if UPLO = 'U', or
     !! A = L * L**H,  if UPLO = 'L',
     !! where U is an upper triangular band matrix, and L is a lower
     !! triangular band matrix, with the same number of superdiagonals or
     !! subdiagonals as A.  The factored form of A is then used to solve the
     !! system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldb, n, nrhs
           ! Array Arguments 
           complex(sp), intent(inout) :: ab(ldab,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldab<kd+1 ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPBSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**h*u or a = l*l**h.
           call stdlib_cpbtrf( uplo, n, kd, ab, ldab, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_cpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
           end if
           return
     end subroutine stdlib_cpbsv


     subroutine stdlib_cpbsvx( fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb,equed, s, b, ldb, x, &
     !! CPBSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
     !! compute the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian positive definite band matrix and X
     !! and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               ldx, rcond, ferr, berr,work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(inout) :: equed
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldafb, ldb, ldx, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           real(sp), intent(inout) :: s(*)
           complex(sp), intent(inout) :: ab(ldab,*), afb(ldafb,*), b(ldb,*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: equil, nofact, rcequ, upper
           integer(ilp) :: i, infequ, j, j1, j2
           real(sp) :: amax, anorm, bignum, scond, smax, smin, smlnum
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           equil = stdlib_lsame( fact, 'E' )
           upper = stdlib_lsame( uplo, 'U' )
           if( nofact .or. equil ) then
              equed = 'N'
              rcequ = .false.
           else
              rcequ = stdlib_lsame( equed, 'Y' )
              smlnum = stdlib_slamch( 'SAFE MINIMUM' )
              bignum = one / smlnum
           end if
           ! test the input parameters.
           if( .not.nofact .and. .not.equil .and. .not.stdlib_lsame( fact, 'F' ) )then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( kd<0 ) then
              info = -4
           else if( nrhs<0 ) then
              info = -5
           else if( ldab<kd+1 ) then
              info = -7
           else if( ldafb<kd+1 ) then
              info = -9
           else if( stdlib_lsame( fact, 'F' ) .and. .not.( rcequ .or. stdlib_lsame( equed, 'N' ) )&
                      ) then
              info = -10
           else
              if( rcequ ) then
                 smin = bignum
                 smax = zero
                 do j = 1, n
                    smin = min( smin, s( j ) )
                    smax = max( smax, s( j ) )
                 end do
                 if( smin<=zero ) then
                    info = -11
                 else if( n>0 ) then
                    scond = max( smin, smlnum ) / min( smax, bignum )
                 else
                    scond = one
                 end if
              end if
              if( info==0 ) then
                 if( ldb<max( 1, n ) ) then
                    info = -13
                 else if( ldx<max( 1, n ) ) then
                    info = -15
                 end if
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPBSVX', -info )
              return
           end if
           if( equil ) then
              ! compute row and column scalings to equilibrate the matrix a.
              call stdlib_cpbequ( uplo, n, kd, ab, ldab, s, scond, amax, infequ )
              if( infequ==0 ) then
                 ! equilibrate the matrix.
                 call stdlib_claqhb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                 rcequ = stdlib_lsame( equed, 'Y' )
              end if
           end if
           ! scale the right-hand side.
           if( rcequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    b( i, j ) = s( i )*b( i, j )
                 end do
              end do
           end if
           if( nofact .or. equil ) then
              ! compute the cholesky factorization a = u**h *u or a = l*l**h.
              if( upper ) then
                 do j = 1, n
                    j1 = max( j-kd, 1 )
                    call stdlib_ccopy( j-j1+1, ab( kd+1-j+j1, j ), 1,afb( kd+1-j+j1, j ), 1 )
                              
                 end do
              else
                 do j = 1, n
                    j2 = min( j+kd, n )
                    call stdlib_ccopy( j2-j+1, ab( 1, j ), 1, afb( 1, j ), 1 )
                 end do
              end if
              call stdlib_cpbtrf( uplo, n, kd, afb, ldafb, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_clanhb( '1', uplo, n, kd, ab, ldab, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_cpbcon( uplo, n, kd, afb, ldafb, anorm, rcond, work, rwork,info )
           ! compute the solution matrix x.
           call stdlib_clacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_cpbtrs( uplo, n, kd, nrhs, afb, ldafb, x, ldx, info )
           ! use iterative refinement to improve the computed solution and
           ! compute error bounds and backward error estimates for it.
           call stdlib_cpbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x,ldx, ferr, berr,&
                      work, rwork, info )
           ! transform the solution matrix x to a solution of the original
           ! system.
           if( rcequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    x( i, j ) = s( i )*x( i, j )
                 end do
              end do
              do j = 1, nrhs
                 ferr( j ) = ferr( j ) / scond
              end do
           end if
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_cpbsvx


     pure subroutine stdlib_cpftrf( transr, uplo, n, a, info )
     !! CPFTRF computes the Cholesky factorization of a complex Hermitian
     !! positive definite matrix A.
     !! The factorization has the form
     !! A = U**H * U,  if UPLO = 'U', or
     !! A = L  * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is lower triangular.
     !! This is the block version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, uplo
           integer(ilp), intent(in) :: n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(0:*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lower, nisodd, normaltransr
           integer(ilp) :: n1, n2, k
           ! Intrinsic Functions 
           intrinsic :: mod
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'C' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPFTRF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! if n is odd, set nisodd = .true.
           ! if n is even, set k = n/2 and nisodd = .false.
           if( mod( n, 2 )==0 ) then
              k = n / 2
              nisodd = .false.
           else
              nisodd = .true.
           end if
           ! set n1 and n2 depending on lower
           if( lower ) then
              n2 = n / 2
              n1 = n - n2
           else
              n1 = n / 2
              n2 = n - n1
           end if
           ! start execution: there are eight cases
           if( nisodd ) then
              ! n is odd
              if( normaltransr ) then
                 ! n is odd and transr = 'n'
                 if( lower ) then
                   ! srpa for lower, normal and n is odd ( a(0:n-1,0:n1-1) )
                   ! t1 -> a(0,0), t2 -> a(0,1), s -> a(n1,0)
                   ! t1 -> a(0), t2 -> a(n), s -> a(n1)
                    call stdlib_cpotrf( 'L', n1, a( 0 ), n, info )
                    if( info>0 )return
                    call stdlib_ctrsm( 'R', 'L', 'C', 'N', n2, n1, cone, a( 0 ), n,a( n1 ), n )
                              
                    call stdlib_cherk( 'U', 'N', n2, n1, -one, a( n1 ), n, one,a( n ), n )
                    call stdlib_cpotrf( 'U', n2, a( n ), n, info )
                    if( info>0 )info = info + n1
                 else
                   ! srpa for upper, normal and n is odd ( a(0:n-1,0:n2-1)
                   ! t1 -> a(n1+1,0), t2 -> a(n1,0), s -> a(0,0)
                   ! t1 -> a(n2), t2 -> a(n1), s -> a(0)
                    call stdlib_cpotrf( 'L', n1, a( n2 ), n, info )
                    if( info>0 )return
                    call stdlib_ctrsm( 'L', 'L', 'N', 'N', n1, n2, cone, a( n2 ), n,a( 0 ), n )
                              
                    call stdlib_cherk( 'U', 'C', n2, n1, -one, a( 0 ), n, one,a( n1 ), n )
                    call stdlib_cpotrf( 'U', n2, a( n1 ), n, info )
                    if( info>0 )info = info + n1
                 end if
              else
                 ! n is odd and transr = 'c'
                 if( lower ) then
                    ! srpa for lower, transpose and n is odd
                    ! t1 -> a(0,0) , t2 -> a(1,0) , s -> a(0,n1)
                    ! t1 -> a(0+0) , t2 -> a(1+0) , s -> a(0+n1*n1); lda=n1
                    call stdlib_cpotrf( 'U', n1, a( 0 ), n1, info )
                    if( info>0 )return
                    call stdlib_ctrsm( 'L', 'U', 'C', 'N', n1, n2, cone, a( 0 ), n1,a( n1*n1 ), &
                              n1 )
                    call stdlib_cherk( 'L', 'C', n2, n1, -one, a( n1*n1 ), n1, one,a( 1 ), n1 )
                              
                    call stdlib_cpotrf( 'L', n2, a( 1 ), n1, info )
                    if( info>0 )info = info + n1
                 else
                    ! srpa for upper, transpose and n is odd
                    ! t1 -> a(0,n1+1), t2 -> a(0,n1), s -> a(0,0)
                    ! t1 -> a(n2*n2), t2 -> a(n1*n2), s -> a(0); lda = n2
                    call stdlib_cpotrf( 'U', n1, a( n2*n2 ), n2, info )
                    if( info>0 )return
                    call stdlib_ctrsm( 'R', 'U', 'N', 'N', n2, n1, cone, a( n2*n2 ),n2, a( 0 ), &
                              n2 )
                    call stdlib_cherk( 'L', 'N', n2, n1, -one, a( 0 ), n2, one,a( n1*n2 ), n2 )
                              
                    call stdlib_cpotrf( 'L', n2, a( n1*n2 ), n2, info )
                    if( info>0 )info = info + n1
                 end if
              end if
           else
              ! n is even
              if( normaltransr ) then
                 ! n is even and transr = 'n'
                 if( lower ) then
                    ! srpa for lower, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(1,0), t2 -> a(0,0), s -> a(k+1,0)
                    ! t1 -> a(1), t2 -> a(0), s -> a(k+1)
                    call stdlib_cpotrf( 'L', k, a( 1 ), n+1, info )
                    if( info>0 )return
                    call stdlib_ctrsm( 'R', 'L', 'C', 'N', k, k, cone, a( 1 ), n+1,a( k+1 ), n+1 )
                              
                    call stdlib_cherk( 'U', 'N', k, k, -one, a( k+1 ), n+1, one,a( 0 ), n+1 )
                              
                    call stdlib_cpotrf( 'U', k, a( 0 ), n+1, info )
                    if( info>0 )info = info + k
                 else
                    ! srpa for upper, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(k+1,0) ,  t2 -> a(k,0),   s -> a(0,0)
                    ! t1 -> a(k+1), t2 -> a(k), s -> a(0)
                    call stdlib_cpotrf( 'L', k, a( k+1 ), n+1, info )
                    if( info>0 )return
                    call stdlib_ctrsm( 'L', 'L', 'N', 'N', k, k, cone, a( k+1 ),n+1, a( 0 ), n+1 )
                              
                    call stdlib_cherk( 'U', 'C', k, k, -one, a( 0 ), n+1, one,a( k ), n+1 )
                              
                    call stdlib_cpotrf( 'U', k, a( k ), n+1, info )
                    if( info>0 )info = info + k
                 end if
              else
                 ! n is even and transr = 'c'
                 if( lower ) then
                    ! srpa for lower, transpose and n is even (see paper)
                    ! t1 -> b(0,1), t2 -> b(0,0), s -> b(0,k+1)
                    ! t1 -> a(0+k), t2 -> a(0+0), s -> a(0+k*(k+1)); lda=k
                    call stdlib_cpotrf( 'U', k, a( 0+k ), k, info )
                    if( info>0 )return
                    call stdlib_ctrsm( 'L', 'U', 'C', 'N', k, k, cone, a( k ), n1,a( k*( k+1 ) ), &
                              k )
                    call stdlib_cherk( 'L', 'C', k, k, -one, a( k*( k+1 ) ), k, one,a( 0 ), k )
                              
                    call stdlib_cpotrf( 'L', k, a( 0 ), k, info )
                    if( info>0 )info = info + k
                 else
                    ! srpa for upper, transpose and n is even (see paper)
                    ! t1 -> b(0,k+1),     t2 -> b(0,k),   s -> b(0,0)
                    ! t1 -> a(0+k*(k+1)), t2 -> a(0+k*k), s -> a(0+0)); lda=k
                    call stdlib_cpotrf( 'U', k, a( k*( k+1 ) ), k, info )
                    if( info>0 )return
                    call stdlib_ctrsm( 'R', 'U', 'N', 'N', k, k, cone,a( k*( k+1 ) ), k, a( 0 ), &
                              k )
                    call stdlib_cherk( 'L', 'N', k, k, -one, a( 0 ), k, one,a( k*k ), k )
                    call stdlib_cpotrf( 'L', k, a( k*k ), k, info )
                    if( info>0 )info = info + k
                 end if
              end if
           end if
           return
     end subroutine stdlib_cpftrf


     pure subroutine stdlib_cpftri( transr, uplo, n, a, info )
     !! CPFTRI computes the inverse of a complex Hermitian positive definite
     !! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
     !! computed by CPFTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: transr, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(0:*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lower, nisodd, normaltransr
           integer(ilp) :: n1, n2, k
           ! Intrinsic Functions 
           intrinsic :: mod
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           normaltransr = stdlib_lsame( transr, 'N' )
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.normaltransr .and. .not.stdlib_lsame( transr, 'C' ) ) then
              info = -1
           else if( .not.lower .and. .not.stdlib_lsame( uplo, 'U' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPFTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! invert the triangular cholesky factor u or l.
           call stdlib_ctftri( transr, uplo, 'N', n, a, info )
           if( info>0 )return
           ! if n is odd, set nisodd = .true.
           ! if n is even, set k = n/2 and nisodd = .false.
           if( mod( n, 2 )==0 ) then
              k = n / 2
              nisodd = .false.
           else
              nisodd = .true.
           end if
           ! set n1 and n2 depending on lower
           if( lower ) then
              n2 = n / 2
              n1 = n - n2
           else
              n1 = n / 2
              n2 = n - n1
           end if
           ! start execution of triangular matrix multiply: inv(u)*inv(u)^c or
           ! inv(l)^c*inv(l). there are eight cases.
           if( nisodd ) then
              ! n is odd
              if( normaltransr ) then
                 ! n is odd and transr = 'n'
                 if( lower ) then
                    ! srpa for lower, normal and n is odd ( a(0:n-1,0:n1-1) )
                    ! t1 -> a(0,0), t2 -> a(0,1), s -> a(n1,0)
                    ! t1 -> a(0), t2 -> a(n), s -> a(n1)
                    call stdlib_clauum( 'L', n1, a( 0 ), n, info )
                    call stdlib_cherk( 'L', 'C', n1, n2, one, a( n1 ), n, one,a( 0 ), n )
                    call stdlib_ctrmm( 'L', 'U', 'N', 'N', n2, n1, cone, a( n ), n,a( n1 ), n )
                              
                    call stdlib_clauum( 'U', n2, a( n ), n, info )
                 else
                    ! srpa for upper, normal and n is odd ( a(0:n-1,0:n2-1)
                    ! t1 -> a(n1+1,0), t2 -> a(n1,0), s -> a(0,0)
                    ! t1 -> a(n2), t2 -> a(n1), s -> a(0)
                    call stdlib_clauum( 'L', n1, a( n2 ), n, info )
                    call stdlib_cherk( 'L', 'N', n1, n2, one, a( 0 ), n, one,a( n2 ), n )
                    call stdlib_ctrmm( 'R', 'U', 'C', 'N', n1, n2, cone, a( n1 ), n,a( 0 ), n )
                              
                    call stdlib_clauum( 'U', n2, a( n1 ), n, info )
                 end if
              else
                 ! n is odd and transr = 'c'
                 if( lower ) then
                    ! srpa for lower, transpose, and n is odd
                    ! t1 -> a(0), t2 -> a(1), s -> a(0+n1*n1)
                    call stdlib_clauum( 'U', n1, a( 0 ), n1, info )
                    call stdlib_cherk( 'U', 'N', n1, n2, one, a( n1*n1 ), n1, one,a( 0 ), n1 )
                              
                    call stdlib_ctrmm( 'R', 'L', 'N', 'N', n1, n2, cone, a( 1 ), n1,a( n1*n1 ), &
                              n1 )
                    call stdlib_clauum( 'L', n2, a( 1 ), n1, info )
                 else
                    ! srpa for upper, transpose, and n is odd
                    ! t1 -> a(0+n2*n2), t2 -> a(0+n1*n2), s -> a(0)
                    call stdlib_clauum( 'U', n1, a( n2*n2 ), n2, info )
                    call stdlib_cherk( 'U', 'C', n1, n2, one, a( 0 ), n2, one,a( n2*n2 ), n2 )
                              
                    call stdlib_ctrmm( 'L', 'L', 'C', 'N', n2, n1, cone, a( n1*n2 ),n2, a( 0 ), &
                              n2 )
                    call stdlib_clauum( 'L', n2, a( n1*n2 ), n2, info )
                 end if
              end if
           else
              ! n is even
              if( normaltransr ) then
                 ! n is even and transr = 'n'
                 if( lower ) then
                    ! srpa for lower, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(1,0), t2 -> a(0,0), s -> a(k+1,0)
                    ! t1 -> a(1), t2 -> a(0), s -> a(k+1)
                    call stdlib_clauum( 'L', k, a( 1 ), n+1, info )
                    call stdlib_cherk( 'L', 'C', k, k, one, a( k+1 ), n+1, one,a( 1 ), n+1 )
                              
                    call stdlib_ctrmm( 'L', 'U', 'N', 'N', k, k, cone, a( 0 ), n+1,a( k+1 ), n+1 )
                              
                    call stdlib_clauum( 'U', k, a( 0 ), n+1, info )
                 else
                    ! srpa for upper, normal, and n is even ( a(0:n,0:k-1) )
                    ! t1 -> a(k+1,0) ,  t2 -> a(k,0),   s -> a(0,0)
                    ! t1 -> a(k+1), t2 -> a(k), s -> a(0)
                    call stdlib_clauum( 'L', k, a( k+1 ), n+1, info )
                    call stdlib_cherk( 'L', 'N', k, k, one, a( 0 ), n+1, one,a( k+1 ), n+1 )
                              
                    call stdlib_ctrmm( 'R', 'U', 'C', 'N', k, k, cone, a( k ), n+1,a( 0 ), n+1 )
                              
                    call stdlib_clauum( 'U', k, a( k ), n+1, info )
                 end if
              else
                 ! n is even and transr = 'c'
                 if( lower ) then
                    ! srpa for lower, transpose, and n is even (see paper)
                    ! t1 -> b(0,1), t2 -> b(0,0), s -> b(0,k+1),
                    ! t1 -> a(0+k), t2 -> a(0+0), s -> a(0+k*(k+1)); lda=k
                    call stdlib_clauum( 'U', k, a( k ), k, info )
                    call stdlib_cherk( 'U', 'N', k, k, one, a( k*( k+1 ) ), k, one,a( k ), k )
                              
                    call stdlib_ctrmm( 'R', 'L', 'N', 'N', k, k, cone, a( 0 ), k,a( k*( k+1 ) ), &
                              k )
                    call stdlib_clauum( 'L', k, a( 0 ), k, info )
                 else
                    ! srpa for upper, transpose, and n is even (see paper)
                    ! t1 -> b(0,k+1),     t2 -> b(0,k),   s -> b(0,0),
                    ! t1 -> a(0+k*(k+1)), t2 -> a(0+k*k), s -> a(0+0)); lda=k
                    call stdlib_clauum( 'U', k, a( k*( k+1 ) ), k, info )
                    call stdlib_cherk( 'U', 'C', k, k, one, a( 0 ), k, one,a( k*( k+1 ) ), k )
                              
                    call stdlib_ctrmm( 'L', 'L', 'C', 'N', k, k, cone, a( k*k ), k,a( 0 ), k )
                              
                    call stdlib_clauum( 'L', k, a( k*k ), k, info )
                 end if
              end if
           end if
           return
     end subroutine stdlib_cpftri


     pure subroutine stdlib_cposv( uplo, n, nrhs, a, lda, b, ldb, info )
     !! CPOSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian positive definite matrix and X and B
     !! are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**H* U,  if UPLO = 'U', or
     !! A = L * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix and  L is a lower triangular
     !! matrix.  The factored form of A is then used to solve the system of
     !! equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPOSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**h*u or a = l*l**h.
           call stdlib_cpotrf( uplo, n, a, lda, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_cpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
           end if
           return
     end subroutine stdlib_cposv


     subroutine stdlib_cposvx( fact, uplo, n, nrhs, a, lda, af, ldaf, equed,s, b, ldb, x, ldx, &
     !! CPOSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
     !! compute the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian positive definite matrix and X and B
     !! are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               rcond, ferr, berr, work,rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(inout) :: equed
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           real(sp), intent(inout) :: s(*)
           complex(sp), intent(inout) :: a(lda,*), af(ldaf,*), b(ldb,*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: equil, nofact, rcequ
           integer(ilp) :: i, infequ, j
           real(sp) :: amax, anorm, bignum, scond, smax, smin, smlnum
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           equil = stdlib_lsame( fact, 'E' )
           if( nofact .or. equil ) then
              equed = 'N'
              rcequ = .false.
           else
              rcequ = stdlib_lsame( equed, 'Y' )
              smlnum = stdlib_slamch( 'SAFE MINIMUM' )
              bignum = one / smlnum
           end if
           ! test the input parameters.
           if( .not.nofact .and. .not.equil .and. .not.stdlib_lsame( fact, 'F' ) )then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldaf<max( 1, n ) ) then
              info = -8
           else if( stdlib_lsame( fact, 'F' ) .and. .not.( rcequ .or. stdlib_lsame( equed, 'N' ) )&
                      ) then
              info = -9
           else
              if( rcequ ) then
                 smin = bignum
                 smax = zero
                 do j = 1, n
                    smin = min( smin, s( j ) )
                    smax = max( smax, s( j ) )
                 end do
                 if( smin<=zero ) then
                    info = -10
                 else if( n>0 ) then
                    scond = max( smin, smlnum ) / min( smax, bignum )
                 else
                    scond = one
                 end if
              end if
              if( info==0 ) then
                 if( ldb<max( 1, n ) ) then
                    info = -12
                 else if( ldx<max( 1, n ) ) then
                    info = -14
                 end if
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPOSVX', -info )
              return
           end if
           if( equil ) then
              ! compute row and column scalings to equilibrate the matrix a.
              call stdlib_cpoequ( n, a, lda, s, scond, amax, infequ )
              if( infequ==0 ) then
                 ! equilibrate the matrix.
                 call stdlib_claqhe( uplo, n, a, lda, s, scond, amax, equed )
                 rcequ = stdlib_lsame( equed, 'Y' )
              end if
           end if
           ! scale the right hand side.
           if( rcequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    b( i, j ) = s( i )*b( i, j )
                 end do
              end do
           end if
           if( nofact .or. equil ) then
              ! compute the cholesky factorization a = u**h *u or a = l*l**h.
              call stdlib_clacpy( uplo, n, n, a, lda, af, ldaf )
              call stdlib_cpotrf( uplo, n, af, ldaf, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_clanhe( '1', uplo, n, a, lda, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_cpocon( uplo, n, af, ldaf, anorm, rcond, work, rwork, info )
           ! compute the solution matrix x.
           call stdlib_clacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_cpotrs( uplo, n, nrhs, af, ldaf, x, ldx, info )
           ! use iterative refinement to improve the computed solution and
           ! compute error bounds and backward error estimates for it.
           call stdlib_cporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx,ferr, berr, work, &
                     rwork, info )
           ! transform the solution matrix x to a solution of the original
           ! system.
           if( rcequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    x( i, j ) = s( i )*x( i, j )
                 end do
              end do
              do j = 1, nrhs
                 ferr( j ) = ferr( j ) / scond
              end do
           end if
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_cposvx


     pure subroutine stdlib_cptrfs( uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx,ferr, berr, work, &
     !! CPTRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is Hermitian positive definite
     !! and tridiagonal, and provides error bounds and backward error
     !! estimates for the solution.
               rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           real(sp), intent(in) :: d(*), df(*)
           complex(sp), intent(in) :: b(ldb,*), e(*), ef(*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, ix, j, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin
           complex(sp) :: bi, cx, dx, ex, zdum
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,conjg,max,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPTRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = 4
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_100: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x.  also compute
              ! abs(a)*abs(x) + abs(b) for use in the backward error bound.
              if( upper ) then
                 if( n==1 ) then
                    bi = b( 1, j )
                    dx = d( 1 )*x( 1, j )
                    work( 1 ) = bi - dx
                    rwork( 1 ) = cabs1( bi ) + cabs1( dx )
                 else
                    bi = b( 1, j )
                    dx = d( 1 )*x( 1, j )
                    ex = e( 1 )*x( 2, j )
                    work( 1 ) = bi - dx - ex
                    rwork( 1 ) = cabs1( bi ) + cabs1( dx ) +cabs1( e( 1 ) )*cabs1( x( 2, j ) )
                              
                    do i = 2, n - 1
                       bi = b( i, j )
                       cx = conjg( e( i-1 ) )*x( i-1, j )
                       dx = d( i )*x( i, j )
                       ex = e( i )*x( i+1, j )
                       work( i ) = bi - cx - dx - ex
                       rwork( i ) = cabs1( bi ) +cabs1( e( i-1 ) )*cabs1( x( i-1, j ) ) +cabs1( &
                                 dx ) + cabs1( e( i ) )*cabs1( x( i+1, j ) )
                    end do
                    bi = b( n, j )
                    cx = conjg( e( n-1 ) )*x( n-1, j )
                    dx = d( n )*x( n, j )
                    work( n ) = bi - cx - dx
                    rwork( n ) = cabs1( bi ) + cabs1( e( n-1 ) )*cabs1( x( n-1, j ) ) + cabs1( dx &
                              )
                 end if
              else
                 if( n==1 ) then
                    bi = b( 1, j )
                    dx = d( 1 )*x( 1, j )
                    work( 1 ) = bi - dx
                    rwork( 1 ) = cabs1( bi ) + cabs1( dx )
                 else
                    bi = b( 1, j )
                    dx = d( 1 )*x( 1, j )
                    ex = conjg( e( 1 ) )*x( 2, j )
                    work( 1 ) = bi - dx - ex
                    rwork( 1 ) = cabs1( bi ) + cabs1( dx ) +cabs1( e( 1 ) )*cabs1( x( 2, j ) )
                              
                    do i = 2, n - 1
                       bi = b( i, j )
                       cx = e( i-1 )*x( i-1, j )
                       dx = d( i )*x( i, j )
                       ex = conjg( e( i ) )*x( i+1, j )
                       work( i ) = bi - cx - dx - ex
                       rwork( i ) = cabs1( bi ) +cabs1( e( i-1 ) )*cabs1( x( i-1, j ) ) +cabs1( &
                                 dx ) + cabs1( e( i ) )*cabs1( x( i+1, j ) )
                    end do
                    bi = b( n, j )
                    cx = e( n-1 )*x( n-1, j )
                    dx = d( n )*x( n, j )
                    work( n ) = bi - cx - dx
                    rwork( n ) = cabs1( bi ) + cabs1( e( n-1 ) )*cabs1( x( n-1, j ) ) + cabs1( dx &
                              )
                 end if
              end if
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_cpttrs( uplo, n, 1, df, ef, work, n, info )
                 call stdlib_caxpy( n, cmplx( one,KIND=sp), work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              ix = stdlib_isamax( n, rwork, 1 )
              ferr( j ) = rwork( ix )
              ! estimate the norm of inv(a).
              ! solve m(a) * x = e, where m(a) = (m(i,j)) is given by
                 ! m(i,j) =  abs(a(i,j)), i = j,
                 ! m(i,j) = -abs(a(i,j)), i .ne. j,
              ! and e = [ 1, 1, ..., 1 ]**t.  note m(a) = m(l)*d*m(l)**h.
              ! solve m(l) * x = e.
              rwork( 1 ) = one
              do i = 2, n
                 rwork( i ) = one + rwork( i-1 )*abs( ef( i-1 ) )
              end do
              ! solve d * m(l)**h * x = b.
              rwork( n ) = rwork( n ) / df( n )
              do i = n - 1, 1, -1
                 rwork( i ) = rwork( i ) / df( i ) +rwork( i+1 )*abs( ef( i ) )
              end do
              ! compute norm(inv(a)) = max(x(i)), 1<=i<=n.
              ix = stdlib_isamax( n, rwork, 1 )
              ferr( j ) = ferr( j )*abs( rwork( ix ) )
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_100
           return
     end subroutine stdlib_cptrfs


     pure subroutine stdlib_cptsv( n, nrhs, d, e, b, ldb, info )
     !! CPTSV computes the solution to a complex system of linear equations
     !! A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal
     !! matrix, and X and B are N-by-NRHS matrices.
     !! A is factored as A = L*D*L**H, and the factored form of A is then
     !! used to solve the system of equations.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(sp), intent(inout) :: d(*)
           complex(sp), intent(inout) :: b(ldb,*), e(*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( nrhs<0 ) then
              info = -2
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPTSV ', -info )
              return
           end if
           ! compute the l*d*l**h (or u**h*d*u) factorization of a.
           call stdlib_cpttrf( n, d, e, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_cpttrs( 'LOWER', n, nrhs, d, e, b, ldb, info )
           end if
           return
     end subroutine stdlib_cptsv


     pure subroutine stdlib_cptsvx( fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx,rcond, ferr, berr,&
     !! CPTSVX uses the factorization A = L*D*L**H to compute the solution
     !! to a complex system of linear equations A*X = B, where A is an
     !! N-by-N Hermitian positive definite tridiagonal matrix and X and B
     !! are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
                work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: fact
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           real(sp), intent(in) :: d(*)
           real(sp), intent(inout) :: df(*)
           complex(sp), intent(in) :: b(ldb,*), e(*)
           complex(sp), intent(inout) :: ef(*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(sp) :: anorm
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPTSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the l*d*l**h (or u**h*d*u) factorization of a.
              call stdlib_scopy( n, d, 1, df, 1 )
              if( n>1 )call stdlib_ccopy( n-1, e, 1, ef, 1 )
              call stdlib_cpttrf( n, df, ef, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_clanht( '1', n, d, e )
           ! compute the reciprocal of the condition number of a.
           call stdlib_cptcon( n, df, ef, anorm, rcond, rwork, info )
           ! compute the solution vectors x.
           call stdlib_clacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_cpttrs( 'LOWER', n, nrhs, df, ef, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_cptrfs( 'LOWER', n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr,berr, work, &
                     rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_cptsvx


     pure subroutine stdlib_cstedc( compz, n, d, e, z, ldz, work, lwork, rwork,lrwork, iwork, &
     !! CSTEDC computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric tridiagonal matrix using the divide and conquer method.
     !! The eigenvectors of a full or band complex Hermitian matrix can also
     !! be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
     !! matrix to tridiagonal form.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.  See SLAED3 for details.
               liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, liwork, lrwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: finish, i, icompz, ii, j, k, lgn, liwmin, ll, lrwmin, lwmin, m, smlsiz,&
                      start
           real(sp) :: eps, orgnrm, p, tiny
           ! Intrinsic Functions 
           intrinsic :: abs,int,log,max,mod,real,sqrt
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 .or. lrwork==-1 .or. liwork==-1 )
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or.( icompz>0 .and. ldz<max( 1, n ) ) ) then
              info = -6
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              smlsiz = stdlib_ilaenv( 9, 'CSTEDC', ' ', 0, 0, 0, 0 )
              if( n<=1 .or. icompz==0 ) then
                 lwmin = 1
                 liwmin = 1
                 lrwmin = 1
              else if( n<=smlsiz ) then
                 lwmin = 1
                 liwmin = 1
                 lrwmin = 2*( n - 1 )
              else if( icompz==1 ) then
                 lgn = int( log( real( n,KIND=sp) ) / log( two ),KIND=ilp)
                 if( 2**lgn<n )lgn = lgn + 1
                 if( 2**lgn<n )lgn = lgn + 1
                 lwmin = n*n
                 lrwmin = 1 + 3*n + 2*n*lgn + 4*n**2
                 liwmin = 6 + 6*n + 5*n*lgn
              else if( icompz==2 ) then
                 lwmin = 1
                 lrwmin = 1 + 4*n + 2*n**2
                 liwmin = 3 + 5*n
              end if
              work( 1 ) = lwmin
              rwork( 1 ) = lrwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -8
              else if( lrwork<lrwmin .and. .not.lquery ) then
                 info = -10
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSTEDC', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz/=0 )z( 1, 1 ) = one
              return
           end if
           ! if the following conditional clause is removed, then the routine
           ! will use the divide and conquer routine to compute only the
           ! eigenvalues, which requires (3n + 3n**2) real workspace and
           ! (2 + 5n + 2n lg(n)) integer workspace.
           ! since on many architectures stdlib_ssterf is much faster than any other
           ! algorithm for finding eigenvalues only, it is used here
           ! as the default. if the conditional clause is removed, then
           ! information on the size of workspace needs to be changed.
           ! if compz = 'n', use stdlib_ssterf to compute the eigenvalues.
           if( icompz==0 ) then
              call stdlib_ssterf( n, d, e, info )
              go to 70
           end if
           ! if n is smaller than the minimum divide size (smlsiz+1), then
           ! solve the problem with another solver.
           if( n<=smlsiz ) then
              call stdlib_csteqr( compz, n, d, e, z, ldz, rwork, info )
           else
              ! if compz = 'i', we simply call stdlib_sstedc instead.
              if( icompz==2 ) then
                 call stdlib_slaset( 'FULL', n, n, zero, one, rwork, n )
                 ll = n*n + 1
                 call stdlib_sstedc( 'I', n, d, e, rwork, n,rwork( ll ), lrwork-ll+1, iwork, &
                           liwork, info )
                 do j = 1, n
                    do i = 1, n
                       z( i, j ) = rwork( ( j-1 )*n+i )
                    end do
                 end do
                 go to 70
              end if
              ! from now on, only option left to be handled is compz = 'v',
              ! i.e. icompz = 1.
              ! scale.
              orgnrm = stdlib_slanst( 'M', n, d, e )
              if( orgnrm==zero )go to 70
              eps = stdlib_slamch( 'EPSILON' )
              start = 1
              ! while ( start <= n )
              30 continue
              if( start<=n ) then
                 ! let finish be the position of the next subdiagonal entry
                 ! such that e( finish ) <= tiny or finish = n if no such
                 ! subdiagonal exists.  the matrix identified by the elements
                 ! between start and finish constitutes an independent
                 ! sub-problem.
                 finish = start
                 40 continue
                 if( finish<n ) then
                    tiny = eps*sqrt( abs( d( finish ) ) )*sqrt( abs( d( finish+1 ) ) )
                    if( abs( e( finish ) )>tiny ) then
                       finish = finish + 1
                       go to 40
                    end if
                 end if
                 ! (sub) problem determined.  compute its size and solve it.
                 m = finish - start + 1
                 if( m>smlsiz ) then
                    ! scale.
                    orgnrm = stdlib_slanst( 'M', m, d( start ), e( start ) )
                    call stdlib_slascl( 'G', 0, 0, orgnrm, one, m, 1, d( start ), m,info )
                    call stdlib_slascl( 'G', 0, 0, orgnrm, one, m-1, 1, e( start ),m-1, info )
                              
                    call stdlib_claed0( n, m, d( start ), e( start ), z( 1, start ),ldz, work, n, &
                              rwork, iwork, info )
                    if( info>0 ) then
                       info = ( info / ( m+1 )+start-1 )*( n+1 ) +mod( info, ( m+1 ) ) + start - &
                                 1
                       go to 70
                    end if
                    ! scale back.
                    call stdlib_slascl( 'G', 0, 0, one, orgnrm, m, 1, d( start ), m,info )
                 else
                    call stdlib_ssteqr( 'I', m, d( start ), e( start ), rwork, m,rwork( m*m+1 ), &
                              info )
                    call stdlib_clacrm( n, m, z( 1, start ), ldz, rwork, m, work, n,rwork( m*m+1 )&
                               )
                    call stdlib_clacpy( 'A', n, m, work, n, z( 1, start ), ldz )
                    if( info>0 ) then
                       info = start*( n+1 ) + finish
                       go to 70
                    end if
                 end if
                 start = finish + 1
                 go to 30
              end if
              ! endwhile
              ! use selection sort to minimize swaps of eigenvectors
              do ii = 2, n
                i = ii - 1
                k = i
                p = d( i )
                do j = ii, n
                   if( d( j )<p ) then
                      k = j
                      p = d( j )
                   end if
                end do
                if( k/=i ) then
                   d( k ) = d( i )
                   d( i ) = p
                   call stdlib_cswap( n, z( 1, i ), 1, z( 1, k ), 1 )
                end if
              end do
           end if
           70 continue
           work( 1 ) = lwmin
           rwork( 1 ) = lrwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_cstedc


     pure subroutine stdlib_cstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
     !! CSTEGR computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     !! a well defined set of pairwise different real eigenvalues, the corresponding
     !! real eigenvectors are pairwise orthogonal.
     !! The spectrum may be computed either completely or partially by specifying
     !! either an interval (VL,VU] or a range of indices IL:IU for the desired
     !! eigenvalues.
     !! CSTEGR is a compatibility wrapper around the improved CSTEMR routine.
     !! See SSTEMR for further details.
     !! One important change is that the ABSTOL parameter no longer provides any
     !! benefit and hence is no longer used.
     !! Note : CSTEGR and CSTEMR work only on machines which follow
     !! IEEE-754 floating-point standard in their handling of infinities and
     !! NaNs.  Normal execution may create these exceptiona values and hence
     !! may abort due to a floating point exception in environments which
     !! do not conform to the IEEE-754 standard.
               isuppz, work, lwork, iwork,liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           integer(ilp), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: w(*), work(*)
           complex(sp), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: tryrac
           ! Executable Statements 
           info = 0
           tryrac = .false.
           call stdlib_cstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, n, isuppz, &
                     tryrac, work, lwork,iwork, liwork, info )
     end subroutine stdlib_cstegr


     pure subroutine stdlib_ctgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alpha, beta, q, &
     !! CTGSEN reorders the generalized Schur decomposition of a complex
     !! matrix pair (A, B) (in terms of an unitary equivalence trans-
     !! formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues
     !! appears in the leading diagonal blocks of the pair (A,B). The leading
     !! columns of Q and Z form unitary bases of the corresponding left and
     !! right eigenspaces (deflating subspaces). (A, B) must be in
     !! generalized Schur canonical form, that is, A and B are both upper
     !! triangular.
     !! CTGSEN also computes the generalized eigenvalues
     !! w(j)= ALPHA(j) / BETA(j)
     !! of the reordered matrix pair (A, B).
     !! Optionally, the routine computes estimates of reciprocal condition
     !! numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
     !! (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
     !! between the matrix pairs (A11, B11) and (A22,B22) that correspond to
     !! the selected cluster and the eigenvalues outside the cluster, resp.,
     !! and norms of "projections" onto left and right eigenspaces w.r.t.
     !! the selected cluster in the (1,1)-block.
               ldq, z, ldz, m, pl, pr, dif,work, lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(out) :: pl, pr
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: dif(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(sp), intent(out) :: alpha(*), beta(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, swap, wantd, wantd1, wantd2, wantp
           integer(ilp) :: i, ierr, ijb, k, kase, ks, liwmin, lwmin, mn2, n1, n2
           real(sp) :: dscale, dsum, rdscal, safmin
           complex(sp) :: temp1, temp2
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           intrinsic :: abs,cmplx,conjg,max,sqrt
           ! Executable Statements 
           ! decode and test the input parameters
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ijob<0 .or. ijob>5 ) then
              info = -1
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -13
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGSEN', -info )
              return
           end if
           ierr = 0
           wantp = ijob==1 .or. ijob>=4
           wantd1 = ijob==2 .or. ijob==4
           wantd2 = ijob==3 .or. ijob==5
           wantd = wantd1 .or. wantd2
           ! set m to the dimension of the specified pair of deflating
           ! subspaces.
           m = 0
           if( .not.lquery .or. ijob/=0 ) then
           do k = 1, n
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
              if( k<n ) then
                 if( select( k ) )m = m + 1
              else
                 if( select( n ) )m = m + 1
              end if
           end do
           end if
           if( ijob==1 .or. ijob==2 .or. ijob==4 ) then
              lwmin = max( 1, 2*m*(n-m) )
              liwmin = max( 1, n+2 )
           else if( ijob==3 .or. ijob==5 ) then
              lwmin = max( 1, 4*m*(n-m) )
              liwmin = max( 1, 2*m*(n-m), n+2 )
           else
              lwmin = 1
              liwmin = 1
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           if( lwork<lwmin .and. .not.lquery ) then
              info = -21
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -23
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wantp ) then
                 pl = one
                 pr = one
              end if
              if( wantd ) then
                 dscale = zero
                 dsum = one
                 do i = 1, n
                    call stdlib_classq( n, a( 1, i ), 1, dscale, dsum )
                    call stdlib_classq( n, b( 1, i ), 1, dscale, dsum )
                 end do
                 dif( 1 ) = dscale*sqrt( dsum )
                 dif( 2 ) = dif( 1 )
              end if
              go to 70
           end if
           ! get machine constant
           safmin = stdlib_slamch( 'S' )
           ! collect the selected blocks at the top-left corner of (a, b).
           ks = 0
           do k = 1, n
              swap = select( k )
              if( swap ) then
                 ks = ks + 1
                 ! swap the k-th block to position ks. compute unitary q
                 ! and z that will swap adjacent diagonal blocks in (a, b).
                 if( k/=ks )call stdlib_ctgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, k,&
                            ks, ierr )
                 if( ierr>0 ) then
                    ! swap is rejected: exit.
                    info = 1
                    if( wantp ) then
                       pl = zero
                       pr = zero
                    end if
                    if( wantd ) then
                       dif( 1 ) = zero
                       dif( 2 ) = zero
                    end if
                    go to 70
                 end if
              end if
           end do
           if( wantp ) then
              ! solve generalized sylvester equation for r and l:
                         ! a11 * r - l * a22 = a12
                         ! b11 * r - l * b22 = b12
              n1 = m
              n2 = n - m
              i = n1 + 1
              call stdlib_clacpy( 'FULL', n1, n2, a( 1, i ), lda, work, n1 )
              call stdlib_clacpy( 'FULL', n1, n2, b( 1, i ), ldb, work( n1*n2+1 ),n1 )
              ijb = 0
              call stdlib_ctgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b( i,&
               i ), ldb, work( n1*n2+1 ), n1,dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-2*n1*n2, &
                         iwork, ierr )
              ! estimate the reciprocal of norms of "projections" onto
              ! left and right eigenspaces
              rdscal = zero
              dsum = one
              call stdlib_classq( n1*n2, work, 1, rdscal, dsum )
              pl = rdscal*sqrt( dsum )
              if( pl==zero ) then
                 pl = one
              else
                 pl = dscale / ( sqrt( dscale*dscale / pl+pl )*sqrt( pl ) )
              end if
              rdscal = zero
              dsum = one
              call stdlib_classq( n1*n2, work( n1*n2+1 ), 1, rdscal, dsum )
              pr = rdscal*sqrt( dsum )
              if( pr==zero ) then
                 pr = one
              else
                 pr = dscale / ( sqrt( dscale*dscale / pr+pr )*sqrt( pr ) )
              end if
           end if
           if( wantd ) then
              ! compute estimates difu and difl.
              if( wantd1 ) then
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = idifjb
                 ! frobenius norm-based difu estimate.
                 call stdlib_ctgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b(&
                  i, i ), ldb, work( n1*n2+1 ),n1, dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
                 ! frobenius norm-based difl estimate.
                 call stdlib_ctgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda, work,n2, b( i, i ),&
                  ldb, b, ldb, work( n1*n2+1 ),n2, dscale, dif( 2 ), work( n1*n2*2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
              else
                 ! compute 1-norm-based estimates of difu and difl using
                 ! reversed communication with stdlib_clacn2. in each step a
                 ! generalized sylvester equation or a transposed variant
                 ! is solved.
                 kase = 0
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = 0
                 mn2 = 2*n1*n2
                 ! 1-norm-based estimate of difu.
                 40 continue
                 call stdlib_clacn2( mn2, work( mn2+1 ), work, dif( 1 ), kase,isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation
                       call stdlib_ctgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_ctgsyl( 'C', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 40
                 end if
                 dif( 1 ) = dscale / dif( 1 )
                 ! 1-norm-based estimate of difl.
                 50 continue
                 call stdlib_clacn2( mn2, work( mn2+1 ), work, dif( 2 ), kase,isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation
                       call stdlib_ctgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_ctgsyl( 'C', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 50
                 end if
                 dif( 2 ) = dscale / dif( 2 )
              end if
           end if
           ! if b(k,k) is complex, make it real and positive (normalization
           ! of the generalized schur form) and store the generalized
           ! eigenvalues of reordered pair (a, b)
           do k = 1, n
              dscale = abs( b( k, k ) )
              if( dscale>safmin ) then
                 temp1 = conjg( b( k, k ) / dscale )
                 temp2 = b( k, k ) / dscale
                 b( k, k ) = dscale
                 call stdlib_cscal( n-k, temp1, b( k, k+1 ), ldb )
                 call stdlib_cscal( n-k+1, temp1, a( k, k ), lda )
                 if( wantq )call stdlib_cscal( n, temp2, q( 1, k ), 1 )
              else
                 b( k, k ) = cmplx( zero, zero,KIND=sp)
              end if
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
           end do
           70 continue
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_ctgsen


     pure subroutine stdlib_ctgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
     !! CTGSNA estimates reciprocal condition numbers for specified
     !! eigenvalues and/or eigenvectors of a matrix pair (A, B).
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
               dif, mm, m, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: dif(*), s(*)
           complex(sp), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, somcon, wantbh, wantdf, wants
           integer(ilp) :: i, ierr, ifst, ilst, k, ks, lwmin, n1, n2
           real(sp) :: bignum, cond, eps, lnrm, rnrm, scale, smlnum
           complex(sp) :: yhax, yhbx
           ! Local Arrays 
           complex(sp) :: dummy(1), dummy1(1)
           ! Intrinsic Functions 
           intrinsic :: abs,cmplx,max
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantdf = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.wants .and. .not.wantdf ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( wants .and. ldvl<n ) then
              info = -10
           else if( wants .and. ldvr<n ) then
              info = -12
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 do k = 1, n
                    if( select( k ) )m = m + 1
                 end do
              else
                 m = n
              end if
              if( n==0 ) then
                 lwmin = 1
              else if( stdlib_lsame( job, 'V' ) .or. stdlib_lsame( job, 'B' ) ) then
                 lwmin = 2*n*n
              else
                 lwmin = n
              end if
              work( 1 ) = lwmin
              if( mm<m ) then
                 info = -15
              else if( lwork<lwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGSNA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           ks = 0
           loop_20: do k = 1, n
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( .not.select( k ) )cycle loop_20
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 rnrm = stdlib_scnrm2( n, vr( 1, ks ), 1 )
                 lnrm = stdlib_scnrm2( n, vl( 1, ks ), 1 )
                 call stdlib_cgemv( 'N', n, n, cmplx( one, zero,KIND=sp), a, lda,vr( 1, ks ), 1, &
                           cmplx( zero, zero,KIND=sp), work, 1 )
                 yhax = stdlib_cdotc( n, work, 1, vl( 1, ks ), 1 )
                 call stdlib_cgemv( 'N', n, n, cmplx( one, zero,KIND=sp), b, ldb,vr( 1, ks ), 1, &
                           cmplx( zero, zero,KIND=sp), work, 1 )
                 yhbx = stdlib_cdotc( n, work, 1, vl( 1, ks ), 1 )
                 cond = stdlib_slapy2( abs( yhax ), abs( yhbx ) )
                 if( cond==zero ) then
                    s( ks ) = -one
                 else
                    s( ks ) = cond / ( rnrm*lnrm )
                 end if
              end if
              if( wantdf ) then
                 if( n==1 ) then
                    dif( ks ) = stdlib_slapy2( abs( a( 1, 1 ) ), abs( b( 1, 1 ) ) )
                 else
                    ! estimate the reciprocal condition number of the k-th
                    ! eigenvectors.
                    ! copy the matrix (a, b) to the array work and move the
                    ! (k,k)th pair to the (1,1) position.
                    call stdlib_clacpy( 'FULL', n, n, a, lda, work, n )
                    call stdlib_clacpy( 'FULL', n, n, b, ldb, work( n*n+1 ), n )
                    ifst = k
                    ilst = 1
                    call stdlib_ctgexc( .false., .false., n, work, n, work( n*n+1 ),n, dummy, 1, &
                              dummy1, 1, ifst, ilst, ierr )
                    if( ierr>0 ) then
                       ! ill-conditioned problem - swap rejected.
                       dif( ks ) = zero
                    else
                       ! reordering successful, solve generalized sylvester
                       ! equation for r and l,
                                  ! a22 * r - l * a11 = a12
                                  ! b22 * r - l * b11 = b12,
                       ! and compute estimate of difl[(a11,b11), (a22, b22)].
                       n1 = 1
                       n2 = n - n1
                       i = n*n + 1
                       call stdlib_ctgsyl( 'N', idifjb, n2, n1, work( n*n1+n1+1 ),n, work, n, &
                       work( n1+1 ), n,work( n*n1+n1+i ), n, work( i ), n,work( n1+i ), n, scale, &
                                 dif( ks ), dummy,1, iwork, ierr )
                    end if
                 end if
              end if
           end do loop_20
           work( 1 ) = lwmin
           return
     end subroutine stdlib_ctgsna


     subroutine stdlib_ctrsen( job, compq, select, n, t, ldt, q, ldq, w, m, s,sep, work, lwork, &
     !! CTRSEN reorders the Schur factorization of a complex matrix
     !! A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in
     !! the leading positions on the diagonal of the upper triangular matrix
     !! T, and the leading columns of Q form an orthonormal basis of the
     !! corresponding right invariant subspace.
     !! Optionally the routine computes the reciprocal condition numbers of
     !! the cluster of eigenvalues and/or the invariant subspace.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: compq, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldq, ldt, lwork, n
           real(sp), intent(out) :: s, sep
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           complex(sp), intent(inout) :: q(ldq,*), t(ldt,*)
           complex(sp), intent(out) :: w(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wantbh, wantq, wants, wantsp
           integer(ilp) :: ierr, k, kase, ks, lwmin, n1, n2, nn
           real(sp) :: est, rnorm, scale
           ! Local Arrays 
           integer(ilp) :: isave(3)
           real(sp) :: rwork(1)
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! decode and test the input parameters.
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           wantq = stdlib_lsame( compq, 'V' )
           ! set m to the number of selected eigenvalues.
           m = 0
           do k = 1, n
              if( select( k ) )m = m + 1
           end do
           n1 = m
           n2 = n - m
           nn = n1*n2
           info = 0
           lquery = ( lwork==-1 )
           if( wantsp ) then
              lwmin = max( 1, 2*nn )
           else if( stdlib_lsame( job, 'N' ) ) then
              lwmin = 1
           else if( stdlib_lsame( job, 'E' ) ) then
              lwmin = max( 1, nn )
           end if
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.wants .and. .not.wantsp )then
              info = -1
           else if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -8
           else if( lwork<lwmin .and. .not.lquery ) then
              info = -14
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTRSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==n .or. m==0 ) then
              if( wants )s = one
              if( wantsp )sep = stdlib_clange( '1', n, n, t, ldt, rwork )
              go to 40
           end if
           ! collect the selected eigenvalues at the top left corner of t.
           ks = 0
           do k = 1, n
              if( select( k ) ) then
                 ks = ks + 1
                 ! swap the k-th eigenvalue to position ks.
                 if( k/=ks )call stdlib_ctrexc( compq, n, t, ldt, q, ldq, k, ks, ierr )
              end if
           end do
           if( wants ) then
              ! solve the sylvester equation for r:
                 ! t11*r - r*t22 = scale*t12
              call stdlib_clacpy( 'F', n1, n2, t( 1, n1+1 ), ldt, work, n1 )
              call stdlib_ctrsyl( 'N', 'N', -1, n1, n2, t, ldt, t( n1+1, n1+1 ),ldt, work, n1, &
                        scale, ierr )
              ! estimate the reciprocal of the condition number of the cluster
              ! of eigenvalues.
              rnorm = stdlib_clange( 'F', n1, n2, work, n1, rwork )
              if( rnorm==zero ) then
                 s = one
              else
                 s = scale / ( sqrt( scale*scale / rnorm+rnorm )*sqrt( rnorm ) )
              end if
           end if
           if( wantsp ) then
              ! estimate sep(t11,t22).
              est = zero
              kase = 0
              30 continue
              call stdlib_clacn2( nn, work( nn+1 ), work, est, kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! solve t11*r - r*t22 = scale*x.
                    call stdlib_ctrsyl( 'N', 'N', -1, n1, n2, t, ldt,t( n1+1, n1+1 ), ldt, work, &
                              n1, scale,ierr )
                 else
                    ! solve t11**h*r - r*t22**h = scale*x.
                    call stdlib_ctrsyl( 'C', 'C', -1, n1, n2, t, ldt,t( n1+1, n1+1 ), ldt, work, &
                              n1, scale,ierr )
                 end if
                 go to 30
              end if
              sep = scale / est
           end if
           40 continue
           ! copy reordered eigenvalues to w.
           do k = 1, n
              w( k ) = t( k, k )
           end do
           work( 1 ) = lwmin
           return
     end subroutine stdlib_ctrsen


     subroutine stdlib_cunbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
     !! CUNBDB1 simultaneously bidiagonalizes the blocks of a tall and skinny
     !! matrix X with orthonomal columns:
     !! [ B11 ]
     !! [ X11 ]   [ P1 |    ] [  0  ]
     !! [-----] = [---------] [-----] Q1**T .
     !! [ X21 ]   [    | P2 ] [ B21 ]
     !! [  0  ]
     !! X11 is P-by-Q, and X21 is (M-P)-by-Q. Q must be no larger than P,
     !! M-P, or M-Q. Routines CUNBDB2, CUNBDB3, and CUNBDB4 handle cases in
     !! which Q is not the minimum dimension.
     !! The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
     !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
     !! Householder vectors.
     !! B11 and B12 are Q-by-Q bidiagonal matrices represented implicitly by
     !! angles THETA, PHI.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lwork, m, p, q, ldx11, ldx21
           ! Array Arguments 
           real(sp), intent(out) :: phi(*), theta(*)
           complex(sp), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           complex(sp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
        ! ====================================================================
           
           ! Local Scalars 
           real(sp) :: c, s
           integer(ilp) :: childinfo, i, ilarf, iorbdb5, llarf, lorbdb5, lworkmin, &
                     lworkopt
           logical(lk) :: lquery
           ! Intrinsic Function 
           intrinsic :: atan2,cos,max,sin,sqrt
           ! Executable Statements 
           ! test input arguments
           info = 0
           lquery = lwork == -1
           if( m < 0 ) then
              info = -1
           else if( p < q .or. m-p < q ) then
              info = -2
           else if( q < 0 .or. m-q < q ) then
              info = -3
           else if( ldx11 < max( 1, p ) ) then
              info = -5
           else if( ldx21 < max( 1, m-p ) ) then
              info = -7
           end if
           ! compute workspace
           if( info == 0 ) then
              ilarf = 2
              llarf = max( p-1, m-p-1, q-1 )
              iorbdb5 = 2
              lorbdb5 = q-2
              lworkopt = max( ilarf+llarf-1, iorbdb5+lorbdb5-1 )
              lworkmin = lworkopt
              work(1) = lworkopt
              if( lwork < lworkmin .and. .not.lquery ) then
                info = -14
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'CUNBDB1', -info )
              return
           else if( lquery ) then
              return
           end if
           ! reduce columns 1, ..., q of x11 and x21
           do i = 1, q
              call stdlib_clarfgp( p-i+1, x11(i,i), x11(i+1,i), 1, taup1(i) )
              call stdlib_clarfgp( m-p-i+1, x21(i,i), x21(i+1,i), 1, taup2(i) )
              theta(i) = atan2( real( x21(i,i),KIND=sp), real( x11(i,i),KIND=sp) )
              c = cos( theta(i) )
              s = sin( theta(i) )
              x11(i,i) = cone
              x21(i,i) = cone
              call stdlib_clarf( 'L', p-i+1, q-i, x11(i,i), 1, conjg(taup1(i)),x11(i,i+1), ldx11, &
                        work(ilarf) )
              call stdlib_clarf( 'L', m-p-i+1, q-i, x21(i,i), 1, conjg(taup2(i)),x21(i,i+1), &
                        ldx21, work(ilarf) )
              if( i < q ) then
                 call stdlib_csrot( q-i, x11(i,i+1), ldx11, x21(i,i+1), ldx21, c,s )
                 call stdlib_clacgv( q-i, x21(i,i+1), ldx21 )
                 call stdlib_clarfgp( q-i, x21(i,i+1), x21(i,i+2), ldx21, tauq1(i) )
                 s = real( x21(i,i+1),KIND=sp)
                 x21(i,i+1) = cone
                 call stdlib_clarf( 'R', p-i, q-i, x21(i,i+1), ldx21, tauq1(i),x11(i+1,i+1), &
                           ldx11, work(ilarf) )
                 call stdlib_clarf( 'R', m-p-i, q-i, x21(i,i+1), ldx21, tauq1(i),x21(i+1,i+1), &
                           ldx21, work(ilarf) )
                 call stdlib_clacgv( q-i, x21(i,i+1), ldx21 )
                 c = sqrt( stdlib_scnrm2( p-i, x11(i+1,i+1), 1 )**2+ stdlib_scnrm2( m-p-i, x21(i+&
                           1,i+1), 1 )**2 )
                 phi(i) = atan2( s, c )
                 call stdlib_cunbdb5( p-i, m-p-i, q-i-1, x11(i+1,i+1), 1,x21(i+1,i+1), 1, x11(i+1,&
                           i+2), ldx11,x21(i+1,i+2), ldx21, work(iorbdb5), lorbdb5,childinfo )
              end if
           end do
           return
     end subroutine stdlib_cunbdb1


     subroutine stdlib_cunbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
     !! CUNBDB2 simultaneously bidiagonalizes the blocks of a tall and skinny
     !! matrix X with orthonomal columns:
     !! [ B11 ]
     !! [ X11 ]   [ P1 |    ] [  0  ]
     !! [-----] = [---------] [-----] Q1**T .
     !! [ X21 ]   [    | P2 ] [ B21 ]
     !! [  0  ]
     !! X11 is P-by-Q, and X21 is (M-P)-by-Q. P must be no larger than M-P,
     !! Q, or M-Q. Routines CUNBDB1, CUNBDB3, and CUNBDB4 handle cases in
     !! which P is not the minimum dimension.
     !! The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
     !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
     !! Householder vectors.
     !! B11 and B12 are P-by-P bidiagonal matrices represented implicitly by
     !! angles THETA, PHI.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lwork, m, p, q, ldx11, ldx21
           ! Array Arguments 
           real(sp), intent(out) :: phi(*), theta(*)
           complex(sp), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           complex(sp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
        ! ====================================================================
           
           ! Local Scalars 
           real(sp) :: c, s
           integer(ilp) :: childinfo, i, ilarf, iorbdb5, llarf, lorbdb5, lworkmin, &
                     lworkopt
           logical(lk) :: lquery
           ! Intrinsic Function 
           intrinsic :: atan2,cos,max,sin,sqrt
           ! Executable Statements 
           ! test input arguments
           info = 0
           lquery = lwork == -1
           if( m < 0 ) then
              info = -1
           else if( p < 0 .or. p > m-p ) then
              info = -2
           else if( q < 0 .or. q < p .or. m-q < p ) then
              info = -3
           else if( ldx11 < max( 1, p ) ) then
              info = -5
           else if( ldx21 < max( 1, m-p ) ) then
              info = -7
           end if
           ! compute workspace
           if( info == 0 ) then
              ilarf = 2
              llarf = max( p-1, m-p, q-1 )
              iorbdb5 = 2
              lorbdb5 = q-1
              lworkopt = max( ilarf+llarf-1, iorbdb5+lorbdb5-1 )
              lworkmin = lworkopt
              work(1) = lworkopt
              if( lwork < lworkmin .and. .not.lquery ) then
                info = -14
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'CUNBDB2', -info )
              return
           else if( lquery ) then
              return
           end if
           ! reduce rows 1, ..., p of x11 and x21
           do i = 1, p
              if( i > 1 ) then
                 call stdlib_csrot( q-i+1, x11(i,i), ldx11, x21(i-1,i), ldx21, c,s )
              end if
              call stdlib_clacgv( q-i+1, x11(i,i), ldx11 )
              call stdlib_clarfgp( q-i+1, x11(i,i), x11(i,i+1), ldx11, tauq1(i) )
              c = real( x11(i,i),KIND=sp)
              x11(i,i) = cone
              call stdlib_clarf( 'R', p-i, q-i+1, x11(i,i), ldx11, tauq1(i),x11(i+1,i), ldx11, &
                        work(ilarf) )
              call stdlib_clarf( 'R', m-p-i+1, q-i+1, x11(i,i), ldx11, tauq1(i),x21(i,i), ldx21, &
                        work(ilarf) )
              call stdlib_clacgv( q-i+1, x11(i,i), ldx11 )
              s = sqrt( stdlib_scnrm2( p-i, x11(i+1,i), 1 )**2+ stdlib_scnrm2( m-p-i+1, x21(i,i), &
                        1 )**2 )
              theta(i) = atan2( s, c )
              call stdlib_cunbdb5( p-i, m-p-i+1, q-i, x11(i+1,i), 1, x21(i,i), 1,x11(i+1,i+1), &
                        ldx11, x21(i,i+1), ldx21,work(iorbdb5), lorbdb5, childinfo )
              call stdlib_cscal( p-i, cnegone, x11(i+1,i), 1 )
              call stdlib_clarfgp( m-p-i+1, x21(i,i), x21(i+1,i), 1, taup2(i) )
              if( i < p ) then
                 call stdlib_clarfgp( p-i, x11(i+1,i), x11(i+2,i), 1, taup1(i) )
                 phi(i) = atan2( real( x11(i+1,i),KIND=sp), real( x21(i,i),KIND=sp) )
                 c = cos( phi(i) )
                 s = sin( phi(i) )
                 x11(i+1,i) = cone
                 call stdlib_clarf( 'L', p-i, q-i, x11(i+1,i), 1, conjg(taup1(i)),x11(i+1,i+1), &
                           ldx11, work(ilarf) )
              end if
              x21(i,i) = cone
              call stdlib_clarf( 'L', m-p-i+1, q-i, x21(i,i), 1, conjg(taup2(i)),x21(i,i+1), &
                        ldx21, work(ilarf) )
           end do
           ! reduce the bottom-right portion of x21 to the identity matrix
           do i = p + 1, q
              call stdlib_clarfgp( m-p-i+1, x21(i,i), x21(i+1,i), 1, taup2(i) )
              x21(i,i) = cone
              call stdlib_clarf( 'L', m-p-i+1, q-i, x21(i,i), 1, conjg(taup2(i)),x21(i,i+1), &
                        ldx21, work(ilarf) )
           end do
           return
     end subroutine stdlib_cunbdb2


     subroutine stdlib_cunbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
     !! CUNBDB3 simultaneously bidiagonalizes the blocks of a tall and skinny
     !! matrix X with orthonomal columns:
     !! [ B11 ]
     !! [ X11 ]   [ P1 |    ] [  0  ]
     !! [-----] = [---------] [-----] Q1**T .
     !! [ X21 ]   [    | P2 ] [ B21 ]
     !! [  0  ]
     !! X11 is P-by-Q, and X21 is (M-P)-by-Q. M-P must be no larger than P,
     !! Q, or M-Q. Routines CUNBDB1, CUNBDB2, and CUNBDB4 handle cases in
     !! which M-P is not the minimum dimension.
     !! The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
     !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
     !! Householder vectors.
     !! B11 and B12 are (M-P)-by-(M-P) bidiagonal matrices represented
     !! implicitly by angles THETA, PHI.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lwork, m, p, q, ldx11, ldx21
           ! Array Arguments 
           real(sp), intent(out) :: phi(*), theta(*)
           complex(sp), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           complex(sp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
        ! ====================================================================
           
           ! Local Scalars 
           real(sp) :: c, s
           integer(ilp) :: childinfo, i, ilarf, iorbdb5, llarf, lorbdb5, lworkmin, &
                     lworkopt
           logical(lk) :: lquery
           ! Intrinsic Function 
           intrinsic :: atan2,cos,max,sin,sqrt
           ! Executable Statements 
           ! test input arguments
           info = 0
           lquery = lwork == -1
           if( m < 0 ) then
              info = -1
           else if( 2*p < m .or. p > m ) then
              info = -2
           else if( q < m-p .or. m-q < m-p ) then
              info = -3
           else if( ldx11 < max( 1, p ) ) then
              info = -5
           else if( ldx21 < max( 1, m-p ) ) then
              info = -7
           end if
           ! compute workspace
           if( info == 0 ) then
              ilarf = 2
              llarf = max( p, m-p-1, q-1 )
              iorbdb5 = 2
              lorbdb5 = q-1
              lworkopt = max( ilarf+llarf-1, iorbdb5+lorbdb5-1 )
              lworkmin = lworkopt
              work(1) = lworkopt
              if( lwork < lworkmin .and. .not.lquery ) then
                info = -14
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'CUNBDB3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! reduce rows 1, ..., m-p of x11 and x21
           do i = 1, m-p
              if( i > 1 ) then
                 call stdlib_csrot( q-i+1, x11(i-1,i), ldx11, x21(i,i), ldx11, c,s )
              end if
              call stdlib_clacgv( q-i+1, x21(i,i), ldx21 )
              call stdlib_clarfgp( q-i+1, x21(i,i), x21(i,i+1), ldx21, tauq1(i) )
              s = real( x21(i,i),KIND=sp)
              x21(i,i) = cone
              call stdlib_clarf( 'R', p-i+1, q-i+1, x21(i,i), ldx21, tauq1(i),x11(i,i), ldx11, &
                        work(ilarf) )
              call stdlib_clarf( 'R', m-p-i, q-i+1, x21(i,i), ldx21, tauq1(i),x21(i+1,i), ldx21, &
                        work(ilarf) )
              call stdlib_clacgv( q-i+1, x21(i,i), ldx21 )
              c = sqrt( stdlib_scnrm2( p-i+1, x11(i,i), 1 )**2+ stdlib_scnrm2( m-p-i, x21(i+1,i), &
                        1 )**2 )
              theta(i) = atan2( s, c )
              call stdlib_cunbdb5( p-i+1, m-p-i, q-i, x11(i,i), 1, x21(i+1,i), 1,x11(i,i+1), &
                        ldx11, x21(i+1,i+1), ldx21,work(iorbdb5), lorbdb5, childinfo )
              call stdlib_clarfgp( p-i+1, x11(i,i), x11(i+1,i), 1, taup1(i) )
              if( i < m-p ) then
                 call stdlib_clarfgp( m-p-i, x21(i+1,i), x21(i+2,i), 1, taup2(i) )
                 phi(i) = atan2( real( x21(i+1,i),KIND=sp), real( x11(i,i),KIND=sp) )
                 c = cos( phi(i) )
                 s = sin( phi(i) )
                 x21(i+1,i) = cone
                 call stdlib_clarf( 'L', m-p-i, q-i, x21(i+1,i), 1, conjg(taup2(i)),x21(i+1,i+1), &
                           ldx21, work(ilarf) )
              end if
              x11(i,i) = cone
              call stdlib_clarf( 'L', p-i+1, q-i, x11(i,i), 1, conjg(taup1(i)),x11(i,i+1), ldx11, &
                        work(ilarf) )
           end do
           ! reduce the bottom-right portion of x11 to the identity matrix
           do i = m-p + 1, q
              call stdlib_clarfgp( p-i+1, x11(i,i), x11(i+1,i), 1, taup1(i) )
              x11(i,i) = cone
              call stdlib_clarf( 'L', p-i+1, q-i, x11(i,i), 1, conjg(taup1(i)),x11(i,i+1), ldx11, &
                        work(ilarf) )
           end do
           return
     end subroutine stdlib_cunbdb3


     subroutine stdlib_cunbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
     !! CUNBDB4 simultaneously bidiagonalizes the blocks of a tall and skinny
     !! matrix X with orthonomal columns:
     !! [ B11 ]
     !! [ X11 ]   [ P1 |    ] [  0  ]
     !! [-----] = [---------] [-----] Q1**T .
     !! [ X21 ]   [    | P2 ] [ B21 ]
     !! [  0  ]
     !! X11 is P-by-Q, and X21 is (M-P)-by-Q. M-Q must be no larger than P,
     !! M-P, or Q. Routines CUNBDB1, CUNBDB2, and CUNBDB3 handle cases in
     !! which M-Q is not the minimum dimension.
     !! The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
     !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
     !! Householder vectors.
     !! B11 and B12 are (M-Q)-by-(M-Q) bidiagonal matrices represented
     !! implicitly by angles THETA, PHI.
               phantom, work, lwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lwork, m, p, q, ldx11, ldx21
           ! Array Arguments 
           real(sp), intent(out) :: phi(*), theta(*)
           complex(sp), intent(out) :: phantom(*), taup1(*), taup2(*), tauq1(*), work(*)
           complex(sp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
        ! ====================================================================
           
           ! Local Scalars 
           real(sp) :: c, s
           integer(ilp) :: childinfo, i, ilarf, iorbdb5, j, llarf, lorbdb5, lworkmin, &
                     lworkopt
           logical(lk) :: lquery
           ! Intrinsic Function 
           intrinsic :: atan2,cos,max,sin,sqrt
           ! Executable Statements 
           ! test input arguments
           info = 0
           lquery = lwork == -1
           if( m < 0 ) then
              info = -1
           else if( p < m-q .or. m-p < m-q ) then
              info = -2
           else if( q < m-q .or. q > m ) then
              info = -3
           else if( ldx11 < max( 1, p ) ) then
              info = -5
           else if( ldx21 < max( 1, m-p ) ) then
              info = -7
           end if
           ! compute workspace
           if( info == 0 ) then
              ilarf = 2
              llarf = max( q-1, p-1, m-p-1 )
              iorbdb5 = 2
              lorbdb5 = q
              lworkopt = ilarf + llarf - 1
              lworkopt = max( lworkopt, iorbdb5 + lorbdb5 - 1 )
              lworkmin = lworkopt
              work(1) = lworkopt
              if( lwork < lworkmin .and. .not.lquery ) then
                info = -14
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'CUNBDB4', -info )
              return
           else if( lquery ) then
              return
           end if
           ! reduce columns 1, ..., m-q of x11 and x21
           do i = 1, m-q
              if( i == 1 ) then
                 do j = 1, m
                    phantom(j) = czero
                 end do
                 call stdlib_cunbdb5( p, m-p, q, phantom(1), 1, phantom(p+1), 1,x11, ldx11, x21, &
                           ldx21, work(iorbdb5),lorbdb5, childinfo )
                 call stdlib_cscal( p, cnegone, phantom(1), 1 )
                 call stdlib_clarfgp( p, phantom(1), phantom(2), 1, taup1(1) )
                 call stdlib_clarfgp( m-p, phantom(p+1), phantom(p+2), 1, taup2(1) )
                 theta(i) = atan2( real( phantom(1),KIND=sp), real( phantom(p+1),KIND=sp) )
                           
                 c = cos( theta(i) )
                 s = sin( theta(i) )
                 phantom(1) = cone
                 phantom(p+1) = cone
                 call stdlib_clarf( 'L', p, q, phantom(1), 1, conjg(taup1(1)), x11,ldx11, work(&
                           ilarf) )
                 call stdlib_clarf( 'L', m-p, q, phantom(p+1), 1, conjg(taup2(1)),x21, ldx21, &
                           work(ilarf) )
              else
                 call stdlib_cunbdb5( p-i+1, m-p-i+1, q-i+1, x11(i,i-1), 1,x21(i,i-1), 1, x11(i,i)&
                           , ldx11, x21(i,i),ldx21, work(iorbdb5), lorbdb5, childinfo )
                 call stdlib_cscal( p-i+1, cnegone, x11(i,i-1), 1 )
                 call stdlib_clarfgp( p-i+1, x11(i,i-1), x11(i+1,i-1), 1, taup1(i) )
                 call stdlib_clarfgp( m-p-i+1, x21(i,i-1), x21(i+1,i-1), 1,taup2(i) )
                 theta(i) = atan2( real( x11(i,i-1),KIND=sp), real( x21(i,i-1),KIND=sp) )
                 c = cos( theta(i) )
                 s = sin( theta(i) )
                 x11(i,i-1) = cone
                 x21(i,i-1) = cone
                 call stdlib_clarf( 'L', p-i+1, q-i+1, x11(i,i-1), 1,conjg(taup1(i)), x11(i,i), &
                           ldx11, work(ilarf) )
                 call stdlib_clarf( 'L', m-p-i+1, q-i+1, x21(i,i-1), 1,conjg(taup2(i)), x21(i,i), &
                           ldx21, work(ilarf) )
              end if
              call stdlib_csrot( q-i+1, x11(i,i), ldx11, x21(i,i), ldx21, s, -c )
              call stdlib_clacgv( q-i+1, x21(i,i), ldx21 )
              call stdlib_clarfgp( q-i+1, x21(i,i), x21(i,i+1), ldx21, tauq1(i) )
              c = real( x21(i,i),KIND=sp)
              x21(i,i) = cone
              call stdlib_clarf( 'R', p-i, q-i+1, x21(i,i), ldx21, tauq1(i),x11(i+1,i), ldx11, &
                        work(ilarf) )
              call stdlib_clarf( 'R', m-p-i, q-i+1, x21(i,i), ldx21, tauq1(i),x21(i+1,i), ldx21, &
                        work(ilarf) )
              call stdlib_clacgv( q-i+1, x21(i,i), ldx21 )
              if( i < m-q ) then
                 s = sqrt( stdlib_scnrm2( p-i, x11(i+1,i), 1 )**2+ stdlib_scnrm2( m-p-i, x21(i+1,&
                           i), 1 )**2 )
                 phi(i) = atan2( s, c )
              end if
           end do
           ! reduce the bottom-right portion of x11 to [ i 0 ]
           do i = m - q + 1, p
              call stdlib_clacgv( q-i+1, x11(i,i), ldx11 )
              call stdlib_clarfgp( q-i+1, x11(i,i), x11(i,i+1), ldx11, tauq1(i) )
              x11(i,i) = cone
              call stdlib_clarf( 'R', p-i, q-i+1, x11(i,i), ldx11, tauq1(i),x11(i+1,i), ldx11, &
                        work(ilarf) )
              call stdlib_clarf( 'R', q-p, q-i+1, x11(i,i), ldx11, tauq1(i),x21(m-q+1,i), ldx21, &
                        work(ilarf) )
              call stdlib_clacgv( q-i+1, x11(i,i), ldx11 )
           end do
           ! reduce the bottom-right portion of x21 to [ 0 i ]
           do i = p + 1, q
              call stdlib_clacgv( q-i+1, x21(m-q+i-p,i), ldx21 )
              call stdlib_clarfgp( q-i+1, x21(m-q+i-p,i), x21(m-q+i-p,i+1), ldx21,tauq1(i) )
                        
              x21(m-q+i-p,i) = cone
              call stdlib_clarf( 'R', q-i, q-i+1, x21(m-q+i-p,i), ldx21, tauq1(i),x21(m-q+i-p+1,i)&
                        , ldx21, work(ilarf) )
              call stdlib_clacgv( q-i+1, x21(m-q+i-p,i), ldx21 )
           end do
           return
     end subroutine stdlib_cunbdb4


     subroutine stdlib_cuncsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta, &
     !! CUNCSD2BY1 computes the CS decomposition of an M-by-Q matrix X with
     !! orthonormal columns that has been partitioned into a 2-by-1 block
     !! structure:
     !! [  I1 0  0 ]
     !! [  0  C  0 ]
     !! [ X11 ]   [ U1 |    ] [  0  0  0 ]
     !! X = [-----] = [---------] [----------] V1**T .
     !! [ X21 ]   [    | U2 ] [  0  0  0 ]
     !! [  0  S  0 ]
     !! [  0  0  I2]
     !! X11 is P-by-Q. The unitary matrices U1, U2, and V1 are P-by-P,
     !! (M-P)-by-(M-P), and Q-by-Q, respectively. C and S are R-by-R
     !! nonnegative diagonal matrices satisfying C^2 + S^2 = I, in which
     !! R = MIN(P,M-P,Q,M-Q). I1 is a K1-by-K1 identity matrix and I2 is a
     !! K2-by-K2 identity matrix, where K1 = MAX(Q+P-M,0), K2 = MAX(Q-P,0).
               u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, rwork, lrwork, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobu1, jobu2, jobv1t
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu1, ldu2, ldv1t, lwork, ldx11, ldx21, m, p, q
           integer(ilp), intent(in) :: lrwork
           integer(ilp) :: lrworkmin, lrworkopt
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           real(sp), intent(out) :: theta(*)
           complex(sp), intent(out) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), work(*)
           complex(sp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
           integer(ilp), intent(out) :: iwork(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: childinfo, i, ib11d, ib11e, ib12d, ib12e, ib21d, ib21e, ib22d, ib22e, &
           ibbcsd, iorbdb, iorglq, iorgqr, iphi, itaup1, itaup2, itauq1, j, lbbcsd, lorbdb, &
           lorglq, lorglqmin, lorglqopt, lorgqr, lorgqrmin, lorgqropt, lworkmin, lworkopt, &
                     r
           logical(lk) :: lquery, wantu1, wantu2, wantv1t
           ! Local Arrays 
           real(sp) :: dum(1)
           complex(sp) :: cdum(1,1)
           ! Intrinsic Function 
           intrinsic :: int,max,min
           ! Executable Statements 
           ! test input arguments
           info = 0
           wantu1 = stdlib_lsame( jobu1, 'Y' )
           wantu2 = stdlib_lsame( jobu2, 'Y' )
           wantv1t = stdlib_lsame( jobv1t, 'Y' )
           lquery = ( lwork==-1 ) .or. ( lrwork==-1 )
           if( m < 0 ) then
              info = -4
           else if( p < 0 .or. p > m ) then
              info = -5
           else if( q < 0 .or. q > m ) then
              info = -6
           else if( ldx11 < max( 1, p ) ) then
              info = -8
           else if( ldx21 < max( 1, m-p ) ) then
              info = -10
           else if( wantu1 .and. ldu1 < max( 1, p ) ) then
              info = -13
           else if( wantu2 .and. ldu2 < max( 1, m - p ) ) then
              info = -15
           else if( wantv1t .and. ldv1t < max( 1, q ) ) then
              info = -17
           end if
           r = min( p, m-p, q, m-q )
           ! compute workspace
             ! work layout:
           ! |-----------------------------------------|
           ! | lworkopt (1)                            |
           ! |-----------------------------------------|
           ! | taup1 (max(1,p))                        |
           ! | taup2 (max(1,m-p))                      |
           ! | tauq1 (max(1,q))                        |
           ! |-----------------------------------------|
           ! | stdlib_cunbdb work | stdlib_cungqr work | stdlib_cunglq work |
           ! |             |             |             |
           ! |             |             |             |
           ! |             |             |             |
           ! |             |             |             |
           ! |-----------------------------------------|
             ! rwork layout:
           ! |------------------|
           ! | lrworkopt (1)    |
           ! |------------------|
           ! | phi (max(1,r-1)) |
           ! |------------------|
           ! | b11d (r)         |
           ! | b11e (r-1)       |
           ! | b12d (r)         |
           ! | b12e (r-1)       |
           ! | b21d (r)         |
           ! | b21e (r-1)       |
           ! | b22d (r)         |
           ! | b22e (r-1)       |
           ! | stdlib_cbbcsd rwork     |
           ! |------------------|
           if( info == 0 ) then
              iphi = 2
              ib11d = iphi + max( 1, r-1 )
              ib11e = ib11d + max( 1, r )
              ib12d = ib11e + max( 1, r - 1 )
              ib12e = ib12d + max( 1, r )
              ib21d = ib12e + max( 1, r - 1 )
              ib21e = ib21d + max( 1, r )
              ib22d = ib21e + max( 1, r - 1 )
              ib22e = ib22d + max( 1, r )
              ibbcsd = ib22e + max( 1, r - 1 )
              itaup1 = 2
              itaup2 = itaup1 + max( 1, p )
              itauq1 = itaup2 + max( 1, m-p )
              iorbdb = itauq1 + max( 1, q )
              iorgqr = itauq1 + max( 1, q )
              iorglq = itauq1 + max( 1, q )
              lorgqrmin = 1
              lorgqropt = 1
              lorglqmin = 1
              lorglqopt = 1
              if( r == q ) then
                 call stdlib_cunbdb1( m, p, q, x11, ldx11, x21, ldx21, theta,dum, cdum, cdum, &
                           cdum, work, -1,childinfo )
                 lorbdb = int( work(1),KIND=ilp)
                 if( wantu1 .and. p > 0 ) then
                    call stdlib_cungqr( p, p, q, u1, ldu1, cdum, work(1), -1,childinfo )
                    lorgqrmin = max( lorgqrmin, p )
                    lorgqropt = max( lorgqropt, int( work(1),KIND=ilp) )
                 endif
                 if( wantu2 .and. m-p > 0 ) then
                    call stdlib_cungqr( m-p, m-p, q, u2, ldu2, cdum, work(1), -1,childinfo )
                              
                    lorgqrmin = max( lorgqrmin, m-p )
                    lorgqropt = max( lorgqropt, int( work(1),KIND=ilp) )
                 end if
                 if( wantv1t .and. q > 0 ) then
                    call stdlib_cunglq( q-1, q-1, q-1, v1t, ldv1t,cdum, work(1), -1, childinfo )
                              
                    lorglqmin = max( lorglqmin, q-1 )
                    lorglqopt = max( lorglqopt, int( work(1),KIND=ilp) )
                 end if
                 call stdlib_cbbcsd( jobu1, jobu2, jobv1t, 'N', 'N', m, p, q, theta,dum(1), u1, &
                 ldu1, u2, ldu2, v1t, ldv1t, cdum,1, dum, dum, dum, dum, dum, dum, dum, dum,rwork(&
                           1), -1, childinfo )
                 lbbcsd = int( rwork(1),KIND=ilp)
              else if( r == p ) then
                 call stdlib_cunbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, dum,cdum, cdum, &
                           cdum, work(1), -1, childinfo )
                 lorbdb = int( work(1),KIND=ilp)
                 if( wantu1 .and. p > 0 ) then
                    call stdlib_cungqr( p-1, p-1, p-1, u1(2,2), ldu1, cdum, work(1),-1, childinfo &
                              )
                    lorgqrmin = max( lorgqrmin, p-1 )
                    lorgqropt = max( lorgqropt, int( work(1),KIND=ilp) )
                 end if
                 if( wantu2 .and. m-p > 0 ) then
                    call stdlib_cungqr( m-p, m-p, q, u2, ldu2, cdum, work(1), -1,childinfo )
                              
                    lorgqrmin = max( lorgqrmin, m-p )
                    lorgqropt = max( lorgqropt, int( work(1),KIND=ilp) )
                 end if
                 if( wantv1t .and. q > 0 ) then
                    call stdlib_cunglq( q, q, r, v1t, ldv1t, cdum, work(1), -1,childinfo )
                    lorglqmin = max( lorglqmin, q )
                    lorglqopt = max( lorglqopt, int( work(1),KIND=ilp) )
                 end if
                 call stdlib_cbbcsd( jobv1t, 'N', jobu1, jobu2, 'T', m, q, p, theta,dum, v1t, &
                 ldv1t, cdum, 1, u1, ldu1, u2, ldu2,dum, dum, dum, dum, dum, dum, dum, dum,rwork(&
                           1), -1, childinfo )
                 lbbcsd = int( rwork(1),KIND=ilp)
              else if( r == m-p ) then
                 call stdlib_cunbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, dum,cdum, cdum, &
                           cdum, work(1), -1, childinfo )
                 lorbdb = int( work(1),KIND=ilp)
                 if( wantu1 .and. p > 0 ) then
                    call stdlib_cungqr( p, p, q, u1, ldu1, cdum, work(1), -1,childinfo )
                    lorgqrmin = max( lorgqrmin, p )
                    lorgqropt = max( lorgqropt, int( work(1),KIND=ilp) )
                 end if
                 if( wantu2 .and. m-p > 0 ) then
                    call stdlib_cungqr( m-p-1, m-p-1, m-p-1, u2(2,2), ldu2, cdum,work(1), -1, &
                              childinfo )
                    lorgqrmin = max( lorgqrmin, m-p-1 )
                    lorgqropt = max( lorgqropt, int( work(1),KIND=ilp) )
                 end if
                 if( wantv1t .and. q > 0 ) then
                    call stdlib_cunglq( q, q, r, v1t, ldv1t, cdum, work(1), -1,childinfo )
                    lorglqmin = max( lorglqmin, q )
                    lorglqopt = max( lorglqopt, int( work(1),KIND=ilp) )
                 end if
                 call stdlib_cbbcsd( 'N', jobv1t, jobu2, jobu1, 'T', m, m-q, m-p,theta, dum, cdum,&
                  1, v1t, ldv1t, u2, ldu2, u1,ldu1, dum, dum, dum, dum, dum, dum, dum, dum,rwork(&
                            1), -1, childinfo )
                 lbbcsd = int( rwork(1),KIND=ilp)
              else
                 call stdlib_cunbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, dum,cdum, cdum, &
                           cdum, cdum, work(1), -1, childinfo)
                 lorbdb = m + int( work(1),KIND=ilp)
                 if( wantu1 .and. p > 0 ) then
                    call stdlib_cungqr( p, p, m-q, u1, ldu1, cdum, work(1), -1,childinfo )
                    lorgqrmin = max( lorgqrmin, p )
                    lorgqropt = max( lorgqropt, int( work(1),KIND=ilp) )
                 end if
                 if( wantu2 .and. m-p > 0 ) then
                    call stdlib_cungqr( m-p, m-p, m-q, u2, ldu2, cdum, work(1), -1,childinfo )
                              
                    lorgqrmin = max( lorgqrmin, m-p )
                    lorgqropt = max( lorgqropt, int( work(1),KIND=ilp) )
                 end if
                 if( wantv1t .and. q > 0 ) then
                    call stdlib_cunglq( q, q, q, v1t, ldv1t, cdum, work(1), -1,childinfo )
                    lorglqmin = max( lorglqmin, q )
                    lorglqopt = max( lorglqopt, int( work(1),KIND=ilp) )
                 end if
                 call stdlib_cbbcsd( jobu2, jobu1, 'N', jobv1t, 'N', m, m-p, m-q,theta, dum, u2, &
                 ldu2, u1, ldu1, cdum, 1, v1t,ldv1t, dum, dum, dum, dum, dum, dum, dum, dum,rwork(&
                           1), -1, childinfo )
                 lbbcsd = int( rwork(1),KIND=ilp)
              end if
              lrworkmin = ibbcsd+lbbcsd-1
              lrworkopt = lrworkmin
              rwork(1) = lrworkopt
              lworkmin = max( iorbdb+lorbdb-1,iorgqr+lorgqrmin-1,iorglq+lorglqmin-1 )
              lworkopt = max( iorbdb+lorbdb-1,iorgqr+lorgqropt-1,iorglq+lorglqopt-1 )
              work(1) = lworkopt
              if( lwork < lworkmin .and. .not.lquery ) then
                 info = -19
              end if
              if( lrwork < lrworkmin .and. .not.lquery ) then
                 info = -21
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'CUNCSD2BY1', -info )
              return
           else if( lquery ) then
              return
           end if
           lorgqr = lwork-iorgqr+1
           lorglq = lwork-iorglq+1
           ! handle four cases separately: r = q, r = p, r = m-p, and r = m-q,
           ! in which r = min(p,m-p,q,m-q)
           if( r == q ) then
              ! case 1: r = q
              ! simultaneously bidiagonalize x11 and x21
              call stdlib_cunbdb1( m, p, q, x11, ldx11, x21, ldx21, theta,rwork(iphi), work(&
                        itaup1), work(itaup2),work(itauq1), work(iorbdb), lorbdb, childinfo )
              ! accumulate householder reflectors
              if( wantu1 .and. p > 0 ) then
                 call stdlib_clacpy( 'L', p, q, x11, ldx11, u1, ldu1 )
                 call stdlib_cungqr( p, p, q, u1, ldu1, work(itaup1), work(iorgqr),lorgqr, &
                           childinfo )
              end if
              if( wantu2 .and. m-p > 0 ) then
                 call stdlib_clacpy( 'L', m-p, q, x21, ldx21, u2, ldu2 )
                 call stdlib_cungqr( m-p, m-p, q, u2, ldu2, work(itaup2),work(iorgqr), lorgqr, &
                           childinfo )
              end if
              if( wantv1t .and. q > 0 ) then
                 v1t(1,1) = cone
                 do j = 2, q
                    v1t(1,j) = czero
                    v1t(j,1) = czero
                 end do
                 call stdlib_clacpy( 'U', q-1, q-1, x21(1,2), ldx21, v1t(2,2),ldv1t )
                 call stdlib_cunglq( q-1, q-1, q-1, v1t(2,2), ldv1t, work(itauq1),work(iorglq), &
                           lorglq, childinfo )
              end if
              ! simultaneously diagonalize x11 and x21.
              call stdlib_cbbcsd( jobu1, jobu2, jobv1t, 'N', 'N', m, p, q, theta,rwork(iphi), u1, &
              ldu1, u2, ldu2, v1t, ldv1t, cdum,1, rwork(ib11d), rwork(ib11e), rwork(ib12d),rwork(&
              ib12e), rwork(ib21d), rwork(ib21e),rwork(ib22d), rwork(ib22e), rwork(ibbcsd),lrwork-&
                        ibbcsd+1, childinfo )
              ! permute rows and columns to place czero submatrices in
              ! preferred positions
              if( q > 0 .and. wantu2 ) then
                 do i = 1, q
                    iwork(i) = m - p - q + i
                 end do
                 do i = q + 1, m - p
                    iwork(i) = i - q
                 end do
                 call stdlib_clapmt( .false., m-p, m-p, u2, ldu2, iwork )
              end if
           else if( r == p ) then
              ! case 2: r = p
              ! simultaneously bidiagonalize x11 and x21
              call stdlib_cunbdb2( m, p, q, x11, ldx11, x21, ldx21, theta,rwork(iphi), work(&
                        itaup1), work(itaup2),work(itauq1), work(iorbdb), lorbdb, childinfo )
              ! accumulate householder reflectors
              if( wantu1 .and. p > 0 ) then
                 u1(1,1) = cone
                 do j = 2, p
                    u1(1,j) = czero
                    u1(j,1) = czero
                 end do
                 call stdlib_clacpy( 'L', p-1, p-1, x11(2,1), ldx11, u1(2,2), ldu1 )
                 call stdlib_cungqr( p-1, p-1, p-1, u1(2,2), ldu1, work(itaup1),work(iorgqr), &
                           lorgqr, childinfo )
              end if
              if( wantu2 .and. m-p > 0 ) then
                 call stdlib_clacpy( 'L', m-p, q, x21, ldx21, u2, ldu2 )
                 call stdlib_cungqr( m-p, m-p, q, u2, ldu2, work(itaup2),work(iorgqr), lorgqr, &
                           childinfo )
              end if
              if( wantv1t .and. q > 0 ) then
                 call stdlib_clacpy( 'U', p, q, x11, ldx11, v1t, ldv1t )
                 call stdlib_cunglq( q, q, r, v1t, ldv1t, work(itauq1),work(iorglq), lorglq, &
                           childinfo )
              end if
              ! simultaneously diagonalize x11 and x21.
              call stdlib_cbbcsd( jobv1t, 'N', jobu1, jobu2, 'T', m, q, p, theta,rwork(iphi), v1t,&
               ldv1t, cdum, 1, u1, ldu1, u2,ldu2, rwork(ib11d), rwork(ib11e), rwork(ib12d),rwork(&
               ib12e), rwork(ib21d), rwork(ib21e),rwork(ib22d), rwork(ib22e), rwork(ibbcsd), &
                         lbbcsd,childinfo )
              ! permute rows and columns to place identity submatrices in
              ! preferred positions
              if( q > 0 .and. wantu2 ) then
                 do i = 1, q
                    iwork(i) = m - p - q + i
                 end do
                 do i = q + 1, m - p
                    iwork(i) = i - q
                 end do
                 call stdlib_clapmt( .false., m-p, m-p, u2, ldu2, iwork )
              end if
           else if( r == m-p ) then
              ! case 3: r = m-p
              ! simultaneously bidiagonalize x11 and x21
              call stdlib_cunbdb3( m, p, q, x11, ldx11, x21, ldx21, theta,rwork(iphi), work(&
                        itaup1), work(itaup2),work(itauq1), work(iorbdb), lorbdb, childinfo )
              ! accumulate householder reflectors
              if( wantu1 .and. p > 0 ) then
                 call stdlib_clacpy( 'L', p, q, x11, ldx11, u1, ldu1 )
                 call stdlib_cungqr( p, p, q, u1, ldu1, work(itaup1), work(iorgqr),lorgqr, &
                           childinfo )
              end if
              if( wantu2 .and. m-p > 0 ) then
                 u2(1,1) = cone
                 do j = 2, m-p
                    u2(1,j) = czero
                    u2(j,1) = czero
                 end do
                 call stdlib_clacpy( 'L', m-p-1, m-p-1, x21(2,1), ldx21, u2(2,2),ldu2 )
                 call stdlib_cungqr( m-p-1, m-p-1, m-p-1, u2(2,2), ldu2,work(itaup2), work(iorgqr)&
                           , lorgqr, childinfo )
              end if
              if( wantv1t .and. q > 0 ) then
                 call stdlib_clacpy( 'U', m-p, q, x21, ldx21, v1t, ldv1t )
                 call stdlib_cunglq( q, q, r, v1t, ldv1t, work(itauq1),work(iorglq), lorglq, &
                           childinfo )
              end if
              ! simultaneously diagonalize x11 and x21.
              call stdlib_cbbcsd( 'N', jobv1t, jobu2, jobu1, 'T', m, m-q, m-p,theta, rwork(iphi), &
              cdum, 1, v1t, ldv1t, u2, ldu2,u1, ldu1, rwork(ib11d), rwork(ib11e),rwork(ib12d), &
              rwork(ib12e), rwork(ib21d),rwork(ib21e), rwork(ib22d), rwork(ib22e),rwork(ibbcsd), &
                        lbbcsd, childinfo )
              ! permute rows and columns to place identity submatrices in
              ! preferred positions
              if( q > r ) then
                 do i = 1, r
                    iwork(i) = q - r + i
                 end do
                 do i = r + 1, q
                    iwork(i) = i - r
                 end do
                 if( wantu1 ) then
                    call stdlib_clapmt( .false., p, q, u1, ldu1, iwork )
                 end if
                 if( wantv1t ) then
                    call stdlib_clapmr( .false., q, q, v1t, ldv1t, iwork )
                 end if
              end if
           else
              ! case 4: r = m-q
              ! simultaneously bidiagonalize x11 and x21
              call stdlib_cunbdb4( m, p, q, x11, ldx11, x21, ldx21, theta,rwork(iphi), work(&
              itaup1), work(itaup2),work(itauq1), work(iorbdb), work(iorbdb+m),lorbdb-m, &
                        childinfo )
              ! accumulate householder reflectors
              if( wantu2 .and. m-p > 0 ) then
                 call stdlib_ccopy( m-p, work(iorbdb+p), 1, u2, 1 )
              end if
              if( wantu1 .and. p > 0 ) then
                 call stdlib_ccopy( p, work(iorbdb), 1, u1, 1 )
                 do j = 2, p
                    u1(1,j) = czero
                 end do
                 call stdlib_clacpy( 'L', p-1, m-q-1, x11(2,1), ldx11, u1(2,2),ldu1 )
                 call stdlib_cungqr( p, p, m-q, u1, ldu1, work(itaup1),work(iorgqr), lorgqr, &
                           childinfo )
              end if
              if( wantu2 .and. m-p > 0 ) then
                 do j = 2, m-p
                    u2(1,j) = czero
                 end do
                 call stdlib_clacpy( 'L', m-p-1, m-q-1, x21(2,1), ldx21, u2(2,2),ldu2 )
                 call stdlib_cungqr( m-p, m-p, m-q, u2, ldu2, work(itaup2),work(iorgqr), lorgqr, &
                           childinfo )
              end if
              if( wantv1t .and. q > 0 ) then
                 call stdlib_clacpy( 'U', m-q, q, x21, ldx21, v1t, ldv1t )
                 call stdlib_clacpy( 'U', p-(m-q), q-(m-q), x11(m-q+1,m-q+1), ldx11,v1t(m-q+1,m-q+&
                           1), ldv1t )
                 call stdlib_clacpy( 'U', -p+q, q-p, x21(m-q+1,p+1), ldx21,v1t(p+1,p+1), ldv1t )
                           
                 call stdlib_cunglq( q, q, q, v1t, ldv1t, work(itauq1),work(iorglq), lorglq, &
                           childinfo )
              end if
              ! simultaneously diagonalize x11 and x21.
              call stdlib_cbbcsd( jobu2, jobu1, 'N', jobv1t, 'N', m, m-p, m-q,theta, rwork(iphi), &
              u2, ldu2, u1, ldu1, cdum, 1,v1t, ldv1t, rwork(ib11d), rwork(ib11e),rwork(ib12d), &
              rwork(ib12e), rwork(ib21d),rwork(ib21e), rwork(ib22d), rwork(ib22e),rwork(ibbcsd), &
                        lbbcsd, childinfo )
              ! permute rows and columns to place identity submatrices in
              ! preferred positions
              if( p > r ) then
                 do i = 1, r
                    iwork(i) = p - r + i
                 end do
                 do i = r + 1, p
                    iwork(i) = i - r
                 end do
                 if( wantu1 ) then
                    call stdlib_clapmt( .false., p, p, u1, ldu1, iwork )
                 end if
                 if( wantv1t ) then
                    call stdlib_clapmr( .false., p, q, v1t, ldv1t, iwork )
                 end if
              end if
           end if
           return
     end subroutine stdlib_cuncsd2by1


     pure subroutine stdlib_cungbr( vect, m, n, k, a, lda, tau, work, lwork, info )
     !! CUNGBR generates one of the complex unitary matrices Q or P**H
     !! determined by CGEBRD when reducing a complex matrix A to bidiagonal
     !! form: A = Q * B * P**H.  Q and P**H are defined as products of
     !! elementary reflectors H(i) or G(i) respectively.
     !! If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
     !! is of order M:
     !! if m >= k, Q = H(1) H(2) . . . H(k) and CUNGBR returns the first n
     !! columns of Q, where m >= n >= k;
     !! if m < k, Q = H(1) H(2) . . . H(m-1) and CUNGBR returns Q as an
     !! M-by-M matrix.
     !! If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
     !! is of order N:
     !! if k < n, P**H = G(k) . . . G(2) G(1) and CUNGBR returns the first m
     !! rows of P**H, where n >= m >= k;
     !! if k >= n, P**H = G(n-1) . . . G(2) G(1) and CUNGBR returns P**H as
     !! an N-by-N matrix.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: vect
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wantq
           integer(ilp) :: i, iinfo, j, lwkopt, mn
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           wantq = stdlib_lsame( vect, 'Q' )
           mn = min( m, n )
           lquery = ( lwork==-1 )
           if( .not.wantq .and. .not.stdlib_lsame( vect, 'P' ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( n<0 .or. ( wantq .and. ( n>m .or. n<min( m,k ) ) ) .or. ( .not.wantq .and. ( &
                     m>n .or. m<min( n, k ) ) ) ) then
              info = -3
           else if( k<0 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( lwork<max( 1, mn ) .and. .not.lquery ) then
              info = -9
           end if
           if( info==0 ) then
              work( 1 ) = 1
              if( wantq ) then
                 if( m>=k ) then
                    call stdlib_cungqr( m, n, k, a, lda, tau, work, -1, iinfo )
                 else
                    if( m>1 ) then
                       call stdlib_cungqr( m-1, m-1, m-1, a, lda, tau, work, -1,iinfo )
                    end if
                 end if
              else
                 if( k<n ) then
                    call stdlib_cunglq( m, n, k, a, lda, tau, work, -1, iinfo )
                 else
                    if( n>1 ) then
                       call stdlib_cunglq( n-1, n-1, n-1, a, lda, tau, work, -1,iinfo )
                    end if
                 end if
              end if
              lwkopt = real( work( 1 ),KIND=sp)
              lwkopt = max (lwkopt, mn)
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNGBR', -info )
              return
           else if( lquery ) then
              work( 1 ) = lwkopt
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              work( 1 ) = 1
              return
           end if
           if( wantq ) then
              ! form q, determined by a call to stdlib_cgebrd to reduce an m-by-k
              ! matrix
              if( m>=k ) then
                 ! if m >= k, assume m >= n >= k
                 call stdlib_cungqr( m, n, k, a, lda, tau, work, lwork, iinfo )
              else
                 ! if m < k, assume m = n
                 ! shift the vectors which define the elementary reflectors cone
                 ! column to the right, and set the first row and column of q
                 ! to those of the unit matrix
                 do j = m, 2, -1
                    a( 1, j ) = czero
                    do i = j + 1, m
                       a( i, j ) = a( i, j-1 )
                    end do
                 end do
                 a( 1, 1 ) = cone
                 do i = 2, m
                    a( i, 1 ) = czero
                 end do
                 if( m>1 ) then
                    ! form q(2:m,2:m)
                    call stdlib_cungqr( m-1, m-1, m-1, a( 2, 2 ), lda, tau, work,lwork, iinfo )
                              
                 end if
              end if
           else
              ! form p**h, determined by a call to stdlib_cgebrd to reduce a k-by-n
              ! matrix
              if( k<n ) then
                 ! if k < n, assume k <= m <= n
                 call stdlib_cunglq( m, n, k, a, lda, tau, work, lwork, iinfo )
              else
                 ! if k >= n, assume m = n
                 ! shift the vectors which define the elementary reflectors cone
                 ! row downward, and set the first row and column of p**h to
                 ! those of the unit matrix
                 a( 1, 1 ) = cone
                 do i = 2, n
                    a( i, 1 ) = czero
                 end do
                 do j = 2, n
                    do i = j - 1, 2, -1
                       a( i, j ) = a( i-1, j )
                    end do
                    a( 1, j ) = czero
                 end do
                 if( n>1 ) then
                    ! form p**h(2:n,2:n)
                    call stdlib_cunglq( n-1, n-1, n-1, a( 2, 2 ), lda, tau, work,lwork, iinfo )
                              
                 end if
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cungbr


     pure subroutine stdlib_cungtsqr( m, n, mb, nb, a, lda, t, ldt, work, lwork,info )
     !! CUNGTSQR generates an M-by-N complex matrix Q_out with orthonormal
     !! columns, which are the first N columns of a product of comlpex unitary
     !! matrices of order M which are returned by CLATSQR
     !! Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).
     !! See the documentation for CLATSQR.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldt, lwork, m, n, mb, nb
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: t(ldt,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: iinfo, ldc, lworkopt, lc, lw, nblocal, j
           ! Intrinsic Functions 
           intrinsic :: cmplx,max,min
           ! Executable Statements 
           ! test the input parameters
           lquery  = lwork==-1
           info = 0
           if( m<0 ) then
              info = -1
           else if( n<0 .or. m<n ) then
              info = -2
           else if( mb<=n ) then
              info = -3
           else if( nb<1 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldt<max( 1, min( nb, n ) ) ) then
              info = -8
           else
              ! test the input lwork for the dimension of the array work.
              ! this workspace is used to store array c(ldc, n) and work(lwork)
              ! in the call to stdlib_clamtsqr. see the documentation for stdlib_clamtsqr.
              if( lwork<2 .and. (.not.lquery) ) then
                 info = -10
              else
                 ! set block size for column blocks
                 nblocal = min( nb, n )
                 ! lwork = -1, then set the size for the array c(ldc,n)
                 ! in stdlib_clamtsqr call and set the optimal size of the work array
                 ! work(lwork) in stdlib_clamtsqr call.
                 ldc = m
                 lc = ldc*n
                 lw = n * nblocal
                 lworkopt = lc+lw
                 if( ( lwork<max( 1, lworkopt ) ).and.(.not.lquery) ) then
                    info = -10
                 end if
              end if
           end if
           ! handle error in the input parameters and return workspace query.
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNGTSQR', -info )
              return
           else if ( lquery ) then
              work( 1 ) = cmplx( lworkopt,KIND=sp)
              return
           end if
           ! quick return if possible
           if( min( m, n )==0 ) then
              work( 1 ) = cmplx( lworkopt,KIND=sp)
              return
           end if
           ! (1) form explicitly the tall-skinny m-by-n left submatrix q1_in
           ! of m-by-m orthogonal matrix q_in, which is implicitly stored in
           ! the subdiagonal part of input array a and in the input array t.
           ! perform by the following operation using the routine stdlib_clamtsqr.
               ! q1_in = q_in * ( i ), where i is a n-by-n identity matrix,
                              ! ( 0 )        0 is a (m-n)-by-n zero matrix.
           ! (1a) form m-by-n matrix in the array work(1:ldc*n) with ones
           ! on the diagonal and zeros elsewhere.
           call stdlib_claset( 'F', m, n, czero, cone, work, ldc )
           ! (1b)  on input, work(1:ldc*n) stores ( i );
                                                ! ( 0 )
                 ! on output, work(1:ldc*n) stores q1_in.
           call stdlib_clamtsqr( 'L', 'N', m, n, n, mb, nblocal, a, lda, t, ldt,work, ldc, work( &
                     lc+1 ), lw, iinfo )
           ! (2) copy the result from the part of the work array (1:m,1:n)
           ! with the leading dimension ldc that starts at work(1) into
           ! the output array a(1:m,1:n) column-by-column.
           do j = 1, n
              call stdlib_ccopy( m, work( (j-1)*ldc + 1 ), 1, a( 1, j ), 1 )
           end do
           work( 1 ) = cmplx( lworkopt,KIND=sp)
           return
     end subroutine stdlib_cungtsqr


     pure subroutine stdlib_cunmbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, lwork, &
     !! If VECT = 'Q', CUNMBR: overwrites the general complex M-by-N matrix C
     !! with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! If VECT = 'P', CUNMBR overwrites the general complex M-by-N matrix C
     !! with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      P * C          C * P
     !! TRANS = 'C':      P**H * C       C * P**H
     !! Here Q and P**H are the unitary matrices determined by CGEBRD when
     !! reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
     !! and P**H are defined as products of elementary reflectors H(i) and
     !! G(i) respectively.
     !! Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
     !! order of the unitary matrix Q or P**H that is applied.
     !! If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
     !! if nq >= k, Q = H(1) H(2) . . . H(k);
     !! if nq < k, Q = H(1) H(2) . . . H(nq-1).
     !! If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
     !! if k < nq, P = G(1) G(2) . . . G(k);
     !! if k >= nq, P = G(1) G(2) . . . G(nq-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans, vect
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, lda, ldc, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: applyq, left, lquery, notran
           character :: transt
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, ni, nq, nw
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           applyq = stdlib_lsame( vect, 'Q' )
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           ! nq is the order of q or p and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.applyq .and. .not.stdlib_lsame( vect, 'P' ) ) then
              info = -1
           else if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -2
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( k<0 ) then
              info = -6
           else if( ( applyq .and. lda<max( 1, nq ) ) .or.( .not.applyq .and. lda<max( 1, min( nq,&
                      k ) ) ) )then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              if( m>0 .and. n>0 ) then
                 if( applyq ) then
                    if( left ) then
                       nb = stdlib_ilaenv( 1, 'CUNMQR', side // trans, m-1, n, m-1,-1 )
                    else
                       nb = stdlib_ilaenv( 1, 'CUNMQR', side // trans, m, n-1, n-1,-1 )
                    end if
                 else
                    if( left ) then
                       nb = stdlib_ilaenv( 1, 'CUNMLQ', side // trans, m-1, n, m-1,-1 )
                    else
                       nb = stdlib_ilaenv( 1, 'CUNMLQ', side // trans, m, n-1, n-1,-1 )
                    end if
                 end if
                 lwkopt = nw*nb
              else
                 lwkopt = 1
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNMBR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           if( applyq ) then
              ! apply q
              if( nq>=k ) then
                 ! q was determined by a call to stdlib_cgebrd with nq >= k
                 call stdlib_cunmqr( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, iinfo &
                           )
              else if( nq>1 ) then
                 ! q was determined by a call to stdlib_cgebrd with nq < k
                 if( left ) then
                    mi = m - 1
                    ni = n
                    i1 = 2
                    i2 = 1
                 else
                    mi = m
                    ni = n - 1
                    i1 = 1
                    i2 = 2
                 end if
                 call stdlib_cunmqr( side, trans, mi, ni, nq-1, a( 2, 1 ), lda, tau,c( i1, i2 ), &
                           ldc, work, lwork, iinfo )
              end if
           else
              ! apply p
              if( notran ) then
                 transt = 'C'
              else
                 transt = 'N'
              end if
              if( nq>k ) then
                 ! p was determined by a call to stdlib_cgebrd with nq > k
                 call stdlib_cunmlq( side, transt, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                           iinfo )
              else if( nq>1 ) then
                 ! p was determined by a call to stdlib_cgebrd with nq <= k
                 if( left ) then
                    mi = m - 1
                    ni = n
                    i1 = 2
                    i2 = 1
                 else
                    mi = m
                    ni = n - 1
                    i1 = 1
                    i2 = 2
                 end if
                 call stdlib_cunmlq( side, transt, mi, ni, nq-1, a( 1, 2 ), lda,tau, c( i1, i2 ), &
                           ldc, work, lwork, iinfo )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cunmbr


     pure subroutine stdlib_cgelq( m, n, a, lda, t, tsize, work, lwork,info )
     !! CGELQ computes an LQ factorization of a complex M-by-N matrix A:
     !! A = ( L 0 ) *  Q
     !! where:
     !! Q is a N-by-N orthogonal matrix;
     !! L is a lower-triangular M-by-M matrix;
     !! 0 is a M-by-(N-M) zero matrix, if M < N.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd. --
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, tsize, lwork
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: t(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, lminws, mint, minw
           integer(ilp) :: mb, nb, mintsz, nblcks, lwmin, lwopt, lwreq
           ! Intrinsic Functions 
           intrinsic :: max,min,mod
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( tsize==-1 .or. tsize==-2 .or.lwork==-1 .or. lwork==-2 )
           mint = .false.
           minw = .false.
           if( tsize==-2 .or. lwork==-2 ) then
             if( tsize/=-1 ) mint = .true.
             if( lwork/=-1 ) minw = .true.
           end if
           ! determine the block size
           if( min( m, n )>0 ) then
             mb = stdlib_ilaenv( 1, 'CGELQ ', ' ', m, n, 1, -1 )
             nb = stdlib_ilaenv( 1, 'CGELQ ', ' ', m, n, 2, -1 )
           else
             mb = 1
             nb = n
           end if
           if( mb>min( m, n ) .or. mb<1 ) mb = 1
           if( nb>n .or. nb<=m ) nb = n
           mintsz = m + 5
           if( nb>m .and. n>m ) then
             if( mod( n - m, nb - m )==0 ) then
               nblcks = ( n - m ) / ( nb - m )
             else
               nblcks = ( n - m ) / ( nb - m ) + 1
             end if
           else
             nblcks = 1
           end if
           ! determine if the workspace size satisfies minimal size
           if( ( n<=m ) .or. ( nb<=m ) .or. ( nb>=n ) ) then
              lwmin = max( 1, n )
              lwopt = max( 1, mb*n )
           else
              lwmin = max( 1, m )
              lwopt = max( 1, mb*m )
           end if
           lminws = .false.
           if( ( tsize<max( 1, mb*m*nblcks + 5 ) .or. lwork<lwopt ).and. ( lwork>=lwmin ) .and. ( &
                     tsize>=mintsz ).and. ( .not.lquery ) ) then
             if( tsize<max( 1, mb*m*nblcks + 5 ) ) then
               lminws = .true.
               mb = 1
               nb = n
             end if
             if( lwork<lwopt ) then
               lminws = .true.
               mb = 1
             end if
           end if
           if( ( n<=m ) .or. ( nb<=m ) .or. ( nb>=n ) ) then
              lwreq = max( 1, mb*n )
           else
              lwreq = max( 1, mb*m )
           end if
           if( m<0 ) then
             info = -1
           else if( n<0 ) then
             info = -2
           else if( lda<max( 1, m ) ) then
             info = -4
           else if( tsize<max( 1, mb*m*nblcks + 5 ).and. ( .not.lquery ) .and. ( .not.lminws ) ) &
                     then
             info = -6
           else if( ( lwork<lwreq ) .and.( .not.lquery ).and. ( .not.lminws ) ) then
             info = -8
           end if
           if( info==0 ) then
             if( mint ) then
               t( 1 ) = mintsz
             else
               t( 1 ) = mb*m*nblcks + 5
             end if
             t( 2 ) = mb
             t( 3 ) = nb
             if( minw ) then
               work( 1 ) = lwmin
             else
               work( 1 ) = lwreq
             end if
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'CGELQ', -info )
             return
           else if( lquery ) then
             return
           end if
           ! quick return if possible
           if( min( m, n )==0 ) then
             return
           end if
           ! the lq decomposition
           if( ( n<=m ) .or. ( nb<=m ) .or. ( nb>=n ) ) then
             call stdlib_cgelqt( m, n, mb, a, lda, t( 6 ), mb, work, info )
           else
             call stdlib_claswlq( m, n, mb, nb, a, lda, t( 6 ), mb, work,lwork, info )
           end if
           work( 1 ) = lwreq
           return
     end subroutine stdlib_cgelq


     subroutine stdlib_cgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
     !! CGELSD computes the minimum-norm solution to a real linear least
     !! squares problem:
     !! minimize 2-norm(| b - A*x |)
     !! using the singular value decomposition (SVD) of A. A is an M-by-N
     !! matrix which may be rank-deficient.
     !! Several right hand side vectors b and solution vectors x can be
     !! handled in a single call; they are stored as the columns of the
     !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution
     !! matrix X.
     !! The problem is solved in three steps:
     !! (1) Reduce the coefficient matrix A to bidiagonal form with
     !! Householder transformations, reducing the original problem
     !! into a "bidiagonal least squares problem" (BLS)
     !! (2) Solve the BLS using a divide and conquer approach.
     !! (3) Apply back all the Householder transformations to solve
     !! the original least squares problem.
     !! The effective rank of A is determined by treating as zero those
     !! singular values which are less than RCOND times the largest singular
     !! value.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info, rank
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(sp), intent(in) :: rcond
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), s(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: iascl, ibscl, ie, il, itau, itaup, itauq, ldwork, liwork, lrwork, &
                     maxmn, maxwrk, minmn, minwrk, mm, mnthr, nlvl, nrwork, nwork, smlsiz
           real(sp) :: anrm, bignum, bnrm, eps, sfmin, smlnum
           ! Intrinsic Functions 
           intrinsic :: int,log,max,min,real
           ! Executable Statements 
           ! test the input arguments.
           info = 0
           minmn = min( m, n )
           maxmn = max( m, n )
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, maxmn ) ) then
              info = -7
           end if
           ! compute workspace.
           ! (note: comments in the code beginning "workspace:" describe the
           ! minimal amount of workspace needed at that point in the code,
           ! as well as the preferred amount for good performance.
           ! nb refers to the optimal block size for the immediately
           ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              liwork = 1
              lrwork = 1
              if( minmn>0 ) then
                 smlsiz = stdlib_ilaenv( 9, 'CGELSD', ' ', 0, 0, 0, 0 )
                 mnthr = stdlib_ilaenv( 6, 'CGELSD', ' ', m, n, nrhs, -1 )
                 nlvl = max( int( log( real( minmn,KIND=sp) / real( smlsiz + 1,KIND=sp) ) /log( &
                           two ),KIND=ilp) + 1, 0 )
                 liwork = 3*minmn*nlvl + 11*minmn
                 mm = m
                 if( m>=n .and. m>=mnthr ) then
                    ! path 1a - overdetermined, with many more rows than
                              ! columns.
                    mm = n
                    maxwrk = max( maxwrk, n*stdlib_ilaenv( 1, 'CGEQRF', ' ', m, n,-1, -1 ) )
                              
                    maxwrk = max( maxwrk, nrhs*stdlib_ilaenv( 1, 'CUNMQR', 'LC', m,nrhs, n, -1 ) )
                              
                 end if
                 if( m>=n ) then
                    ! path 1 - overdetermined or exactly determined.
                    lrwork = 10*n + 2*n*smlsiz + 8*n*nlvl + 3*smlsiz*nrhs +max( (smlsiz+1)**2, n*(&
                              1+nrhs) + 2*nrhs )
                    maxwrk = max( maxwrk, 2*n + ( mm + n )*stdlib_ilaenv( 1,'CGEBRD', ' ', mm, n, &
                              -1, -1 ) )
                    maxwrk = max( maxwrk, 2*n + nrhs*stdlib_ilaenv( 1, 'CUNMBR','QLC', mm, nrhs, &
                              n, -1 ) )
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'CUNMBR', 'PLN', n, &
                              nrhs, n, -1 ) )
                    maxwrk = max( maxwrk, 2*n + n*nrhs )
                    minwrk = max( 2*n + mm, 2*n + n*nrhs )
                 end if
                 if( n>m ) then
                    lrwork = 10*m + 2*m*smlsiz + 8*m*nlvl + 3*smlsiz*nrhs +max( (smlsiz+1)**2, n*(&
                              1+nrhs) + 2*nrhs )
                    if( n>=mnthr ) then
                       ! path 2a - underdetermined, with many more columns
                                 ! than rows.
                       maxwrk = m + m*stdlib_ilaenv( 1, 'CGELQF', ' ', m, n, -1,-1 )
                       maxwrk = max( maxwrk, m*m + 4*m + 2*m*stdlib_ilaenv( 1,'CGEBRD', ' ', m, m,&
                                  -1, -1 ) )
                       maxwrk = max( maxwrk, m*m + 4*m + nrhs*stdlib_ilaenv( 1,'CUNMBR', 'QLC', m,&
                                  nrhs, m, -1 ) )
                       maxwrk = max( maxwrk, m*m + 4*m + ( m - 1 )*stdlib_ilaenv( 1,'CUNMLQ', &
                                 'LC', n, nrhs, m, -1 ) )
                       if( nrhs>1 ) then
                          maxwrk = max( maxwrk, m*m + m + m*nrhs )
                       else
                          maxwrk = max( maxwrk, m*m + 2*m )
                       end if
                       maxwrk = max( maxwrk, m*m + 4*m + m*nrhs )
           ! xxx: ensure the path 2a case below is triggered.  the workspace
           ! calculation should use queries for all routines eventually.
                       maxwrk = max( maxwrk,4*m+m*m+max( m, 2*m-4, nrhs, n-3*m ) )
                    else
                       ! path 2 - underdetermined.
                       maxwrk = 2*m + ( n + m )*stdlib_ilaenv( 1, 'CGEBRD', ' ', m,n, -1, -1 )
                                 
                       maxwrk = max( maxwrk, 2*m + nrhs*stdlib_ilaenv( 1, 'CUNMBR','QLC', m, nrhs,&
                                  m, -1 ) )
                       maxwrk = max( maxwrk, 2*m + m*stdlib_ilaenv( 1, 'CUNMBR','PLN', n, nrhs, m,&
                                  -1 ) )
                       maxwrk = max( maxwrk, 2*m + m*nrhs )
                    end if
                    minwrk = max( 2*m + n, 2*m + m*nrhs )
                 end if
              end if
              minwrk = min( minwrk, maxwrk )
              work( 1 ) = maxwrk
              iwork( 1 ) = liwork
              rwork( 1 ) = lrwork
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGELSD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==0 .or. n==0 ) then
              rank = 0
              return
           end if
           ! get machine parameters.
           eps = stdlib_slamch( 'P' )
           sfmin = stdlib_slamch( 'S' )
           smlnum = sfmin / eps
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           ! scale a if max entry outside range [smlnum,bignum].
           anrm = stdlib_clange( 'M', m, n, a, lda, rwork )
           iascl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_clascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, info )
              iascl = 1
           else if( anrm>bignum ) then
              ! scale matrix norm down to bignum.
              call stdlib_clascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, info )
              iascl = 2
           else if( anrm==zero ) then
              ! matrix all zero. return zero solution.
              call stdlib_claset( 'F', max( m, n ), nrhs, czero, czero, b, ldb )
              call stdlib_slaset( 'F', minmn, 1, zero, zero, s, 1 )
              rank = 0
              go to 10
           end if
           ! scale b if max entry outside range [smlnum,bignum].
           bnrm = stdlib_clange( 'M', m, nrhs, b, ldb, rwork )
           ibscl = 0
           if( bnrm>zero .and. bnrm<smlnum ) then
              ! scale matrix norm up to smlnum.
              call stdlib_clascl( 'G', 0, 0, bnrm, smlnum, m, nrhs, b, ldb, info )
              ibscl = 1
           else if( bnrm>bignum ) then
              ! scale matrix norm down to bignum.
              call stdlib_clascl( 'G', 0, 0, bnrm, bignum, m, nrhs, b, ldb, info )
              ibscl = 2
           end if
           ! if m < n make sure b(m+1:n,:) = 0
           if( m<n )call stdlib_claset( 'F', n-m, nrhs, czero, czero, b( m+1, 1 ), ldb )
           ! overdetermined case.
           if( m>=n ) then
              ! path 1 - overdetermined or exactly determined.
              mm = m
              if( m>=mnthr ) then
                 ! path 1a - overdetermined, with many more rows than columns
                 mm = n
                 itau = 1
                 nwork = itau + n
                 ! compute a=q*r.
                 ! (rworkspace: need n)
                 ! (cworkspace: need n, prefer n*nb)
                 call stdlib_cgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                           info )
                 ! multiply b by transpose(q).
                 ! (rworkspace: need n)
                 ! (cworkspace: need nrhs, prefer nrhs*nb)
                 call stdlib_cunmqr( 'L', 'C', m, nrhs, n, a, lda, work( itau ), b,ldb, work( &
                           nwork ), lwork-nwork+1, info )
                 ! zero out below r.
                 if( n>1 ) then
                    call stdlib_claset( 'L', n-1, n-1, czero, czero, a( 2, 1 ),lda )
                 end if
              end if
              itauq = 1
              itaup = itauq + n
              nwork = itaup + n
              ie = 1
              nrwork = ie + n
              ! bidiagonalize r in a.
              ! (rworkspace: need n)
              ! (cworkspace: need 2*n+mm, prefer 2*n+(mm+n)*nb)
              call stdlib_cgebrd( mm, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                        work( nwork ), lwork-nwork+1,info )
              ! multiply b by transpose of left bidiagonalizing vectors of r.
              ! (cworkspace: need 2*n+nrhs, prefer 2*n+nrhs*nb)
              call stdlib_cunmbr( 'Q', 'L', 'C', mm, nrhs, n, a, lda, work( itauq ),b, ldb, work( &
                        nwork ), lwork-nwork+1, info )
              ! solve the bidiagonal least squares problem.
              call stdlib_clalsd( 'U', smlsiz, n, nrhs, s, rwork( ie ), b, ldb,rcond, rank, work( &
                        nwork ), rwork( nrwork ),iwork, info )
              if( info/=0 ) then
                 go to 10
              end if
              ! multiply b by right bidiagonalizing vectors of r.
              call stdlib_cunmbr( 'P', 'L', 'N', n, nrhs, n, a, lda, work( itaup ),b, ldb, work( &
                        nwork ), lwork-nwork+1, info )
           else if( n>=mnthr .and. lwork>=4*m+m*m+max( m, 2*m-4, nrhs, n-3*m ) ) then
              ! path 2a - underdetermined, with many more columns than rows
              ! and sufficient workspace for an efficient algorithm.
              ldwork = m
              if( lwork>=max( 4*m+m*lda+max( m, 2*m-4, nrhs, n-3*m ),m*lda+m+m*nrhs ) )ldwork = &
                        lda
              itau = 1
              nwork = m + 1
              ! compute a=l*q.
              ! (cworkspace: need 2*m, prefer m+m*nb)
              call stdlib_cgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, info )
                        
              il = nwork
              ! copy l to work(il), zeroing out above its diagonal.
              call stdlib_clacpy( 'L', m, m, a, lda, work( il ), ldwork )
              call stdlib_claset( 'U', m-1, m-1, czero, czero, work( il+ldwork ),ldwork )
              itauq = il + ldwork*m
              itaup = itauq + m
              nwork = itaup + m
              ie = 1
              nrwork = ie + m
              ! bidiagonalize l in work(il).
              ! (rworkspace: need m)
              ! (cworkspace: need m*m+4*m, prefer m*m+4*m+2*m*nb)
              call stdlib_cgebrd( m, m, work( il ), ldwork, s, rwork( ie ),work( itauq ), work( &
                        itaup ), work( nwork ),lwork-nwork+1, info )
              ! multiply b by transpose of left bidiagonalizing vectors of l.
              ! (cworkspace: need m*m+4*m+nrhs, prefer m*m+4*m+nrhs*nb)
              call stdlib_cunmbr( 'Q', 'L', 'C', m, nrhs, m, work( il ), ldwork,work( itauq ), b, &
                        ldb, work( nwork ),lwork-nwork+1, info )
              ! solve the bidiagonal least squares problem.
              call stdlib_clalsd( 'U', smlsiz, m, nrhs, s, rwork( ie ), b, ldb,rcond, rank, work( &
                        nwork ), rwork( nrwork ),iwork, info )
              if( info/=0 ) then
                 go to 10
              end if
              ! multiply b by right bidiagonalizing vectors of l.
              call stdlib_cunmbr( 'P', 'L', 'N', m, nrhs, m, work( il ), ldwork,work( itaup ), b, &
                        ldb, work( nwork ),lwork-nwork+1, info )
              ! zero out below first m rows of b.
              call stdlib_claset( 'F', n-m, nrhs, czero, czero, b( m+1, 1 ), ldb )
              nwork = itau + m
              ! multiply transpose(q) by b.
              ! (cworkspace: need nrhs, prefer nrhs*nb)
              call stdlib_cunmlq( 'L', 'C', n, nrhs, m, a, lda, work( itau ), b,ldb, work( nwork )&
                        , lwork-nwork+1, info )
           else
              ! path 2 - remaining underdetermined cases.
              itauq = 1
              itaup = itauq + m
              nwork = itaup + m
              ie = 1
              nrwork = ie + m
              ! bidiagonalize a.
              ! (rworkspace: need m)
              ! (cworkspace: need 2*m+n, prefer 2*m+(m+n)*nb)
              call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), work(&
                         nwork ), lwork-nwork+1,info )
              ! multiply b by transpose of left bidiagonalizing vectors.
              ! (cworkspace: need 2*m+nrhs, prefer 2*m+nrhs*nb)
              call stdlib_cunmbr( 'Q', 'L', 'C', m, nrhs, n, a, lda, work( itauq ),b, ldb, work( &
                        nwork ), lwork-nwork+1, info )
              ! solve the bidiagonal least squares problem.
              call stdlib_clalsd( 'L', smlsiz, m, nrhs, s, rwork( ie ), b, ldb,rcond, rank, work( &
                        nwork ), rwork( nrwork ),iwork, info )
              if( info/=0 ) then
                 go to 10
              end if
              ! multiply b by right bidiagonalizing vectors of a.
              call stdlib_cunmbr( 'P', 'L', 'N', n, nrhs, m, a, lda, work( itaup ),b, ldb, work( &
                        nwork ), lwork-nwork+1, info )
           end if
           ! undo scaling.
           if( iascl==1 ) then
              call stdlib_clascl( 'G', 0, 0, anrm, smlnum, n, nrhs, b, ldb, info )
              call stdlib_slascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,info )
           else if( iascl==2 ) then
              call stdlib_clascl( 'G', 0, 0, anrm, bignum, n, nrhs, b, ldb, info )
              call stdlib_slascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,info )
           end if
           if( ibscl==1 ) then
              call stdlib_clascl( 'G', 0, 0, smlnum, bnrm, n, nrhs, b, ldb, info )
           else if( ibscl==2 ) then
              call stdlib_clascl( 'G', 0, 0, bignum, bnrm, n, nrhs, b, ldb, info )
           end if
           10 continue
           work( 1 ) = maxwrk
           iwork( 1 ) = liwork
           rwork( 1 ) = lrwork
           return
     end subroutine stdlib_cgelsd


     subroutine stdlib_cgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
     !! CGELSS computes the minimum norm solution to a complex linear
     !! least squares problem:
     !! Minimize 2-norm(| b - A*x |).
     !! using the singular value decomposition (SVD) of A. A is an M-by-N
     !! matrix which may be rank-deficient.
     !! Several right hand side vectors b and solution vectors x can be
     !! handled in a single call; they are stored as the columns of the
     !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
     !! X.
     !! The effective rank of A is determined by treating as zero those
     !! singular values which are less than RCOND times the largest singular
     !! value.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info, rank
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(sp), intent(in) :: rcond
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*), s(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: bl, chunk, i, iascl, ibscl, ie, il, irwork, itau, itaup, itauq, iwork, &
                     ldwork, maxmn, maxwrk, minmn, minwrk, mm, mnthr
           integer(ilp) :: lwork_cgeqrf, lwork_cunmqr, lwork_cgebrd, lwork_cunmbr, lwork_cungbr, &
                     lwork_cunmlq, lwork_cgelqf
           real(sp) :: anrm, bignum, bnrm, eps, sfmin, smlnum, thr
           ! Local Arrays 
           complex(sp) :: dum(1)
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           minmn = min( m, n )
           maxmn = max( m, n )
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, maxmn ) ) then
              info = -7
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace refers
             ! to real workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              if( minmn>0 ) then
                 mm = m
                 mnthr = stdlib_ilaenv( 6, 'CGELSS', ' ', m, n, nrhs, -1 )
                 if( m>=n .and. m>=mnthr ) then
                    ! path 1a - overdetermined, with many more rows than
                              ! columns
                    ! compute space needed for stdlib_cgeqrf
                    call stdlib_cgeqrf( m, n, a, lda, dum(1), dum(1), -1, info )
                    lwork_cgeqrf = real( dum(1),KIND=sp)
                    ! compute space needed for stdlib_cunmqr
                    call stdlib_cunmqr( 'L', 'C', m, nrhs, n, a, lda, dum(1), b,ldb, dum(1), -1, &
                              info )
                    lwork_cunmqr = real( dum(1),KIND=sp)
                    mm = n
                    maxwrk = max( maxwrk, n + n*stdlib_ilaenv( 1, 'CGEQRF', ' ', m,n, -1, -1 ) )
                              
                    maxwrk = max( maxwrk, n + nrhs*stdlib_ilaenv( 1, 'CUNMQR', 'LC',m, nrhs, n, -&
                              1 ) )
                 end if
                 if( m>=n ) then
                    ! path 1 - overdetermined or exactly determined
                    ! compute space needed for stdlib_cgebrd
                    call stdlib_cgebrd( mm, n, a, lda, s, s, dum(1), dum(1), dum(1),-1, info )
                              
                    lwork_cgebrd = real( dum(1),KIND=sp)
                    ! compute space needed for stdlib_cunmbr
                    call stdlib_cunmbr( 'Q', 'L', 'C', mm, nrhs, n, a, lda, dum(1),b, ldb, dum(1),&
                               -1, info )
                    lwork_cunmbr = real( dum(1),KIND=sp)
                    ! compute space needed for stdlib_cungbr
                    call stdlib_cungbr( 'P', n, n, n, a, lda, dum(1),dum(1), -1, info )
                    lwork_cungbr = real( dum(1),KIND=sp)
                    ! compute total workspace needed
                    maxwrk = max( maxwrk, 2*n + lwork_cgebrd )
                    maxwrk = max( maxwrk, 2*n + lwork_cunmbr )
                    maxwrk = max( maxwrk, 2*n + lwork_cungbr )
                    maxwrk = max( maxwrk, n*nrhs )
                    minwrk = 2*n + max( nrhs, m )
                 end if
                 if( n>m ) then
                    minwrk = 2*m + max( nrhs, n )
                    if( n>=mnthr ) then
                       ! path 2a - underdetermined, with many more columns
                       ! than rows
                       ! compute space needed for stdlib_cgelqf
                       call stdlib_cgelqf( m, n, a, lda, dum(1), dum(1),-1, info )
                       lwork_cgelqf = real( dum(1),KIND=sp)
                       ! compute space needed for stdlib_cgebrd
                       call stdlib_cgebrd( m, m, a, lda, s, s, dum(1), dum(1),dum(1), -1, info )
                                 
                       lwork_cgebrd = real( dum(1),KIND=sp)
                       ! compute space needed for stdlib_cunmbr
                       call stdlib_cunmbr( 'Q', 'L', 'C', m, nrhs, n, a, lda,dum(1), b, ldb, dum(&
                                 1), -1, info )
                       lwork_cunmbr = real( dum(1),KIND=sp)
                       ! compute space needed for stdlib_cungbr
                       call stdlib_cungbr( 'P', m, m, m, a, lda, dum(1),dum(1), -1, info )
                       lwork_cungbr = real( dum(1),KIND=sp)
                       ! compute space needed for stdlib_cunmlq
                       call stdlib_cunmlq( 'L', 'C', n, nrhs, m, a, lda, dum(1),b, ldb, dum(1), -&
                                 1, info )
                       lwork_cunmlq = real( dum(1),KIND=sp)
                       ! compute total workspace needed
                       maxwrk = m + lwork_cgelqf
                       maxwrk = max( maxwrk, 3*m + m*m + lwork_cgebrd )
                       maxwrk = max( maxwrk, 3*m + m*m + lwork_cunmbr )
                       maxwrk = max( maxwrk, 3*m + m*m + lwork_cungbr )
                       if( nrhs>1 ) then
                          maxwrk = max( maxwrk, m*m + m + m*nrhs )
                       else
                          maxwrk = max( maxwrk, m*m + 2*m )
                       end if
                       maxwrk = max( maxwrk, m + lwork_cunmlq )
                    else
                       ! path 2 - underdetermined
                       ! compute space needed for stdlib_cgebrd
                       call stdlib_cgebrd( m, n, a, lda, s, s, dum(1), dum(1),dum(1), -1, info )
                                 
                       lwork_cgebrd = real( dum(1),KIND=sp)
                       ! compute space needed for stdlib_cunmbr
                       call stdlib_cunmbr( 'Q', 'L', 'C', m, nrhs, m, a, lda,dum(1), b, ldb, dum(&
                                 1), -1, info )
                       lwork_cunmbr = real( dum(1),KIND=sp)
                       ! compute space needed for stdlib_cungbr
                       call stdlib_cungbr( 'P', m, n, m, a, lda, dum(1),dum(1), -1, info )
                       lwork_cungbr = real( dum(1),KIND=sp)
                       maxwrk = 2*m + lwork_cgebrd
                       maxwrk = max( maxwrk, 2*m + lwork_cunmbr )
                       maxwrk = max( maxwrk, 2*m + lwork_cungbr )
                       maxwrk = max( maxwrk, n*nrhs )
                    end if
                 end if
                 maxwrk = max( minwrk, maxwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery )info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGELSS', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              rank = 0
              return
           end if
           ! get machine parameters
           eps = stdlib_slamch( 'P' )
           sfmin = stdlib_slamch( 'S' )
           smlnum = sfmin / eps
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', m, n, a, lda, rwork )
           iascl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_clascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, info )
              iascl = 1
           else if( anrm>bignum ) then
              ! scale matrix norm down to bignum
              call stdlib_clascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, info )
              iascl = 2
           else if( anrm==zero ) then
              ! matrix all zero. return zero solution.
              call stdlib_claset( 'F', max( m, n ), nrhs, czero, czero, b, ldb )
              call stdlib_slaset( 'F', minmn, 1, zero, zero, s, minmn )
              rank = 0
              go to 70
           end if
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_clange( 'M', m, nrhs, b, ldb, rwork )
           ibscl = 0
           if( bnrm>zero .and. bnrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_clascl( 'G', 0, 0, bnrm, smlnum, m, nrhs, b, ldb, info )
              ibscl = 1
           else if( bnrm>bignum ) then
              ! scale matrix norm down to bignum
              call stdlib_clascl( 'G', 0, 0, bnrm, bignum, m, nrhs, b, ldb, info )
              ibscl = 2
           end if
           ! overdetermined case
           if( m>=n ) then
              ! path 1 - overdetermined or exactly determined
              mm = m
              if( m>=mnthr ) then
                 ! path 1a - overdetermined, with many more rows than columns
                 mm = n
                 itau = 1
                 iwork = itau + n
                 ! compute a=q*r
                 ! (cworkspace: need 2*n, prefer n+n*nb)
                 ! (rworkspace: none)
                 call stdlib_cgeqrf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                           info )
                 ! multiply b by transpose(q)
                 ! (cworkspace: need n+nrhs, prefer n+nrhs*nb)
                 ! (rworkspace: none)
                 call stdlib_cunmqr( 'L', 'C', m, nrhs, n, a, lda, work( itau ), b,ldb, work( &
                           iwork ), lwork-iwork+1, info )
                 ! zero out below r
                 if( n>1 )call stdlib_claset( 'L', n-1, n-1, czero, czero, a( 2, 1 ),lda )
              end if
              ie = 1
              itauq = 1
              itaup = itauq + n
              iwork = itaup + n
              ! bidiagonalize r in a
              ! (cworkspace: need 2*n+mm, prefer 2*n+(mm+n)*nb)
              ! (rworkspace: need n)
              call stdlib_cgebrd( mm, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                        work( iwork ), lwork-iwork+1,info )
              ! multiply b by transpose of left bidiagonalizing vectors of r
              ! (cworkspace: need 2*n+nrhs, prefer 2*n+nrhs*nb)
              ! (rworkspace: none)
              call stdlib_cunmbr( 'Q', 'L', 'C', mm, nrhs, n, a, lda, work( itauq ),b, ldb, work( &
                        iwork ), lwork-iwork+1, info )
              ! generate right bidiagonalizing vectors of r in a
              ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_cungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), lwork-iwork+&
                        1, info )
              irwork = ie + n
              ! perform bidiagonal qr iteration
                ! multiply b by transpose of left singular vectors
                ! compute right singular vectors in a
              ! (cworkspace: none)
              ! (rworkspace: need bdspac)
              call stdlib_cbdsqr( 'U', n, n, 0, nrhs, s, rwork( ie ), a, lda, dum,1, b, ldb, &
                        rwork( irwork ), info )
              if( info/=0 )go to 70
              ! multiply b by reciprocals of singular values
              thr = max( rcond*s( 1 ), sfmin )
              if( rcond<zero )thr = max( eps*s( 1 ), sfmin )
              rank = 0
              do i = 1, n
                 if( s( i )>thr ) then
                    call stdlib_csrscl( nrhs, s( i ), b( i, 1 ), ldb )
                    rank = rank + 1
                 else
                    call stdlib_claset( 'F', 1, nrhs, czero, czero, b( i, 1 ), ldb )
                 end if
              end do
              ! multiply b by right singular vectors
              ! (cworkspace: need n, prefer n*nrhs)
              ! (rworkspace: none)
              if( lwork>=ldb*nrhs .and. nrhs>1 ) then
                 call stdlib_cgemm( 'C', 'N', n, nrhs, n, cone, a, lda, b, ldb,czero, work, ldb )
                           
                 call stdlib_clacpy( 'G', n, nrhs, work, ldb, b, ldb )
              else if( nrhs>1 ) then
                 chunk = lwork / n
                 do i = 1, nrhs, chunk
                    bl = min( nrhs-i+1, chunk )
                    call stdlib_cgemm( 'C', 'N', n, bl, n, cone, a, lda, b( 1, i ),ldb, czero, &
                              work, n )
                    call stdlib_clacpy( 'G', n, bl, work, n, b( 1, i ), ldb )
                 end do
              else
                 call stdlib_cgemv( 'C', n, n, cone, a, lda, b, 1, czero, work, 1 )
                 call stdlib_ccopy( n, work, 1, b, 1 )
              end if
           else if( n>=mnthr .and. lwork>=3*m+m*m+max( m, nrhs, n-2*m ) )then
              ! underdetermined case, m much less than n
              ! path 2a - underdetermined, with many more columns than rows
              ! and sufficient workspace for an efficient algorithm
              ldwork = m
              if( lwork>=3*m+m*lda+max( m, nrhs, n-2*m ) )ldwork = lda
              itau = 1
              iwork = m + 1
              ! compute a=l*q
              ! (cworkspace: need 2*m, prefer m+m*nb)
              ! (rworkspace: none)
              call stdlib_cgelqf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, info )
                        
              il = iwork
              ! copy l to work(il), zeroing out above it
              call stdlib_clacpy( 'L', m, m, a, lda, work( il ), ldwork )
              call stdlib_claset( 'U', m-1, m-1, czero, czero, work( il+ldwork ),ldwork )
              ie = 1
              itauq = il + ldwork*m
              itaup = itauq + m
              iwork = itaup + m
              ! bidiagonalize l in work(il)
              ! (cworkspace: need m*m+4*m, prefer m*m+3*m+2*m*nb)
              ! (rworkspace: need m)
              call stdlib_cgebrd( m, m, work( il ), ldwork, s, rwork( ie ),work( itauq ), work( &
                        itaup ), work( iwork ),lwork-iwork+1, info )
              ! multiply b by transpose of left bidiagonalizing vectors of l
              ! (cworkspace: need m*m+3*m+nrhs, prefer m*m+3*m+nrhs*nb)
              ! (rworkspace: none)
              call stdlib_cunmbr( 'Q', 'L', 'C', m, nrhs, m, work( il ), ldwork,work( itauq ), b, &
                        ldb, work( iwork ),lwork-iwork+1, info )
              ! generate right bidiagonalizing vectors of r in work(il)
              ! (cworkspace: need m*m+4*m-1, prefer m*m+3*m+(m-1)*nb)
              ! (rworkspace: none)
              call stdlib_cungbr( 'P', m, m, m, work( il ), ldwork, work( itaup ),work( iwork ), &
                        lwork-iwork+1, info )
              irwork = ie + m
              ! perform bidiagonal qr iteration, computing right singular
              ! vectors of l in work(il) and multiplying b by transpose of
              ! left singular vectors
              ! (cworkspace: need m*m)
              ! (rworkspace: need bdspac)
              call stdlib_cbdsqr( 'U', m, m, 0, nrhs, s, rwork( ie ), work( il ),ldwork, a, lda, &
                        b, ldb, rwork( irwork ), info )
              if( info/=0 )go to 70
              ! multiply b by reciprocals of singular values
              thr = max( rcond*s( 1 ), sfmin )
              if( rcond<zero )thr = max( eps*s( 1 ), sfmin )
              rank = 0
              do i = 1, m
                 if( s( i )>thr ) then
                    call stdlib_csrscl( nrhs, s( i ), b( i, 1 ), ldb )
                    rank = rank + 1
                 else
                    call stdlib_claset( 'F', 1, nrhs, czero, czero, b( i, 1 ), ldb )
                 end if
              end do
              iwork = il + m*ldwork
              ! multiply b by right singular vectors of l in work(il)
              ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nrhs)
              ! (rworkspace: none)
              if( lwork>=ldb*nrhs+iwork-1 .and. nrhs>1 ) then
                 call stdlib_cgemm( 'C', 'N', m, nrhs, m, cone, work( il ), ldwork,b, ldb, czero, &
                           work( iwork ), ldb )
                 call stdlib_clacpy( 'G', m, nrhs, work( iwork ), ldb, b, ldb )
              else if( nrhs>1 ) then
                 chunk = ( lwork-iwork+1 ) / m
                 do i = 1, nrhs, chunk
                    bl = min( nrhs-i+1, chunk )
                    call stdlib_cgemm( 'C', 'N', m, bl, m, cone, work( il ), ldwork,b( 1, i ), &
                              ldb, czero, work( iwork ), m )
                    call stdlib_clacpy( 'G', m, bl, work( iwork ), m, b( 1, i ),ldb )
                 end do
              else
                 call stdlib_cgemv( 'C', m, m, cone, work( il ), ldwork, b( 1, 1 ),1, czero, work(&
                            iwork ), 1 )
                 call stdlib_ccopy( m, work( iwork ), 1, b( 1, 1 ), 1 )
              end if
              ! zero out below first m rows of b
              call stdlib_claset( 'F', n-m, nrhs, czero, czero, b( m+1, 1 ), ldb )
              iwork = itau + m
              ! multiply transpose(q) by b
              ! (cworkspace: need m+nrhs, prefer m+nhrs*nb)
              ! (rworkspace: none)
              call stdlib_cunmlq( 'L', 'C', n, nrhs, m, a, lda, work( itau ), b,ldb, work( iwork )&
                        , lwork-iwork+1, info )
           else
              ! path 2 - remaining underdetermined cases
              ie = 1
              itauq = 1
              itaup = itauq + m
              iwork = itaup + m
              ! bidiagonalize a
              ! (cworkspace: need 3*m, prefer 2*m+(m+n)*nb)
              ! (rworkspace: need n)
              call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), work(&
                         iwork ), lwork-iwork+1,info )
              ! multiply b by transpose of left bidiagonalizing vectors
              ! (cworkspace: need 2*m+nrhs, prefer 2*m+nrhs*nb)
              ! (rworkspace: none)
              call stdlib_cunmbr( 'Q', 'L', 'C', m, nrhs, n, a, lda, work( itauq ),b, ldb, work( &
                        iwork ), lwork-iwork+1, info )
              ! generate right bidiagonalizing vectors in a
              ! (cworkspace: need 3*m, prefer 2*m+m*nb)
              ! (rworkspace: none)
              call stdlib_cungbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), lwork-iwork+&
                        1, info )
              irwork = ie + m
              ! perform bidiagonal qr iteration,
                 ! computing right singular vectors of a in a and
                 ! multiplying b by transpose of left singular vectors
              ! (cworkspace: none)
              ! (rworkspace: need bdspac)
              call stdlib_cbdsqr( 'L', m, n, 0, nrhs, s, rwork( ie ), a, lda, dum,1, b, ldb, &
                        rwork( irwork ), info )
              if( info/=0 )go to 70
              ! multiply b by reciprocals of singular values
              thr = max( rcond*s( 1 ), sfmin )
              if( rcond<zero )thr = max( eps*s( 1 ), sfmin )
              rank = 0
              do i = 1, m
                 if( s( i )>thr ) then
                    call stdlib_csrscl( nrhs, s( i ), b( i, 1 ), ldb )
                    rank = rank + 1
                 else
                    call stdlib_claset( 'F', 1, nrhs, czero, czero, b( i, 1 ), ldb )
                 end if
              end do
              ! multiply b by right singular vectors of a
              ! (cworkspace: need n, prefer n*nrhs)
              ! (rworkspace: none)
              if( lwork>=ldb*nrhs .and. nrhs>1 ) then
                 call stdlib_cgemm( 'C', 'N', n, nrhs, m, cone, a, lda, b, ldb,czero, work, ldb )
                           
                 call stdlib_clacpy( 'G', n, nrhs, work, ldb, b, ldb )
              else if( nrhs>1 ) then
                 chunk = lwork / n
                 do i = 1, nrhs, chunk
                    bl = min( nrhs-i+1, chunk )
                    call stdlib_cgemm( 'C', 'N', n, bl, m, cone, a, lda, b( 1, i ),ldb, czero, &
                              work, n )
                    call stdlib_clacpy( 'F', n, bl, work, n, b( 1, i ), ldb )
                 end do
              else
                 call stdlib_cgemv( 'C', m, n, cone, a, lda, b, 1, czero, work, 1 )
                 call stdlib_ccopy( n, work, 1, b, 1 )
              end if
           end if
           ! undo scaling
           if( iascl==1 ) then
              call stdlib_clascl( 'G', 0, 0, anrm, smlnum, n, nrhs, b, ldb, info )
              call stdlib_slascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,info )
           else if( iascl==2 ) then
              call stdlib_clascl( 'G', 0, 0, anrm, bignum, n, nrhs, b, ldb, info )
              call stdlib_slascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,info )
           end if
           if( ibscl==1 ) then
              call stdlib_clascl( 'G', 0, 0, smlnum, bnrm, n, nrhs, b, ldb, info )
           else if( ibscl==2 ) then
              call stdlib_clascl( 'G', 0, 0, bignum, bnrm, n, nrhs, b, ldb, info )
           end if
           70 continue
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_cgelss


     subroutine stdlib_cgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, rwork, &
     !! CGELSY computes the minimum-norm solution to a complex linear least
     !! squares problem:
     !! minimize || A * X - B ||
     !! using a complete orthogonal factorization of A.  A is an M-by-N
     !! matrix which may be rank-deficient.
     !! Several right hand side vectors b and solution vectors x can be
     !! handled in a single call; they are stored as the columns of the
     !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution
     !! matrix X.
     !! The routine first computes a QR factorization with column pivoting:
     !! A * P = Q * [ R11 R12 ]
     !! [  0  R22 ]
     !! with R11 defined as the largest leading submatrix whose estimated
     !! condition number is less than 1/RCOND.  The order of R11, RANK,
     !! is the effective rank of A.
     !! Then, R22 is considered to be negligible, and R12 is annihilated
     !! by unitary transformations from the right, arriving at the
     !! complete orthogonal factorization:
     !! A * P = Q * [ T11 0 ] * Z
     !! [  0  0 ]
     !! The minimum-norm solution is then
     !! X = P * Z**H [ inv(T11)*Q1**H*B ]
     !! [        0         ]
     !! where Q1 consists of the first RANK columns of Q.
     !! This routine is basically identical to the original xGELSX except
     !! three differences:
     !! o The permutation of matrix B (the right hand side) is faster and
     !! more simple.
     !! o The call to the subroutine xGEQPF has been substituted by the
     !! the call to the subroutine xGEQP3. This subroutine is a Blas-3
     !! version of the QR factorization with column pivoting.
     !! o Matrix B (the right hand side) is updated with Blas-3.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info, rank
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(sp), intent(in) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: jpvt(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: imax = 1
           integer(ilp), parameter :: imin = 2
           
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iascl, ibscl, ismax, ismin, j, lwkopt, mn, nb, nb1, nb2, nb3, &
                     nb4
           real(sp) :: anrm, bignum, bnrm, smax, smaxpr, smin, sminpr, smlnum, wsize
           complex(sp) :: c1, c2, s1, s2
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,real,cmplx
           ! Executable Statements 
           mn = min( m, n )
           ismin = mn + 1
           ismax = 2*mn + 1
           ! test the input arguments.
           info = 0
           nb1 = stdlib_ilaenv( 1, 'CGEQRF', ' ', m, n, -1, -1 )
           nb2 = stdlib_ilaenv( 1, 'CGERQF', ' ', m, n, -1, -1 )
           nb3 = stdlib_ilaenv( 1, 'CUNMQR', ' ', m, n, nrhs, -1 )
           nb4 = stdlib_ilaenv( 1, 'CUNMRQ', ' ', m, n, nrhs, -1 )
           nb = max( nb1, nb2, nb3, nb4 )
           lwkopt = max( 1, mn+2*n+nb*(n+1), 2*mn+nb*nrhs )
           work( 1 ) = cmplx( lwkopt,KIND=sp)
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, m, n ) ) then
              info = -7
           else if( lwork<( mn+max( 2*mn, n+1, mn+nrhs ) ) .and..not.lquery ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGELSY', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( min( m, n, nrhs )==0 ) then
              rank = 0
              return
           end if
           ! get machine parameters
           smlnum = stdlib_slamch( 'S' ) / stdlib_slamch( 'P' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           ! scale a, b if max entries outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', m, n, a, lda, rwork )
           iascl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_clascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, info )
              iascl = 1
           else if( anrm>bignum ) then
              ! scale matrix norm down to bignum
              call stdlib_clascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, info )
              iascl = 2
           else if( anrm==zero ) then
              ! matrix all zero. return zero solution.
              call stdlib_claset( 'F', max( m, n ), nrhs, czero, czero, b, ldb )
              rank = 0
              go to 70
           end if
           bnrm = stdlib_clange( 'M', m, nrhs, b, ldb, rwork )
           ibscl = 0
           if( bnrm>zero .and. bnrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_clascl( 'G', 0, 0, bnrm, smlnum, m, nrhs, b, ldb, info )
              ibscl = 1
           else if( bnrm>bignum ) then
              ! scale matrix norm down to bignum
              call stdlib_clascl( 'G', 0, 0, bnrm, bignum, m, nrhs, b, ldb, info )
              ibscl = 2
           end if
           ! compute qr factorization with column pivoting of a:
              ! a * p = q * r
           call stdlib_cgeqp3( m, n, a, lda, jpvt, work( 1 ), work( mn+1 ),lwork-mn, rwork, info )
                     
           wsize = mn + real( work( mn+1 ),KIND=sp)
           ! complex workspace: mn+nb*(n+1). real workspace 2*n.
           ! details of householder rotations stored in work(1:mn).
           ! determine rank using incremental condition estimation
           work( ismin ) = cone
           work( ismax ) = cone
           smax = abs( a( 1, 1 ) )
           smin = smax
           if( abs( a( 1, 1 ) )==zero ) then
              rank = 0
              call stdlib_claset( 'F', max( m, n ), nrhs, czero, czero, b, ldb )
              go to 70
           else
              rank = 1
           end if
           10 continue
           if( rank<mn ) then
              i = rank + 1
              call stdlib_claic1( imin, rank, work( ismin ), smin, a( 1, i ),a( i, i ), sminpr, &
                        s1, c1 )
              call stdlib_claic1( imax, rank, work( ismax ), smax, a( 1, i ),a( i, i ), smaxpr, &
                        s2, c2 )
              if( smaxpr*rcond<=sminpr ) then
                 do i = 1, rank
                    work( ismin+i-1 ) = s1*work( ismin+i-1 )
                    work( ismax+i-1 ) = s2*work( ismax+i-1 )
                 end do
                 work( ismin+rank ) = c1
                 work( ismax+rank ) = c2
                 smin = sminpr
                 smax = smaxpr
                 rank = rank + 1
                 go to 10
              end if
           end if
           ! complex workspace: 3*mn.
           ! logically partition r = [ r11 r12 ]
                                   ! [  0  r22 ]
           ! where r11 = r(1:rank,1:rank)
           ! [r11,r12] = [ t11, 0 ] * y
           if( rank<n )call stdlib_ctzrzf( rank, n, a, lda, work( mn+1 ), work( 2*mn+1 ),lwork-&
                     2*mn, info )
           ! complex workspace: 2*mn.
           ! details of householder rotations stored in work(mn+1:2*mn)
           ! b(1:m,1:nrhs) := q**h * b(1:m,1:nrhs)
           call stdlib_cunmqr( 'LEFT', 'CONJUGATE TRANSPOSE', m, nrhs, mn, a, lda,work( 1 ), b, &
                     ldb, work( 2*mn+1 ), lwork-2*mn, info )
           wsize = max( wsize, 2*mn+real( work( 2*mn+1 ),KIND=sp) )
           ! complex workspace: 2*mn+nb*nrhs.
           ! b(1:rank,1:nrhs) := inv(t11) * b(1:rank,1:nrhs)
           call stdlib_ctrsm( 'LEFT', 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', rank,nrhs, cone, a, &
                     lda, b, ldb )
           do j = 1, nrhs
              do i = rank + 1, n
                 b( i, j ) = czero
              end do
           end do
           ! b(1:n,1:nrhs) := y**h * b(1:n,1:nrhs)
           if( rank<n ) then
              call stdlib_cunmrz( 'LEFT', 'CONJUGATE TRANSPOSE', n, nrhs, rank,n-rank, a, lda, &
                        work( mn+1 ), b, ldb,work( 2*mn+1 ), lwork-2*mn, info )
           end if
           ! complex workspace: 2*mn+nrhs.
           ! b(1:n,1:nrhs) := p * b(1:n,1:nrhs)
           do j = 1, nrhs
              do i = 1, n
                 work( jpvt( i ) ) = b( i, j )
              end do
              call stdlib_ccopy( n, work( 1 ), 1, b( 1, j ), 1 )
           end do
           ! complex workspace: n.
           ! undo scaling
           if( iascl==1 ) then
              call stdlib_clascl( 'G', 0, 0, anrm, smlnum, n, nrhs, b, ldb, info )
              call stdlib_clascl( 'U', 0, 0, smlnum, anrm, rank, rank, a, lda,info )
           else if( iascl==2 ) then
              call stdlib_clascl( 'G', 0, 0, anrm, bignum, n, nrhs, b, ldb, info )
              call stdlib_clascl( 'U', 0, 0, bignum, anrm, rank, rank, a, lda,info )
           end if
           if( ibscl==1 ) then
              call stdlib_clascl( 'G', 0, 0, smlnum, bnrm, n, nrhs, b, ldb, info )
           else if( ibscl==2 ) then
              call stdlib_clascl( 'G', 0, 0, bignum, bnrm, n, nrhs, b, ldb, info )
           end if
           70 continue
           work( 1 ) = cmplx( lwkopt,KIND=sp)
           return
     end subroutine stdlib_cgelsy


     pure subroutine stdlib_cgemlq( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork, &
     !! CGEMLQ overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix defined as the product
     !! of blocked elementary reflectors computed by short wide
     !! LQ factorization (CGELQ)
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, k, tsize, lwork, ldc
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), t(*)
           complex(sp), intent(inout) :: c(ldc,*)
           complex(sp), intent(out) :: work(*)
       ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, right, tran, notran, lquery
           integer(ilp) :: mb, nb, lw, nblcks, mn
           ! Intrinsic Functions 
           intrinsic :: int,max,min,mod
           ! Executable Statements 
           ! test the input arguments
           lquery  = lwork==-1
           notran  = stdlib_lsame( trans, 'N' )
           tran    = stdlib_lsame( trans, 'C' )
           left    = stdlib_lsame( side, 'L' )
           right   = stdlib_lsame( side, 'R' )
           mb = int( t( 2 ),KIND=ilp)
           nb = int( t( 3 ),KIND=ilp)
           if( left ) then
             lw = n * mb
             mn = m
           else
             lw = m * mb
             mn = n
           end if
           if( ( nb>k ) .and. ( mn>k ) ) then
             if( mod( mn - k, nb - k ) == 0 ) then
               nblcks = ( mn - k ) / ( nb - k )
             else
               nblcks = ( mn - k ) / ( nb - k ) + 1
             end if
           else
             nblcks = 1
           end if
           info = 0
           if( .not.left .and. .not.right ) then
             info = -1
           else if( .not.tran .and. .not.notran ) then
             info = -2
           else if( m<0 ) then
             info = -3
           else if( n<0 ) then
             info = -4
           else if( k<0 .or. k>mn ) then
             info = -5
           else if( lda<max( 1, k ) ) then
             info = -7
           else if( tsize<5 ) then
             info = -9
           else if( ldc<max( 1, m ) ) then
             info = -11
           else if( ( lwork<max( 1, lw ) ) .and. ( .not.lquery ) ) then
             info = -13
           end if
           if( info==0 ) then
             work( 1 ) = real( lw,KIND=sp)
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'CGEMLQ', -info )
             return
           else if( lquery ) then
             return
           end if
           ! quick return if possible
           if( min( m, n, k )==0 ) then
             return
           end if
           if( ( left .and. m<=k ) .or. ( right .and. n<=k ).or. ( nb<=k ) .or. ( nb>=max( m, n, &
                     k ) ) ) then
             call stdlib_cgemlqt( side, trans, m, n, k, mb, a, lda,t( 6 ), mb, c, ldc, work, info &
                       )
           else
             call stdlib_clamswlq( side, trans, m, n, k, mb, nb, a, lda, t( 6 ),mb, c, ldc, work, &
                       lwork, info )
           end if
           work( 1 ) = real( lw,KIND=sp)
           return
     end subroutine stdlib_cgemlq


     pure subroutine stdlib_cgemqr( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork, &
     !! CGEMQR overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix defined as the product
     !! of blocked elementary reflectors computed by tall skinny
     !! QR factorization (CGEQR)
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, k, tsize, lwork, ldc
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), t(*)
           complex(sp), intent(inout) :: c(ldc,*)
           complex(sp), intent(out) :: work(*)
       ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, right, tran, notran, lquery
           integer(ilp) :: mb, nb, lw, nblcks, mn
           ! Intrinsic Functions 
           intrinsic :: int,max,min,mod
           ! Executable Statements 
           ! test the input arguments
           lquery  = lwork==-1
           notran  = stdlib_lsame( trans, 'N' )
           tran    = stdlib_lsame( trans, 'C' )
           left    = stdlib_lsame( side, 'L' )
           right   = stdlib_lsame( side, 'R' )
           mb = int( t( 2 ),KIND=ilp)
           nb = int( t( 3 ),KIND=ilp)
           if( left ) then
             lw = n * nb
             mn = m
           else
             lw = mb * nb
             mn = n
           end if
           if( ( mb>k ) .and. ( mn>k ) ) then
             if( mod( mn - k, mb - k )==0 ) then
               nblcks = ( mn - k ) / ( mb - k )
             else
               nblcks = ( mn - k ) / ( mb - k ) + 1
             end if
           else
             nblcks = 1
           end if
           info = 0
           if( .not.left .and. .not.right ) then
             info = -1
           else if( .not.tran .and. .not.notran ) then
             info = -2
           else if( m<0 ) then
             info = -3
           else if( n<0 ) then
             info = -4
           else if( k<0 .or. k>mn ) then
             info = -5
           else if( lda<max( 1, mn ) ) then
             info = -7
           else if( tsize<5 ) then
             info = -9
           else if( ldc<max( 1, m ) ) then
             info = -11
           else if( ( lwork<max( 1, lw ) ) .and. ( .not.lquery ) ) then
             info = -13
           end if
           if( info==0 ) then
             work( 1 ) = lw
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'CGEMQR', -info )
             return
           else if( lquery ) then
             return
           end if
           ! quick return if possible
           if( min( m, n, k )==0 ) then
             return
           end if
           if( ( left .and. m<=k ) .or. ( right .and. n<=k ).or. ( mb<=k ) .or. ( mb>=max( m, n, &
                     k ) ) ) then
             call stdlib_cgemqrt( side, trans, m, n, k, nb, a, lda, t( 6 ),nb, c, ldc, work, info &
                       )
           else
             call stdlib_clamtsqr( side, trans, m, n, k, mb, nb, a, lda, t( 6 ),nb, c, ldc, work, &
                       lwork, info )
           end if
           work( 1 ) = lw
           return
     end subroutine stdlib_cgemqr


     pure subroutine stdlib_cgeqr( m, n, a, lda, t, tsize, work, lwork,info )
     !! CGEQR computes a QR factorization of a complex M-by-N matrix A:
     !! A = Q * ( R ),
     !! ( 0 )
     !! where:
     !! Q is a M-by-M orthogonal matrix;
     !! R is an upper-triangular N-by-N matrix;
     !! 0 is a (M-N)-by-N zero matrix, if M > N.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd. --
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, m, n, tsize, lwork
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: t(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, lminws, mint, minw
           integer(ilp) :: mb, nb, mintsz, nblcks
           ! Intrinsic Functions 
           intrinsic :: max,min,mod
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( tsize==-1 .or. tsize==-2 .or.lwork==-1 .or. lwork==-2 )
           mint = .false.
           minw = .false.
           if( tsize==-2 .or. lwork==-2 ) then
             if( tsize/=-1 ) mint = .true.
             if( lwork/=-1 ) minw = .true.
           end if
           ! determine the block size
           if( min( m, n )>0 ) then
             mb = stdlib_ilaenv( 1, 'CGEQR ', ' ', m, n, 1, -1 )
             nb = stdlib_ilaenv( 1, 'CGEQR ', ' ', m, n, 2, -1 )
           else
             mb = m
             nb = 1
           end if
           if( mb>m .or. mb<=n ) mb = m
           if( nb>min( m, n ) .or. nb<1 ) nb = 1
           mintsz = n + 5
           if( mb>n .and. m>n ) then
             if( mod( m - n, mb - n )==0 ) then
               nblcks = ( m - n ) / ( mb - n )
             else
               nblcks = ( m - n ) / ( mb - n ) + 1
             end if
           else
             nblcks = 1
           end if
           ! determine if the workspace size satisfies minimal size
           lminws = .false.
           if( ( tsize<max( 1, nb*n*nblcks + 5 ) .or. lwork<nb*n ).and. ( lwork>=n ) .and. ( &
                     tsize>=mintsz ).and. ( .not.lquery ) ) then
             if( tsize<max( 1, nb*n*nblcks + 5 ) ) then
               lminws = .true.
               nb = 1
               mb = m
             end if
             if( lwork<nb*n ) then
               lminws = .true.
               nb = 1
             end if
           end if
           if( m<0 ) then
             info = -1
           else if( n<0 ) then
             info = -2
           else if( lda<max( 1, m ) ) then
             info = -4
           else if( tsize<max( 1, nb*n*nblcks + 5 ).and. ( .not.lquery ) .and. ( .not.lminws ) ) &
                     then
             info = -6
           else if( ( lwork<max( 1, n*nb ) ) .and. ( .not.lquery ).and. ( .not.lminws ) ) &
                     then
             info = -8
           end if
           if( info==0 ) then
             if( mint ) then
               t( 1 ) = mintsz
             else
               t( 1 ) = nb*n*nblcks + 5
             end if
             t( 2 ) = mb
             t( 3 ) = nb
             if( minw ) then
               work( 1 ) = max( 1, n )
             else
               work( 1 ) = max( 1, nb*n )
             end if
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'CGEQR', -info )
             return
           else if( lquery ) then
             return
           end if
           ! quick return if possible
           if( min( m, n )==0 ) then
             return
           end if
           ! the qr decomposition
           if( ( m<=n ) .or. ( mb<=n ) .or. ( mb>=m ) ) then
             call stdlib_cgeqrt( m, n, nb, a, lda, t( 6 ), nb, work, info )
           else
             call stdlib_clatsqr( m, n, mb, nb, a, lda, t( 6 ), nb, work,lwork, info )
           end if
           work( 1 ) = max( 1, nb*n )
           return
     end subroutine stdlib_cgeqr


     subroutine stdlib_cgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, rwork, iwork, &
     !! CGESDD computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, optionally computing the left and/or right singular
     !! vectors, by using divide-and-conquer method. The SVD is written
     !! A = U * SIGMA * conjugate-transpose(V)
     !! where SIGMA is an M-by-N matrix which is zero except for its
     !! min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
     !! V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
     !! are the singular values of A; they are real and non-negative, and
     !! are returned in descending order.  The first min(m,n) columns of
     !! U and V are the left and right singular vectors of A.
     !! Note that the routine returns VT = V**H, not V.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldvt, lwork, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), s(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery, wntqa, wntqas, wntqn, wntqo, wntqs
           integer(ilp) :: blk, chunk, i, ie, ierr, il, ir, iru, irvt, iscl, itau, itaup, itauq, &
           iu, ivt, ldwkvt, ldwrkl, ldwrkr, ldwrku, maxwrk, minmn, minwrk, mnthr1, mnthr2, nrwork,&
                      nwork, wrkbl
           integer(ilp) :: lwork_cgebrd_mn, lwork_cgebrd_mm, lwork_cgebrd_nn, lwork_cgelqf_mn, &
           lwork_cgeqrf_mn, lwork_cungbr_p_mn, lwork_cungbr_p_nn, lwork_cungbr_q_mn, &
           lwork_cungbr_q_mm, lwork_cunglq_mn, lwork_cunglq_nn, lwork_cungqr_mm, lwork_cungqr_mn, &
           lwork_cunmbr_prc_mm, lwork_cunmbr_qln_mm, lwork_cunmbr_prc_mn, lwork_cunmbr_qln_mn, &
                     lwork_cunmbr_prc_nn, lwork_cunmbr_qln_nn
           real(sp) :: anrm, bignum, eps, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(sp) :: dum(1)
           complex(sp) :: cdum(1)
           ! Intrinsic Functions 
           intrinsic :: int,max,min,sqrt
           ! Executable Statements 
           ! test the input arguments
           info   = 0
           minmn  = min( m, n )
           mnthr1 = int( minmn*17.0_sp / 9.0_sp,KIND=ilp)
           mnthr2 = int( minmn*5.0_sp / 3.0_sp,KIND=ilp)
           wntqa  = stdlib_lsame( jobz, 'A' )
           wntqs  = stdlib_lsame( jobz, 'S' )
           wntqas = wntqa .or. wntqs
           wntqo  = stdlib_lsame( jobz, 'O' )
           wntqn  = stdlib_lsame( jobz, 'N' )
           lquery = ( lwork==-1 )
           minwrk = 1
           maxwrk = 1
           if( .not.( wntqa .or. wntqs .or. wntqo .or. wntqn ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldu<1 .or. ( wntqas .and. ldu<m ) .or.( wntqo .and. m<n .and. ldu<m ) ) &
                     then
              info = -8
           else if( ldvt<1 .or. ( wntqa .and. ldvt<n ) .or.( wntqs .and. ldvt<minmn ) .or.( wntqo &
                     .and. m>=n .and. ldvt<n ) ) then
              info = -10
           end if
           ! compute workspace
             ! note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace allocated at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to
             ! real workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              if( m>=n .and. minmn>0 ) then
                 ! there is no complex work space needed for bidiagonal svd
                 ! the realwork space needed for bidiagonal svd (stdlib_sbdsdc,KIND=sp) is
                 ! bdspac = 3*n*n + 4*n for singular values and vectors;
                 ! bdspac = 4*n         for singular values only;
                 ! not including e, ru, and rvt matrices.
                 ! compute space preferred for each routine
                 call stdlib_cgebrd( m, n, cdum(1), m, dum(1), dum(1), cdum(1),cdum(1), cdum(1), -&
                           1, ierr )
                 lwork_cgebrd_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cgebrd( n, n, cdum(1), n, dum(1), dum(1), cdum(1),cdum(1), cdum(1), -&
                           1, ierr )
                 lwork_cgebrd_nn = int( cdum(1),KIND=ilp)
                 call stdlib_cgeqrf( m, n, cdum(1), m, cdum(1), cdum(1), -1, ierr )
                 lwork_cgeqrf_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cungbr( 'P', n, n, n, cdum(1), n, cdum(1), cdum(1),-1, ierr )
                 lwork_cungbr_p_nn = int( cdum(1),KIND=ilp)
                 call stdlib_cungbr( 'Q', m, m, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_cungbr_q_mm = int( cdum(1),KIND=ilp)
                 call stdlib_cungbr( 'Q', m, n, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_cungbr_q_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cungqr( m, m, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_cungqr_mm = int( cdum(1),KIND=ilp)
                 call stdlib_cungqr( m, n, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_cungqr_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cunmbr( 'P', 'R', 'C', n, n, n, cdum(1), n, cdum(1),cdum(1), n, cdum(&
                           1), -1, ierr )
                 lwork_cunmbr_prc_nn = int( cdum(1),KIND=ilp)
                 call stdlib_cunmbr( 'Q', 'L', 'N', m, m, n, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_cunmbr_qln_mm = int( cdum(1),KIND=ilp)
                 call stdlib_cunmbr( 'Q', 'L', 'N', m, n, n, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_cunmbr_qln_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cunmbr( 'Q', 'L', 'N', n, n, n, cdum(1), n, cdum(1),cdum(1), n, cdum(&
                           1), -1, ierr )
                 lwork_cunmbr_qln_nn = int( cdum(1),KIND=ilp)
                 if( m>=mnthr1 ) then
                    if( wntqn ) then
                       ! path 1 (m >> n, jobz='n')
                       maxwrk = n + lwork_cgeqrf_mn
                       maxwrk = max( maxwrk, 2*n + lwork_cgebrd_nn )
                       minwrk = 3*n
                    else if( wntqo ) then
                       ! path 2 (m >> n, jobz='o')
                       wrkbl = n + lwork_cgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_cungqr_mn )
                       wrkbl = max( wrkbl, 2*n + lwork_cgebrd_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_cunmbr_qln_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_cunmbr_prc_nn )
                       maxwrk = m*n + n*n + wrkbl
                       minwrk = 2*n*n + 3*n
                    else if( wntqs ) then
                       ! path 3 (m >> n, jobz='s')
                       wrkbl = n + lwork_cgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_cungqr_mn )
                       wrkbl = max( wrkbl, 2*n + lwork_cgebrd_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_cunmbr_qln_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_cunmbr_prc_nn )
                       maxwrk = n*n + wrkbl
                       minwrk = n*n + 3*n
                    else if( wntqa ) then
                       ! path 4 (m >> n, jobz='a')
                       wrkbl = n + lwork_cgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_cungqr_mm )
                       wrkbl = max( wrkbl, 2*n + lwork_cgebrd_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_cunmbr_qln_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_cunmbr_prc_nn )
                       maxwrk = n*n + wrkbl
                       minwrk = n*n + max( 3*n, n + m )
                    end if
                 else if( m>=mnthr2 ) then
                    ! path 5 (m >> n, but not as much as mnthr1)
                    maxwrk = 2*n + lwork_cgebrd_mn
                    minwrk = 2*n + m
                    if( wntqo ) then
                       ! path 5o (m >> n, jobz='o')
                       maxwrk = max( maxwrk, 2*n + lwork_cungbr_p_nn )
                       maxwrk = max( maxwrk, 2*n + lwork_cungbr_q_mn )
                       maxwrk = maxwrk + m*n
                       minwrk = minwrk + n*n
                    else if( wntqs ) then
                       ! path 5s (m >> n, jobz='s')
                       maxwrk = max( maxwrk, 2*n + lwork_cungbr_p_nn )
                       maxwrk = max( maxwrk, 2*n + lwork_cungbr_q_mn )
                    else if( wntqa ) then
                       ! path 5a (m >> n, jobz='a')
                       maxwrk = max( maxwrk, 2*n + lwork_cungbr_p_nn )
                       maxwrk = max( maxwrk, 2*n + lwork_cungbr_q_mm )
                    end if
                 else
                    ! path 6 (m >= n, but not much larger)
                    maxwrk = 2*n + lwork_cgebrd_mn
                    minwrk = 2*n + m
                    if( wntqo ) then
                       ! path 6o (m >= n, jobz='o')
                       maxwrk = max( maxwrk, 2*n + lwork_cunmbr_prc_nn )
                       maxwrk = max( maxwrk, 2*n + lwork_cunmbr_qln_mn )
                       maxwrk = maxwrk + m*n
                       minwrk = minwrk + n*n
                    else if( wntqs ) then
                       ! path 6s (m >= n, jobz='s')
                       maxwrk = max( maxwrk, 2*n + lwork_cunmbr_qln_mn )
                       maxwrk = max( maxwrk, 2*n + lwork_cunmbr_prc_nn )
                    else if( wntqa ) then
                       ! path 6a (m >= n, jobz='a')
                       maxwrk = max( maxwrk, 2*n + lwork_cunmbr_qln_mm )
                       maxwrk = max( maxwrk, 2*n + lwork_cunmbr_prc_nn )
                    end if
                 end if
              else if( minmn>0 ) then
                 ! there is no complex work space needed for bidiagonal svd
                 ! the realwork space needed for bidiagonal svd (stdlib_sbdsdc,KIND=sp) is
                 ! bdspac = 3*m*m + 4*m for singular values and vectors;
                 ! bdspac = 4*m         for singular values only;
                 ! not including e, ru, and rvt matrices.
                 ! compute space preferred for each routine
                 call stdlib_cgebrd( m, n, cdum(1), m, dum(1), dum(1), cdum(1),cdum(1), cdum(1), -&
                           1, ierr )
                 lwork_cgebrd_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cgebrd( m, m, cdum(1), m, dum(1), dum(1), cdum(1),cdum(1), cdum(1), -&
                           1, ierr )
                 lwork_cgebrd_mm = int( cdum(1),KIND=ilp)
                 call stdlib_cgelqf( m, n, cdum(1), m, cdum(1), cdum(1), -1, ierr )
                 lwork_cgelqf_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cungbr( 'P', m, n, m, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_cungbr_p_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cungbr( 'P', n, n, m, cdum(1), n, cdum(1), cdum(1),-1, ierr )
                 lwork_cungbr_p_nn = int( cdum(1),KIND=ilp)
                 call stdlib_cungbr( 'Q', m, m, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_cungbr_q_mm = int( cdum(1),KIND=ilp)
                 call stdlib_cunglq( m, n, m, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_cunglq_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cunglq( n, n, m, cdum(1), n, cdum(1), cdum(1),-1, ierr )
                 lwork_cunglq_nn = int( cdum(1),KIND=ilp)
                 call stdlib_cunmbr( 'P', 'R', 'C', m, m, m, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_cunmbr_prc_mm = int( cdum(1),KIND=ilp)
                 call stdlib_cunmbr( 'P', 'R', 'C', m, n, m, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_cunmbr_prc_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cunmbr( 'P', 'R', 'C', n, n, m, cdum(1), n, cdum(1),cdum(1), n, cdum(&
                           1), -1, ierr )
                 lwork_cunmbr_prc_nn = int( cdum(1),KIND=ilp)
                 call stdlib_cunmbr( 'Q', 'L', 'N', m, m, m, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_cunmbr_qln_mm = int( cdum(1),KIND=ilp)
                 if( n>=mnthr1 ) then
                    if( wntqn ) then
                       ! path 1t (n >> m, jobz='n')
                       maxwrk = m + lwork_cgelqf_mn
                       maxwrk = max( maxwrk, 2*m + lwork_cgebrd_mm )
                       minwrk = 3*m
                    else if( wntqo ) then
                       ! path 2t (n >> m, jobz='o')
                       wrkbl = m + lwork_cgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_cunglq_mn )
                       wrkbl = max( wrkbl, 2*m + lwork_cgebrd_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_cunmbr_qln_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_cunmbr_prc_mm )
                       maxwrk = m*n + m*m + wrkbl
                       minwrk = 2*m*m + 3*m
                    else if( wntqs ) then
                       ! path 3t (n >> m, jobz='s')
                       wrkbl = m + lwork_cgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_cunglq_mn )
                       wrkbl = max( wrkbl, 2*m + lwork_cgebrd_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_cunmbr_qln_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_cunmbr_prc_mm )
                       maxwrk = m*m + wrkbl
                       minwrk = m*m + 3*m
                    else if( wntqa ) then
                       ! path 4t (n >> m, jobz='a')
                       wrkbl = m + lwork_cgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_cunglq_nn )
                       wrkbl = max( wrkbl, 2*m + lwork_cgebrd_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_cunmbr_qln_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_cunmbr_prc_mm )
                       maxwrk = m*m + wrkbl
                       minwrk = m*m + max( 3*m, m + n )
                    end if
                 else if( n>=mnthr2 ) then
                    ! path 5t (n >> m, but not as much as mnthr1)
                    maxwrk = 2*m + lwork_cgebrd_mn
                    minwrk = 2*m + n
                    if( wntqo ) then
                       ! path 5to (n >> m, jobz='o')
                       maxwrk = max( maxwrk, 2*m + lwork_cungbr_q_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_cungbr_p_mn )
                       maxwrk = maxwrk + m*n
                       minwrk = minwrk + m*m
                    else if( wntqs ) then
                       ! path 5ts (n >> m, jobz='s')
                       maxwrk = max( maxwrk, 2*m + lwork_cungbr_q_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_cungbr_p_mn )
                    else if( wntqa ) then
                       ! path 5ta (n >> m, jobz='a')
                       maxwrk = max( maxwrk, 2*m + lwork_cungbr_q_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_cungbr_p_nn )
                    end if
                 else
                    ! path 6t (n > m, but not much larger)
                    maxwrk = 2*m + lwork_cgebrd_mn
                    minwrk = 2*m + n
                    if( wntqo ) then
                       ! path 6to (n > m, jobz='o')
                       maxwrk = max( maxwrk, 2*m + lwork_cunmbr_qln_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_cunmbr_prc_mn )
                       maxwrk = maxwrk + m*n
                       minwrk = minwrk + m*m
                    else if( wntqs ) then
                       ! path 6ts (n > m, jobz='s')
                       maxwrk = max( maxwrk, 2*m + lwork_cunmbr_qln_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_cunmbr_prc_mn )
                    else if( wntqa ) then
                       ! path 6ta (n > m, jobz='a')
                       maxwrk = max( maxwrk, 2*m + lwork_cunmbr_qln_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_cunmbr_prc_nn )
                    end if
                 end if
              end if
              maxwrk = max( maxwrk, minwrk )
           end if
           if( info==0 ) then
              work( 1 ) = stdlib_sroundup_lwork( maxwrk )
              if( lwork<minwrk .and. .not. lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGESDD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = sqrt( stdlib_slamch( 'S' ) ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', m, n, a, lda, dum )
           if( stdlib_sisnan ( anrm ) ) then
               info = -4
               return
           end if
           iscl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              iscl = 1
              call stdlib_clascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, ierr )
           else if( anrm>bignum ) then
              iscl = 1
              call stdlib_clascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, ierr )
           end if
           if( m>=n ) then
              ! a has at least as many rows as columns. if a has sufficiently
              ! more rows than columns, first reduce using the qr
              ! decomposition (if sufficient workspace available)
              if( m>=mnthr1 ) then
                 if( wntqn ) then
                    ! path 1 (m >> n, jobz='n')
                    ! no singular vectors to be computed
                    itau = 1
                    nwork = itau + n
                    ! compute a=q*r
                    ! cworkspace: need   n [tau] + n    [work]
                    ! cworkspace: prefer n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! zero out below r
                    if (n>1) call stdlib_claset( 'L', n-1, n-1, czero, czero, a( 2, 1 ),lda )
                    ie = 1
                    itauq = 1
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in a
                    ! cworkspace: need   2*n [tauq, taup] + n      [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + 2*n*nb [work]
                    ! rworkspace: need   n [e]
                    call stdlib_cgebrd( n, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( nwork ), lwork-nwork+1,ierr )
                    nrwork = ie + n
                    ! perform bidiagonal svd, compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + bdspac
                    call stdlib_sbdsdc( 'U', 'N', n, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 2 (m >> n, jobz='o')
                    ! n left singular vectors to be overwritten on a and
                    ! n right singular vectors to be computed in vt
                    iu = 1
                    ! work(iu) is n by n
                    ldwrku = n
                    ir = iu + ldwrku*n
                    if( lwork >= m*n + n*n + 3*n ) then
                       ! work(ir) is m by n
                       ldwrkr = m
                    else
                       ldwrkr = ( lwork - n*n - 3*n ) / n
                    end if
                    itau = ir + ldwrkr*n
                    nwork = itau + n
                    ! compute a=q*r
                    ! cworkspace: need   n*n [u] + n*n [r] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! copy r to work( ir ), zeroing out below it
                    call stdlib_clacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                    call stdlib_claset( 'L', n-1, n-1, czero, czero, work( ir+1 ),ldwrkr )
                    ! generate q in a
                    ! cworkspace: need   n*n [u] + n*n [r] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cungqr( m, n, n, a, lda, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ie = 1
                    itauq = itau
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in work(ir)
                    ! cworkspace: need   n*n [u] + n*n [r] + 2*n [tauq, taup] + n      [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + 2*n [tauq, taup] + 2*n*nb [work]
                    ! rworkspace: need   n [e]
                    call stdlib_cgebrd( n, n, work( ir ), ldwrkr, s, rwork( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of r in work(iru) and computing right singular vectors
                    ! of r in work(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = ie + n
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix work(iu)
                    ! overwrite work(iu) by the left singular vectors of r
                    ! cworkspace: need   n*n [u] + n*n [r] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', n, n, rwork( iru ), n, work( iu ),ldwrku )
                    call stdlib_cunmbr( 'Q', 'L', 'N', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                              work( iu ), ldwrku,work( nwork ), lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by the right singular vectors of r
                    ! cworkspace: need   n*n [u] + n*n [r] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork-nwork+1, ierr )
                    ! multiply q in a by left singular vectors of r in
                    ! work(iu), storing result in work(ir) and copying to a
                    ! cworkspace: need   n*n [u] + n*n [r]
                    ! cworkspace: prefer n*n [u] + m*n [r]
                    ! rworkspace: need   0
                    do i = 1, m, ldwrkr
                       chunk = min( m-i+1, ldwrkr )
                       call stdlib_cgemm( 'N', 'N', chunk, n, n, cone, a( i, 1 ),lda, work( iu ), &
                                 ldwrku, czero,work( ir ), ldwrkr )
                       call stdlib_clacpy( 'F', chunk, n, work( ir ), ldwrkr,a( i, 1 ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 3 (m >> n, jobz='s')
                    ! n left singular vectors to be computed in u and
                    ! n right singular vectors to be computed in vt
                    ir = 1
                    ! work(ir) is n by n
                    ldwrkr = n
                    itau = ir + ldwrkr*n
                    nwork = itau + n
                    ! compute a=q*r
                    ! cworkspace: need   n*n [r] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [r] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! copy r to work(ir), zeroing out below it
                    call stdlib_clacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                    call stdlib_claset( 'L', n-1, n-1, czero, czero, work( ir+1 ),ldwrkr )
                    ! generate q in a
                    ! cworkspace: need   n*n [r] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [r] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cungqr( m, n, n, a, lda, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ie = 1
                    itauq = itau
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in work(ir)
                    ! cworkspace: need   n*n [r] + 2*n [tauq, taup] + n      [work]
                    ! cworkspace: prefer n*n [r] + 2*n [tauq, taup] + 2*n*nb [work]
                    ! rworkspace: need   n [e]
                    call stdlib_cgebrd( n, n, work( ir ), ldwrkr, s, rwork( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = ie + n
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix u
                    ! overwrite u by left singular vectors of r
                    ! cworkspace: need   n*n [r] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [r] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', n, n, rwork( iru ), n, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                              u, ldu, work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by right singular vectors of r
                    ! cworkspace: need   n*n [r] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [r] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork-nwork+1, ierr )
                    ! multiply q in a by left singular vectors of r in
                    ! work(ir), storing result in u
                    ! cworkspace: need   n*n [r]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'F', n, n, u, ldu, work( ir ), ldwrkr )
                    call stdlib_cgemm( 'N', 'N', m, n, n, cone, a, lda, work( ir ),ldwrkr, czero, &
                              u, ldu )
                 else if( wntqa ) then
                    ! path 4 (m >> n, jobz='a')
                    ! m left singular vectors to be computed in u and
                    ! n right singular vectors to be computed in vt
                    iu = 1
                    ! work(iu) is n by n
                    ldwrku = n
                    itau = iu + ldwrku*n
                    nwork = itau + n
                    ! compute a=q*r, copying result to u
                    ! cworkspace: need   n*n [u] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [u] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                    ! generate q in u
                    ! cworkspace: need   n*n [u] + n [tau] + m    [work]
                    ! cworkspace: prefer n*n [u] + n [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cungqr( m, m, n, u, ldu, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ! produce r in a, zeroing out below it
                    if (n>1) call stdlib_claset( 'L', n-1, n-1, czero, czero, a( 2, 1 ),lda )
                    ie = 1
                    itauq = itau
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in a
                    ! cworkspace: need   n*n [u] + 2*n [tauq, taup] + n      [work]
                    ! cworkspace: prefer n*n [u] + 2*n [tauq, taup] + 2*n*nb [work]
                    ! rworkspace: need   n [e]
                    call stdlib_cgebrd( n, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( nwork ), lwork-nwork+1,ierr )
                    iru = ie + n
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix work(iu)
                    ! overwrite work(iu) by left singular vectors of r
                    ! cworkspace: need   n*n [u] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [u] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', n, n, rwork( iru ), n, work( iu ),ldwrku )
                    call stdlib_cunmbr( 'Q', 'L', 'N', n, n, n, a, lda,work( itauq ), work( iu ), &
                              ldwrku,work( nwork ), lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by right singular vectors of r
                    ! cworkspace: need   n*n [u] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [u] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! multiply q in u by left singular vectors of r in
                    ! work(iu), storing result in a
                    ! cworkspace: need   n*n [u]
                    ! rworkspace: need   0
                    call stdlib_cgemm( 'N', 'N', m, n, n, cone, u, ldu, work( iu ),ldwrku, czero, &
                              a, lda )
                    ! copy left singular vectors of a from a to u
                    call stdlib_clacpy( 'F', m, n, a, lda, u, ldu )
                 end if
              else if( m>=mnthr2 ) then
                 ! mnthr2 <= m < mnthr1
                 ! path 5 (m >> n, but not as much as mnthr1)
                 ! reduce to bidiagonal form without qr decomposition, use
                 ! stdlib_cungbr and matrix multiplication to compute singular vectors
                 ie = 1
                 nrwork = ie + n
                 itauq = 1
                 itaup = itauq + n
                 nwork = itaup + n
                 ! bidiagonalize a
                 ! cworkspace: need   2*n [tauq, taup] + m        [work]
                 ! cworkspace: prefer 2*n [tauq, taup] + (m+n)*nb [work]
                 ! rworkspace: need   n [e]
                 call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 5n (m >> n, jobz='n')
                    ! compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + bdspac
                    call stdlib_sbdsdc( 'U', 'N', n, s, rwork( ie ), dum, 1,dum,1,dum, idum, &
                              rwork( nrwork ), iwork, info )
                 else if( wntqo ) then
                    iu = nwork
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    ! path 5o (m >> n, jobz='o')
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! generate q in a
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cungbr( 'Q', m, n, n, a, lda, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    if( lwork >= m*n + 3*n ) then
                       ! work( iu ) is m by n
                       ldwrku = m
                    else
                       ! work(iu) is ldwrku by n
                       ldwrku = ( lwork - 3*n ) / n
                    end if
                    nwork = iu + ldwrku*n
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply realmatrix rwork(irvt,KIND=sp) by p**h in vt,
                    ! storing the result in work(iu), copying to vt
                    ! cworkspace: need   2*n [tauq, taup] + n*n [u]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + 2*n*n [rwork]
                    call stdlib_clarcm( n, n, rwork( irvt ), n, vt, ldvt,work( iu ), ldwrku, &
                              rwork( nrwork ) )
                    call stdlib_clacpy( 'F', n, n, work( iu ), ldwrku, vt, ldvt )
                    ! multiply q in a by realmatrix rwork(iru,KIND=sp), storing the
                    ! result in work(iu), copying to a
                    ! cworkspace: need   2*n [tauq, taup] + n*n [u]
                    ! cworkspace: prefer 2*n [tauq, taup] + m*n [u]
                    ! rworkspace: need   n [e] + n*n [ru] + 2*n*n [rwork]
                    ! rworkspace: prefer n [e] + n*n [ru] + 2*m*n [rwork] < n + 5*n*n since m < 2*n here
                    nrwork = irvt
                    do i = 1, m, ldwrku
                       chunk = min( m-i+1, ldwrku )
                       call stdlib_clacrm( chunk, n, a( i, 1 ), lda, rwork( iru ),n, work( iu ), &
                                 ldwrku, rwork( nrwork ) )
                       call stdlib_clacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 5s (m >> n, jobz='s')
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! copy a to u, generate q
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                    call stdlib_cungbr( 'Q', m, n, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply realmatrix rwork(irvt,KIND=sp) by p**h in vt,
                    ! storing the result in a, copying to vt
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + 2*n*n [rwork]
                    call stdlib_clarcm( n, n, rwork( irvt ), n, vt, ldvt, a, lda,rwork( nrwork ) )
                              
                    call stdlib_clacpy( 'F', n, n, a, lda, vt, ldvt )
                    ! multiply q in u by realmatrix rwork(iru,KIND=sp), storing the
                    ! result in a, copying to u
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + 2*m*n [rwork] < n + 5*n*n since m < 2*n here
                    nrwork = irvt
                    call stdlib_clacrm( m, n, u, ldu, rwork( iru ), n, a, lda,rwork( nrwork ) )
                              
                    call stdlib_clacpy( 'F', m, n, a, lda, u, ldu )
                 else
                    ! path 5a (m >> n, jobz='a')
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! copy a to u, generate q
                    ! cworkspace: need   2*n [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                    call stdlib_cungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply realmatrix rwork(irvt,KIND=sp) by p**h in vt,
                    ! storing the result in a, copying to vt
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + 2*n*n [rwork]
                    call stdlib_clarcm( n, n, rwork( irvt ), n, vt, ldvt, a, lda,rwork( nrwork ) )
                              
                    call stdlib_clacpy( 'F', n, n, a, lda, vt, ldvt )
                    ! multiply q in u by realmatrix rwork(iru,KIND=sp), storing the
                    ! result in a, copying to u
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + 2*m*n [rwork] < n + 5*n*n since m < 2*n here
                    nrwork = irvt
                    call stdlib_clacrm( m, n, u, ldu, rwork( iru ), n, a, lda,rwork( nrwork ) )
                              
                    call stdlib_clacpy( 'F', m, n, a, lda, u, ldu )
                 end if
              else
                 ! m < mnthr2
                 ! path 6 (m >= n, but not much larger)
                 ! reduce to bidiagonal form without qr decomposition
                 ! use stdlib_cunmbr to compute singular vectors
                 ie = 1
                 nrwork = ie + n
                 itauq = 1
                 itaup = itauq + n
                 nwork = itaup + n
                 ! bidiagonalize a
                 ! cworkspace: need   2*n [tauq, taup] + m        [work]
                 ! cworkspace: prefer 2*n [tauq, taup] + (m+n)*nb [work]
                 ! rworkspace: need   n [e]
                 call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 6n (m >= n, jobz='n')
                    ! compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + bdspac
                    call stdlib_sbdsdc( 'U', 'N', n, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    iu = nwork
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    if( lwork >= m*n + 3*n ) then
                       ! work( iu ) is m by n
                       ldwrku = m
                    else
                       ! work( iu ) is ldwrku by n
                       ldwrku = ( lwork - 3*n ) / n
                    end if
                    nwork = iu + ldwrku*n
                    ! path 6o (m >= n, jobz='o')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + n*n [u] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*n [u] + n*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_clacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                    if( lwork >= m*n + 3*n ) then
                       ! path 6o-fast
                       ! copy realmatrix rwork(iru,KIND=sp) to complex matrix work(iu)
                       ! overwrite work(iu) by left singular vectors of a, copying
                       ! to a
                       ! cworkspace: need   2*n [tauq, taup] + m*n [u] + n    [work]
                       ! cworkspace: prefer 2*n [tauq, taup] + m*n [u] + n*nb [work]
                       ! rworkspace: need   n [e] + n*n [ru]
                       call stdlib_claset( 'F', m, n, czero, czero, work( iu ),ldwrku )
                       call stdlib_clacp2( 'F', n, n, rwork( iru ), n, work( iu ),ldwrku )
                       call stdlib_cunmbr( 'Q', 'L', 'N', m, n, n, a, lda,work( itauq ), work( iu &
                                 ), ldwrku,work( nwork ), lwork-nwork+1, ierr )
                       call stdlib_clacpy( 'F', m, n, work( iu ), ldwrku, a, lda )
                    else
                       ! path 6o-slow
                       ! generate q in a
                       ! cworkspace: need   2*n [tauq, taup] + n*n [u] + n    [work]
                       ! cworkspace: prefer 2*n [tauq, taup] + n*n [u] + n*nb [work]
                       ! rworkspace: need   0
                       call stdlib_cungbr( 'Q', m, n, n, a, lda, work( itauq ),work( nwork ), &
                                 lwork-nwork+1, ierr )
                       ! multiply q in a by realmatrix rwork(iru,KIND=sp), storing the
                       ! result in work(iu), copying to a
                       ! cworkspace: need   2*n [tauq, taup] + n*n [u]
                       ! cworkspace: prefer 2*n [tauq, taup] + m*n [u]
                       ! rworkspace: need   n [e] + n*n [ru] + 2*n*n [rwork]
                       ! rworkspace: prefer n [e] + n*n [ru] + 2*m*n [rwork] < n + 5*n*n since m < 2*n here
                       nrwork = irvt
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_clacrm( chunk, n, a( i, 1 ), lda,rwork( iru ), n, work( iu )&
                                    , ldwrku,rwork( nrwork ) )
                          call stdlib_clacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    end if
                 else if( wntqs ) then
                    ! path 6s (m >= n, jobz='s')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_claset( 'F', m, n, czero, czero, u, ldu )
                    call stdlib_clacp2( 'F', n, n, rwork( iru ), n, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', m, n, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_clacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                 else
                    ! path 6a (m >= n, jobz='a')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! set the right corner of u to identity matrix
                    call stdlib_claset( 'F', m, m, czero, czero, u, ldu )
                    if( m>n ) then
                       call stdlib_claset( 'F', m-n, m-n, czero, cone,u( n+1, n+1 ), ldu )
                    end if
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + m*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_clacp2( 'F', n, n, rwork( iru ), n, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_clacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                 end if
              end if
           else
              ! a has more columns than rows. if a has sufficiently more
              ! columns than rows, first reduce using the lq decomposition (if
              ! sufficient workspace available)
              if( n>=mnthr1 ) then
                 if( wntqn ) then
                    ! path 1t (n >> m, jobz='n')
                    ! no singular vectors to be computed
                    itau = 1
                    nwork = itau + m
                    ! compute a=l*q
                    ! cworkspace: need   m [tau] + m    [work]
                    ! cworkspace: prefer m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! zero out above l
                    if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero, a( 1, 2 ),lda )
                    ie = 1
                    itauq = 1
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in a
                    ! cworkspace: need   2*m [tauq, taup] + m      [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + 2*m*nb [work]
                    ! rworkspace: need   m [e]
                    call stdlib_cgebrd( m, m, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( nwork ), lwork-nwork+1,ierr )
                    nrwork = ie + m
                    ! perform bidiagonal svd, compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + bdspac
                    call stdlib_sbdsdc( 'U', 'N', m, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 2t (n >> m, jobz='o')
                    ! m right singular vectors to be overwritten on a and
                    ! m left singular vectors to be computed in u
                    ivt = 1
                    ldwkvt = m
                    ! work(ivt) is m by m
                    il = ivt + ldwkvt*m
                    if( lwork >= m*n + m*m + 3*m ) then
                       ! work(il) m by n
                       ldwrkl = m
                       chunk = n
                    else
                       ! work(il) is m by chunk
                       ldwrkl = m
                       chunk = ( lwork - m*m - 3*m ) / m
                    end if
                    itau = il + ldwrkl*chunk
                    nwork = itau + m
                    ! compute a=l*q
                    ! cworkspace: need   m*m [vt] + m*m [l] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! copy l to work(il), zeroing about above it
                    call stdlib_clacpy( 'L', m, m, a, lda, work( il ), ldwrkl )
                    call stdlib_claset( 'U', m-1, m-1, czero, czero,work( il+ldwrkl ), ldwrkl )
                              
                    ! generate q in a
                    ! cworkspace: need   m*m [vt] + m*m [l] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cunglq( m, n, m, a, lda, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ie = 1
                    itauq = itau
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in work(il)
                    ! cworkspace: need   m*m [vt] + m*m [l] + 2*m [tauq, taup] + m      [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + 2*m [tauq, taup] + 2*m*nb [work]
                    ! rworkspace: need   m [e]
                    call stdlib_cgebrd( m, m, work( il ), ldwrkl, s, rwork( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [ru] + m*m [rvt] + bdspac
                    iru = ie + m
                    irvt = iru + m*m
                    nrwork = irvt + m*m
                    call stdlib_sbdsdc( 'U', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix work(iu)
                    ! overwrite work(iu) by the left singular vectors of l
                    ! cworkspace: need   m*m [vt] + m*m [l] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', m, m, m, work( il ), ldwrkl,work( itauq ), &
                              u, ldu, work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix work(ivt)
                    ! overwrite work(ivt) by the right singular vectors of l
                    ! cworkspace: need   m*m [vt] + m*m [l] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', m, m, rwork( irvt ), m, work( ivt ),ldwkvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', m, m, m, work( il ), ldwrkl,work( itaup ), &
                              work( ivt ), ldwkvt,work( nwork ), lwork-nwork+1, ierr )
                    ! multiply right singular vectors of l in work(il) by q
                    ! in a, storing result in work(il) and copying to a
                    ! cworkspace: need   m*m [vt] + m*m [l]
                    ! cworkspace: prefer m*m [vt] + m*n [l]
                    ! rworkspace: need   0
                    do i = 1, n, chunk
                       blk = min( n-i+1, chunk )
                       call stdlib_cgemm( 'N', 'N', m, blk, m, cone, work( ivt ), m,a( 1, i ), &
                                 lda, czero, work( il ),ldwrkl )
                       call stdlib_clacpy( 'F', m, blk, work( il ), ldwrkl,a( 1, i ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 3t (n >> m, jobz='s')
                    ! m right singular vectors to be computed in vt and
                    ! m left singular vectors to be computed in u
                    il = 1
                    ! work(il) is m by m
                    ldwrkl = m
                    itau = il + ldwrkl*m
                    nwork = itau + m
                    ! compute a=l*q
                    ! cworkspace: need   m*m [l] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [l] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! copy l to work(il), zeroing out above it
                    call stdlib_clacpy( 'L', m, m, a, lda, work( il ), ldwrkl )
                    call stdlib_claset( 'U', m-1, m-1, czero, czero,work( il+ldwrkl ), ldwrkl )
                              
                    ! generate q in a
                    ! cworkspace: need   m*m [l] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [l] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cunglq( m, n, m, a, lda, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ie = 1
                    itauq = itau
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in work(il)
                    ! cworkspace: need   m*m [l] + 2*m [tauq, taup] + m      [work]
                    ! cworkspace: prefer m*m [l] + 2*m [tauq, taup] + 2*m*nb [work]
                    ! rworkspace: need   m [e]
                    call stdlib_cgebrd( m, m, work( il ), ldwrkl, s, rwork( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [ru] + m*m [rvt] + bdspac
                    iru = ie + m
                    irvt = iru + m*m
                    nrwork = irvt + m*m
                    call stdlib_sbdsdc( 'U', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix u
                    ! overwrite u by left singular vectors of l
                    ! cworkspace: need   m*m [l] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [l] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', m, m, m, work( il ), ldwrkl,work( itauq ), &
                              u, ldu, work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by left singular vectors of l
                    ! cworkspace: need   m*m [l] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [l] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', m, m, rwork( irvt ), m, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', m, m, m, work( il ), ldwrkl,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork-nwork+1, ierr )
                    ! copy vt to work(il), multiply right singular vectors of l
                    ! in work(il) by q in a, storing result in vt
                    ! cworkspace: need   m*m [l]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'F', m, m, vt, ldvt, work( il ), ldwrkl )
                    call stdlib_cgemm( 'N', 'N', m, n, m, cone, work( il ), ldwrkl,a, lda, czero, &
                              vt, ldvt )
                 else if( wntqa ) then
                    ! path 4t (n >> m, jobz='a')
                    ! n right singular vectors to be computed in vt and
                    ! m left singular vectors to be computed in u
                    ivt = 1
                    ! work(ivt) is m by m
                    ldwkvt = m
                    itau = ivt + ldwkvt*m
                    nwork = itau + m
                    ! compute a=l*q, copying result to vt
                    ! cworkspace: need   m*m [vt] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                    ! generate q in vt
                    ! cworkspace: need   m*m [vt] + m [tau] + n    [work]
                    ! cworkspace: prefer m*m [vt] + m [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cunglq( n, n, m, vt, ldvt, work( itau ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! produce l in a, zeroing out above it
                    if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero, a( 1, 2 ),lda )
                    ie = 1
                    itauq = itau
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in a
                    ! cworkspace: need   m*m [vt] + 2*m [tauq, taup] + m      [work]
                    ! cworkspace: prefer m*m [vt] + 2*m [tauq, taup] + 2*m*nb [work]
                    ! rworkspace: need   m [e]
                    call stdlib_cgebrd( m, m, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( nwork ), lwork-nwork+1,ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [ru] + m*m [rvt] + bdspac
                    iru = ie + m
                    irvt = iru + m*m
                    nrwork = irvt + m*m
                    call stdlib_sbdsdc( 'U', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix u
                    ! overwrite u by left singular vectors of l
                    ! cworkspace: need   m*m [vt] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [vt] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', m, m, m, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix work(ivt)
                    ! overwrite work(ivt) by right singular vectors of l
                    ! cworkspace: need   m*m [vt] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [vt] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', m, m, rwork( irvt ), m, work( ivt ),ldwkvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', m, m, m, a, lda,work( itaup ), work( ivt ),&
                               ldwkvt,work( nwork ), lwork-nwork+1, ierr )
                    ! multiply right singular vectors of l in work(ivt) by
                    ! q in vt, storing result in a
                    ! cworkspace: need   m*m [vt]
                    ! rworkspace: need   0
                    call stdlib_cgemm( 'N', 'N', m, n, m, cone, work( ivt ), ldwkvt,vt, ldvt, &
                              czero, a, lda )
                    ! copy right singular vectors of a from a to vt
                    call stdlib_clacpy( 'F', m, n, a, lda, vt, ldvt )
                 end if
              else if( n>=mnthr2 ) then
                 ! mnthr2 <= n < mnthr1
                 ! path 5t (n >> m, but not as much as mnthr1)
                 ! reduce to bidiagonal form without qr decomposition, use
                 ! stdlib_cungbr and matrix multiplication to compute singular vectors
                 ie = 1
                 nrwork = ie + m
                 itauq = 1
                 itaup = itauq + m
                 nwork = itaup + m
                 ! bidiagonalize a
                 ! cworkspace: need   2*m [tauq, taup] + n        [work]
                 ! cworkspace: prefer 2*m [tauq, taup] + (m+n)*nb [work]
                 ! rworkspace: need   m [e]
                 call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 5tn (n >> m, jobz='n')
                    ! compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + bdspac
                    call stdlib_sbdsdc( 'L', 'N', m, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    ivt = nwork
                    ! path 5to (n >> m, jobz='o')
                    ! copy a to u, generate q
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_cungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! generate p**h in a
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cungbr( 'P', m, n, m, a, lda, work( itaup ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ldwkvt = m
                    if( lwork >= m*n + 3*m ) then
                       ! work( ivt ) is m by n
                       nwork = ivt + ldwkvt*n
                       chunk = n
                    else
                       ! work( ivt ) is m by chunk
                       chunk = ( lwork - 3*m ) / m
                       nwork = ivt + ldwkvt*chunk
                    end if
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    call stdlib_sbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply q in u by realmatrix rwork(irvt,KIND=sp)
                    ! storing the result in work(ivt), copying to u
                    ! cworkspace: need   2*m [tauq, taup] + m*m [vt]
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + 2*m*m [rwork]
                    call stdlib_clacrm( m, m, u, ldu, rwork( iru ), m, work( ivt ),ldwkvt, rwork( &
                              nrwork ) )
                    call stdlib_clacpy( 'F', m, m, work( ivt ), ldwkvt, u, ldu )
                    ! multiply rwork(irvt) by p**h in a, storing the
                    ! result in work(ivt), copying to a
                    ! cworkspace: need   2*m [tauq, taup] + m*m [vt]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*n [vt]
                    ! rworkspace: need   m [e] + m*m [rvt] + 2*m*m [rwork]
                    ! rworkspace: prefer m [e] + m*m [rvt] + 2*m*n [rwork] < m + 5*m*m since n < 2*m here
                    nrwork = iru
                    do i = 1, n, chunk
                       blk = min( n-i+1, chunk )
                       call stdlib_clarcm( m, blk, rwork( irvt ), m, a( 1, i ), lda,work( ivt ), &
                                 ldwkvt, rwork( nrwork ) )
                       call stdlib_clacpy( 'F', m, blk, work( ivt ), ldwkvt,a( 1, i ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 5ts (n >> m, jobz='s')
                    ! copy a to u, generate q
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_cungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                    call stdlib_cungbr( 'P', m, n, m, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_sbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply q in u by realmatrix rwork(iru,KIND=sp), storing the
                    ! result in a, copying to u
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + 2*m*m [rwork]
                    call stdlib_clacrm( m, m, u, ldu, rwork( iru ), m, a, lda,rwork( nrwork ) )
                              
                    call stdlib_clacpy( 'F', m, m, a, lda, u, ldu )
                    ! multiply realmatrix rwork(irvt,KIND=sp) by p**h in vt,
                    ! storing the result in a, copying to vt
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + 2*m*n [rwork] < m + 5*m*m since n < 2*m here
                    nrwork = iru
                    call stdlib_clarcm( m, n, rwork( irvt ), m, vt, ldvt, a, lda,rwork( nrwork ) )
                              
                    call stdlib_clacpy( 'F', m, n, a, lda, vt, ldvt )
                 else
                    ! path 5ta (n >> m, jobz='a')
                    ! copy a to u, generate q
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_cungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*m [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                    call stdlib_cungbr( 'P', n, n, m, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_sbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply q in u by realmatrix rwork(iru,KIND=sp), storing the
                    ! result in a, copying to u
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + 2*m*m [rwork]
                    call stdlib_clacrm( m, m, u, ldu, rwork( iru ), m, a, lda,rwork( nrwork ) )
                              
                    call stdlib_clacpy( 'F', m, m, a, lda, u, ldu )
                    ! multiply realmatrix rwork(irvt,KIND=sp) by p**h in vt,
                    ! storing the result in a, copying to vt
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + 2*m*n [rwork] < m + 5*m*m since n < 2*m here
                    nrwork = iru
                    call stdlib_clarcm( m, n, rwork( irvt ), m, vt, ldvt, a, lda,rwork( nrwork ) )
                              
                    call stdlib_clacpy( 'F', m, n, a, lda, vt, ldvt )
                 end if
              else
                 ! n < mnthr2
                 ! path 6t (n > m, but not much larger)
                 ! reduce to bidiagonal form without lq decomposition
                 ! use stdlib_cunmbr to compute singular vectors
                 ie = 1
                 nrwork = ie + m
                 itauq = 1
                 itaup = itauq + m
                 nwork = itaup + m
                 ! bidiagonalize a
                 ! cworkspace: need   2*m [tauq, taup] + n        [work]
                 ! cworkspace: prefer 2*m [tauq, taup] + (m+n)*nb [work]
                 ! rworkspace: need   m [e]
                 call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 6tn (n > m, jobz='n')
                    ! compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + bdspac
                    call stdlib_sbdsdc( 'L', 'N', m, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 6to (n > m, jobz='o')
                    ldwkvt = m
                    ivt = nwork
                    if( lwork >= m*n + 3*m ) then
                       ! work( ivt ) is m by n
                       call stdlib_claset( 'F', m, n, czero, czero, work( ivt ),ldwkvt )
                       nwork = ivt + ldwkvt*n
                    else
                       ! work( ivt ) is m by chunk
                       chunk = ( lwork - 3*m ) / m
                       nwork = ivt + ldwkvt*chunk
                    end if
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_sbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + m*m [vt] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*m [vt] + m*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru]
                    call stdlib_clacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    if( lwork >= m*n + 3*m ) then
                       ! path 6to-fast
                       ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix work(ivt)
                       ! overwrite work(ivt) by right singular vectors of a,
                       ! copying to a
                       ! cworkspace: need   2*m [tauq, taup] + m*n [vt] + m    [work]
                       ! cworkspace: prefer 2*m [tauq, taup] + m*n [vt] + m*nb [work]
                       ! rworkspace: need   m [e] + m*m [rvt]
                       call stdlib_clacp2( 'F', m, m, rwork( irvt ), m, work( ivt ),ldwkvt )
                                 
                       call stdlib_cunmbr( 'P', 'R', 'C', m, n, m, a, lda,work( itaup ), work( &
                                 ivt ), ldwkvt,work( nwork ), lwork-nwork+1, ierr )
                       call stdlib_clacpy( 'F', m, n, work( ivt ), ldwkvt, a, lda )
                    else
                       ! path 6to-slow
                       ! generate p**h in a
                       ! cworkspace: need   2*m [tauq, taup] + m*m [vt] + m    [work]
                       ! cworkspace: prefer 2*m [tauq, taup] + m*m [vt] + m*nb [work]
                       ! rworkspace: need   0
                       call stdlib_cungbr( 'P', m, n, m, a, lda, work( itaup ),work( nwork ), &
                                 lwork-nwork+1, ierr )
                       ! multiply q in a by realmatrix rwork(iru,KIND=sp), storing the
                       ! result in work(iu), copying to a
                       ! cworkspace: need   2*m [tauq, taup] + m*m [vt]
                       ! cworkspace: prefer 2*m [tauq, taup] + m*n [vt]
                       ! rworkspace: need   m [e] + m*m [rvt] + 2*m*m [rwork]
                       ! rworkspace: prefer m [e] + m*m [rvt] + 2*m*n [rwork] < m + 5*m*m since n < 2*m here
                       nrwork = iru
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_clarcm( m, blk, rwork( irvt ), m, a( 1, i ),lda, work( ivt )&
                                    , ldwkvt,rwork( nrwork ) )
                          call stdlib_clacpy( 'F', m, blk, work( ivt ), ldwkvt,a( 1, i ), lda )
                                    
                       end do
                    end if
                 else if( wntqs ) then
                    ! path 6ts (n > m, jobz='s')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_sbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru]
                    call stdlib_clacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt]
                    call stdlib_claset( 'F', m, n, czero, czero, vt, ldvt )
                    call stdlib_clacp2( 'F', m, m, rwork( irvt ), m, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', m, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                 else
                    ! path 6ta (n > m, jobz='a')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_sbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru]
                    call stdlib_clacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! set all of vt to identity matrix
                    call stdlib_claset( 'F', n, n, czero, cone, vt, ldvt )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + n*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt]
                    call stdlib_clacp2( 'F', m, m, rwork( irvt ), m, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', n, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                 end if
              end if
           end if
           ! undo scaling if necessary
           if( iscl==1 ) then
              if( anrm>bignum )call stdlib_slascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm>bignum )call stdlib_slascl( 'G', 0, 0, bignum, anrm, minmn-1,&
                         1,rwork( ie ), minmn, ierr )
              if( anrm<smlnum )call stdlib_slascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm<smlnum )call stdlib_slascl( 'G', 0, 0, smlnum, anrm, minmn-1,&
                         1,rwork( ie ), minmn, ierr )
           end if
           ! return optimal workspace in work(1)
           work( 1 ) = stdlib_sroundup_lwork( maxwrk )
           return
     end subroutine stdlib_cgesdd


     pure subroutine stdlib_cgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
     !! CGESV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
     !! The LU decomposition with partial pivoting and row interchanges is
     !! used to factor A as
     !! A = P * L * U,
     !! where P is a permutation matrix, L is unit lower triangular, and U is
     !! upper triangular.  The factored form of A is then used to solve the
     !! system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( nrhs<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGESV ', -info )
              return
           end if
           ! compute the lu factorization of a.
           call stdlib_cgetrf( n, n, a, lda, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_cgetrs( 'NO TRANSPOSE', n, nrhs, a, lda, ipiv, b, ldb,info )
           end if
           return
     end subroutine stdlib_cgesv


     subroutine stdlib_cgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, rwork, &
     !! CGESVD computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, optionally computing the left and/or right singular
     !! vectors. The SVD is written
     !! A = U * SIGMA * conjugate-transpose(V)
     !! where SIGMA is an M-by-N matrix which is zero except for its
     !! min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
     !! V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
     !! are the singular values of A; they are real and non-negative, and
     !! are returned in descending order.  The first min(m,n) columns of
     !! U and V are the left and right singular vectors of A.
     !! Note that the routine returns V**H, not V.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobu, jobvt
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldvt, lwork, m, n
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*), s(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery, wntua, wntuas, wntun, wntuo, wntus, wntva, wntvas, wntvn, wntvo,&
                      wntvs
           integer(ilp) :: blk, chunk, i, ie, ierr, ir, irwork, iscl, itau, itaup, itauq, iu, &
           iwork, ldwrkr, ldwrku, maxwrk, minmn, minwrk, mnthr, ncu, ncvt, nru, nrvt, &
                     wrkbl
           integer(ilp) :: lwork_cgeqrf, lwork_cungqr_n, lwork_cungqr_m, lwork_cgebrd, &
                     lwork_cungbr_p, lwork_cungbr_q, lwork_cgelqf, lwork_cunglq_n, lwork_cunglq_m
           real(sp) :: anrm, bignum, eps, smlnum
           ! Local Arrays 
           real(sp) :: dum(1)
           complex(sp) :: cdum(1)
           ! Intrinsic Functions 
           intrinsic :: max,min,sqrt
           ! Executable Statements 
           ! test the input arguments
           info = 0
           minmn = min( m, n )
           wntua = stdlib_lsame( jobu, 'A' )
           wntus = stdlib_lsame( jobu, 'S' )
           wntuas = wntua .or. wntus
           wntuo = stdlib_lsame( jobu, 'O' )
           wntun = stdlib_lsame( jobu, 'N' )
           wntva = stdlib_lsame( jobvt, 'A' )
           wntvs = stdlib_lsame( jobvt, 'S' )
           wntvas = wntva .or. wntvs
           wntvo = stdlib_lsame( jobvt, 'O' )
           wntvn = stdlib_lsame( jobvt, 'N' )
           lquery = ( lwork==-1 )
           if( .not.( wntua .or. wntus .or. wntuo .or. wntun ) ) then
              info = -1
           else if( .not.( wntva .or. wntvs .or. wntvo .or. wntvn ) .or.( wntvo .and. wntuo ) ) &
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldu<1 .or. ( wntuas .and. ldu<m ) ) then
              info = -9
           else if( ldvt<1 .or. ( wntva .and. ldvt<n ) .or.( wntvs .and. ldvt<minmn ) ) &
                     then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to
             ! real workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              if( m>=n .and. minmn>0 ) then
                 ! space needed for stdlib_zbdsqr is bdspac = 5*n
                 mnthr = stdlib_ilaenv( 6, 'CGESVD', jobu // jobvt, m, n, 0, 0 )
                 ! compute space needed for stdlib_cgeqrf
                 call stdlib_cgeqrf( m, n, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_cgeqrf = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_cungqr
                 call stdlib_cungqr( m, n, n, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_cungqr_n = int( cdum(1),KIND=ilp)
                 call stdlib_cungqr( m, m, n, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_cungqr_m = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_cgebrd
                 call stdlib_cgebrd( n, n, a, lda, s, dum(1), cdum(1),cdum(1), cdum(1), -1, ierr )
                           
                 lwork_cgebrd = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_cungbr
                 call stdlib_cungbr( 'P', n, n, n, a, lda, cdum(1),cdum(1), -1, ierr )
                 lwork_cungbr_p = int( cdum(1),KIND=ilp)
                 call stdlib_cungbr( 'Q', n, n, n, a, lda, cdum(1),cdum(1), -1, ierr )
                 lwork_cungbr_q = int( cdum(1),KIND=ilp)
                 mnthr = stdlib_ilaenv( 6, 'CGESVD', jobu // jobvt, m, n, 0, 0 )
                 if( m>=mnthr ) then
                    if( wntun ) then
                       ! path 1 (m much larger than n, jobu='n')
                       maxwrk = n + lwork_cgeqrf
                       maxwrk = max( maxwrk, 2*n+lwork_cgebrd )
                       if( wntvo .or. wntvas )maxwrk = max( maxwrk, 2*n+lwork_cungbr_p )
                       minwrk = 3*n
                    else if( wntuo .and. wntvn ) then
                       ! path 2 (m much larger than n, jobu='o', jobvt='n')
                       wrkbl = n + lwork_cgeqrf
                       wrkbl = max( wrkbl, n+lwork_cungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_q )
                       maxwrk = max( n*n+wrkbl, n*n+m*n )
                       minwrk = 2*n + m
                    else if( wntuo .and. wntvas ) then
                       ! path 3 (m much larger than n, jobu='o', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_cgeqrf
                       wrkbl = max( wrkbl, n+lwork_cungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_p )
                       maxwrk = max( n*n+wrkbl, n*n+m*n )
                       minwrk = 2*n + m
                    else if( wntus .and. wntvn ) then
                       ! path 4 (m much larger than n, jobu='s', jobvt='n')
                       wrkbl = n + lwork_cgeqrf
                       wrkbl = max( wrkbl, n+lwork_cungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_q )
                       maxwrk = n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntus .and. wntvo ) then
                       ! path 5 (m much larger than n, jobu='s', jobvt='o')
                       wrkbl = n + lwork_cgeqrf
                       wrkbl = max( wrkbl, n+lwork_cungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_p )
                       maxwrk = 2*n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntus .and. wntvas ) then
                       ! path 6 (m much larger than n, jobu='s', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_cgeqrf
                       wrkbl = max( wrkbl, n+lwork_cungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_p )
                       maxwrk = n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntua .and. wntvn ) then
                       ! path 7 (m much larger than n, jobu='a', jobvt='n')
                       wrkbl = n + lwork_cgeqrf
                       wrkbl = max( wrkbl, n+lwork_cungqr_m )
                       wrkbl = max( wrkbl, 2*n+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_q )
                       maxwrk = n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntua .and. wntvo ) then
                       ! path 8 (m much larger than n, jobu='a', jobvt='o')
                       wrkbl = n + lwork_cgeqrf
                       wrkbl = max( wrkbl, n+lwork_cungqr_m )
                       wrkbl = max( wrkbl, 2*n+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_p )
                       maxwrk = 2*n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntua .and. wntvas ) then
                       ! path 9 (m much larger than n, jobu='a', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_cgeqrf
                       wrkbl = max( wrkbl, n+lwork_cungqr_m )
                       wrkbl = max( wrkbl, 2*n+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_p )
                       maxwrk = n*n + wrkbl
                       minwrk = 2*n + m
                    end if
                 else
                    ! path 10 (m at least n, but not much larger)
                    call stdlib_cgebrd( m, n, a, lda, s, dum(1), cdum(1),cdum(1), cdum(1), -1, &
                              ierr )
                    lwork_cgebrd = int( cdum(1),KIND=ilp)
                    maxwrk = 2*n + lwork_cgebrd
                    if( wntus .or. wntuo ) then
                       call stdlib_cungbr( 'Q', m, n, n, a, lda, cdum(1),cdum(1), -1, ierr )
                                 
                       lwork_cungbr_q = int( cdum(1),KIND=ilp)
                       maxwrk = max( maxwrk, 2*n+lwork_cungbr_q )
                    end if
                    if( wntua ) then
                       call stdlib_cungbr( 'Q', m, m, n, a, lda, cdum(1),cdum(1), -1, ierr )
                                 
                       lwork_cungbr_q = int( cdum(1),KIND=ilp)
                       maxwrk = max( maxwrk, 2*n+lwork_cungbr_q )
                    end if
                    if( .not.wntvn ) then
                       maxwrk = max( maxwrk, 2*n+lwork_cungbr_p )
                    end if
                    minwrk = 2*n + m
                 end if
              else if( minmn>0 ) then
                 ! space needed for stdlib_cbdsqr is bdspac = 5*m
                 mnthr = stdlib_ilaenv( 6, 'CGESVD', jobu // jobvt, m, n, 0, 0 )
                 ! compute space needed for stdlib_cgelqf
                 call stdlib_cgelqf( m, n, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_cgelqf = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_cunglq
                 call stdlib_cunglq( n, n, m, cdum(1), n, cdum(1), cdum(1), -1,ierr )
                 lwork_cunglq_n = int( cdum(1),KIND=ilp)
                 call stdlib_cunglq( m, n, m, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_cunglq_m = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_cgebrd
                 call stdlib_cgebrd( m, m, a, lda, s, dum(1), cdum(1),cdum(1), cdum(1), -1, ierr )
                           
                 lwork_cgebrd = int( cdum(1),KIND=ilp)
                  ! compute space needed for stdlib_cungbr p
                 call stdlib_cungbr( 'P', m, m, m, a, n, cdum(1),cdum(1), -1, ierr )
                 lwork_cungbr_p = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_cungbr q
                 call stdlib_cungbr( 'Q', m, m, m, a, n, cdum(1),cdum(1), -1, ierr )
                 lwork_cungbr_q = int( cdum(1),KIND=ilp)
                 if( n>=mnthr ) then
                    if( wntvn ) then
                       ! path 1t(n much larger than m, jobvt='n')
                       maxwrk = m + lwork_cgelqf
                       maxwrk = max( maxwrk, 2*m+lwork_cgebrd )
                       if( wntuo .or. wntuas )maxwrk = max( maxwrk, 2*m+lwork_cungbr_q )
                       minwrk = 3*m
                    else if( wntvo .and. wntun ) then
                       ! path 2t(n much larger than m, jobu='n', jobvt='o')
                       wrkbl = m + lwork_cgelqf
                       wrkbl = max( wrkbl, m+lwork_cunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_p )
                       maxwrk = max( m*m+wrkbl, m*m+m*n )
                       minwrk = 2*m + n
                    else if( wntvo .and. wntuas ) then
                       ! path 3t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='o')
                       wrkbl = m + lwork_cgelqf
                       wrkbl = max( wrkbl, m+lwork_cunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_q )
                       maxwrk = max( m*m+wrkbl, m*m+m*n )
                       minwrk = 2*m + n
                    else if( wntvs .and. wntun ) then
                       ! path 4t(n much larger than m, jobu='n', jobvt='s')
                       wrkbl = m + lwork_cgelqf
                       wrkbl = max( wrkbl, m+lwork_cunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_p )
                       maxwrk = m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntvs .and. wntuo ) then
                       ! path 5t(n much larger than m, jobu='o', jobvt='s')
                       wrkbl = m + lwork_cgelqf
                       wrkbl = max( wrkbl, m+lwork_cunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_q )
                       maxwrk = 2*m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntvs .and. wntuas ) then
                       ! path 6t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='s')
                       wrkbl = m + lwork_cgelqf
                       wrkbl = max( wrkbl, m+lwork_cunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_q )
                       maxwrk = m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntva .and. wntun ) then
                       ! path 7t(n much larger than m, jobu='n', jobvt='a')
                       wrkbl = m + lwork_cgelqf
                       wrkbl = max( wrkbl, m+lwork_cunglq_n )
                       wrkbl = max( wrkbl, 2*m+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_p )
                       maxwrk = m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntva .and. wntuo ) then
                       ! path 8t(n much larger than m, jobu='o', jobvt='a')
                       wrkbl = m + lwork_cgelqf
                       wrkbl = max( wrkbl, m+lwork_cunglq_n )
                       wrkbl = max( wrkbl, 2*m+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_q )
                       maxwrk = 2*m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntva .and. wntuas ) then
                       ! path 9t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='a')
                       wrkbl = m + lwork_cgelqf
                       wrkbl = max( wrkbl, m+lwork_cunglq_n )
                       wrkbl = max( wrkbl, 2*m+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_q )
                       maxwrk = m*m + wrkbl
                       minwrk = 2*m + n
                    end if
                 else
                    ! path 10t(n greater than m, but not much larger)
                    call stdlib_cgebrd( m, n, a, lda, s, dum(1), cdum(1),cdum(1), cdum(1), -1, &
                              ierr )
                    lwork_cgebrd = int( cdum(1),KIND=ilp)
                    maxwrk = 2*m + lwork_cgebrd
                    if( wntvs .or. wntvo ) then
                      ! compute space needed for stdlib_cungbr p
                      call stdlib_cungbr( 'P', m, n, m, a, n, cdum(1),cdum(1), -1, ierr )
                      lwork_cungbr_p = int( cdum(1),KIND=ilp)
                      maxwrk = max( maxwrk, 2*m+lwork_cungbr_p )
                    end if
                    if( wntva ) then
                      call stdlib_cungbr( 'P', n,  n, m, a, n, cdum(1),cdum(1), -1, ierr )
                      lwork_cungbr_p = int( cdum(1),KIND=ilp)
                      maxwrk = max( maxwrk, 2*m+lwork_cungbr_p )
                    end if
                    if( .not.wntun ) then
                       maxwrk = max( maxwrk, 2*m+lwork_cungbr_q )
                    end if
                    minwrk = 2*m + n
                 end if
              end if
              maxwrk = max( minwrk, maxwrk )
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGESVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = sqrt( stdlib_slamch( 'S' ) ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', m, n, a, lda, dum )
           iscl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              iscl = 1
              call stdlib_clascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, ierr )
           else if( anrm>bignum ) then
              iscl = 1
              call stdlib_clascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, ierr )
           end if
           if( m>=n ) then
              ! a has at least as many rows as columns. if a has sufficiently
              ! more rows than columns, first reduce using the qr
              ! decomposition (if sufficient workspace available)
              if( m>=mnthr ) then
                 if( wntun ) then
                    ! path 1 (m much larger than n, jobu='n')
                    ! no left singular vectors to be computed
                    itau = 1
                    iwork = itau + n
                    ! compute a=q*r
                    ! (cworkspace: need 2*n, prefer n+n*nb)
                    ! (rworkspace: need 0)
                    call stdlib_cgeqrf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                              ierr )
                    ! zero out below r
                    if( n > 1 ) then
                       call stdlib_claset( 'L', n-1, n-1, czero, czero, a( 2, 1 ),lda )
                    end if
                    ie = 1
                    itauq = 1
                    itaup = itauq + n
                    iwork = itaup + n
                    ! bidiagonalize r in a
                    ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                    ! (rworkspace: need n)
                    call stdlib_cgebrd( n, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( iwork ), lwork-iwork+1,ierr )
                    ncvt = 0
                    if( wntvo .or. wntvas ) then
                       ! if right singular vectors desired, generate p'.
                       ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       ncvt = n
                    end if
                    irwork = ie + n
                    ! perform bidiagonal qr iteration, computing right
                    ! singular vectors of a in a if desired
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_cbdsqr( 'U', n, ncvt, 0, 0, s, rwork( ie ), a, lda,cdum, 1, cdum, &
                              1, rwork( irwork ), info )
                    ! if right singular vectors desired in vt, copy them there
                    if( wntvas )call stdlib_clacpy( 'F', n, n, a, lda, vt, ldvt )
                 else if( wntuo .and. wntvn ) then
                    ! path 2 (m much larger than n, jobu='o', jobvt='n')
                    ! n left singular vectors to be overwritten on a and
                    ! no right singular vectors to be computed
                    if( lwork>=n*n+3*n ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n )+lda*n ) then
                          ! work(iu) is lda by n, work(ir) is lda by n
                          ldwrku = lda
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n )+n*n ) then
                          ! work(iu) is lda by n, work(ir) is n by n
                          ldwrku = lda
                          ldwrkr = n
                       else
                          ! work(iu) is ldwrku by n, work(ir) is n by n
                          ldwrku = ( lwork-n*n ) / n
                          ldwrkr = n
                       end if
                       itau = ir + ldwrkr*n
                       iwork = itau + n
                       ! compute a=q*r
                       ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to work(ir) and zero out below it
                       call stdlib_clacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                       call stdlib_claset( 'L', n-1, n-1, czero, czero,work( ir+1 ), ldwrkr )
                                 
                       ! generate q in a
                       ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in work(ir)
                       ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                       ! (rworkspace: need n)
                       call stdlib_cgebrd( n, n, work( ir ), ldwrkr, s, rwork( ie ),work( itauq ),&
                                  work( itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing r
                       ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                       ! (rworkspace: need 0)
                       call stdlib_cungbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       irwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of r in work(ir)
                       ! (cworkspace: need n*n)
                       ! (rworkspace: need bdspac)
                       call stdlib_cbdsqr( 'U', n, 0, n, 0, s, rwork( ie ), cdum, 1,work( ir ), &
                                 ldwrkr, cdum, 1,rwork( irwork ), info )
                       iu = itauq
                       ! multiply q in a by left singular vectors of r in
                       ! work(ir), storing result in work(iu) and copying to a
                       ! (cworkspace: need n*n+n, prefer n*n+m*n)
                       ! (rworkspace: 0)
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_cgemm( 'N', 'N', chunk, n, n, cone, a( i, 1 ),lda, work( ir &
                                    ), ldwrkr, czero,work( iu ), ldwrku )
                          call stdlib_clacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       ie = 1
                       itauq = 1
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize a
                       ! (cworkspace: need 2*n+m, prefer 2*n+(m+n)*nb)
                       ! (rworkspace: n)
                       call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing a
                       ! (cworkspace: need 3*n, prefer 2*n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'Q', m, n, n, a, lda, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in a
                       ! (cworkspace: need 0)
                       ! (rworkspace: need bdspac)
                       call stdlib_cbdsqr( 'U', n, 0, m, 0, s, rwork( ie ), cdum, 1,a, lda, cdum, &
                                 1, rwork( irwork ), info )
                    end if
                 else if( wntuo .and. wntvas ) then
                    ! path 3 (m much larger than n, jobu='o', jobvt='s' or 'a')
                    ! n left singular vectors to be overwritten on a and
                    ! n right singular vectors to be computed in vt
                    if( lwork>=n*n+3*n ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n )+lda*n ) then
                          ! work(iu) is lda by n and work(ir) is lda by n
                          ldwrku = lda
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n )+n*n ) then
                          ! work(iu) is lda by n and work(ir) is n by n
                          ldwrku = lda
                          ldwrkr = n
                       else
                          ! work(iu) is ldwrku by n and work(ir) is n by n
                          ldwrku = ( lwork-n*n ) / n
                          ldwrkr = n
                       end if
                       itau = ir + ldwrkr*n
                       iwork = itau + n
                       ! compute a=q*r
                       ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to vt, zeroing out below it
                       call stdlib_clacpy( 'U', n, n, a, lda, vt, ldvt )
                       if( n>1 )call stdlib_claset( 'L', n-1, n-1, czero, czero,vt( 2, 1 ), ldvt )
                                 
                       ! generate q in a
                       ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in vt, copying result to work(ir)
                       ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                       ! (rworkspace: need n)
                       call stdlib_cgebrd( n, n, vt, ldvt, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       call stdlib_clacpy( 'L', n, n, vt, ldvt, work( ir ), ldwrkr )
                       ! generate left vectors bidiagonalizing r in work(ir)
                       ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing r in vt
                       ! (cworkspace: need n*n+3*n-1, prefer n*n+2*n+(n-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of r in work(ir) and computing right
                       ! singular vectors of r in vt
                       ! (cworkspace: need n*n)
                       ! (rworkspace: need bdspac)
                       call stdlib_cbdsqr( 'U', n, n, n, 0, s, rwork( ie ), vt,ldvt, work( ir ), &
                                 ldwrkr, cdum, 1,rwork( irwork ), info )
                       iu = itauq
                       ! multiply q in a by left singular vectors of r in
                       ! work(ir), storing result in work(iu) and copying to a
                       ! (cworkspace: need n*n+n, prefer n*n+m*n)
                       ! (rworkspace: 0)
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_cgemm( 'N', 'N', chunk, n, n, cone, a( i, 1 ),lda, work( ir &
                                    ), ldwrkr, czero,work( iu ), ldwrku )
                          call stdlib_clacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       itau = 1
                       iwork = itau + n
                       ! compute a=q*r
                       ! (cworkspace: need 2*n, prefer n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to vt, zeroing out below it
                       call stdlib_clacpy( 'U', n, n, a, lda, vt, ldvt )
                       if( n>1 )call stdlib_claset( 'L', n-1, n-1, czero, czero,vt( 2, 1 ), ldvt )
                                 
                       ! generate q in a
                       ! (cworkspace: need 2*n, prefer n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in vt
                       ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                       ! (rworkspace: n)
                       call stdlib_cgebrd( n, n, vt, ldvt, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! multiply q in a by left vectors bidiagonalizing r
                       ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cunmbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), a, lda,&
                                  work( iwork ),lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing r in vt
                       ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in a and computing right
                       ! singular vectors of a in vt
                       ! (cworkspace: 0)
                       ! (rworkspace: need bdspac)
                       call stdlib_cbdsqr( 'U', n, n, m, 0, s, rwork( ie ), vt,ldvt, a, lda, cdum,&
                                  1, rwork( irwork ),info )
                    end if
                 else if( wntus ) then
                    if( wntvn ) then
                       ! path 4 (m much larger than n, jobu='s', jobvt='n')
                       ! n left singular vectors to be computed in u and
                       ! no right singular vectors to be computed
                       if( lwork>=n*n+3*n ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(ir) is lda by n
                             ldwrkr = lda
                          else
                             ! work(ir) is n by n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(ir), zeroing out below it
                          call stdlib_clacpy( 'U', n, n, a, lda, work( ir ),ldwrkr )
                          call stdlib_claset( 'L', n-1, n-1, czero, czero,work( ir+1 ), ldwrkr )
                                    
                          ! generate q in a
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(ir)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, work( ir ), ldwrkr, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate left vectors bidiagonalizing r in work(ir)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(ir)
                          ! (cworkspace: need n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, 0, n, 0, s, rwork( ie ), cdum,1, work( ir ),&
                                     ldwrkr, cdum, 1,rwork( irwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(ir), storing result in u
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, n, cone, a, lda,work( ir ), ldwrkr, &
                                    czero, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_claset( 'L', n-1, n-1, czero, czero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left vectors bidiagonalizing r
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, 0, m, 0, s, rwork( ie ), cdum,1, u, ldu, &
                                    cdum, 1, rwork( irwork ),info )
                       end if
                    else if( wntvo ) then
                       ! path 5 (m much larger than n, jobu='s', jobvt='o')
                       ! n left singular vectors to be computed in u and
                       ! n right singular vectors to be overwritten on a
                       if( lwork>=2*n*n+3*n ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*n ) then
                             ! work(iu) is lda by n and work(ir) is lda by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+n )*n ) then
                             ! work(iu) is lda by n and work(ir) is n by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          else
                             ! work(iu) is n by n and work(ir) is n by n
                             ldwrku = n
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (cworkspace: need 2*n*n+2*n, prefer 2*n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_clacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_claset( 'L', n-1, n-1, czero, czero,work( iu+1 ), ldwrku )
                                    
                          ! generate q in a
                          ! (cworkspace: need 2*n*n+2*n, prefer 2*n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to
                          ! work(ir)
                          ! (cworkspace: need   2*n*n+3*n,
                                       ! prefer 2*n*n+2*n+2*n*nb)
                          ! (rworkspace: need   n)
                          call stdlib_cgebrd( n, n, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_clacpy( 'U', n, n, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need 2*n*n+3*n, prefer 2*n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need   2*n*n+3*n-1,
                                       ! prefer 2*n*n+2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in work(ir)
                          ! (cworkspace: need 2*n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, n, n, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                    work( iu ),ldwrku, cdum, 1, rwork( irwork ),info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(iu), storing result in u
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, n, cone, a, lda,work( iu ), ldwrku, &
                                    czero, u, ldu )
                          ! copy right singular vectors of r to a
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_clacpy( 'F', n, n, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_claset( 'L', n-1, n-1, czero, czero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left vectors bidiagonalizing r
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right vectors bidiagonalizing r in a
                          ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in a
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, n, m, 0, s, rwork( ie ), a,lda, u, ldu, &
                                    cdum, 1, rwork( irwork ),info )
                       end if
                    else if( wntvas ) then
                       ! path 6 (m much larger than n, jobu='s', jobvt='s'
                               ! or 'a')
                       ! n left singular vectors to be computed in u and
                       ! n right singular vectors to be computed in vt
                       if( lwork>=n*n+3*n ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is n by n
                             ldwrku = n
                          end if
                          itau = iu + ldwrku*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_clacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_claset( 'L', n-1, n-1, czero, czero,work( iu+1 ), ldwrku )
                                    
                          ! generate q in a
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to vt
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_clacpy( 'U', n, n, work( iu ), ldwrku, vt,ldvt )
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (cworkspace: need   n*n+3*n-1,
                                       ! prefer n*n+2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in vt
                          ! (cworkspace: need n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, n, n, 0, s, rwork( ie ), vt,ldvt, work( iu )&
                                    , ldwrku, cdum, 1,rwork( irwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(iu), storing result in u
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, n, cone, a, lda,work( iu ), ldwrku, &
                                    czero, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to vt, zeroing out below it
                          call stdlib_clacpy( 'U', n, n, a, lda, vt, ldvt )
                          if( n>1 )call stdlib_claset( 'L', n-1, n-1, czero, czero,vt( 2, 1 ), &
                                    ldvt )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in vt
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, vt, ldvt, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in vt
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, n, m, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    end if
                 else if( wntua ) then
                    if( wntvn ) then
                       ! path 7 (m much larger than n, jobu='a', jobvt='n')
                       ! m left singular vectors to be computed in u and
                       ! no right singular vectors to be computed
                       if( lwork>=n*n+max( n+m, 3*n ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(ir) is lda by n
                             ldwrkr = lda
                          else
                             ! work(ir) is n by n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! copy r to work(ir), zeroing out below it
                          call stdlib_clacpy( 'U', n, n, a, lda, work( ir ),ldwrkr )
                          call stdlib_claset( 'L', n-1, n-1, czero, czero,work( ir+1 ), ldwrkr )
                                    
                          ! generate q in u
                          ! (cworkspace: need n*n+n+m, prefer n*n+n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(ir)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, work( ir ), ldwrkr, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(ir)
                          ! (cworkspace: need n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, 0, n, 0, s, rwork( ie ), cdum,1, work( ir ),&
                                     ldwrkr, cdum, 1,rwork( irwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(ir), storing result in a
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, n, cone, u, ldu,work( ir ), ldwrkr, &
                                    czero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_clacpy( 'F', m, n, a, lda, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need n+m, prefer n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_claset( 'L', n-1, n-1, czero, czero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in a
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, 0, m, 0, s, rwork( ie ), cdum,1, u, ldu, &
                                    cdum, 1, rwork( irwork ),info )
                       end if
                    else if( wntvo ) then
                       ! path 8 (m much larger than n, jobu='a', jobvt='o')
                       ! m left singular vectors to be computed in u and
                       ! n right singular vectors to be overwritten on a
                       if( lwork>=2*n*n+max( n+m, 3*n ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*n ) then
                             ! work(iu) is lda by n and work(ir) is lda by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+n )*n ) then
                             ! work(iu) is lda by n and work(ir) is n by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          else
                             ! work(iu) is n by n and work(ir) is n by n
                             ldwrku = n
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n*n+2*n, prefer 2*n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need 2*n*n+n+m, prefer 2*n*n+n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_clacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_claset( 'L', n-1, n-1, czero, czero,work( iu+1 ), ldwrku )
                                    
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to
                          ! work(ir)
                          ! (cworkspace: need   2*n*n+3*n,
                                       ! prefer 2*n*n+2*n+2*n*nb)
                          ! (rworkspace: need   n)
                          call stdlib_cgebrd( n, n, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_clacpy( 'U', n, n, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need 2*n*n+3*n, prefer 2*n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need   2*n*n+3*n-1,
                                       ! prefer 2*n*n+2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in work(ir)
                          ! (cworkspace: need 2*n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, n, n, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                    work( iu ),ldwrku, cdum, 1, rwork( irwork ),info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(iu), storing result in a
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, n, cone, u, ldu,work( iu ), ldwrku, &
                                    czero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_clacpy( 'F', m, n, a, lda, u, ldu )
                          ! copy right singular vectors of r from work(ir) to a
                          call stdlib_clacpy( 'F', n, n, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need n+m, prefer n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_claset( 'L', n-1, n-1, czero, czero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in a
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in a
                          ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in a
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, n, m, 0, s, rwork( ie ), a,lda, u, ldu, &
                                    cdum, 1, rwork( irwork ),info )
                       end if
                    else if( wntvas ) then
                       ! path 9 (m much larger than n, jobu='a', jobvt='s'
                               ! or 'a')
                       ! m left singular vectors to be computed in u and
                       ! n right singular vectors to be computed in vt
                       if( lwork>=n*n+max( n+m, 3*n ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is n by n
                             ldwrku = n
                          end if
                          itau = iu + ldwrku*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need n*n+n+m, prefer n*n+n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_clacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_claset( 'L', n-1, n-1, czero, czero,work( iu+1 ), ldwrku )
                                    
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to vt
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_clacpy( 'U', n, n, work( iu ), ldwrku, vt,ldvt )
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (cworkspace: need   n*n+3*n-1,
                                       ! prefer n*n+2*n+(n-1)*nb)
                          ! (rworkspace: need   0)
                          call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in vt
                          ! (cworkspace: need n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, n, n, 0, s, rwork( ie ), vt,ldvt, work( iu )&
                                    , ldwrku, cdum, 1,rwork( irwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(iu), storing result in a
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, n, cone, u, ldu,work( iu ), ldwrku, &
                                    czero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_clacpy( 'F', m, n, a, lda, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need n+m, prefer n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r from a to vt, zeroing out below it
                          call stdlib_clacpy( 'U', n, n, a, lda, vt, ldvt )
                          if( n>1 )call stdlib_claset( 'L', n-1, n-1, czero, czero,vt( 2, 1 ), &
                                    ldvt )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in vt
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, vt, ldvt, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in vt
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, n, m, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    end if
                 end if
              else
                 ! m < mnthr
                 ! path 10 (m at least n, but not much larger)
                 ! reduce to bidiagonal form without qr decomposition
                 ie = 1
                 itauq = 1
                 itaup = itauq + n
                 iwork = itaup + n
                 ! bidiagonalize a
                 ! (cworkspace: need 2*n+m, prefer 2*n+(m+n)*nb)
                 ! (rworkspace: need n)
                 call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( iwork ), lwork-iwork+1,ierr )
                 if( wntuas ) then
                    ! if left singular vectors desired in u, copy result to u
                    ! and generate left bidiagonalizing vectors in u
                    ! (cworkspace: need 2*n+ncu, prefer 2*n+ncu*nb)
                    ! (rworkspace: 0)
                    call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                    if( wntus )ncu = n
                    if( wntua )ncu = m
                    call stdlib_cungbr( 'Q', m, ncu, n, u, ldu, work( itauq ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntvas ) then
                    ! if right singular vectors desired in vt, copy result to
                    ! vt and generate right bidiagonalizing vectors in vt
                    ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                    ! (rworkspace: 0)
                    call stdlib_clacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntuo ) then
                    ! if left singular vectors desired in a, generate left
                    ! bidiagonalizing vectors in a
                    ! (cworkspace: need 3*n, prefer 2*n+n*nb)
                    ! (rworkspace: 0)
                    call stdlib_cungbr( 'Q', m, n, n, a, lda, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvo ) then
                    ! if right singular vectors desired in a, generate right
                    ! bidiagonalizing vectors in a
                    ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                    ! (rworkspace: 0)
                    call stdlib_cungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 irwork = ie + n
                 if( wntuas .or. wntuo )nru = m
                 if( wntun )nru = 0
                 if( wntvas .or. wntvo )ncvt = n
                 if( wntvn )ncvt = 0
                 if( ( .not.wntuo ) .and. ( .not.wntvo ) ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in vt
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_cbdsqr( 'U', n, ncvt, nru, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                              cdum, 1, rwork( irwork ),info )
                 else if( ( .not.wntuo ) .and. wntvo ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in a
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_cbdsqr( 'U', n, ncvt, nru, 0, s, rwork( ie ), a,lda, u, ldu, cdum,&
                               1, rwork( irwork ),info )
                 else
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in a and computing right singular
                    ! vectors in vt
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_cbdsqr( 'U', n, ncvt, nru, 0, s, rwork( ie ), vt,ldvt, a, lda, &
                              cdum, 1, rwork( irwork ),info )
                 end if
              end if
           else
              ! a has more columns than rows. if a has sufficiently more
              ! columns than rows, first reduce using the lq decomposition (if
              ! sufficient workspace available)
              if( n>=mnthr ) then
                 if( wntvn ) then
                    ! path 1t(n much larger than m, jobvt='n')
                    ! no right singular vectors to be computed
                    itau = 1
                    iwork = itau + m
                    ! compute a=l*q
                    ! (cworkspace: need 2*m, prefer m+m*nb)
                    ! (rworkspace: 0)
                    call stdlib_cgelqf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                              ierr )
                    ! zero out above l
                    if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero, a( 1, 2 ),lda )
                    ie = 1
                    itauq = 1
                    itaup = itauq + m
                    iwork = itaup + m
                    ! bidiagonalize l in a
                    ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                    ! (rworkspace: need m)
                    call stdlib_cgebrd( m, m, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( iwork ), lwork-iwork+1,ierr )
                    if( wntuo .or. wntuas ) then
                       ! if left singular vectors desired, generate q
                       ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                    end if
                    irwork = ie + m
                    nru = 0
                    if( wntuo .or. wntuas )nru = m
                    ! perform bidiagonal qr iteration, computing left singular
                    ! vectors of a in a if desired
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_cbdsqr( 'U', m, 0, nru, 0, s, rwork( ie ), cdum, 1,a, lda, cdum, &
                              1, rwork( irwork ), info )
                    ! if left singular vectors desired in u, copy them there
                    if( wntuas )call stdlib_clacpy( 'F', m, m, a, lda, u, ldu )
                 else if( wntvo .and. wntun ) then
                    ! path 2t(n much larger than m, jobu='n', jobvt='o')
                    ! m right singular vectors to be overwritten on a and
                    ! no left singular vectors to be computed
                    if( lwork>=m*m+3*m ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n )+lda*m ) then
                          ! work(iu) is lda by n and work(ir) is lda by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n )+m*m ) then
                          ! work(iu) is lda by n and work(ir) is m by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = m
                       else
                          ! work(iu) is m by chunk and work(ir) is m by m
                          ldwrku = m
                          chunk = ( lwork-m*m ) / m
                          ldwrkr = m
                       end if
                       itau = ir + ldwrkr*m
                       iwork = itau + m
                       ! compute a=l*q
                       ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to work(ir) and zero out above it
                       call stdlib_clacpy( 'L', m, m, a, lda, work( ir ), ldwrkr )
                       call stdlib_claset( 'U', m-1, m-1, czero, czero,work( ir+ldwrkr ), ldwrkr )
                                 
                       ! generate q in a
                       ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in work(ir)
                       ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                       ! (rworkspace: need m)
                       call stdlib_cgebrd( m, m, work( ir ), ldwrkr, s, rwork( ie ),work( itauq ),&
                                  work( itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing l
                       ! (cworkspace: need m*m+3*m-1, prefer m*m+2*m+(m-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       irwork = ie + m
                       ! perform bidiagonal qr iteration, computing right
                       ! singular vectors of l in work(ir)
                       ! (cworkspace: need m*m)
                       ! (rworkspace: need bdspac)
                       call stdlib_cbdsqr( 'U', m, m, 0, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                 cdum, 1, cdum, 1,rwork( irwork ), info )
                       iu = itauq
                       ! multiply right singular vectors of l in work(ir) by q
                       ! in a, storing result in work(iu) and copying to a
                       ! (cworkspace: need m*m+m, prefer m*m+m*n)
                       ! (rworkspace: 0)
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_cgemm( 'N', 'N', m, blk, m, cone, work( ir ),ldwrkr, a( 1, &
                                    i ), lda, czero,work( iu ), ldwrku )
                          call stdlib_clacpy( 'F', m, blk, work( iu ), ldwrku,a( 1, i ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       ie = 1
                       itauq = 1
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize a
                       ! (cworkspace: need 2*m+n, prefer 2*m+(m+n)*nb)
                       ! (rworkspace: need m)
                       call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing a
                       ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + m
                       ! perform bidiagonal qr iteration, computing right
                       ! singular vectors of a in a
                       ! (cworkspace: 0)
                       ! (rworkspace: need bdspac)
                       call stdlib_cbdsqr( 'L', m, n, 0, 0, s, rwork( ie ), a, lda,cdum, 1, cdum, &
                                 1, rwork( irwork ), info )
                    end if
                 else if( wntvo .and. wntuas ) then
                    ! path 3t(n much larger than m, jobu='s' or 'a', jobvt='o')
                    ! m right singular vectors to be overwritten on a and
                    ! m left singular vectors to be computed in u
                    if( lwork>=m*m+3*m ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n )+lda*m ) then
                          ! work(iu) is lda by n and work(ir) is lda by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n )+m*m ) then
                          ! work(iu) is lda by n and work(ir) is m by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = m
                       else
                          ! work(iu) is m by chunk and work(ir) is m by m
                          ldwrku = m
                          chunk = ( lwork-m*m ) / m
                          ldwrkr = m
                       end if
                       itau = ir + ldwrkr*m
                       iwork = itau + m
                       ! compute a=l*q
                       ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to u, zeroing about above it
                       call stdlib_clacpy( 'L', m, m, a, lda, u, ldu )
                       if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero, u( 1, 2 ),ldu )
                       ! generate q in a
                       ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in u, copying result to work(ir)
                       ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                       ! (rworkspace: need m)
                       call stdlib_cgebrd( m, m, u, ldu, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       call stdlib_clacpy( 'U', m, m, u, ldu, work( ir ), ldwrkr )
                       ! generate right vectors bidiagonalizing l in work(ir)
                       ! (cworkspace: need m*m+3*m-1, prefer m*m+2*m+(m-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing l in u
                       ! (cworkspace: need m*m+3*m, prefer m*m+2*m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + m
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of l in u, and computing right
                       ! singular vectors of l in work(ir)
                       ! (cworkspace: need m*m)
                       ! (rworkspace: need bdspac)
                       call stdlib_cbdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( ir ), ldwrkr, u, &
                                 ldu, cdum, 1,rwork( irwork ), info )
                       iu = itauq
                       ! multiply right singular vectors of l in work(ir) by q
                       ! in a, storing result in work(iu) and copying to a
                       ! (cworkspace: need m*m+m, prefer m*m+m*n))
                       ! (rworkspace: 0)
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_cgemm( 'N', 'N', m, blk, m, cone, work( ir ),ldwrkr, a( 1, &
                                    i ), lda, czero,work( iu ), ldwrku )
                          call stdlib_clacpy( 'F', m, blk, work( iu ), ldwrku,a( 1, i ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       itau = 1
                       iwork = itau + m
                       ! compute a=l*q
                       ! (cworkspace: need 2*m, prefer m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to u, zeroing out above it
                       call stdlib_clacpy( 'L', m, m, a, lda, u, ldu )
                       if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero, u( 1, 2 ),ldu )
                       ! generate q in a
                       ! (cworkspace: need 2*m, prefer m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in u
                       ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                       ! (rworkspace: need m)
                       call stdlib_cgebrd( m, m, u, ldu, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! multiply right vectors bidiagonalizing l by q in a
                       ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cunmbr( 'P', 'L', 'C', m, n, m, u, ldu,work( itaup ), a, lda, &
                                 work( iwork ),lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing l in u
                       ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + m
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in u and computing right
                       ! singular vectors of a in a
                       ! (cworkspace: 0)
                       ! (rworkspace: need bdspac)
                       call stdlib_cbdsqr( 'U', m, n, m, 0, s, rwork( ie ), a, lda,u, ldu, cdum, &
                                 1, rwork( irwork ), info )
                    end if
                 else if( wntvs ) then
                    if( wntun ) then
                       ! path 4t(n much larger than m, jobu='n', jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! no left singular vectors to be computed
                       if( lwork>=m*m+3*m ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(ir) is lda by m
                             ldwrkr = lda
                          else
                             ! work(ir) is m by m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(ir), zeroing out above it
                          call stdlib_clacpy( 'L', m, m, a, lda, work( ir ),ldwrkr )
                          call stdlib_claset( 'U', m-1, m-1, czero, czero,work( ir+ldwrkr ), &
                                    ldwrkr )
                          ! generate q in a
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(ir)
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, work( ir ), ldwrkr, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate right vectors bidiagonalizing l in
                          ! work(ir)
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of l in work(ir)
                          ! (cworkspace: need m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, m, 0, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                    cdum, 1, cdum, 1,rwork( irwork ), info )
                          ! multiply right singular vectors of l in work(ir) by
                          ! q in a, storing result in vt
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, m, cone, work( ir ),ldwrkr, a, lda, &
                                    czero, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy result to vt
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero,a( 1, 2 ), lda )
                          ! bidiagonalize l in a
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right vectors bidiagonalizing l by q in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'P', 'L', 'C', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, n, 0, 0, s, rwork( ie ), vt,ldvt, cdum, 1, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    else if( wntuo ) then
                       ! path 5t(n much larger than m, jobu='o', jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! m left singular vectors to be overwritten on a
                       if( lwork>=2*m*m+3*m ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*m ) then
                             ! work(iu) is lda by m and work(ir) is lda by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+m )*m ) then
                             ! work(iu) is lda by m and work(ir) is m by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          else
                             ! work(iu) is m by m and work(ir) is m by m
                             ldwrku = m
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (cworkspace: need 2*m*m+2*m, prefer 2*m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(iu), zeroing out below it
                          call stdlib_clacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_claset( 'U', m-1, m-1, czero, czero,work( iu+ldwrku ), &
                                    ldwrku )
                          ! generate q in a
                          ! (cworkspace: need 2*m*m+2*m, prefer 2*m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to
                          ! work(ir)
                          ! (cworkspace: need   2*m*m+3*m,
                                       ! prefer 2*m*m+2*m+2*m*nb)
                          ! (rworkspace: need   m)
                          call stdlib_cgebrd( m, m, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, m, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need   2*m*m+3*m-1,
                                       ! prefer 2*m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need 2*m*m+3*m, prefer 2*m*m+2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', m, m, m, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in work(ir) and computing
                          ! right singular vectors of l in work(iu)
                          ! (cworkspace: need 2*m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( iu ), ldwrku, &
                                    work( ir ),ldwrkr, cdum, 1, rwork( irwork ),info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in a, storing result in vt
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, m, cone, work( iu ),ldwrku, a, lda, &
                                    czero, vt, ldvt )
                          ! copy left singular vectors of l to a
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_clacpy( 'F', m, m, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero,a( 1, 2 ), lda )
                          ! bidiagonalize l in a
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right vectors bidiagonalizing l by q in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'P', 'L', 'C', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors of l in a
                          ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in a and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, n, m, 0, s, rwork( ie ), vt,ldvt, a, lda, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    else if( wntuas ) then
                       ! path 6t(n much larger than m, jobu='s' or 'a',
                               ! jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! m left singular vectors to be computed in u
                       if( lwork>=m*m+3*m ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is lda by m
                             ldwrku = m
                          end if
                          itau = iu + ldwrku*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_clacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_claset( 'U', m-1, m-1, czero, czero,work( iu+ldwrku ), &
                                    ldwrku )
                          ! generate q in a
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to u
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, m, work( iu ), ldwrku, u,ldu )
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need   m*m+3*m-1,
                                       ! prefer m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in u and computing right
                          ! singular vectors of l in work(iu)
                          ! (cworkspace: need m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( iu ), ldwrku, &
                                    u, ldu, cdum, 1,rwork( irwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in a, storing result in vt
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, m, cone, work( iu ),ldwrku, a, lda, &
                                    czero, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to u, zeroing out above it
                          call stdlib_clacpy( 'L', m, m, a, lda, u, ldu )
                          if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero,u( 1, 2 ), ldu )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in u
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, u, ldu, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in u by q
                          ! in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'P', 'L', 'C', m, n, m, u, ldu,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, n, m, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    end if
                 else if( wntva ) then
                    if( wntun ) then
                       ! path 7t(n much larger than m, jobu='n', jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! no left singular vectors to be computed
                       if( lwork>=m*m+max( n+m, 3*m ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(ir) is lda by m
                             ldwrkr = lda
                          else
                             ! work(ir) is m by m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! copy l to work(ir), zeroing out above it
                          call stdlib_clacpy( 'L', m, m, a, lda, work( ir ),ldwrkr )
                          call stdlib_claset( 'U', m-1, m-1, czero, czero,work( ir+ldwrkr ), &
                                    ldwrkr )
                          ! generate q in vt
                          ! (cworkspace: need m*m+m+n, prefer m*m+m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(ir)
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, work( ir ), ldwrkr, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need   m*m+3*m-1,
                                       ! prefer m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of l in work(ir)
                          ! (cworkspace: need m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, m, 0, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                    cdum, 1, cdum, 1,rwork( irwork ), info )
                          ! multiply right singular vectors of l in work(ir) by
                          ! q in vt, storing result in a
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, m, cone, work( ir ),ldwrkr, vt, ldvt,&
                                     czero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_clacpy( 'F', m, n, a, lda, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need m+n, prefer m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero,a( 1, 2 ), lda )
                          ! bidiagonalize l in a
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in a by q
                          ! in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'P', 'L', 'C', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, n, 0, 0, s, rwork( ie ), vt,ldvt, cdum, 1, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    else if( wntuo ) then
                       ! path 8t(n much larger than m, jobu='o', jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! m left singular vectors to be overwritten on a
                       if( lwork>=2*m*m+max( n+m, 3*m ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*m ) then
                             ! work(iu) is lda by m and work(ir) is lda by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+m )*m ) then
                             ! work(iu) is lda by m and work(ir) is m by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          else
                             ! work(iu) is m by m and work(ir) is m by m
                             ldwrku = m
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m*m+2*m, prefer 2*m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need 2*m*m+m+n, prefer 2*m*m+m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_clacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_claset( 'U', m-1, m-1, czero, czero,work( iu+ldwrku ), &
                                    ldwrku )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to
                          ! work(ir)
                          ! (cworkspace: need   2*m*m+3*m,
                                       ! prefer 2*m*m+2*m+2*m*nb)
                          ! (rworkspace: need   m)
                          call stdlib_cgebrd( m, m, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, m, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need   2*m*m+3*m-1,
                                       ! prefer 2*m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need 2*m*m+3*m, prefer 2*m*m+2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', m, m, m, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in work(ir) and computing
                          ! right singular vectors of l in work(iu)
                          ! (cworkspace: need 2*m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( iu ), ldwrku, &
                                    work( ir ),ldwrkr, cdum, 1, rwork( irwork ),info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in vt, storing result in a
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, m, cone, work( iu ),ldwrku, vt, ldvt,&
                                     czero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_clacpy( 'F', m, n, a, lda, vt, ldvt )
                          ! copy left singular vectors of a from work(ir) to a
                          call stdlib_clacpy( 'F', m, m, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need m+n, prefer m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero,a( 1, 2 ), lda )
                          ! bidiagonalize l in a
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in a by q
                          ! in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'P', 'L', 'C', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in a
                          ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in a and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, n, m, 0, s, rwork( ie ), vt,ldvt, a, lda, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    else if( wntuas ) then
                       ! path 9t(n much larger than m, jobu='s' or 'a',
                               ! jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! m left singular vectors to be computed in u
                       if( lwork>=m*m+max( n+m, 3*m ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(iu) is lda by m
                             ldwrku = lda
                          else
                             ! work(iu) is m by m
                             ldwrku = m
                          end if
                          itau = iu + ldwrku*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need m*m+m+n, prefer m*m+m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_clacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_claset( 'U', m-1, m-1, czero, czero,work( iu+ldwrku ), &
                                    ldwrku )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to u
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, m, work( iu ), ldwrku, u,ldu )
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in u and computing right
                          ! singular vectors of l in work(iu)
                          ! (cworkspace: need m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( iu ), ldwrku, &
                                    u, ldu, cdum, 1,rwork( irwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in vt, storing result in a
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, m, cone, work( iu ),ldwrku, vt, ldvt,&
                                     czero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_clacpy( 'F', m, n, a, lda, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need m+n, prefer m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to u, zeroing out above it
                          call stdlib_clacpy( 'L', m, m, a, lda, u, ldu )
                          if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero,u( 1, 2 ), ldu )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in u
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, u, ldu, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in u by q
                          ! in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'P', 'L', 'C', m, n, m, u, ldu,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, n, m, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    end if
                 end if
              else
                 ! n < mnthr
                 ! path 10t(n greater than m, but not much larger)
                 ! reduce to bidiagonal form without lq decomposition
                 ie = 1
                 itauq = 1
                 itaup = itauq + m
                 iwork = itaup + m
                 ! bidiagonalize a
                 ! (cworkspace: need 2*m+n, prefer 2*m+(m+n)*nb)
                 ! (rworkspace: m)
                 call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( iwork ), lwork-iwork+1,ierr )
                 if( wntuas ) then
                    ! if left singular vectors desired in u, copy result to u
                    ! and generate left bidiagonalizing vectors in u
                    ! (cworkspace: need 3*m-1, prefer 2*m+(m-1)*nb)
                    ! (rworkspace: 0)
                    call stdlib_clacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_cungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvas ) then
                    ! if right singular vectors desired in vt, copy result to
                    ! vt and generate right bidiagonalizing vectors in vt
                    ! (cworkspace: need 2*m+nrvt, prefer 2*m+nrvt*nb)
                    ! (rworkspace: 0)
                    call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                    if( wntva )nrvt = n
                    if( wntvs )nrvt = m
                    call stdlib_cungbr( 'P', nrvt, n, m, vt, ldvt, work( itaup ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntuo ) then
                    ! if left singular vectors desired in a, generate left
                    ! bidiagonalizing vectors in a
                    ! (cworkspace: need 3*m-1, prefer 2*m+(m-1)*nb)
                    ! (rworkspace: 0)
                    call stdlib_cungbr( 'Q', m, m, n, a, lda, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvo ) then
                    ! if right singular vectors desired in a, generate right
                    ! bidiagonalizing vectors in a
                    ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                    ! (rworkspace: 0)
                    call stdlib_cungbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 irwork = ie + m
                 if( wntuas .or. wntuo )nru = m
                 if( wntun )nru = 0
                 if( wntvas .or. wntvo )ncvt = n
                 if( wntvn )ncvt = 0
                 if( ( .not.wntuo ) .and. ( .not.wntvo ) ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in vt
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_cbdsqr( 'L', m, ncvt, nru, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                              cdum, 1, rwork( irwork ),info )
                 else if( ( .not.wntuo ) .and. wntvo ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in a
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_cbdsqr( 'L', m, ncvt, nru, 0, s, rwork( ie ), a,lda, u, ldu, cdum,&
                               1, rwork( irwork ),info )
                 else
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in a and computing right singular
                    ! vectors in vt
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_cbdsqr( 'L', m, ncvt, nru, 0, s, rwork( ie ), vt,ldvt, a, lda, &
                              cdum, 1, rwork( irwork ),info )
                 end if
              end if
           end if
           ! undo scaling if necessary
           if( iscl==1 ) then
              if( anrm>bignum )call stdlib_slascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm>bignum )call stdlib_slascl( 'G', 0, 0, bignum, anrm, minmn-1,&
                         1,rwork( ie ), minmn, ierr )
              if( anrm<smlnum )call stdlib_slascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm<smlnum )call stdlib_slascl( 'G', 0, 0, smlnum, anrm, minmn-1,&
                         1,rwork( ie ), minmn, ierr )
           end if
           ! return optimal workspace in work(1)
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_cgesvd


     subroutine stdlib_cgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
     !! CGESVDQ computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N unitary matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
               numrank, iwork, liwork,cwork, lcwork, rwork, lrwork, info )
           ! Scalar Arguments 
           character, intent(in) :: joba, jobp, jobr, jobu, jobv
           integer(ilp), intent(in) :: m, n, lda, ldu, ldv, liwork, lrwork
           integer(ilp), intent(out) :: numrank, info
           integer(ilp), intent(inout) :: lcwork
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: u(ldu,*), v(ldv,*), cwork(*)
           real(sp), intent(out) :: s(*), rwork(*)
           integer(ilp), intent(out) :: iwork(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           integer(ilp) :: ierr, nr, n1, optratio, p, q
           integer(ilp) :: lwcon, lwqp3, lwrk_cgelqf, lwrk_cgesvd, lwrk_cgesvd2, lwrk_cgeqp3, &
           lwrk_cgeqrf, lwrk_cunmlq, lwrk_cunmqr, lwrk_cunmqr2, lwlqf, lwqrf, lwsvd, lwsvd2, &
                     lwunq, lwunq2, lwunlq, minwrk, minwrk2, optwrk, optwrk2, iminwrk, rminwrk
           logical(lk) :: accla, acclm, acclh, ascaled, conda, dntwu, dntwv, lquery, lsvc0, lsvec,&
                      rowprm, rsvec, rtrans, wntua, wntuf, wntur, wntus, wntva, wntvr
           real(sp) :: big, epsln, rtmp, sconda, sfmin
           complex(sp) :: ctmp
           ! Local Arrays
           complex(sp) :: cdummy(1)
           real(sp) :: rdummy(1)
           ! Intrinsic Functions 
           intrinsic :: abs,conjg,max,min,real,sqrt
           ! Executable Statements 
           ! test the input arguments
           wntus  = stdlib_lsame( jobu, 'S' ) .or. stdlib_lsame( jobu, 'U' )
           wntur  = stdlib_lsame( jobu, 'R' )
           wntua  = stdlib_lsame( jobu, 'A' )
           wntuf  = stdlib_lsame( jobu, 'F' )
           lsvc0  = wntus .or. wntur .or. wntua
           lsvec  = lsvc0 .or. wntuf
           dntwu  = stdlib_lsame( jobu, 'N' )
           wntvr  = stdlib_lsame( jobv, 'R' )
           wntva  = stdlib_lsame( jobv, 'A' ) .or. stdlib_lsame( jobv, 'V' )
           rsvec  = wntvr .or. wntva
           dntwv  = stdlib_lsame( jobv, 'N' )
           accla  = stdlib_lsame( joba, 'A' )
           acclm  = stdlib_lsame( joba, 'M' )
           conda  = stdlib_lsame( joba, 'E' )
           acclh  = stdlib_lsame( joba, 'H' ) .or. conda
           rowprm = stdlib_lsame( jobp, 'P' )
           rtrans = stdlib_lsame( jobr, 'T' )
           if ( rowprm ) then
              iminwrk = max( 1, n + m - 1 )
              rminwrk = max( 2, m, 5*n )
           else
              iminwrk = max( 1, n )
              rminwrk = max( 2, 5*n )
           end if
           lquery = (liwork == -1 .or. lcwork == -1 .or. lrwork == -1)
           info  = 0
           if ( .not. ( accla .or. acclm .or. acclh ) ) then
              info = -1
           else if ( .not.( rowprm .or. stdlib_lsame( jobp, 'N' ) ) ) then
               info = -2
           else if ( .not.( rtrans .or. stdlib_lsame( jobr, 'N' ) ) ) then
               info = -3
           else if ( .not.( lsvec .or. dntwu ) ) then
              info = -4
           else if ( wntur .and. wntva ) then
              info = -5
           else if ( .not.( rsvec .or. dntwv )) then
              info = -5
           else if ( m<0 ) then
              info = -6
           else if ( ( n<0 ) .or. ( n>m ) ) then
              info = -7
           else if ( lda<max( 1, m ) ) then
              info = -9
           else if ( ldu<1 .or. ( lsvc0 .and. ldu<m ) .or.( wntuf .and. ldu<n ) ) then
              info = -12
           else if ( ldv<1 .or. ( rsvec .and. ldv<n ) .or.( conda .and. ldv<n ) ) then
              info = -14
           else if ( liwork < iminwrk .and. .not. lquery ) then
              info = -17
           end if
           if ( info == 0 ) then
           ! compute workspace
              ! Compute The Minimal And The Optimal Workspace Lengths
              ! [[the expressions for computing the minimal and the optimal
              ! values of lcwork are written with a lot of redundancy and
              ! can be simplified. however, this detailed form is easier for
              ! maintenance and modifications of the code.]]
              ! Minimal Workspace Length For Stdlib_Cgeqp3 Of An M X N Matrix
              lwqp3 = n+1
              ! Minimal Workspace Length For Stdlib_Cunmqr To Build Left Singular Vectors
              if ( wntus .or. wntur ) then
                  lwunq  = max( n  , 1 )
              else if ( wntua ) then
                  lwunq = max( m , 1 )
              end if
              ! Minimal Workspace Length For Stdlib_Cpocon Of An N X N Matrix
              lwcon = 2 * n
              ! Stdlib_Cgesvd Of An N X N Matrix
              lwsvd = max( 3 * n, 1 )
              if ( lquery ) then
                  call stdlib_cgeqp3( m, n, a, lda, iwork, cdummy, cdummy, -1,rdummy, ierr )
                            
                  lwrk_cgeqp3 = int( cdummy(1),KIND=ilp)
                  if ( wntus .or. wntur ) then
                      call stdlib_cunmqr( 'L', 'N', m, n, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_cunmqr = int( cdummy(1),KIND=ilp)
                  else if ( wntua ) then
                      call stdlib_cunmqr( 'L', 'N', m, m, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_cunmqr = int( cdummy(1),KIND=ilp)
                  else
                      lwrk_cunmqr = 0
                  end if
              end if
              minwrk = 2
              optwrk = 2
              if ( .not. (lsvec .or. rsvec )) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If
                  ! only the singular values are requested
                  if ( conda ) then
                     minwrk = max( n+lwqp3, lwcon, lwsvd )
                  else
                     minwrk = max( n+lwqp3, lwsvd )
                  end if
                  if ( lquery ) then
                      call stdlib_cgesvd( 'N', 'N', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                rdummy, ierr )
                      lwrk_cgesvd = int( cdummy(1),KIND=ilp)
                      if ( conda ) then
                         optwrk = max( n+lwrk_cgeqp3, n+lwcon, lwrk_cgesvd )
                      else
                         optwrk = max( n+lwrk_cgeqp3, lwrk_cgesvd )
                      end if
                  end if
              else if ( lsvec .and. (.not.rsvec) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! singular values and the left singular vectors are requested
                  if ( conda ) then
                      minwrk = n + max( lwqp3, lwcon, lwsvd, lwunq )
                  else
                      minwrk = n + max( lwqp3, lwsvd, lwunq )
                  end if
                  if ( lquery ) then
                     if ( rtrans ) then
                        call stdlib_cgesvd( 'N', 'O', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                  rdummy, ierr )
                     else
                        call stdlib_cgesvd( 'O', 'N', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                  rdummy, ierr )
                     end if
                     lwrk_cgesvd = int( cdummy(1),KIND=ilp)
                     if ( conda ) then
                         optwrk = n + max( lwrk_cgeqp3, lwcon, lwrk_cgesvd,lwrk_cunmqr )
                     else
                         optwrk = n + max( lwrk_cgeqp3, lwrk_cgesvd,lwrk_cunmqr )
                     end if
                  end if
              else if ( rsvec .and. (.not.lsvec) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! singular values and the right singular vectors are requested
                  if ( conda ) then
                      minwrk = n + max( lwqp3, lwcon, lwsvd )
                  else
                      minwrk = n + max( lwqp3, lwsvd )
                  end if
                  if ( lquery ) then
                      if ( rtrans ) then
                          call stdlib_cgesvd( 'O', 'N', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -&
                                    1, rdummy, ierr )
                      else
                          call stdlib_cgesvd( 'N', 'O', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -&
                                    1, rdummy, ierr )
                      end if
                      lwrk_cgesvd = int( cdummy(1),KIND=ilp)
                      if ( conda ) then
                          optwrk = n + max( lwrk_cgeqp3, lwcon, lwrk_cgesvd )
                      else
                          optwrk = n + max( lwrk_cgeqp3, lwrk_cgesvd )
                      end if
                  end if
              else
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! full svd is requested
                  if ( rtrans ) then
                      minwrk = max( lwqp3, lwsvd, lwunq )
                      if ( conda ) minwrk = max( minwrk, lwcon )
                      minwrk = minwrk + n
                      if ( wntva ) then
                         ! .. minimal workspace length for n x n/2 stdlib_cgeqrf
                         lwqrf  = max( n/2, 1 )
                         ! .. minimal workspace length for n/2 x n/2 stdlib_cgesvd
                         lwsvd2 = max( 3 * (n/2), 1 )
                         lwunq2 = max( n, 1 )
                         minwrk2 = max( lwqp3, n/2+lwqrf, n/2+lwsvd2,n/2+lwunq2, lwunq )
                         if ( conda ) minwrk2 = max( minwrk2, lwcon )
                         minwrk2 = n + minwrk2
                         minwrk = max( minwrk, minwrk2 )
                      end if
                  else
                      minwrk = max( lwqp3, lwsvd, lwunq )
                      if ( conda ) minwrk = max( minwrk, lwcon )
                      minwrk = minwrk + n
                      if ( wntva ) then
                         ! .. minimal workspace length for n/2 x n stdlib_cgelqf
                         lwlqf  = max( n/2, 1 )
                         lwsvd2 = max( 3 * (n/2), 1 )
                         lwunlq = max( n , 1 )
                         minwrk2 = max( lwqp3, n/2+lwlqf, n/2+lwsvd2,n/2+lwunlq, lwunq )
                         if ( conda ) minwrk2 = max( minwrk2, lwcon )
                         minwrk2 = n + minwrk2
                         minwrk = max( minwrk, minwrk2 )
                      end if
                  end if
                  if ( lquery ) then
                     if ( rtrans ) then
                        call stdlib_cgesvd( 'O', 'A', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                  rdummy, ierr )
                        lwrk_cgesvd = int( cdummy(1),KIND=ilp)
                        optwrk = max(lwrk_cgeqp3,lwrk_cgesvd,lwrk_cunmqr)
                        if ( conda ) optwrk = max( optwrk, lwcon )
                        optwrk = n + optwrk
                        if ( wntva ) then
                            call stdlib_cgeqrf(n,n/2,u,ldu,cdummy,cdummy,-1,ierr)
                            lwrk_cgeqrf = int( cdummy(1),KIND=ilp)
                            call stdlib_cgesvd( 'S', 'O', n/2,n/2, v,ldv, s, u,ldu,v, ldv, cdummy,&
                                       -1, rdummy, ierr )
                            lwrk_cgesvd2 = int( cdummy(1),KIND=ilp)
                            call stdlib_cunmqr( 'R', 'C', n, n, n/2, u, ldu, cdummy,v, ldv, &
                                      cdummy, -1, ierr )
                            lwrk_cunmqr2 = int( cdummy(1),KIND=ilp)
                            optwrk2 = max( lwrk_cgeqp3, n/2+lwrk_cgeqrf,n/2+lwrk_cgesvd2, n/2+&
                                      lwrk_cunmqr2 )
                            if ( conda ) optwrk2 = max( optwrk2, lwcon )
                            optwrk2 = n + optwrk2
                            optwrk = max( optwrk, optwrk2 )
                        end if
                     else
                        call stdlib_cgesvd( 'S', 'O', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                  rdummy, ierr )
                        lwrk_cgesvd = int( cdummy(1),KIND=ilp)
                        optwrk = max(lwrk_cgeqp3,lwrk_cgesvd,lwrk_cunmqr)
                        if ( conda ) optwrk = max( optwrk, lwcon )
                        optwrk = n + optwrk
                        if ( wntva ) then
                           call stdlib_cgelqf(n/2,n,u,ldu,cdummy,cdummy,-1,ierr)
                           lwrk_cgelqf = int( cdummy(1),KIND=ilp)
                           call stdlib_cgesvd( 'S','O', n/2,n/2, v, ldv, s, u, ldu,v, ldv, cdummy,&
                                      -1, rdummy, ierr )
                           lwrk_cgesvd2 = int( cdummy(1),KIND=ilp)
                           call stdlib_cunmlq( 'R', 'N', n, n, n/2, u, ldu, cdummy,v, ldv, cdummy,&
                                     -1,ierr )
                           lwrk_cunmlq = int( cdummy(1),KIND=ilp)
                           optwrk2 = max( lwrk_cgeqp3, n/2+lwrk_cgelqf,n/2+lwrk_cgesvd2, n/2+&
                                     lwrk_cunmlq )
                            if ( conda ) optwrk2 = max( optwrk2, lwcon )
                            optwrk2 = n + optwrk2
                            optwrk = max( optwrk, optwrk2 )
                        end if
                     end if
                  end if
              end if
              minwrk = max( 2, minwrk )
              optwrk = max( 2, optwrk )
              if ( lcwork < minwrk .and. (.not.lquery) ) info = -19
           end if
           if (info == 0 .and. lrwork < rminwrk .and. .not. lquery) then
              info = -21
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGESVDQ', -info )
              return
           else if ( lquery ) then
           ! return optimal workspace
               iwork(1) = iminwrk
               cwork(1) = optwrk
               cwork(2) = minwrk
               rwork(1) = rminwrk
               return
           end if
           ! quick return if the matrix is void.
           if( ( m==0 ) .or. ( n==0 ) ) then
           ! All Output Is Void
              return
           end if
           big = stdlib_slamch('O')
           ascaled = .false.
           if ( rowprm ) then
                 ! Reordering The Rows In Decreasing Sequence In The
                 ! ell-infinity norm - this enhances numerical robustness in
                 ! the case of differently scaled rows.
                 do p = 1, m
                     ! rwork(p) = abs( a(p,stdlib_icamax(n,a(p,1),lda)) )
                     ! [[stdlib_clange will return nan if an entry of the p-th row is nan]]
                     rwork(p) = stdlib_clange( 'M', 1, n, a(p,1), lda, rdummy )
                     ! .. check for nan's and inf's
                     if ( ( rwork(p) /= rwork(p) ) .or.( (rwork(p)*zero) /= zero ) ) then
                         info = - 8
                         call stdlib_xerbla( 'CGESVDQ', -info )
                         return
                     end if
                 end do
                 do p = 1, m - 1
                 q = stdlib_isamax( m-p+1, rwork(p), 1 ) + p - 1
                 iwork(n+p) = q
                 if ( p /= q ) then
                    rtmp     = rwork(p)
                    rwork(p) = rwork(q)
                    rwork(q) = rtmp
                 end if
                 end do
                 if ( rwork(1) == zero ) then
                    ! quick return: a is the m x n zero matrix.
                    numrank = 0
                    call stdlib_slaset( 'G', n, 1, zero, zero, s, n )
                    if ( wntus ) call stdlib_claset('G', m, n, czero, cone, u, ldu)
                    if ( wntua ) call stdlib_claset('G', m, m, czero, cone, u, ldu)
                    if ( wntva ) call stdlib_claset('G', n, n, czero, cone, v, ldv)
                    if ( wntuf ) then
                        call stdlib_claset( 'G', n, 1, czero, czero, cwork, n )
                        call stdlib_claset( 'G', m, n, czero, cone, u, ldu )
                    end if
                    do p = 1, n
                        iwork(p) = p
                    end do
                    if ( rowprm ) then
                        do p = n + 1, n + m - 1
                            iwork(p) = p - n
                        end do
                    end if
                    if ( conda ) rwork(1) = -1
                    rwork(2) = -1
                    return
                 end if
                 if ( rwork(1) > big / sqrt(real(m,KIND=sp)) ) then
                     ! .. to prevent overflow in the qr factorization, scale the
                     ! matrix by 1/sqrt(m) if too large entry detected
                     call stdlib_clascl('G',0,0,sqrt(real(m,KIND=sp)),one, m,n, a,lda, ierr)
                               
                     ascaled = .true.
                 end if
                 call stdlib_claswp( n, a, lda, 1, m-1, iwork(n+1), 1 )
           end if
          ! .. at this stage, preemptive scaling is done only to avoid column
          ! norms overflows during the qr factorization. the svd procedure should
          ! have its own scaling to save the singular values from overflows and
          ! underflows. that depends on the svd procedure.
           if ( .not.rowprm ) then
               rtmp = stdlib_clange( 'M', m, n, a, lda, rwork )
               if ( ( rtmp /= rtmp ) .or.( (rtmp*zero) /= zero ) ) then
                    info = - 8
                    call stdlib_xerbla( 'CGESVDQ', -info )
                    return
               end if
               if ( rtmp > big / sqrt(real(m,KIND=sp)) ) then
                   ! .. to prevent overflow in the qr factorization, scale the
                   ! matrix by 1/sqrt(m) if too large entry detected
                   call stdlib_clascl('G',0,0, sqrt(real(m,KIND=sp)),one, m,n, a,lda, ierr)
                             
                   ascaled = .true.
               end if
           end if
           ! Qr Factorization With Column Pivoting
           ! a * p = q * [ r ]
                       ! [ 0 ]
           do p = 1, n
              ! All Columns Are Free Columns
              iwork(p) = 0
           end do
           call stdlib_cgeqp3( m, n, a, lda, iwork, cwork, cwork(n+1), lcwork-n,rwork, ierr )
                     
          ! if the user requested accuracy level allows truncation in the
          ! computed upper triangular factor, the matrix r is examined and,
          ! if possible, replaced with its leading upper trapezoidal part.
           epsln = stdlib_slamch('E')
           sfmin = stdlib_slamch('S')
           ! small = sfmin / epsln
           nr = n
           if ( accla ) then
              ! standard absolute error bound suffices. all sigma_i with
              ! sigma_i < n*eps*||a||_f are flushed to zero. this is an
              ! aggressive enforcement of lower numerical rank by introducing a
              ! backward error of the order of n*eps*||a||_f.
              nr = 1
              rtmp = sqrt(real(n,KIND=sp))*epsln
              do p = 2, n
                 if ( abs(a(p,p)) < (rtmp*abs(a(1,1))) ) go to 3002
                    nr = nr + 1
              end do
              3002 continue
           elseif ( acclm ) then
              ! .. similarly as above, only slightly more gentle (less aggressive).
              ! sudden drop on the diagonal of r is used as the criterion for being
              ! close-to-rank-deficient. the threshold is set to epsln=stdlib_slamch('e').
              ! [[this can be made more flexible by replacing this hard-coded value
              ! with a user specified threshold.]] also, the values that underflow
              ! will be truncated.
              nr = 1
              do p = 2, n
                 if ( ( abs(a(p,p)) < (epsln*abs(a(p-1,p-1))) ) .or.( abs(a(p,p)) < sfmin ) ) go &
                           to 3402
                 nr = nr + 1
              end do
              3402 continue
           else
              ! Rrqr Not Authorized To Determine Numerical Rank Except In The
              ! obvious case of zero pivots.
              ! .. inspect r for exact zeros on the diagonal;
              ! r(i,i)=0 => r(i:n,i:n)=0.
              nr = 1
              do p = 2, n
                 if ( abs(a(p,p)) == zero ) go to 3502
                 nr = nr + 1
              end do
              3502 continue
              if ( conda ) then
                 ! estimate the scaled condition number of a. use the fact that it is
                 ! the same as the scaled condition number of r.
                    ! V Is Used As Workspace
                    call stdlib_clacpy( 'U', n, n, a, lda, v, ldv )
                    ! only the leading nr x nr submatrix of the triangular factor
                    ! is considered. only if nr=n will this give a reliable error
                    ! bound. however, even for nr < n, this can be used on an
                    ! expert level and obtain useful information in the sense of
                    ! perturbation theory.
                    do p = 1, nr
                       rtmp = stdlib_scnrm2( p, v(1,p), 1 )
                       call stdlib_csscal( p, one/rtmp, v(1,p), 1 )
                    end do
                    if ( .not. ( lsvec .or. rsvec ) ) then
                        call stdlib_cpocon( 'U', nr, v, ldv, one, rtmp,cwork, rwork, ierr )
                                  
                    else
                        call stdlib_cpocon( 'U', nr, v, ldv, one, rtmp,cwork(n+1), rwork, ierr )
                                  
                    end if
                    sconda = one / sqrt(rtmp)
                 ! for nr=n, sconda is an estimate of sqrt(||(r^* * r)^(-1)||_1),
                 ! n^(-1/4) * sconda <= ||r^(-1)||_2 <= n^(1/4) * sconda
                 ! see the reference [1] for more details.
              end if
           endif
           if ( wntur ) then
               n1 = nr
           else if ( wntus .or. wntuf) then
               n1 = n
           else if ( wntua ) then
               n1 = m
           end if
           if ( .not. ( rsvec .or. lsvec ) ) then
      ! .......................................................................
              ! Only The Singular Values Are Requested
      ! .......................................................................
              if ( rtrans ) then
               ! .. compute the singular values of r**h = [a](1:nr,1:n)**h
                 ! .. set the lower triangle of [a] to [a](1:nr,1:n)**h and
                 ! the upper triangle of [a] to zero.
                 do p = 1, min( n, nr )
                    a(p,p) = conjg(a(p,p))
                    do q = p + 1, n
                       a(q,p) = conjg(a(p,q))
                       if ( q <= nr ) a(p,q) = czero
                    end do
                 end do
                 call stdlib_cgesvd( 'N', 'N', n, nr, a, lda, s, u, ldu,v, ldv, cwork, lcwork, &
                           rwork, info )
              else
                 ! .. compute the singular values of r = [a](1:nr,1:n)
                 if ( nr > 1 )call stdlib_claset( 'L', nr-1,nr-1, czero,czero, a(2,1), lda )
                           
                 call stdlib_cgesvd( 'N', 'N', nr, n, a, lda, s, u, ldu,v, ldv, cwork, lcwork, &
                           rwork, info )
              end if
           else if ( lsvec .and. ( .not. rsvec) ) then
      ! .......................................................................
             ! The Singular Values And The Left Singular Vectors Requested
      ! .......................................................................""""""""
              if ( rtrans ) then
                  ! .. apply stdlib_cgesvd to r**h
                  ! .. copy r**h into [u] and overwrite [u] with the right singular
                  ! vectors of r
                 do p = 1, nr
                    do q = p, n
                       u(q,p) = conjg(a(p,q))
                    end do
                 end do
                 if ( nr > 1 )call stdlib_claset( 'U', nr-1,nr-1, czero,czero, u(1,2), ldu )
                           
                 ! .. the left singular vectors not computed, the nr right singular
                 ! vectors overwrite [u](1:nr,1:nr) as conjugate transposed. these
                 ! will be pre-multiplied by q to build the left singular vectors of a.
                    call stdlib_cgesvd( 'N', 'O', n, nr, u, ldu, s, u, ldu,u, ldu, cwork(n+1), &
                              lcwork-n, rwork, info )
                    do p = 1, nr
                        u(p,p) = conjg(u(p,p))
                        do q = p + 1, nr
                           ctmp   = conjg(u(q,p))
                           u(q,p) = conjg(u(p,q))
                           u(p,q) = ctmp
                        end do
                    end do
              else
                  ! Apply Stdlib_Cgesvd To R
                  ! .. copy r into [u] and overwrite [u] with the left singular vectors
                  call stdlib_clacpy( 'U', nr, n, a, lda, u, ldu )
                  if ( nr > 1 )call stdlib_claset( 'L', nr-1, nr-1, czero, czero, u(2,1), ldu )
                            
                  ! .. the right singular vectors not computed, the nr left singular
                  ! vectors overwrite [u](1:nr,1:nr)
                     call stdlib_cgesvd( 'O', 'N', nr, n, u, ldu, s, u, ldu,v, ldv, cwork(n+1), &
                               lcwork-n, rwork, info )
                     ! .. now [u](1:nr,1:nr) contains the nr left singular vectors of
                     ! r. these will be pre-multiplied by q to build the left singular
                     ! vectors of a.
              end if
                 ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
              if ( ( nr < m ) .and. ( .not.wntuf ) ) then
                  call stdlib_claset('A', m-nr, nr, czero, czero, u(nr+1,1), ldu)
                  if ( nr < n1 ) then
                     call stdlib_claset( 'A',nr,n1-nr,czero,czero,u(1,nr+1), ldu )
                     call stdlib_claset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1), ldu )
                  end if
              end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! vectors matrix u.
              if ( .not.wntuf )call stdlib_cunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, &
                        cwork(n+1), lcwork-n, ierr )
              if ( rowprm .and. .not.wntuf )call stdlib_claswp( n1, u, ldu, 1, m-1, iwork(n+1), -&
                        1 )
           else if ( rsvec .and. ( .not. lsvec ) ) then
      ! .......................................................................
             ! The Singular Values And The Right Singular Vectors Requested
      ! .......................................................................
               if ( rtrans ) then
                  ! .. apply stdlib_cgesvd to r**h
                  ! .. copy r**h into v and overwrite v with the left singular vectors
                 do p = 1, nr
                    do q = p, n
                       v(q,p) = conjg(a(p,q))
                    end do
                 end do
                 if ( nr > 1 )call stdlib_claset( 'U', nr-1,nr-1, czero,czero, v(1,2), ldv )
                           
                 ! .. the left singular vectors of r**h overwrite v, the right singular
                 ! vectors not computed
                 if ( wntvr .or. ( nr == n ) ) then
                    call stdlib_cgesvd( 'O', 'N', n, nr, v, ldv, s, u, ldu,u, ldu, cwork(n+1), &
                              lcwork-n, rwork, info )
                    do p = 1, nr
                        v(p,p) = conjg(v(p,p))
                        do q = p + 1, nr
                           ctmp   = conjg(v(q,p))
                           v(q,p) = conjg(v(p,q))
                           v(p,q) = ctmp
                        end do
                    end do
                    if ( nr < n ) then
                        do p = 1, nr
                           do q = nr + 1, n
                               v(p,q) = conjg(v(q,p))
                           end do
                        end do
                    end if
                    call stdlib_clapmt( .false., nr, n, v, ldv, iwork )
                 else
                     ! .. need all n right singular vectors and nr < n
                     ! [!] this is simple implementation that augments [v](1:n,1:nr)
                     ! by padding a zero block. in the case nr << n, a more efficient
                     ! way is to first use the qr factorization. for more details
                     ! how to implement this, see the " full svd " branch.
                     call stdlib_claset('G', n, n-nr, czero, czero, v(1,nr+1), ldv)
                     call stdlib_cgesvd( 'O', 'N', n, n, v, ldv, s, u, ldu,u, ldu, cwork(n+1), &
                               lcwork-n, rwork, info )
                     do p = 1, n
                        v(p,p) = conjg(v(p,p))
                        do q = p + 1, n
                           ctmp   = conjg(v(q,p))
                           v(q,p) = conjg(v(p,q))
                           v(p,q) = ctmp
                        end do
                     end do
                     call stdlib_clapmt( .false., n, n, v, ldv, iwork )
                 end if
               else
                  ! Aply Stdlib_Cgesvd To R
                  ! Copy R Into V And Overwrite V With The Right Singular Vectors
                  call stdlib_clacpy( 'U', nr, n, a, lda, v, ldv )
                  if ( nr > 1 )call stdlib_claset( 'L', nr-1, nr-1, czero, czero, v(2,1), ldv )
                            
                  ! .. the right singular vectors overwrite v, the nr left singular
                  ! vectors stored in u(1:nr,1:nr)
                  if ( wntvr .or. ( nr == n ) ) then
                     call stdlib_cgesvd( 'N', 'O', nr, n, v, ldv, s, u, ldu,v, ldv, cwork(n+1), &
                               lcwork-n, rwork, info )
                     call stdlib_clapmt( .false., nr, n, v, ldv, iwork )
                     ! .. now [v](1:nr,1:n) contains v(1:n,1:nr)**h
                  else
                     ! .. need all n right singular vectors and nr < n
                     ! [!] this is simple implementation that augments [v](1:nr,1:n)
                     ! by padding a zero block. in the case nr << n, a more efficient
                     ! way is to first use the lq factorization. for more details
                     ! how to implement this, see the " full svd " branch.
                      call stdlib_claset('G', n-nr, n, czero,czero, v(nr+1,1), ldv)
                      call stdlib_cgesvd( 'N', 'O', n, n, v, ldv, s, u, ldu,v, ldv, cwork(n+1), &
                                lcwork-n, rwork, info )
                      call stdlib_clapmt( .false., n, n, v, ldv, iwork )
                  end if
                  ! .. now [v] contains the adjoint of the matrix of the right singular
                  ! vectors of a.
               end if
           else
      ! .......................................................................
             ! Full Svd Requested
      ! .......................................................................
              if ( rtrans ) then
                  ! .. apply stdlib_cgesvd to r**h [[this option is left for r
                 if ( wntvr .or. ( nr == n ) ) then
                  ! .. copy r**h into [v] and overwrite [v] with the left singular
                  ! vectors of r**h
                 do p = 1, nr
                    do q = p, n
                       v(q,p) = conjg(a(p,q))
                    end do
                 end do
                 if ( nr > 1 )call stdlib_claset( 'U', nr-1,nr-1, czero,czero, v(1,2), ldv )
                           
                 ! .. the left singular vectors of r**h overwrite [v], the nr right
                 ! singular vectors of r**h stored in [u](1:nr,1:nr) as conjugate
                 ! transposed
                    call stdlib_cgesvd( 'O', 'A', n, nr, v, ldv, s, v, ldv,u, ldu, cwork(n+1), &
                              lcwork-n, rwork, info )
                    ! Assemble V
                    do p = 1, nr
                       v(p,p) = conjg(v(p,p))
                       do q = p + 1, nr
                          ctmp   = conjg(v(q,p))
                          v(q,p) = conjg(v(p,q))
                          v(p,q) = ctmp
                       end do
                    end do
                    if ( nr < n ) then
                        do p = 1, nr
                           do q = nr+1, n
                              v(p,q) = conjg(v(q,p))
                           end do
                        end do
                    end if
                    call stdlib_clapmt( .false., nr, n, v, ldv, iwork )
                     do p = 1, nr
                        u(p,p) = conjg(u(p,p))
                        do q = p + 1, nr
                           ctmp   = conjg(u(q,p))
                           u(q,p) = conjg(u(p,q))
                           u(p,q) = ctmp
                        end do
                     end do
                     if ( ( nr < m ) .and. .not.(wntuf)) then
                       call stdlib_claset('A', m-nr,nr, czero,czero, u(nr+1,1), ldu)
                       if ( nr < n1 ) then
                          call stdlib_claset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                          call stdlib_claset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1), ldu )
                                    
                       end if
                    end if
                 else
                     ! .. need all n right singular vectors and nr < n
                  ! .. copy r**h into [v] and overwrite [v] with the left singular
                  ! vectors of r**h
                     ! [[the optimal ratio n/nr for using qrf instead of padding
                       ! with zeros. here hard coded to 2; it must be at least
                       ! two due to work space constraints.]]
                     ! optratio = stdlib_ilaenv(6, 'cgesvd', 's' // 'o', nr,n,0,0)
                     ! optratio = max( optratio, 2 )
                     optratio = 2
                     if ( optratio*nr > n ) then
                        do p = 1, nr
                           do q = p, n
                              v(q,p) = conjg(a(p,q))
                           end do
                        end do
                        if ( nr > 1 )call stdlib_claset('U',nr-1,nr-1, czero,czero, v(1,2),ldv)
                                  
                        call stdlib_claset('A',n,n-nr,czero,czero,v(1,nr+1),ldv)
                        call stdlib_cgesvd( 'O', 'A', n, n, v, ldv, s, v, ldv,u, ldu, cwork(n+1), &
                                  lcwork-n, rwork, info )
                        do p = 1, n
                           v(p,p) = conjg(v(p,p))
                           do q = p + 1, n
                              ctmp   = conjg(v(q,p))
                              v(q,p) = conjg(v(p,q))
                              v(p,q) = ctmp
                           end do
                        end do
                        call stdlib_clapmt( .false., n, n, v, ldv, iwork )
                    ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x n1), i.e. (m x n) or (m x m).
                        do p = 1, n
                           u(p,p) = conjg(u(p,p))
                           do q = p + 1, n
                              ctmp   = conjg(u(q,p))
                              u(q,p) = conjg(u(p,q))
                              u(p,q) = ctmp
                           end do
                        end do
                        if ( ( n < m ) .and. .not.(wntuf)) then
                           call stdlib_claset('A',m-n,n,czero,czero,u(n+1,1),ldu)
                           if ( n < n1 ) then
                             call stdlib_claset('A',n,n1-n,czero,czero,u(1,n+1),ldu)
                             call stdlib_claset('A',m-n,n1-n,czero,cone,u(n+1,n+1), ldu )
                           end if
                        end if
                     else
                        ! .. copy r**h into [u] and overwrite [u] with the right
                        ! singular vectors of r
                        do p = 1, nr
                           do q = p, n
                              u(q,nr+p) = conjg(a(p,q))
                           end do
                        end do
                        if ( nr > 1 )call stdlib_claset('U',nr-1,nr-1,czero,czero,u(1,nr+2),ldu)
                                  
                        call stdlib_cgeqrf( n, nr, u(1,nr+1), ldu, cwork(n+1),cwork(n+nr+1), &
                                  lcwork-n-nr, ierr )
                        do p = 1, nr
                            do q = 1, n
                                v(q,p) = conjg(u(p,nr+q))
                            end do
                        end do
                       if (nr>1) call stdlib_claset('U',nr-1,nr-1,czero,czero,v(1,2),ldv)
                       call stdlib_cgesvd( 'S', 'O', nr, nr, v, ldv, s, u, ldu,v,ldv, cwork(n+nr+&
                                 1),lcwork-n-nr,rwork, info )
                       call stdlib_claset('A',n-nr,nr,czero,czero,v(nr+1,1),ldv)
                       call stdlib_claset('A',nr,n-nr,czero,czero,v(1,nr+1),ldv)
                       call stdlib_claset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                       call stdlib_cunmqr('R','C', n, n, nr, u(1,nr+1), ldu,cwork(n+1),v,ldv,&
                                 cwork(n+nr+1),lcwork-n-nr,ierr)
                       call stdlib_clapmt( .false., n, n, v, ldv, iwork )
                       ! Assemble The Left Singular Vector Matrix U Of Dimensions
                       ! (m x nr) or (m x n) or (m x m).
                       if ( ( nr < m ) .and. .not.(wntuf)) then
                          call stdlib_claset('A',m-nr,nr,czero,czero,u(nr+1,1),ldu)
                          if ( nr < n1 ) then
                          call stdlib_claset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                          call stdlib_claset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1),ldu)
                          end if
                       end if
                     end if
                 end if
              else
                  ! .. apply stdlib_cgesvd to r [[this is the recommended option]]
                  if ( wntvr .or. ( nr == n ) ) then
                      ! .. copy r into [v] and overwrite v with the right singular vectors
                      call stdlib_clacpy( 'U', nr, n, a, lda, v, ldv )
                     if ( nr > 1 )call stdlib_claset( 'L', nr-1,nr-1, czero,czero, v(2,1), ldv )
                               
                     ! .. the right singular vectors of r overwrite [v], the nr left
                     ! singular vectors of r stored in [u](1:nr,1:nr)
                     call stdlib_cgesvd( 'S', 'O', nr, n, v, ldv, s, u, ldu,v, ldv, cwork(n+1), &
                               lcwork-n, rwork, info )
                     call stdlib_clapmt( .false., nr, n, v, ldv, iwork )
                     ! .. now [v](1:nr,1:n) contains v(1:n,1:nr)**h
                     ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
                    if ( ( nr < m ) .and. .not.(wntuf)) then
                       call stdlib_claset('A', m-nr,nr, czero,czero, u(nr+1,1), ldu)
                       if ( nr < n1 ) then
                          call stdlib_claset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                          call stdlib_claset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1), ldu )
                                    
                       end if
                    end if
                  else
                    ! .. need all n right singular vectors and nr < n
                    ! The Requested Number Of The Left Singular Vectors
                     ! is then n1 (n or m)
                     ! [[the optimal ratio n/nr for using lq instead of padding
                       ! with zeros. here hard coded to 2; it must be at least
                       ! two due to work space constraints.]]
                     ! optratio = stdlib_ilaenv(6, 'cgesvd', 's' // 'o', nr,n,0,0)
                     ! optratio = max( optratio, 2 )
                    optratio = 2
                    if ( optratio * nr > n ) then
                       call stdlib_clacpy( 'U', nr, n, a, lda, v, ldv )
                       if ( nr > 1 )call stdlib_claset('L', nr-1,nr-1, czero,czero, v(2,1),ldv)
                                 
                    ! .. the right singular vectors of r overwrite [v], the nr left
                       ! singular vectors of r stored in [u](1:nr,1:nr)
                       call stdlib_claset('A', n-nr,n, czero,czero, v(nr+1,1),ldv)
                       call stdlib_cgesvd( 'S', 'O', n, n, v, ldv, s, u, ldu,v, ldv, cwork(n+1), &
                                 lcwork-n, rwork, info )
                       call stdlib_clapmt( .false., n, n, v, ldv, iwork )
                       ! .. now [v] contains the adjoint of the matrix of the right
                       ! singular vectors of a. the leading n left singular vectors
                       ! are in [u](1:n,1:n)
                       ! Assemble The Left Singular Vector Matrix U Of Dimensions
                       ! (m x n1), i.e. (m x n) or (m x m).
                       if ( ( n < m ) .and. .not.(wntuf)) then
                           call stdlib_claset('A',m-n,n,czero,czero,u(n+1,1),ldu)
                           if ( n < n1 ) then
                             call stdlib_claset('A',n,n1-n,czero,czero,u(1,n+1),ldu)
                             call stdlib_claset( 'A',m-n,n1-n,czero,cone,u(n+1,n+1), ldu )
                           end if
                       end if
                    else
                       call stdlib_clacpy( 'U', nr, n, a, lda, u(nr+1,1), ldu )
                       if ( nr > 1 )call stdlib_claset('L',nr-1,nr-1,czero,czero,u(nr+2,1),ldu)
                                 
                       call stdlib_cgelqf( nr, n, u(nr+1,1), ldu, cwork(n+1),cwork(n+nr+1), &
                                 lcwork-n-nr, ierr )
                       call stdlib_clacpy('L',nr,nr,u(nr+1,1),ldu,v,ldv)
                       if ( nr > 1 )call stdlib_claset('U',nr-1,nr-1,czero,czero,v(1,2),ldv)
                                 
                       call stdlib_cgesvd( 'S', 'O', nr, nr, v, ldv, s, u, ldu,v, ldv, cwork(n+nr+&
                                 1), lcwork-n-nr, rwork, info )
                       call stdlib_claset('A',n-nr,nr,czero,czero,v(nr+1,1),ldv)
                       call stdlib_claset('A',nr,n-nr,czero,czero,v(1,nr+1),ldv)
                       call stdlib_claset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                       call stdlib_cunmlq('R','N',n,n,nr,u(nr+1,1),ldu,cwork(n+1),v, ldv, cwork(n+&
                                 nr+1),lcwork-n-nr,ierr)
                       call stdlib_clapmt( .false., n, n, v, ldv, iwork )
                     ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
                       if ( ( nr < m ) .and. .not.(wntuf)) then
                          call stdlib_claset('A',m-nr,nr,czero,czero,u(nr+1,1),ldu)
                          if ( nr < n1 ) then
                          call stdlib_claset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                          call stdlib_claset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1), ldu )
                                    
                          end if
                       end if
                    end if
                  end if
              ! .. end of the "r**h or r" branch
              end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! vectors matrix u.
              if ( .not. wntuf )call stdlib_cunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, &
                        cwork(n+1), lcwork-n, ierr )
              if ( rowprm .and. .not.wntuf )call stdlib_claswp( n1, u, ldu, 1, m-1, iwork(n+1), -&
                        1 )
           ! ... end of the "full svd" branch
           end if
           ! check whether some singular values are returned as zeros, e.g.
           ! due to underflow, and update the numerical rank.
           p = nr
           do q = p, 1, -1
               if ( s(q) > zero ) go to 4002
               nr = nr - 1
           end do
           4002 continue
           ! .. if numerical rank deficiency is detected, the truncated
           ! singular values are set to zero.
           if ( nr < n ) call stdlib_slaset( 'G', n-nr,1, zero,zero, s(nr+1), n )
           ! .. undo scaling; this may cause overflow in the largest singular
           ! values.
           if ( ascaled )call stdlib_slascl( 'G',0,0, one,sqrt(real(m,KIND=sp)), nr,1, s, n, ierr &
                     )
           if ( conda ) rwork(1) = sconda
           rwork(2) = p - nr
           ! .. p-nr is the number of singular values that are computed as
           ! exact zeros in stdlib_cgesvd() applied to the (possibly truncated)
           ! full row rank triangular (trapezoidal) factor of a.
           numrank = nr
           return
     end subroutine stdlib_cgesvdq


     subroutine stdlib_cgesvx( fact, trans, n, nrhs, a, lda, af, ldaf, ipiv,equed, r, c, b, ldb, &
     !! CGESVX uses the LU factorization to compute the solution to a complex
     !! system of linear equations
     !! A * X = B,
     !! where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               x, ldx, rcond, ferr, berr,work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(inout) :: equed
           character, intent(in) :: fact, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           real(sp), intent(inout) :: c(*), r(*)
           complex(sp), intent(inout) :: a(lda,*), af(ldaf,*), b(ldb,*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: colequ, equil, nofact, notran, rowequ
           character :: norm
           integer(ilp) :: i, infequ, j
           real(sp) :: amax, anorm, bignum, colcnd, rcmax, rcmin, rowcnd, rpvgrw, smlnum
           ! Intrinsic Functions 
           intrinsic :: max,min
           ! Executable Statements 
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           equil = stdlib_lsame( fact, 'E' )
           notran = stdlib_lsame( trans, 'N' )
           if( nofact .or. equil ) then
              equed = 'N'
              rowequ = .false.
              colequ = .false.
           else
              rowequ = stdlib_lsame( equed, 'R' ) .or. stdlib_lsame( equed, 'B' )
              colequ = stdlib_lsame( equed, 'C' ) .or. stdlib_lsame( equed, 'B' )
              smlnum = stdlib_slamch( 'SAFE MINIMUM' )
              bignum = one / smlnum
           end if
           ! test the input parameters.
           if( .not.nofact .and. .not.equil .and. .not.stdlib_lsame( fact, 'F' ) )then
              info = -1
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) .and. .not.stdlib_lsame( &
                     trans, 'C' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldaf<max( 1, n ) ) then
              info = -8
           else if( stdlib_lsame( fact, 'F' ) .and. .not.( rowequ .or. colequ .or. stdlib_lsame( &
                     equed, 'N' ) ) ) then
              info = -10
           else
              if( rowequ ) then
                 rcmin = bignum
                 rcmax = zero
                 do j = 1, n
                    rcmin = min( rcmin, r( j ) )
                    rcmax = max( rcmax, r( j ) )
                 end do
                 if( rcmin<=zero ) then
                    info = -11
                 else if( n>0 ) then
                    rowcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
                 else
                    rowcnd = one
                 end if
              end if
              if( colequ .and. info==0 ) then
                 rcmin = bignum
                 rcmax = zero
                 do j = 1, n
                    rcmin = min( rcmin, c( j ) )
                    rcmax = max( rcmax, c( j ) )
                 end do
                 if( rcmin<=zero ) then
                    info = -12
                 else if( n>0 ) then
                    colcnd = max( rcmin, smlnum ) / min( rcmax, bignum )
                 else
                    colcnd = one
                 end if
              end if
              if( info==0 ) then
                 if( ldb<max( 1, n ) ) then
                    info = -14
                 else if( ldx<max( 1, n ) ) then
                    info = -16
                 end if
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGESVX', -info )
              return
           end if
           if( equil ) then
              ! compute row and column scalings to equilibrate the matrix a.
              call stdlib_cgeequ( n, n, a, lda, r, c, rowcnd, colcnd, amax, infequ )
              if( infequ==0 ) then
                 ! equilibrate the matrix.
                 call stdlib_claqge( n, n, a, lda, r, c, rowcnd, colcnd, amax,equed )
                 rowequ = stdlib_lsame( equed, 'R' ) .or. stdlib_lsame( equed, 'B' )
                 colequ = stdlib_lsame( equed, 'C' ) .or. stdlib_lsame( equed, 'B' )
              end if
           end if
           ! scale the right hand side.
           if( notran ) then
              if( rowequ ) then
                 do j = 1, nrhs
                    do i = 1, n
                       b( i, j ) = r( i )*b( i, j )
                    end do
                 end do
              end if
           else if( colequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    b( i, j ) = c( i )*b( i, j )
                 end do
              end do
           end if
           if( nofact .or. equil ) then
              ! compute the lu factorization of a.
              call stdlib_clacpy( 'FULL', n, n, a, lda, af, ldaf )
              call stdlib_cgetrf( n, n, af, ldaf, ipiv, info )
              ! return if info is non-zero.
              if( info>0 ) then
                 ! compute the reciprocal pivot growth factor of the
                 ! leading rank-deficient info columns of a.
                 rpvgrw = stdlib_clantr( 'M', 'U', 'N', info, info, af, ldaf,rwork )
                 if( rpvgrw==zero ) then
                    rpvgrw = one
                 else
                    rpvgrw = stdlib_clange( 'M', n, info, a, lda, rwork ) /rpvgrw
                 end if
                 rwork( 1 ) = rpvgrw
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a and the
           ! reciprocal pivot growth factor rpvgrw.
           if( notran ) then
              norm = '1'
           else
              norm = 'I'
           end if
           anorm = stdlib_clange( norm, n, n, a, lda, rwork )
           rpvgrw = stdlib_clantr( 'M', 'U', 'N', n, n, af, ldaf, rwork )
           if( rpvgrw==zero ) then
              rpvgrw = one
           else
              rpvgrw = stdlib_clange( 'M', n, n, a, lda, rwork ) / rpvgrw
           end if
           ! compute the reciprocal of the condition number of a.
           call stdlib_cgecon( norm, n, af, ldaf, anorm, rcond, work, rwork, info )
           ! compute the solution matrix x.
           call stdlib_clacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_cgetrs( trans, n, nrhs, af, ldaf, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solution and
           ! compute error bounds and backward error estimates for it.
           call stdlib_cgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x,ldx, ferr, berr, &
                     work, rwork, info )
           ! transform the solution matrix x to a solution of the original
           ! system.
           if( notran ) then
              if( colequ ) then
                 do j = 1, nrhs
                    do i = 1, n
                       x( i, j ) = c( i )*x( i, j )
                    end do
                 end do
                 do j = 1, nrhs
                    ferr( j ) = ferr( j ) / colcnd
                 end do
              end if
           else if( rowequ ) then
              do j = 1, nrhs
                 do i = 1, n
                    x( i, j ) = r( i )*x( i, j )
                 end do
              end do
              do j = 1, nrhs
                 ferr( j ) = ferr( j ) / rowcnd
              end do
           end if
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           rwork( 1 ) = rpvgrw
           return
     end subroutine stdlib_cgesvx


     subroutine stdlib_cgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
     !! CGETSLS solves overdetermined or underdetermined complex linear systems
     !! involving an M-by-N matrix A, using a tall skinny QR or short wide LQ
     !! factorization of A.  It is assumed that A has full rank.
     !! The following options are provided:
     !! 1. If TRANS = 'N' and m >= n:  find the least squares solution of
     !! an overdetermined system, i.e., solve the least squares problem
     !! minimize || B - A*X ||.
     !! 2. If TRANS = 'N' and m < n:  find the minimum norm solution of
     !! an underdetermined system A * X = B.
     !! 3. If TRANS = 'C' and m >= n:  find the minimum norm solution of
     !! an undetermined system A**T * X = B.
     !! 4. If TRANS = 'C' and m < n:  find the least squares solution of
     !! an overdetermined system, i.e., solve the least squares problem
     !! minimize || B - A**T * X ||.
     !! Several right hand side vectors b and solution vectors x can be
     !! handled in a single call; they are stored as the columns of the
     !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution
     !! matrix X.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, nrhs
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery, tran
           integer(ilp) :: i, iascl, ibscl, j, maxmn, brow, scllen, tszo, tszm, lwo, lwm, lw1, &
                     lw2, wsizeo, wsizem, info2
           real(sp) :: anrm, bignum, bnrm, smlnum, dum(1)
           complex(sp) :: tq(5), workq(1)
           ! Intrinsic Functions 
           intrinsic :: real,max,min,int
           ! Executable Statements 
           ! test the input arguments.
           info = 0
           maxmn = max( m, n )
           tran  = stdlib_lsame( trans, 'C' )
           lquery = ( lwork==-1 .or. lwork==-2 )
           if( .not.( stdlib_lsame( trans, 'N' ) .or.stdlib_lsame( trans, 'C' ) ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldb<max( 1, m, n ) ) then
              info = -8
           end if
           if( info==0 ) then
           ! determine the optimum and minimum lwork
            if( m>=n ) then
              call stdlib_cgeqr( m, n, a, lda, tq, -1, workq, -1, info2 )
              tszo = int( tq( 1 ),KIND=ilp)
              lwo  = int( workq( 1 ),KIND=ilp)
              call stdlib_cgemqr( 'L', trans, m, nrhs, n, a, lda, tq,tszo, b, ldb, workq, -1, &
                        info2 )
              lwo  = max( lwo, int( workq( 1 ),KIND=ilp) )
              call stdlib_cgeqr( m, n, a, lda, tq, -2, workq, -2, info2 )
              tszm = int( tq( 1 ),KIND=ilp)
              lwm  = int( workq( 1 ),KIND=ilp)
              call stdlib_cgemqr( 'L', trans, m, nrhs, n, a, lda, tq,tszm, b, ldb, workq, -1, &
                        info2 )
              lwm = max( lwm, int( workq( 1 ),KIND=ilp) )
              wsizeo = tszo + lwo
              wsizem = tszm + lwm
            else
              call stdlib_cgelq( m, n, a, lda, tq, -1, workq, -1, info2 )
              tszo = int( tq( 1 ),KIND=ilp)
              lwo  = int( workq( 1 ),KIND=ilp)
              call stdlib_cgemlq( 'L', trans, n, nrhs, m, a, lda, tq,tszo, b, ldb, workq, -1, &
                        info2 )
              lwo  = max( lwo, int( workq( 1 ),KIND=ilp) )
              call stdlib_cgelq( m, n, a, lda, tq, -2, workq, -2, info2 )
              tszm = int( tq( 1 ),KIND=ilp)
              lwm  = int( workq( 1 ),KIND=ilp)
              call stdlib_cgemlq( 'L', trans, n, nrhs, m, a, lda, tq,tszm, b, ldb, workq, -1, &
                        info2 )
              lwm  = max( lwm, int( workq( 1 ),KIND=ilp) )
              wsizeo = tszo + lwo
              wsizem = tszm + lwm
            end if
            if( ( lwork<wsizem ).and.( .not.lquery ) ) then
               info = -10
            end if
            work( 1 ) = real( wsizeo,KIND=sp)
           end if
           if( info/=0 ) then
             call stdlib_xerbla( 'CGETSLS', -info )
             return
           end if
           if( lquery ) then
             if( lwork==-2 ) work( 1 ) = real( wsizem,KIND=sp)
             return
           end if
           if( lwork<wsizeo ) then
             lw1 = tszm
             lw2 = lwm
           else
             lw1 = tszo
             lw2 = lwo
           end if
           ! quick return if possible
           if( min( m, n, nrhs )==0 ) then
                call stdlib_claset( 'FULL', max( m, n ), nrhs, czero, czero,b, ldb )
                return
           end if
           ! get machine parameters
            smlnum = stdlib_slamch( 'S' ) / stdlib_slamch( 'P' )
            bignum = one / smlnum
            call stdlib_slabad( smlnum, bignum )
           ! scale a, b if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', m, n, a, lda, dum )
           iascl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_clascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, info )
              iascl = 1
           else if( anrm>bignum ) then
              ! scale matrix norm down to bignum
              call stdlib_clascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, info )
              iascl = 2
           else if( anrm==zero ) then
              ! matrix all zero. return zero solution.
              call stdlib_claset( 'F', maxmn, nrhs, czero, czero, b, ldb )
              go to 50
           end if
           brow = m
           if ( tran ) then
             brow = n
           end if
           bnrm = stdlib_clange( 'M', brow, nrhs, b, ldb, dum )
           ibscl = 0
           if( bnrm>zero .and. bnrm<smlnum ) then
              ! scale matrix norm up to smlnum
              call stdlib_clascl( 'G', 0, 0, bnrm, smlnum, brow, nrhs, b, ldb,info )
              ibscl = 1
           else if( bnrm>bignum ) then
              ! scale matrix norm down to bignum
              call stdlib_clascl( 'G', 0, 0, bnrm, bignum, brow, nrhs, b, ldb,info )
              ibscl = 2
           end if
           if ( m>=n ) then
              ! compute qr factorization of a
             call stdlib_cgeqr( m, n, a, lda, work( lw2+1 ), lw1,work( 1 ), lw2, info )
             if ( .not.tran ) then
                 ! least-squares problem min || a * x - b ||
                 ! b(1:m,1:nrhs) := q**t * b(1:m,1:nrhs)
               call stdlib_cgemqr( 'L' , 'C', m, nrhs, n, a, lda,work( lw2+1 ), lw1, b, ldb, work(&
                          1 ), lw2,info )
                 ! b(1:n,1:nrhs) := inv(r) * b(1:n,1:nrhs)
               call stdlib_ctrtrs( 'U', 'N', 'N', n, nrhs,a, lda, b, ldb, info )
               if( info>0 ) then
                 return
               end if
               scllen = n
             else
                 ! overdetermined system of equations a**t * x = b
                 ! b(1:n,1:nrhs) := inv(r**t) * b(1:n,1:nrhs)
                 call stdlib_ctrtrs( 'U', 'C', 'N', n, nrhs,a, lda, b, ldb, info )
                 if( info>0 ) then
                    return
                 end if
                 ! b(n+1:m,1:nrhs) = czero
                 do j = 1, nrhs
                    do i = n + 1, m
                       b( i, j ) = czero
                    end do
                 end do
                 ! b(1:m,1:nrhs) := q(1:n,:) * b(1:n,1:nrhs)
                 call stdlib_cgemqr( 'L', 'N', m, nrhs, n, a, lda,work( lw2+1 ), lw1, b, ldb, &
                           work( 1 ), lw2,info )
                 scllen = m
              end if
           else
              ! compute lq factorization of a
              call stdlib_cgelq( m, n, a, lda, work( lw2+1 ), lw1,work( 1 ), lw2, info )
              ! workspace at least m, optimally m*nb.
              if( .not.tran ) then
                 ! underdetermined system of equations a * x = b
                 ! b(1:m,1:nrhs) := inv(l) * b(1:m,1:nrhs)
                 call stdlib_ctrtrs( 'L', 'N', 'N', m, nrhs,a, lda, b, ldb, info )
                 if( info>0 ) then
                    return
                 end if
                 ! b(m+1:n,1:nrhs) = 0
                 do j = 1, nrhs
                    do i = m + 1, n
                       b( i, j ) = czero
                    end do
                 end do
                 ! b(1:n,1:nrhs) := q(1:n,:)**t * b(1:m,1:nrhs)
                 call stdlib_cgemlq( 'L', 'C', n, nrhs, m, a, lda,work( lw2+1 ), lw1, b, ldb, &
                           work( 1 ), lw2,info )
                 ! workspace at least nrhs, optimally nrhs*nb
                 scllen = n
              else
                 ! overdetermined system min || a**t * x - b ||
                 ! b(1:n,1:nrhs) := q * b(1:n,1:nrhs)
                 call stdlib_cgemlq( 'L', 'N', n, nrhs, m, a, lda,work( lw2+1 ), lw1, b, ldb, &
                           work( 1 ), lw2,info )
                 ! workspace at least nrhs, optimally nrhs*nb
                 ! b(1:m,1:nrhs) := inv(l**t) * b(1:m,1:nrhs)
                 call stdlib_ctrtrs( 'L', 'C', 'N', m, nrhs,a, lda, b, ldb, info )
                 if( info>0 ) then
                    return
                 end if
                 scllen = m
              end if
           end if
           ! undo scaling
           if( iascl==1 ) then
             call stdlib_clascl( 'G', 0, 0, anrm, smlnum, scllen, nrhs, b, ldb,info )
           else if( iascl==2 ) then
             call stdlib_clascl( 'G', 0, 0, anrm, bignum, scllen, nrhs, b, ldb,info )
           end if
           if( ibscl==1 ) then
             call stdlib_clascl( 'G', 0, 0, smlnum, bnrm, scllen, nrhs, b, ldb,info )
           else if( ibscl==2 ) then
             call stdlib_clascl( 'G', 0, 0, bignum, bnrm, scllen, nrhs, b, ldb,info )
           end if
           50 continue
           work( 1 ) = real( tszo + lwo,KIND=sp)
           return
     end subroutine stdlib_cgetsls


     pure subroutine stdlib_cgetsqrhrt( m, n, mb1, nb1, nb2, a, lda, t, ldt, work,lwork, info )
     !! CGETSQRHRT computes a NB2-sized column blocked QR-factorization
     !! of a complex M-by-N matrix A with M >= N,
     !! A = Q * R.
     !! The routine uses internally a NB1-sized column blocked and MB1-sized
     !! row blocked TSQR-factorization and perfors the reconstruction
     !! of the Householder vectors from the TSQR output. The routine also
     !! converts the R_tsqr factor from the TSQR-factorization output into
     !! the R factor that corresponds to the Householder QR-factorization,
     !! A = Q_tsqr * R_tsqr = Q * R.
     !! The output Q and R factors are stored in the same format as in CGEQRT
     !! (Q is in blocked compact WY-representation). See the documentation
     !! of CGEQRT for more details on the format.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldt, lwork, m, n, nb1, nb2, mb1
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: t(ldt,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, lw1, lw2, lwt, ldwt, lworkopt, nb1local, nb2local, &
                     num_all_row_blocks
           ! Intrinsic Functions 
           intrinsic :: ceiling,real,cmplx,max,min
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery  = lwork==-1
           if( m<0 ) then
              info = -1
           else if( n<0 .or. m<n ) then
              info = -2
           else if( mb1<=n ) then
              info = -3
           else if( nb1<1 ) then
              info = -4
           else if( nb2<1 ) then
              info = -5
           else if( lda<max( 1, m ) ) then
              info = -7
           else if( ldt<max( 1,  min( nb2, n ) ) ) then
              info = -9
           else
              ! test the input lwork for the dimension of the array work.
              ! this workspace is used to store array:
              ! a) matrix t and work for stdlib_clatsqr;
              ! b) n-by-n upper-triangular factor r_tsqr;
              ! c) matrix t and array work for stdlib_cungtsqr_row;
              ! d) diagonal d for stdlib_cunhr_col.
              if( lwork<n*n+1 .and. .not.lquery ) then
                 info = -11
              else
                 ! set block size for column blocks
                 nb1local = min( nb1, n )
                 num_all_row_blocks = max( 1,ceiling( real( m - n,KIND=sp) / real( mb1 - n,&
                           KIND=sp) ) )
                 ! length and leading dimension of work array to place
                 ! t array in tsqr.
                 lwt = num_all_row_blocks * n * nb1local
                 ldwt = nb1local
                 ! length of tsqr work array
                 lw1 = nb1local * n
                 ! length of stdlib_cungtsqr_row work array.
                 lw2 = nb1local * max( nb1local, ( n - nb1local ) )
                 lworkopt = max( lwt + lw1, max( lwt+n*n+lw2, lwt+n*n+n ) )
                 if( ( lwork<max( 1, lworkopt ) ).and.(.not.lquery) ) then
                    info = -11
                 end if
              end if
           end if
           ! handle error in the input parameters and return workspace query.
           if( info/=0 ) then
              call stdlib_xerbla( 'CGETSQRHRT', -info )
              return
           else if ( lquery ) then
              work( 1 ) = cmplx( lworkopt,KIND=sp)
              return
           end if
           ! quick return if possible
           if( min( m, n )==0 ) then
              work( 1 ) = cmplx( lworkopt,KIND=sp)
              return
           end if
           nb2local = min( nb2, n )
           ! (1) perform tsqr-factorization of the m-by-n matrix a.
           call stdlib_clatsqr( m, n, mb1, nb1local, a, lda, work, ldwt,work(lwt+1), lw1, iinfo )
                     
           ! (2) copy the factor r_tsqr stored in the upper-triangular part
               ! of a into the square matrix in the work array
               ! work(lwt+1:lwt+n*n) column-by-column.
           do j = 1, n
              call stdlib_ccopy( j, a( 1, j ), 1, work( lwt + n*(j-1)+1 ), 1 )
           end do
           ! (3) generate a m-by-n matrix q with orthonormal columns from
           ! the result stored below the diagonal in the array a in place.
           call stdlib_cungtsqr_row( m, n, mb1, nb1local, a, lda, work, ldwt,work( lwt+n*n+1 ), &
                     lw2, iinfo )
           ! (4) perform the reconstruction of householder vectors from
           ! the matrix q (stored in a) in place.
           call stdlib_cunhr_col( m, n, nb2local, a, lda, t, ldt,work( lwt+n*n+1 ), iinfo )
                     
           ! (5) copy the factor r_tsqr stored in the square matrix in the
           ! work array work(lwt+1:lwt+n*n) into the upper-triangular
           ! part of a.
           ! (6) compute from r_tsqr the factor r_hr corresponding to
           ! the reconstructed householder vectors, i.e. r_hr = s * r_tsqr.
           ! this multiplication by the sign matrix s on the left means
           ! changing the sign of i-th row of the matrix r_tsqr according
           ! to sign of the i-th diagonal element diag(i) of the matrix s.
           ! diag is stored in work( lwt+n*n+1 ) from the stdlib_cunhr_col output.
           ! (5) and (6) can be combined in a single loop, so the rows in a
           ! are accessed only once.
           do i = 1, n
              if( work( lwt+n*n+i )==-cone ) then
                 do j = i, n
                    a( i, j ) = -cone * work( lwt+n*(j-1)+i )
                 end do
              else
                 call stdlib_ccopy( n-i+1, work(lwt+n*(i-1)+i), n, a( i, i ), lda )
              end if
           end do
           work( 1 ) = cmplx( lworkopt,KIND=sp)
           return
     end subroutine stdlib_cgetsqrhrt


     subroutine stdlib_cgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alpha, beta, &
     !! CGGES computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, the generalized complex Schur
     !! form (S, T), and optionally left and/or right Schur vectors (VSL
     !! and VSR). This gives the generalized Schur factorization
     !! (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )
     !! where (VSR)**H is the conjugate-transpose of VSR.
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! triangular matrix S and the upper triangular matrix T. The leading
     !! columns of VSL and VSR then form an unitary basis for the
     !! corresponding left and right eigenspaces (deflating subspaces).
     !! (If only the generalized eigenvalues are needed, use the driver
     !! CGGEV instead, which is faster.)
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0, and even for both being zero.
     !! A pair of matrices (S,T) is in generalized complex Schur form if S
     !! and T are upper triangular and, in addition, the diagonal elements
     !! of T are non-negative real numbers.
               vsl, ldvsl, vsr, ldvsr, work,lwork, rwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           ! Function Arguments 
           procedure(stdlib_selctg_c) :: selctg
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, wantst
           integer(ilp) :: i, icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, iright, irows, irwrk, &
                     itau, iwrk, lwkmin, lwkopt
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl, pvsr, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(sp) :: dif(2)
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -14
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -16
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              lwkmin = max( 1, 2*n )
              lwkopt = max( 1, n + n*stdlib_ilaenv( 1, 'CGEQRF', ' ', n, 1, n, 0 ) )
              lwkopt = max( lwkopt, n +n*stdlib_ilaenv( 1, 'CUNMQR', ' ', n, 1, n, -1 ) )
              if( ilvsl ) then
                 lwkopt = max( lwkopt, n +n*stdlib_ilaenv( 1, 'CUNGQR', ' ', n, 1, n, -1 ) )
                           
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery )info = -18
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGES ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_clange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (real workspace: need 6*n)
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_cggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (complex workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = 1
           iwrk = itau + irows
           call stdlib_cgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (complex workspace: need n, prefer n*nb)
           call stdlib_cunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           ! (complex workspace: need n, prefer n*nb)
           if( ilvsl ) then
              call stdlib_claset( 'FULL', n, n, czero, cone, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_clacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_cungqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_claset( 'FULL', n, n, czero, cone, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           call stdlib_cgghrd( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      ierr )
           sdim = 0
           ! perform qz algorithm, computing schur vectors if desired
           ! (complex workspace: need n)
           ! (real workspace: need n)
           iwrk = itau
           call stdlib_chgeqz( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vsl, &
                     ldvsl, vsr, ldvsr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 30
           end if
           ! sort eigenvalues alpha/beta if desired
           ! (workspace: none needed)
           if( wantst ) then
              ! undo scaling on eigenvalues before selecting
              if( ilascl )call stdlib_clascl( 'G', 0, 0, anrm, anrmto, n, 1, alpha, n, ierr )
                        
              if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrm, bnrmto, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alpha( i ), beta( i ) )
              end do
              call stdlib_ctgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb, alpha,beta, vsl, &
              ldvsl, vsr, ldvsr, sdim, pvsl, pvsr,dif, work( iwrk ), lwork-iwrk+1, idum, 1, ierr )
                        
              if( ierr==1 )info = n + 3
           end if
           ! apply back-permutation to vsl and vsr
           ! (workspace: none needed)
           if( ilvsl )call stdlib_cggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_cggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsr, ldvsr, ierr )
           ! undo scaling
           if( ilascl ) then
              call stdlib_clascl( 'U', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_clascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_clascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_clascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              sdim = 0
              do i = 1, n
                 cursl = selctg( alpha( i ), beta( i ) )
                 if( cursl )sdim = sdim + 1
                 if( cursl .and. .not.lastsl )info = n + 2
                 lastsl = cursl
              end do
           end if
           30 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cgges


     subroutine stdlib_cggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,b, ldb, sdim, alpha,&
     !! CGGESX computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, the complex Schur form (S,T),
     !! and, optionally, the left and/or right matrices of Schur vectors (VSL
     !! and VSR).  This gives the generalized Schur factorization
     !! (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H )
     !! where (VSR)**H is the conjugate-transpose of VSR.
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! triangular matrix S and the upper triangular matrix T; computes
     !! a reciprocal condition number for the average of the selected
     !! eigenvalues (RCONDE); and computes a reciprocal condition number for
     !! the right and left deflating subspaces corresponding to the selected
     !! eigenvalues (RCONDV). The leading columns of VSL and VSR then form
     !! an orthonormal basis for the corresponding left and right eigenspaces
     !! (deflating subspaces).
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0 or for both being zero.
     !! A pair of matrices (S,T) is in generalized complex Schur form if T is
     !! upper triangular with non-negative diagonal and S is upper
     !! triangular.
      beta, vsl, ldvsl, vsr,ldvsr, rconde, rcondv, work, lwork, rwork,iwork, liwork, bwork, info )
                
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sense, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, liwork, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: rconde(2), rcondv(2), rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           ! Function Arguments 
           procedure(stdlib_selctg_c) :: selctg
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, wantsb, wantse, &
                     wantsn, wantst, wantsv
           integer(ilp) :: i, icols, ierr, ihi, ijob, ijobvl, ijobvr, ileft, ilo, iright, irows, &
                     irwrk, itau, iwrk, liwmin, lwrk, maxwrk, minwrk
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pl, pr, smlnum
           ! Local Arrays 
           real(sp) :: dif(2)
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( wantsn ) then
              ijob = 0
           else if( wantse ) then
              ijob = 1
           else if( wantsv ) then
              ijob = 2
           else if( wantsb ) then
              ijob = 4
           end if
           ! test the input arguments
           info = 0
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( .not.( wantsn .or. wantse .or. wantsv .or. wantsb ) .or.( .not.wantst .and. &
                     .not.wantsn ) ) then
              info = -5
           else if( n<0 ) then
              info = -6
           else if( lda<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -15
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -17
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              if( n>0) then
                 minwrk = 2*n
                 maxwrk = n*(1 + stdlib_ilaenv( 1, 'CGEQRF', ' ', n, 1, n, 0 ) )
                 maxwrk = max( maxwrk, n*( 1 +stdlib_ilaenv( 1, 'CUNMQR', ' ', n, 1, n, -1 ) ) )
                           
                 if( ilvsl ) then
                    maxwrk = max( maxwrk, n*( 1 +stdlib_ilaenv( 1, 'CUNGQR', ' ', n, 1, n, -1 ) ) &
                              )
                 end if
                 lwrk = maxwrk
                 if( ijob>=1 )lwrk = max( lwrk, n*n/2 )
              else
                 minwrk = 1
                 maxwrk = 1
                 lwrk   = 1
              end if
              work( 1 ) = lwrk
              if( wantsn .or. n==0 ) then
                 liwmin = 1
              else
                 liwmin = n + 2
              end if
              iwork( 1 ) = liwmin
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -21
              else if( liwork<liwmin  .and. .not.lquery) then
                 info = -24
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGESX', -info )
              return
           else if (lquery) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_clange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (real workspace: need 6*n)
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_cggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (complex workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = 1
           iwrk = itau + irows
           call stdlib_cgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the unitary transformation to matrix a
           ! (complex workspace: need n, prefer n*nb)
           call stdlib_cunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           ! (complex workspace: need n, prefer n*nb)
           if( ilvsl ) then
              call stdlib_claset( 'FULL', n, n, czero, cone, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_clacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_cungqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_claset( 'FULL', n, n, czero, cone, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           call stdlib_cgghrd( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      ierr )
           sdim = 0
           ! perform qz algorithm, computing schur vectors if desired
           ! (complex workspace: need n)
           ! (real workspace:    need n)
           iwrk = itau
           call stdlib_chgeqz( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vsl, &
                     ldvsl, vsr, ldvsr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 40
           end if
           ! sort eigenvalues alpha/beta and compute the reciprocal of
           ! condition number(s)
           if( wantst ) then
              ! undo scaling on eigenvalues before selctging
              if( ilascl )call stdlib_clascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
                        
              if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alpha( i ), beta( i ) )
              end do
              ! reorder eigenvalues, transform generalized schur vectors, and
              ! compute reciprocal condition numbers
              ! (complex workspace: if ijob >= 1, need max(1, 2*sdim*(n-sdim))
                                  ! otherwise, need 1 )
              call stdlib_ctgsen( ijob, ilvsl, ilvsr, bwork, n, a, lda, b, ldb,alpha, beta, vsl, &
              ldvsl, vsr, ldvsr, sdim, pl, pr,dif, work( iwrk ), lwork-iwrk+1, iwork, liwork,ierr &
                        )
              if( ijob>=1 )maxwrk = max( maxwrk, 2*sdim*( n-sdim ) )
              if( ierr==-21 ) then
                  ! not enough complex workspace
                 info = -21
              else
                 if( ijob==1 .or. ijob==4 ) then
                    rconde( 1 ) = pl
                    rconde( 2 ) = pr
                 end if
                 if( ijob==2 .or. ijob==4 ) then
                    rcondv( 1 ) = dif( 1 )
                    rcondv( 2 ) = dif( 2 )
                 end if
                 if( ierr==1 )info = n + 3
              end if
           end if
           ! apply permutation to vsl and vsr
           ! (workspace: none needed)
           if( ilvsl )call stdlib_cggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_cggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsr, ldvsr, ierr )
           ! undo scaling
           if( ilascl ) then
              call stdlib_clascl( 'U', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_clascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_clascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_clascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              sdim = 0
              do i = 1, n
                 cursl = selctg( alpha( i ), beta( i ) )
                 if( cursl )sdim = sdim + 1
                 if( cursl .and. .not.lastsl )info = n + 2
                 lastsl = cursl
              end do
           end if
           40 continue
           work( 1 ) = maxwrk
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_cggesx


     subroutine stdlib_cggev( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
     !! CGGEV computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, and optionally, the left and/or
     !! right generalized eigenvectors.
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right generalized eigenvector v(j) corresponding to the
     !! generalized eigenvalue lambda(j) of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j).
     !! The left generalized eigenvector u(j) corresponding to the
     !! generalized eigenvalues lambda(j) of (A,B) satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H * B
     !! where u(j)**H is the conjugate-transpose of u(j).
               work, lwork, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery
           character :: chtemp
           integer(ilp) :: icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, in, iright, irows, irwrk,&
                      itau, iwrk, jc, jr, lwkmin, lwkopt
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           complex(sp) :: x
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real,sqrt
           ! Statement Functions 
           real(sp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=sp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -11
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -13
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv. the workspace is
             ! computed assuming ilo = 1 and ihi = n, the worst case.)
           if( info==0 ) then
              lwkmin = max( 1, 2*n )
              lwkopt = max( 1, n + n*stdlib_ilaenv( 1, 'CGEQRF', ' ', n, 1, n, 0 ) )
              lwkopt = max( lwkopt, n +n*stdlib_ilaenv( 1, 'CUNMQR', ' ', n, 1, n, 0 ) )
              if( ilvl ) then
                 lwkopt = max( lwkopt, n +n*stdlib_ilaenv( 1, 'CUNGQR', ' ', n, 1, n, -1 ) )
                           
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery )info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'E' )*stdlib_slamch( 'B' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_clange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrices a, b to isolate eigenvalues if possible
           ! (real workspace: need 6*n)
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_cggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (complex workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           if( ilv ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = 1
           iwrk = itau + irows
           call stdlib_cgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (complex workspace: need n, prefer n*nb)
           call stdlib_cunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl
           ! (complex workspace: need n, prefer n*nb)
           if( ilvl ) then
              call stdlib_claset( 'FULL', n, n, czero, cone, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_clacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_cungqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vr
           if( ilvr )call stdlib_claset( 'FULL', n, n, czero, cone, vr, ldvr )
           ! reduce to generalized hessenberg form
           if( ilv ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_cgghrd( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        ierr )
           else
              call stdlib_cgghrd( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur form and schur vectors)
           ! (complex workspace: need n)
           ! (real workspace: need n)
           iwrk = itau
           if( ilv ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_chgeqz( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vl, &
                     ldvl, vr, ldvr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 70
           end if
           ! compute eigenvectors
           ! (real workspace: need 2*n)
           ! (complex workspace: need 2*n)
           if( ilv ) then
              if( ilvl ) then
                 if( ilvr ) then
                    chtemp = 'B'
                 else
                    chtemp = 'L'
                 end if
              else
                 chtemp = 'R'
              end if
              call stdlib_ctgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, n, &
                        in, work( iwrk ), rwork( irwrk ),ierr )
              if( ierr/=0 ) then
                 info = n + 2
                 go to 70
              end if
              ! undo balancing on vl and vr and normalization
              ! (workspace: none needed)
              if( ilvl ) then
                 call stdlib_cggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), n, vl,&
                            ldvl, ierr )
                 loop_30: do jc = 1, n
                    temp = zero
                    do jr = 1, n
                       temp = max( temp, abs1( vl( jr, jc ) ) )
                    end do
                    if( temp<smlnum )cycle loop_30
                    temp = one / temp
                    do jr = 1, n
                       vl( jr, jc ) = vl( jr, jc )*temp
                    end do
                 end do loop_30
              end if
              if( ilvr ) then
                 call stdlib_cggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), n, vr,&
                            ldvr, ierr )
                 loop_60: do jc = 1, n
                    temp = zero
                    do jr = 1, n
                       temp = max( temp, abs1( vr( jr, jc ) ) )
                    end do
                    if( temp<smlnum )cycle loop_60
                    temp = one / temp
                    do jr = 1, n
                       vr( jr, jc ) = vr( jr, jc )*temp
                    end do
                 end do loop_60
              end if
           end if
           ! undo scaling if necessary
           70 continue
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cggev


     subroutine stdlib_cggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,alpha, beta, vl, &
     !! CGGEVX computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B) the generalized eigenvalues, and optionally, the left and/or
     !! right generalized eigenvectors.
     !! Optionally, it also computes a balancing transformation to improve
     !! the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     !! LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
     !! the eigenvalues (RCONDE), and reciprocal condition numbers for the
     !! right eigenvectors (RCONDV).
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j) .
     !! The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! u(j)**H * A  = lambda(j) * u(j)**H * B.
     !! where u(j)**H is the conjugate-transpose of u(j).
     ldvl, vr, ldvr, ilo, ihi,lscale, rscale, abnrm, bbnrm, rconde, rcondv,work, lwork, rwork, &
               iwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(sp), intent(out) :: abnrm, bbnrm
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: lscale(*), rconde(*), rcondv(*), rscale(*), rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery, noscl, wantsb, wantse, wantsn, &
                     wantsv
           character :: chtemp
           integer(ilp) :: i, icols, ierr, ijobvl, ijobvr, in, irows, itau, iwrk, iwrk1, j, jc, &
                     jr, m, maxwrk, minwrk
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           complex(sp) :: x
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real,sqrt
           ! Statement Functions 
           real(sp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=sp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           noscl  = stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc, 'P' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( .not.( noscl .or. stdlib_lsame( balanc,'S' ) .or.stdlib_lsame( balanc, 'B' ) ) ) &
                     then
              info = -1
           else if( ijobvl<=0 ) then
              info = -2
           else if( ijobvr<=0 ) then
              info = -3
           else if( .not.( wantsn .or. wantse .or. wantsb .or. wantsv ) )then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -13
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -15
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv. the workspace is
             ! computed assuming ilo = 1 and ihi = n, the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 minwrk = 2*n
                 if( wantse ) then
                    minwrk = 4*n
                 else if( wantsv .or. wantsb ) then
                    minwrk = 2*n*( n + 1)
                 end if
                 maxwrk = minwrk
                 maxwrk = max( maxwrk,n + n*stdlib_ilaenv( 1, 'CGEQRF', ' ', n, 1, n, 0 ) )
                           
                 maxwrk = max( maxwrk,n + n*stdlib_ilaenv( 1, 'CUNMQR', ' ', n, 1, n, 0 ) )
                           
                 if( ilvl ) then
                    maxwrk = max( maxwrk, n +n*stdlib_ilaenv( 1, 'CUNGQR', ' ', n, 1, n, 0 ) )
                              
                 end if
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -25
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_clange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute and/or balance the matrix pair (a,b)
           ! (real workspace: need 6*n if balanc = 's' or 'b', 1 otherwise)
           call stdlib_cggbal( balanc, n, a, lda, b, ldb, ilo, ihi, lscale, rscale,rwork, ierr )
                     
           ! compute abnrm and bbnrm
           abnrm = stdlib_clange( '1', n, n, a, lda, rwork( 1 ) )
           if( ilascl ) then
              rwork( 1 ) = abnrm
              call stdlib_slascl( 'G', 0, 0, anrmto, anrm, 1, 1, rwork( 1 ), 1,ierr )
              abnrm = rwork( 1 )
           end if
           bbnrm = stdlib_clange( '1', n, n, b, ldb, rwork( 1 ) )
           if( ilbscl ) then
              rwork( 1 ) = bbnrm
              call stdlib_slascl( 'G', 0, 0, bnrmto, bnrm, 1, 1, rwork( 1 ), 1,ierr )
              bbnrm = rwork( 1 )
           end if
           ! reduce b to triangular form (qr decomposition of b)
           ! (complex workspace: need n, prefer n*nb )
           irows = ihi + 1 - ilo
           if( ilv .or. .not.wantsn ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = 1
           iwrk = itau + irows
           call stdlib_cgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the unitary transformation to a
           ! (complex workspace: need n, prefer n*nb)
           call stdlib_cunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl and/or vr
           ! (workspace: need n, prefer n*nb)
           if( ilvl ) then
              call stdlib_claset( 'FULL', n, n, czero, cone, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_clacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_cungqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           if( ilvr )call stdlib_claset( 'FULL', n, n, czero, cone, vr, ldvr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           if( ilv .or. .not.wantsn ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_cgghrd( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        ierr )
           else
              call stdlib_cgghrd( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur forms and schur vectors)
           ! (complex workspace: need n)
           ! (real workspace: need n)
           iwrk = itau
           if( ilv .or. .not.wantsn ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_chgeqz( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vl, &
                     ldvl, vr, ldvr, work( iwrk ),lwork+1-iwrk, rwork, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 90
           end if
           ! compute eigenvectors and estimate condition numbers if desired
           ! stdlib_ctgevc: (complex workspace: need 2*n )
                   ! (real workspace:    need 2*n )
           ! stdlib_ctgsna: (complex workspace: need 2*n*n if sense='v' or 'b')
                   ! (integer workspace: need n+2 )
           if( ilv .or. .not.wantsn ) then
              if( ilv ) then
                 if( ilvl ) then
                    if( ilvr ) then
                       chtemp = 'B'
                    else
                       chtemp = 'L'
                    end if
                 else
                    chtemp = 'R'
                 end if
                 call stdlib_ctgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, n,&
                            in, work( iwrk ), rwork,ierr )
                 if( ierr/=0 ) then
                    info = n + 2
                    go to 90
                 end if
              end if
              if( .not.wantsn ) then
                 ! compute eigenvectors (stdlib_ctgevc) and estimate condition
                 ! numbers (stdlib_ctgsna). note that the definition of the condition
                 ! number is not invariant under transformation (u,v) to
                 ! (q*u, z*v), where (u,v) are eigenvectors of the generalized
                 ! schur form (s,t), q and z are orthogonal matrices. in order
                 ! to avoid using extra 2*n*n workspace, we have to
                 ! re-calculate eigenvectors and estimate the condition numbers
                 ! one at a time.
                 do i = 1, n
                    do j = 1, n
                       bwork( j ) = .false.
                    end do
                    bwork( i ) = .true.
                    iwrk = n + 1
                    iwrk1 = iwrk + n
                    if( wantse .or. wantsb ) then
                       call stdlib_ctgevc( 'B', 'S', bwork, n, a, lda, b, ldb,work( 1 ), n, work( &
                                 iwrk ), n, 1, m,work( iwrk1 ), rwork, ierr )
                       if( ierr/=0 ) then
                          info = n + 2
                          go to 90
                       end if
                    end if
                    call stdlib_ctgsna( sense, 'S', bwork, n, a, lda, b, ldb,work( 1 ), n, work( &
                    iwrk ), n, rconde( i ),rcondv( i ), 1, m, work( iwrk1 ),lwork-iwrk1+1, iwork, &
                              ierr )
                 end do
              end if
           end if
           ! undo balancing on vl and vr and normalization
           ! (workspace: none needed)
           if( ilvl ) then
              call stdlib_cggbak( balanc, 'L', n, ilo, ihi, lscale, rscale, n, vl,ldvl, ierr )
                        
              loop_50: do jc = 1, n
                 temp = zero
                 do jr = 1, n
                    temp = max( temp, abs1( vl( jr, jc ) ) )
                 end do
                 if( temp<smlnum )cycle loop_50
                 temp = one / temp
                 do jr = 1, n
                    vl( jr, jc ) = vl( jr, jc )*temp
                 end do
              end do loop_50
           end if
           if( ilvr ) then
              call stdlib_cggbak( balanc, 'R', n, ilo, ihi, lscale, rscale, n, vr,ldvr, ierr )
                        
              loop_80: do jc = 1, n
                 temp = zero
                 do jr = 1, n
                    temp = max( temp, abs1( vr( jr, jc ) ) )
                 end do
                 if( temp<smlnum )cycle loop_80
                 temp = one / temp
                 do jr = 1, n
                    vr( jr, jc ) = vr( jr, jc )*temp
                 end do
              end do loop_80
           end if
           ! undo scaling if necessary
           90 continue
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_cggevx


     subroutine stdlib_chbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,rwork, info )
     !! CHBEV computes all the eigenvalues and, optionally, eigenvectors of
     !! a complex Hermitian band matrix A.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldz, n
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ab(ldab,*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lower, wantz
           integer(ilp) :: iinfo, imax, inde, indrwk, iscale
           real(sp) :: anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum
           ! Intrinsic Functions 
           intrinsic :: sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           lower = stdlib_lsame( uplo, 'L' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( lower .or. stdlib_lsame( uplo, 'U' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( kd<0 ) then
              info = -4
           else if( ldab<kd+1 ) then
              info = -6
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHBEV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( lower ) then
                 w( 1 ) = real( ab( 1, 1 ),KIND=sp)
              else
                 w( 1 ) = real( ab( kd+1, 1 ),KIND=sp)
              end if
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           anrm = stdlib_clanhb( 'M', uplo, n, kd, ab, ldab, rwork )
           iscale = 0
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 ) then
              if( lower ) then
                 call stdlib_clascl( 'B', kd, kd, one, sigma, n, n, ab, ldab, info )
              else
                 call stdlib_clascl( 'Q', kd, kd, one, sigma, n, n, ab, ldab, info )
              end if
           end if
           ! call stdlib_chbtrd to reduce hermitian band matrix to tridiagonal form.
           inde = 1
           call stdlib_chbtrd( jobz, uplo, n, kd, ab, ldab, w, rwork( inde ), z,ldz, work, iinfo )
                     
           ! for eigenvalues only, call stdlib_ssterf.  for eigenvectors, call stdlib_csteqr.
           if( .not.wantz ) then
              call stdlib_ssterf( n, w, rwork( inde ), info )
           else
              indrwk = inde + n
              call stdlib_csteqr( jobz, n, w, rwork( inde ), z, ldz,rwork( indrwk ), info )
                        
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = n
              else
                 imax = info - 1
              end if
              call stdlib_sscal( imax, one / sigma, w, 1 )
           end if
           return
     end subroutine stdlib_chbev


     subroutine stdlib_chbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, rwork, lrwork, &
     !! CHBEVD computes all the eigenvalues and, optionally, eigenvectors of
     !! a complex Hermitian band matrix A.  If eigenvectors are desired, it
     !! uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               iwork, liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldz, liwork, lrwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ab(ldab,*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lower, lquery, wantz
           integer(ilp) :: iinfo, imax, inde, indwk2, indwrk, iscale, liwmin, llrwk, llwk2, &
                     lrwmin, lwmin
           real(sp) :: anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum
           ! Intrinsic Functions 
           intrinsic :: sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           lower = stdlib_lsame( uplo, 'L' )
           lquery = ( lwork==-1 .or. liwork==-1 .or. lrwork==-1 )
           info = 0
           if( n<=1 ) then
              lwmin = 1
              lrwmin = 1
              liwmin = 1
           else
              if( wantz ) then
                 lwmin = 2*n**2
                 lrwmin = 1 + 5*n + 2*n**2
                 liwmin = 3 + 5*n
              else
                 lwmin = n
                 lrwmin = n
                 liwmin = 1
              end if
           end if
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( lower .or. stdlib_lsame( uplo, 'U' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( kd<0 ) then
              info = -4
           else if( ldab<kd+1 ) then
              info = -6
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -9
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              rwork( 1 ) = lrwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -11
              else if( lrwork<lrwmin .and. .not.lquery ) then
                 info = -13
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -15
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHBEVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              w( 1 ) = real( ab( 1, 1 ),KIND=sp)
              if( wantz )z( 1, 1 ) = cone
              return
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           anrm = stdlib_clanhb( 'M', uplo, n, kd, ab, ldab, rwork )
           iscale = 0
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 ) then
              if( lower ) then
                 call stdlib_clascl( 'B', kd, kd, one, sigma, n, n, ab, ldab, info )
              else
                 call stdlib_clascl( 'Q', kd, kd, one, sigma, n, n, ab, ldab, info )
              end if
           end if
           ! call stdlib_chbtrd to reduce hermitian band matrix to tridiagonal form.
           inde = 1
           indwrk = inde + n
           indwk2 = 1 + n*n
           llwk2 = lwork - indwk2 + 1
           llrwk = lrwork - indwrk + 1
           call stdlib_chbtrd( jobz, uplo, n, kd, ab, ldab, w, rwork( inde ), z,ldz, work, iinfo )
                     
           ! for eigenvalues only, call stdlib_ssterf.  for eigenvectors, call stdlib_cstedc.
           if( .not.wantz ) then
              call stdlib_ssterf( n, w, rwork( inde ), info )
           else
              call stdlib_cstedc( 'I', n, w, rwork( inde ), work, n, work( indwk2 ),llwk2, rwork( &
                        indwrk ), llrwk, iwork, liwork,info )
              call stdlib_cgemm( 'N', 'N', n, n, n, cone, z, ldz, work, n, czero,work( indwk2 ), &
                        n )
              call stdlib_clacpy( 'A', n, n, work( indwk2 ), n, z, ldz )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = n
              else
                 imax = info - 1
              end if
              call stdlib_sscal( imax, one / sigma, w, 1 )
           end if
           work( 1 ) = lwmin
           rwork( 1 ) = lrwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_chbevd


     subroutine stdlib_chbevx( jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl,vu, il, iu, abstol, &
     !! CHBEVX computes selected eigenvalues and, optionally, eigenvectors
     !! of a complex Hermitian band matrix A.  Eigenvalues and eigenvectors
     !! can be selected by specifying either a range of values or a range of
     !! indices for the desired eigenvalues.
               m, w, z, ldz, work, rwork,iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, iu, kd, ldab, ldq, ldz, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ab(ldab,*)
           complex(sp), intent(out) :: q(ldq,*), work(*), z(ldz,*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, lower, test, valeig, wantz
           character :: order
           integer(ilp) :: i, iinfo, imax, indd, inde, indee, indibl, indisp, indiwk, indrwk, &
                     indwrk, iscale, itmp1, j, jj, nsplit
           real(sp) :: abstll, anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum, tmp1, vll, &
                     vuu
           complex(sp) :: ctmp1
           ! Intrinsic Functions 
           intrinsic :: max,min,real,sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lower = stdlib_lsame( uplo, 'L' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( .not.( lower .or. stdlib_lsame( uplo, 'U' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( kd<0 ) then
              info = -5
           else if( ldab<kd+1 ) then
              info = -7
           else if( wantz .and. ldq<max( 1, n ) ) then
              info = -9
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -11
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -12
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -13
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) )info = -18
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHBEVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           if( n==1 ) then
              m = 1
              if( lower ) then
                 ctmp1 = ab( 1, 1 )
              else
                 ctmp1 = ab( kd+1, 1 )
              end if
              tmp1 = real( ctmp1,KIND=sp)
              if( valeig ) then
                 if( .not.( vl<tmp1 .and. vu>=tmp1 ) )m = 0
              end if
              if( m==1 ) then
                 w( 1 ) = real( ctmp1,KIND=sp)
                 if( wantz )z( 1, 1 ) = cone
              end if
              return
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           abstll = abstol
           if ( valeig ) then
              vll = vl
              vuu = vu
           else
              vll = zero
              vuu = zero
           endif
           anrm = stdlib_clanhb( 'M', uplo, n, kd, ab, ldab, rwork )
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 ) then
              if( lower ) then
                 call stdlib_clascl( 'B', kd, kd, one, sigma, n, n, ab, ldab, info )
              else
                 call stdlib_clascl( 'Q', kd, kd, one, sigma, n, n, ab, ldab, info )
              end if
              if( abstol>0 )abstll = abstol*sigma
              if( valeig ) then
                 vll = vl*sigma
                 vuu = vu*sigma
              end if
           end if
           ! call stdlib_chbtrd to reduce hermitian band matrix to tridiagonal form.
           indd = 1
           inde = indd + n
           indrwk = inde + n
           indwrk = 1
           call stdlib_chbtrd( jobz, uplo, n, kd, ab, ldab, rwork( indd ),rwork( inde ), q, ldq, &
                     work( indwrk ), iinfo )
           ! if all eigenvalues are desired and abstol is less than or equal
           ! to zero, then call stdlib_ssterf or stdlib_csteqr.  if this fails for some
           ! eigenvalue, then try stdlib_sstebz.
           test = .false.
           if (indeig) then
              if (il==1 .and. iu==n) then
                 test = .true.
              end if
           end if
           if ((alleig .or. test) .and. (abstol<=zero)) then
              call stdlib_scopy( n, rwork( indd ), 1, w, 1 )
              indee = indrwk + 2*n
              if( .not.wantz ) then
                 call stdlib_scopy( n-1, rwork( inde ), 1, rwork( indee ), 1 )
                 call stdlib_ssterf( n, w, rwork( indee ), info )
              else
                 call stdlib_clacpy( 'A', n, n, q, ldq, z, ldz )
                 call stdlib_scopy( n-1, rwork( inde ), 1, rwork( indee ), 1 )
                 call stdlib_csteqr( jobz, n, w, rwork( indee ), z, ldz,rwork( indrwk ), info )
                           
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 30
              end if
              info = 0
           end if
           ! otherwise, call stdlib_sstebz and, if eigenvectors are desired, stdlib_cstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indibl = 1
           indisp = indibl + n
           indiwk = indisp + n
           call stdlib_sstebz( range, order, n, vll, vuu, il, iu, abstll,rwork( indd ), rwork( &
           inde ), m, nsplit, w,iwork( indibl ), iwork( indisp ), rwork( indrwk ),iwork( indiwk ),&
                      info )
           if( wantz ) then
              call stdlib_cstein( n, rwork( indd ), rwork( inde ), m, w,iwork( indibl ), iwork( &
                        indisp ), z, ldz,rwork( indrwk ), iwork( indiwk ), ifail, info )
              ! apply unitary matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_cstein.
              do j = 1, m
                 call stdlib_ccopy( n, z( 1, j ), 1, work( 1 ), 1 )
                 call stdlib_cgemv( 'N', n, n, cone, q, ldq, work, 1, czero,z( 1, j ), 1 )
              end do
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           30 continue
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = m
              else
                 imax = info - 1
              end if
              call stdlib_sscal( imax, one / sigma, w, 1 )
           end if
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_cswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_chbevx


     pure subroutine stdlib_chbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
     !! CHBGV computes all the eigenvalues, and optionally, the eigenvectors
     !! of a complex generalized Hermitian-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
     !! and banded, and B is also positive definite.
               rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldz, n
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper, wantz
           character :: vect
           integer(ilp) :: iinfo, inde, indwrk
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHBGV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_cpbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           inde = 1
           indwrk = inde + n
           call stdlib_chbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, z, ldz,work, rwork( &
                     indwrk ), iinfo )
           ! reduce to tridiagonal form.
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_chbtrd( vect, uplo, n, ka, ab, ldab, w, rwork( inde ), z,ldz, work, iinfo )
                     
           ! for eigenvalues only, call stdlib_ssterf.  for eigenvectors, call stdlib_csteqr.
           if( .not.wantz ) then
              call stdlib_ssterf( n, w, rwork( inde ), info )
           else
              call stdlib_csteqr( jobz, n, w, rwork( inde ), z, ldz,rwork( indwrk ), info )
                        
           end if
           return
     end subroutine stdlib_chbgv


     pure subroutine stdlib_chbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
     !! CHBGVD computes all the eigenvalues, and optionally, the eigenvectors
     !! of a complex generalized Hermitian-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
     !! and banded, and B is also positive definite.  If eigenvectors are
     !! desired, it uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               lwork, rwork, lrwork, iwork,liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldz, liwork, lrwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper, wantz
           character :: vect
           integer(ilp) :: iinfo, inde, indwk2, indwrk, liwmin, llrwk, llwk2, lrwmin, &
                     lwmin
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 .or. lrwork==-1 .or. liwork==-1 )
           info = 0
           if( n<=1 ) then
              lwmin = 1+n
              lrwmin = 1+n
              liwmin = 1
           else if( wantz ) then
              lwmin = 2*n**2
              lrwmin = 1 + 5*n + 2*n**2
              liwmin = 3 + 5*n
           else
              lwmin = n
              lrwmin = n
              liwmin = 1
           end if
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -12
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              rwork( 1 ) = lrwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -14
              else if( lrwork<lrwmin .and. .not.lquery ) then
                 info = -16
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHBGVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_cpbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           inde = 1
           indwrk = inde + n
           indwk2 = 1 + n*n
           llwk2 = lwork - indwk2 + 2
           llrwk = lrwork - indwrk + 2
           call stdlib_chbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, z, ldz,work, rwork, &
                     iinfo )
           ! reduce hermitian band matrix to tridiagonal form.
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_chbtrd( vect, uplo, n, ka, ab, ldab, w, rwork( inde ), z,ldz, work, iinfo )
                     
           ! for eigenvalues only, call stdlib_ssterf.  for eigenvectors, call stdlib_cstedc.
           if( .not.wantz ) then
              call stdlib_ssterf( n, w, rwork( inde ), info )
           else
              call stdlib_cstedc( 'I', n, w, rwork( inde ), work, n, work( indwk2 ),llwk2, rwork( &
                        indwrk ), llrwk, iwork, liwork,info )
              call stdlib_cgemm( 'N', 'N', n, n, n, cone, z, ldz, work, n, czero,work( indwk2 ), &
                        n )
              call stdlib_clacpy( 'A', n, n, work( indwk2 ), n, z, ldz )
           end if
           work( 1 ) = lwmin
           rwork( 1 ) = lrwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_chbgvd


     pure subroutine stdlib_chbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,ldbb, q, ldq, vl, &
     !! CHBGVX computes all the eigenvalues, and optionally, the eigenvectors
     !! of a complex generalized Hermitian-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
     !! and banded, and B is also positive definite.  Eigenvalues and
     !! eigenvectors can be selected by specifying either all eigenvalues,
     !! a range of values or a range of indices for the desired eigenvalues.
               vu, il, iu, abstol, m, w, z,ldz, work, rwork, iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, iu, ka, kb, ldab, ldbb, ldq, ldz, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(sp), intent(out) :: q(ldq,*), work(*), z(ldz,*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, upper, valeig, wantz
           character :: order, vect
           integer(ilp) :: i, iinfo, indd, inde, indee, indibl, indisp, indiwk, indrwk, indwrk, &
                     itmp1, j, jj, nsplit
           real(sp) :: tmp1
           ! Intrinsic Functions 
           intrinsic :: min
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ka<0 ) then
              info = -5
           else if( kb<0 .or. kb>ka ) then
              info = -6
           else if( ldab<ka+1 ) then
              info = -8
           else if( ldbb<kb+1 ) then
              info = -10
           else if( ldq<1 .or. ( wantz .and. ldq<n ) ) then
              info = -12
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -14
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -15
                 else if ( iu<min( n, il ) .or. iu>n ) then
                    info = -16
                 end if
              end if
           end if
           if( info==0) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -21
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHBGVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_cpbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           call stdlib_chbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq,work, rwork, &
                     iinfo )
           ! solve the standard eigenvalue problem.
           ! reduce hermitian band matrix to tridiagonal form.
           indd = 1
           inde = indd + n
           indrwk = inde + n
           indwrk = 1
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_chbtrd( vect, uplo, n, ka, ab, ldab, rwork( indd ),rwork( inde ), q, ldq, &
                     work( indwrk ), iinfo )
           ! if all eigenvalues are desired and abstol is less than or equal
           ! to zero, then call stdlib_ssterf or stdlib_csteqr.  if this fails for some
           ! eigenvalue, then try stdlib_sstebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ( abstol<=zero ) ) then
              call stdlib_scopy( n, rwork( indd ), 1, w, 1 )
              indee = indrwk + 2*n
              call stdlib_scopy( n-1, rwork( inde ), 1, rwork( indee ), 1 )
              if( .not.wantz ) then
                 call stdlib_ssterf( n, w, rwork( indee ), info )
              else
                 call stdlib_clacpy( 'A', n, n, q, ldq, z, ldz )
                 call stdlib_csteqr( jobz, n, w, rwork( indee ), z, ldz,rwork( indrwk ), info )
                           
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 30
              end if
              info = 0
           end if
           ! otherwise, call stdlib_sstebz and, if eigenvectors are desired,
           ! call stdlib_cstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indibl = 1
           indisp = indibl + n
           indiwk = indisp + n
           call stdlib_sstebz( range, order, n, vl, vu, il, iu, abstol,rwork( indd ), rwork( inde &
           ), m, nsplit, w,iwork( indibl ), iwork( indisp ), rwork( indrwk ),iwork( indiwk ), &
                     info )
           if( wantz ) then
              call stdlib_cstein( n, rwork( indd ), rwork( inde ), m, w,iwork( indibl ), iwork( &
                        indisp ), z, ldz,rwork( indrwk ), iwork( indiwk ), ifail, info )
              ! apply unitary matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_cstein.
              do j = 1, m
                 call stdlib_ccopy( n, z( 1, j ), 1, work( 1 ), 1 )
                 call stdlib_cgemv( 'N', n, n, cone, q, ldq, work, 1, czero,z( 1, j ), 1 )
              end do
           end if
           30 continue
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_cswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_chbgvx


     subroutine stdlib_cheevd( jobz, uplo, n, a, lda, w, work, lwork, rwork,lrwork, iwork, liwork,&
     !! CHEEVD computes all eigenvalues and, optionally, eigenvectors of a
     !! complex Hermitian matrix A.  If eigenvectors are desired, it uses a
     !! divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
                info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, liwork, lrwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lower, lquery, wantz
           integer(ilp) :: iinfo, imax, inde, indrwk, indtau, indwk2, indwrk, iscale, liopt, &
                     liwmin, llrwk, llwork, llwrk2, lopt, lropt, lrwmin, lwmin
           real(sp) :: anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           lower = stdlib_lsame( uplo, 'L' )
           lquery = ( lwork==-1 .or. lrwork==-1 .or. liwork==-1 )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( lower .or. stdlib_lsame( uplo, 'U' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info==0 ) then
              if( n<=1 ) then
                 lwmin = 1
                 lrwmin = 1
                 liwmin = 1
                 lopt = lwmin
                 lropt = lrwmin
                 liopt = liwmin
              else
                 if( wantz ) then
                    lwmin = 2*n + n*n
                    lrwmin = 1 + 5*n + 2*n**2
                    liwmin = 3 + 5*n
                 else
                    lwmin = n + 1
                    lrwmin = n
                    liwmin = 1
                 end if
                 lopt = max( lwmin, n +stdlib_ilaenv( 1, 'CHETRD', uplo, n, -1, -1, -1 ) )
                 lropt = lrwmin
                 liopt = liwmin
              end if
              work( 1 ) = lopt
              rwork( 1 ) = lropt
              iwork( 1 ) = liopt
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -8
              else if( lrwork<lrwmin .and. .not.lquery ) then
                 info = -10
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHEEVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              w( 1 ) = real( a( 1, 1 ),KIND=sp)
              if( wantz )a( 1, 1 ) = cone
              return
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           anrm = stdlib_clanhe( 'M', uplo, n, a, lda, rwork )
           iscale = 0
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 )call stdlib_clascl( uplo, 0, 0, one, sigma, n, n, a, lda, info )
           ! call stdlib_chetrd to reduce hermitian matrix to tridiagonal form.
           inde = 1
           indtau = 1
           indwrk = indtau + n
           indrwk = inde + n
           indwk2 = indwrk + n*n
           llwork = lwork - indwrk + 1
           llwrk2 = lwork - indwk2 + 1
           llrwk = lrwork - indrwk + 1
           call stdlib_chetrd( uplo, n, a, lda, w, rwork( inde ), work( indtau ),work( indwrk ), &
                     llwork, iinfo )
           ! for eigenvalues only, call stdlib_ssterf.  for eigenvectors, first call
           ! stdlib_cstedc to generate the eigenvector matrix, work(indwrk), of the
           ! tridiagonal matrix, then call stdlib_cunmtr to multiply it to the
           ! householder transformations represented as householder vectors in
           ! a.
           if( .not.wantz ) then
              call stdlib_ssterf( n, w, rwork( inde ), info )
           else
              call stdlib_cstedc( 'I', n, w, rwork( inde ), work( indwrk ), n,work( indwk2 ), &
                        llwrk2, rwork( indrwk ), llrwk,iwork, liwork, info )
              call stdlib_cunmtr( 'L', uplo, 'N', n, n, a, lda, work( indtau ),work( indwrk ), n, &
                        work( indwk2 ), llwrk2, iinfo )
              call stdlib_clacpy( 'A', n, n, work( indwrk ), n, a, lda )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = n
              else
                 imax = info - 1
              end if
              call stdlib_sscal( imax, one / sigma, w, 1 )
           end if
           work( 1 ) = lopt
           rwork( 1 ) = lropt
           iwork( 1 ) = liopt
           return
     end subroutine stdlib_cheevd


     subroutine stdlib_chegvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, lrwork,&
     !! CHEGVD computes all the eigenvalues, and optionally, the eigenvectors
     !! of a complex generalized Hermitian-definite eigenproblem, of the form
     !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
     !! B are assumed to be Hermitian and B is also positive definite.
     !! If eigenvectors are desired, it uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
                iwork, liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: itype, lda, ldb, liwork, lrwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper, wantz
           character :: trans
           integer(ilp) :: liopt, liwmin, lopt, lropt, lrwmin, lwmin
           ! Intrinsic Functions 
           intrinsic :: max,real
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 .or. lrwork==-1 .or. liwork==-1 )
           info = 0
           if( n<=1 ) then
              lwmin = 1
              lrwmin = 1
              liwmin = 1
           else if( wantz ) then
              lwmin = 2*n + n*n
              lrwmin = 1 + 5*n + 2*n*n
              liwmin = 3 + 5*n
           else
              lwmin = n + 1
              lrwmin = n
              liwmin = 1
           end if
           lopt = lwmin
           lropt = lrwmin
           liopt = liwmin
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -2
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info==0 ) then
              work( 1 ) = lopt
              rwork( 1 ) = lropt
              iwork( 1 ) = liopt
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -11
              else if( lrwork<lrwmin .and. .not.lquery ) then
                 info = -13
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -15
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHEGVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a cholesky factorization of b.
           call stdlib_cpotrf( uplo, n, b, ldb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem and solve.
           call stdlib_chegst( itype, uplo, n, a, lda, b, ldb, info )
           call stdlib_cheevd( jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork,iwork, liwork,&
                      info )
           lopt = max( real( lopt,KIND=sp), real( work( 1 ),KIND=sp) )
           lropt = max( real( lropt,KIND=sp), real( rwork( 1 ),KIND=sp) )
           liopt = max( real( liopt,KIND=sp), real( iwork( 1 ),KIND=sp) )
           if( wantz .and. info==0 ) then
              ! backtransform eigenvectors to the original problem.
              if( itype==1 .or. itype==2 ) then
                 ! for a*x=(lambda)*b*x and a*b*x=(lambda)*x;
                 ! backtransform eigenvectors: x = inv(l)**h *y or inv(u)*y
                 if( upper ) then
                    trans = 'N'
                 else
                    trans = 'C'
                 end if
                 call stdlib_ctrsm( 'LEFT', uplo, trans, 'NON-UNIT', n, n, cone,b, ldb, a, lda )
                           
              else if( itype==3 ) then
                 ! for b*a*x=(lambda)*x;
                 ! backtransform eigenvectors: x = l*y or u**h *y
                 if( upper ) then
                    trans = 'C'
                 else
                    trans = 'N'
                 end if
                 call stdlib_ctrmm( 'LEFT', uplo, trans, 'NON-UNIT', n, n, cone,b, ldb, a, lda )
                           
              end if
           end if
           work( 1 ) = lopt
           rwork( 1 ) = lropt
           iwork( 1 ) = liopt
           return
     end subroutine stdlib_chegvd


     subroutine stdlib_chpevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,rwork, lrwork, iwork, &
     !! CHPEVD computes all the eigenvalues and, optionally, eigenvectors of
     !! a complex Hermitian matrix A in packed storage.  If eigenvectors are
     !! desired, it uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, liwork, lrwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery, wantz
           integer(ilp) :: iinfo, imax, inde, indrwk, indtau, indwrk, iscale, liwmin, llrwk, &
                     llwrk, lrwmin, lwmin
           real(sp) :: anrm, bignum, eps, rmax, rmin, safmin, sigma, smlnum
           ! Intrinsic Functions 
           intrinsic :: sqrt
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           lquery = ( lwork==-1 .or. lrwork==-1 .or. liwork==-1 )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( stdlib_lsame( uplo, 'L' ) .or. stdlib_lsame( uplo, 'U' ) ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -7
           end if
           if( info==0 ) then
              if( n<=1 ) then
                 lwmin = 1
                 liwmin = 1
                 lrwmin = 1
              else
                 if( wantz ) then
                    lwmin = 2*n
                    lrwmin = 1 + 5*n + 2*n**2
                    liwmin = 3 + 5*n
                 else
                    lwmin = n
                    lrwmin = n
                    liwmin = 1
                 end if
              end if
              work( 1 ) = lwmin
              rwork( 1 ) = lrwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -9
              else if( lrwork<lrwmin .and. .not.lquery ) then
                 info = -11
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPEVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              w( 1 ) = real( ap( 1 ),KIND=sp)
              if( wantz )z( 1, 1 ) = cone
              return
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           anrm = stdlib_clanhp( 'M', uplo, n, ap, rwork )
           iscale = 0
           if( anrm>zero .and. anrm<rmin ) then
              iscale = 1
              sigma = rmin / anrm
           else if( anrm>rmax ) then
              iscale = 1
              sigma = rmax / anrm
           end if
           if( iscale==1 ) then
              call stdlib_csscal( ( n*( n+1 ) ) / 2, sigma, ap, 1 )
           end if
           ! call stdlib_chptrd to reduce hermitian packed matrix to tridiagonal form.
           inde = 1
           indtau = 1
           indrwk = inde + n
           indwrk = indtau + n
           llwrk = lwork - indwrk + 1
           llrwk = lrwork - indrwk + 1
           call stdlib_chptrd( uplo, n, ap, w, rwork( inde ), work( indtau ),iinfo )
           ! for eigenvalues only, call stdlib_ssterf.  for eigenvectors, first call
           ! stdlib_cupgtr to generate the orthogonal matrix, then call stdlib_cstedc.
           if( .not.wantz ) then
              call stdlib_ssterf( n, w, rwork( inde ), info )
           else
              call stdlib_cstedc( 'I', n, w, rwork( inde ), z, ldz, work( indwrk ),llwrk, rwork( &
                        indrwk ), llrwk, iwork, liwork,info )
              call stdlib_cupmtr( 'L', uplo, 'N', n, n, ap, work( indtau ), z, ldz,work( indwrk ),&
                         iinfo )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = n
              else
                 imax = info - 1
              end if
              call stdlib_sscal( imax, one / sigma, w, 1 )
           end if
           work( 1 ) = lwmin
           rwork( 1 ) = lrwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_chpevd


     subroutine stdlib_chpgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, rwork, lrwork,&
     !! CHPGVD computes all the eigenvalues and, optionally, the eigenvectors
     !! of a complex generalized Hermitian-definite eigenproblem, of the form
     !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
     !! B are assumed to be Hermitian, stored in packed format, and B is also
     !! positive definite.
     !! If eigenvectors are desired, it uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
                iwork, liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: itype, ldz, liwork, lrwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ap(*), bp(*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper, wantz
           character :: trans
           integer(ilp) :: j, liwmin, lrwmin, lwmin, neig
           ! Intrinsic Functions 
           intrinsic :: max,real
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 .or. lrwork==-1 .or. liwork==-1 )
           info = 0
           if( itype<1 .or. itype>3 ) then
              info = -1
           else if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -2
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -9
           end if
           if( info==0 ) then
              if( n<=1 ) then
                 lwmin = 1
                 liwmin = 1
                 lrwmin = 1
              else
                 if( wantz ) then
                    lwmin = 2*n
                    lrwmin = 1 + 5*n + 2*n**2
                    liwmin = 3 + 5*n
                 else
                    lwmin = n
                    lrwmin = n
                    liwmin = 1
                 end if
              end if
              work( 1 ) = lwmin
              rwork( 1 ) = lrwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -11
              else if( lrwork<lrwmin .and. .not.lquery ) then
                 info = -13
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -15
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPGVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a cholesky factorization of b.
           call stdlib_cpptrf( uplo, n, bp, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem and solve.
           call stdlib_chpgst( itype, uplo, n, ap, bp, info )
           call stdlib_chpevd( jobz, uplo, n, ap, w, z, ldz, work, lwork, rwork,lrwork, iwork, &
                     liwork, info )
           lwmin = max( real( lwmin,KIND=sp), real( work( 1 ),KIND=sp) )
           lrwmin = max( real( lrwmin,KIND=sp), real( rwork( 1 ),KIND=sp) )
           liwmin = max( real( liwmin,KIND=sp), real( iwork( 1 ),KIND=sp) )
           if( wantz ) then
              ! backtransform eigenvectors to the original problem.
              neig = n
              if( info>0 )neig = info - 1
              if( itype==1 .or. itype==2 ) then
                 ! for a*x=(lambda)*b*x and a*b*x=(lambda)*x;
                 ! backtransform eigenvectors: x = inv(l)**h *y or inv(u)*y
                 if( upper ) then
                    trans = 'N'
                 else
                    trans = 'C'
                 end if
                 do j = 1, neig
                    call stdlib_ctpsv( uplo, trans, 'NON-UNIT', n, bp, z( 1, j ),1 )
                 end do
              else if( itype==3 ) then
                 ! for b*a*x=(lambda)*x;
                 ! backtransform eigenvectors: x = l*y or u**h *y
                 if( upper ) then
                    trans = 'C'
                 else
                    trans = 'N'
                 end if
                 do j = 1, neig
                    call stdlib_ctpmv( uplo, trans, 'NON-UNIT', n, bp, z( 1, j ),1 )
                 end do
              end if
           end if
           work( 1 ) = lwmin
           rwork( 1 ) = lrwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_chpgvd


     subroutine stdlib_cgees( jobvs, sort, select, n, a, lda, sdim, w, vs,ldvs, work, lwork, &
     !! CGEES computes for an N-by-N complex nonsymmetric matrix A, the
     !! eigenvalues, the Schur form T, and, optionally, the matrix of Schur
     !! vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).
     !! Optionally, it also orders the eigenvalues on the diagonal of the
     !! Schur form so that selected eigenvalues are at the top left.
     !! The leading columns of Z then form an orthonormal basis for the
     !! invariant subspace corresponding to the selected eigenvalues.
     !! A complex matrix is in Schur form if it is upper triangular.
               rwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobvs, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldvs, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: vs(ldvs,*), w(*), work(*)
           ! Function Arguments 
           procedure(stdlib_select_c) :: select
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantst, wantvs
           integer(ilp) :: hswork, i, ibal, icond, ierr, ieval, ihi, ilo, itau, iwrk, maxwrk, &
                     minwrk
           real(sp) :: anrm, bignum, cscale, eps, s, sep, smlnum
           ! Local Arrays 
           real(sp) :: dum(1)
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvs = stdlib_lsame( jobvs, 'V' )
           wantst = stdlib_lsame( sort, 'S' )
           if( ( .not.wantvs ) .and. ( .not.stdlib_lsame( jobvs, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldvs<1 .or. ( wantvs .and. ldvs<n ) ) then
              info = -10
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to real
             ! workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_chseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'CGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 2*n
                 call stdlib_chseqr( 'S', jobvs, n, 1, n, a, lda, w, vs, ldvs,work, -1, ieval )
                           
                 hswork = real( work( 1 ),KIND=sp)
                 if( .not.wantvs ) then
                    maxwrk = max( maxwrk, hswork )
                 else
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'CUNGHR',' ', n, 1, n, -&
                              1 ) )
                    maxwrk = max( maxwrk, hswork )
                 end if
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEES ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_clascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (cworkspace: none)
           ! (rworkspace: need n)
           ibal = 1
           call stdlib_cgebal( 'P', n, a, lda, ilo, ihi, rwork( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (cworkspace: need 2*n, prefer n+n*nb)
           ! (rworkspace: none)
           itau = 1
           iwrk = n + itau
           call stdlib_cgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvs ) then
              ! copy householder vectors to vs
              call stdlib_clacpy( 'L', n, n, a, lda, vs, ldvs )
              ! generate unitary matrix in vs
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_cunghr( n, ilo, ihi, vs, ldvs, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
           end if
           sdim = 0
           ! perform qr iteration, accumulating schur vectors in vs if desired
           ! (cworkspace: need 1, prefer hswork (see comments) )
           ! (rworkspace: none)
           iwrk = itau
           call stdlib_chseqr( 'S', jobvs, n, ilo, ihi, a, lda, w, vs, ldvs,work( iwrk ), lwork-&
                     iwrk+1, ieval )
           if( ieval>0 )info = ieval
           ! sort eigenvalues if desired
           if( wantst .and. info==0 ) then
              if( scalea )call stdlib_clascl( 'G', 0, 0, cscale, anrm, n, 1, w, n, ierr )
              do i = 1, n
                 bwork( i ) = select( w( i ) )
              end do
              ! reorder eigenvalues and transform schur vectors
              ! (cworkspace: none)
              ! (rworkspace: none)
              call stdlib_ctrsen( 'N', jobvs, bwork, n, a, lda, vs, ldvs, w, sdim,s, sep, work( &
                        iwrk ), lwork-iwrk+1, icond )
           end if
           if( wantvs ) then
              ! undo balancing
              ! (cworkspace: none)
              ! (rworkspace: need n)
              call stdlib_cgebak( 'P', 'R', n, ilo, ihi, rwork( ibal ), n, vs, ldvs,ierr )
           end if
           if( scalea ) then
              ! undo scaling for the schur form of a
              call stdlib_clascl( 'U', 0, 0, cscale, anrm, n, n, a, lda, ierr )
              call stdlib_ccopy( n, a, lda+1, w, 1 )
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_cgees


     subroutine stdlib_cgeesx( jobvs, sort, select, sense, n, a, lda, sdim, w,vs, ldvs, rconde, &
     !! CGEESX computes for an N-by-N complex nonsymmetric matrix A, the
     !! eigenvalues, the Schur form T, and, optionally, the matrix of Schur
     !! vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).
     !! Optionally, it also orders the eigenvalues on the diagonal of the
     !! Schur form so that selected eigenvalues are at the top left;
     !! computes a reciprocal condition number for the average of the
     !! selected eigenvalues (RCONDE); and computes a reciprocal condition
     !! number for the right invariant subspace corresponding to the
     !! selected eigenvalues (RCONDV).  The leading columns of Z form an
     !! orthonormal basis for this invariant subspace.
     !! For further explanation of the reciprocal condition numbers RCONDE
     !! and RCONDV, see Section 4.10_sp of the LAPACK Users' Guide (where
     !! these quantities are called s and sep respectively).
     !! A complex matrix is in Schur form if it is upper triangular.
               rcondv, work, lwork, rwork,bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobvs, sense, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldvs, lwork, n
           real(sp), intent(out) :: rconde, rcondv
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: vs(ldvs,*), w(*), work(*)
           ! Function Arguments 
           procedure(stdlib_select_c) :: select
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantsb, wantse, wantsn, wantst, wantsv, wantvs
           integer(ilp) :: hswork, i, ibal, icond, ierr, ieval, ihi, ilo, itau, iwrk, lwrk, &
                     maxwrk, minwrk
           real(sp) :: anrm, bignum, cscale, eps, smlnum
           ! Local Arrays 
           real(sp) :: dum(1)
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! test the input arguments
           info = 0
           wantvs = stdlib_lsame( jobvs, 'V' )
           wantst = stdlib_lsame( sort, 'S' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           lquery = ( lwork==-1 )
           if( ( .not.wantvs ) .and. ( .not.stdlib_lsame( jobvs, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -2
           else if( .not.( wantsn .or. wantse .or. wantsv .or. wantsb ) .or.( .not.wantst .and. &
                     .not.wantsn ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldvs<1 .or. ( wantvs .and. ldvs<n ) ) then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of real workspace needed at that point in the
             ! code, as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to real
             ! workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_chseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.
             ! if sense = 'e', 'v' or 'b', then the amount of workspace needed
             ! depends on sdim, which is computed by the routine stdlib_ctrsen later
             ! in the code.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 lwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'CGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 2*n
                 call stdlib_chseqr( 'S', jobvs, n, 1, n, a, lda, w, vs, ldvs,work, -1, ieval )
                           
                 hswork = real( work( 1 ),KIND=sp)
                 if( .not.wantvs ) then
                    maxwrk = max( maxwrk, hswork )
                 else
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'CUNGHR',' ', n, 1, n, -&
                              1 ) )
                    maxwrk = max( maxwrk, hswork )
                 end if
                 lwrk = maxwrk
                 if( .not.wantsn )lwrk = max( lwrk, ( n*n )/2 )
              end if
              work( 1 ) = lwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -15
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEESX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_clascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (cworkspace: none)
           ! (rworkspace: need n)
           ibal = 1
           call stdlib_cgebal( 'P', n, a, lda, ilo, ihi, rwork( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (cworkspace: need 2*n, prefer n+n*nb)
           ! (rworkspace: none)
           itau = 1
           iwrk = n + itau
           call stdlib_cgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvs ) then
              ! copy householder vectors to vs
              call stdlib_clacpy( 'L', n, n, a, lda, vs, ldvs )
              ! generate unitary matrix in vs
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_cunghr( n, ilo, ihi, vs, ldvs, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
           end if
           sdim = 0
           ! perform qr iteration, accumulating schur vectors in vs if desired
           ! (cworkspace: need 1, prefer hswork (see comments) )
           ! (rworkspace: none)
           iwrk = itau
           call stdlib_chseqr( 'S', jobvs, n, ilo, ihi, a, lda, w, vs, ldvs,work( iwrk ), lwork-&
                     iwrk+1, ieval )
           if( ieval>0 )info = ieval
           ! sort eigenvalues if desired
           if( wantst .and. info==0 ) then
              if( scalea )call stdlib_clascl( 'G', 0, 0, cscale, anrm, n, 1, w, n, ierr )
              do i = 1, n
                 bwork( i ) = select( w( i ) )
              end do
              ! reorder eigenvalues, transform schur vectors, and compute
              ! reciprocal condition numbers
              ! (cworkspace: if sense is not 'n', need 2*sdim*(n-sdim)
                           ! otherwise, need none )
              ! (rworkspace: none)
              call stdlib_ctrsen( sense, jobvs, bwork, n, a, lda, vs, ldvs, w, sdim,rconde, &
                        rcondv, work( iwrk ), lwork-iwrk+1,icond )
              if( .not.wantsn )maxwrk = max( maxwrk, 2*sdim*( n-sdim ) )
              if( icond==-14 ) then
                 ! not enough complex workspace
                 info = -15
              end if
           end if
           if( wantvs ) then
              ! undo balancing
              ! (cworkspace: none)
              ! (rworkspace: need n)
              call stdlib_cgebak( 'P', 'R', n, ilo, ihi, rwork( ibal ), n, vs, ldvs,ierr )
           end if
           if( scalea ) then
              ! undo scaling for the schur form of a
              call stdlib_clascl( 'U', 0, 0, cscale, anrm, n, n, a, lda, ierr )
              call stdlib_ccopy( n, a, lda+1, w, 1 )
              if( ( wantsv .or. wantsb ) .and. info==0 ) then
                 dum( 1 ) = rcondv
                 call stdlib_slascl( 'G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr )
                 rcondv = dum( 1 )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_cgeesx


     subroutine stdlib_cgeev( jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr,work, lwork, rwork, &
     !! CGEEV computes for an N-by-N complex nonsymmetric matrix A, the
     !! eigenvalues and, optionally, the left and/or right eigenvectors.
     !! The right eigenvector v(j) of A satisfies
     !! A * v(j) = lambda(j) * v(j)
     !! where lambda(j) is its eigenvalue.
     !! The left eigenvector u(j) of A satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H
     !! where u(j)**H denotes the conjugate transpose of u(j).
     !! The computed eigenvectors are normalized to have Euclidean norm
     !! equal to 1 and largest component real.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: vl(ldvl,*), vr(ldvr,*), w(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantvl, wantvr
           character :: side
           integer(ilp) :: hswork, i, ibal, ierr, ihi, ilo, irwork, itau, iwrk, k, lwork_trevc, &
                     maxwrk, minwrk, nout
           real(sp) :: anrm, bignum, cscale, eps, scl, smlnum
           complex(sp) :: tmp
           ! Local Arrays 
           logical(lk) :: select(1)
           real(sp) :: dum(1)
           ! Intrinsic Functions 
           intrinsic :: real,cmplx,conjg,aimag,max,sqrt
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvl = stdlib_lsame( jobvl, 'V' )
           wantvr = stdlib_lsame( jobvr, 'V' )
           if( ( .not.wantvl ) .and. ( .not.stdlib_lsame( jobvl, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantvr ) .and. ( .not.stdlib_lsame( jobvr, 'N' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldvl<1 .or. ( wantvl .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( wantvr .and. ldvr<n ) ) then
              info = -10
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to real
             ! workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_chseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'CGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 2*n
                 if( wantvl ) then
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'CUNGHR',' ', n, 1, n, -&
                              1 ) )
                    call stdlib_ctrevc3( 'L', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, rwork, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    call stdlib_chseqr( 'S', 'V', n, 1, n, a, lda, w, vl, ldvl,work, -1, info )
                              
                 else if( wantvr ) then
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'CUNGHR',' ', n, 1, n, -&
                              1 ) )
                    call stdlib_ctrevc3( 'R', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, rwork, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    call stdlib_chseqr( 'S', 'V', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                              
                 else
                    call stdlib_chseqr( 'E', 'N', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                              
                 end if
                 hswork = int( work(1),KIND=ilp)
                 maxwrk = max( maxwrk, hswork, minwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_clascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! balance the matrix
           ! (cworkspace: none)
           ! (rworkspace: need n)
           ibal = 1
           call stdlib_cgebal( 'B', n, a, lda, ilo, ihi, rwork( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (cworkspace: need 2*n, prefer n+n*nb)
           ! (rworkspace: none)
           itau = 1
           iwrk = itau + n
           call stdlib_cgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvl ) then
              ! want left eigenvectors
              ! copy householder vectors to vl
              side = 'L'
              call stdlib_clacpy( 'L', n, n, a, lda, vl, ldvl )
              ! generate unitary matrix in vl
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_cunghr( n, ilo, ihi, vl, ldvl, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vl
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_chseqr( 'S', 'V', n, ilo, ihi, a, lda, w, vl, ldvl,work( iwrk ), lwork-&
                        iwrk+1, info )
              if( wantvr ) then
                 ! want left and right eigenvectors
                 ! copy schur vectors to vr
                 side = 'B'
                 call stdlib_clacpy( 'F', n, n, vl, ldvl, vr, ldvr )
              end if
           else if( wantvr ) then
              ! want right eigenvectors
              ! copy householder vectors to vr
              side = 'R'
              call stdlib_clacpy( 'L', n, n, a, lda, vr, ldvr )
              ! generate unitary matrix in vr
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_cunghr( n, ilo, ihi, vr, ldvr, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vr
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_chseqr( 'S', 'V', n, ilo, ihi, a, lda, w, vr, ldvr,work( iwrk ), lwork-&
                        iwrk+1, info )
           else
              ! compute eigenvalues only
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_chseqr( 'E', 'N', n, ilo, ihi, a, lda, w, vr, ldvr,work( iwrk ), lwork-&
                        iwrk+1, info )
           end if
           ! if info /= 0 from stdlib_chseqr, then quit
           if( info/=0 )go to 50
           if( wantvl .or. wantvr ) then
              ! compute left and/or right eigenvectors
              ! (cworkspace: need 2*n, prefer n + 2*n*nb)
              ! (rworkspace: need 2*n)
              irwork = ibal + n
              call stdlib_ctrevc3( side, 'B', select, n, a, lda, vl, ldvl, vr, ldvr,n, nout, work(&
                         iwrk ), lwork-iwrk+1,rwork( irwork ), n, ierr )
           end if
           if( wantvl ) then
              ! undo balancing of left eigenvectors
              ! (cworkspace: none)
              ! (rworkspace: need n)
              call stdlib_cgebak( 'B', 'L', n, ilo, ihi, rwork( ibal ), n, vl, ldvl,ierr )
              ! normalize left eigenvectors and make largest component real
              do i = 1, n
                 scl = one / stdlib_scnrm2( n, vl( 1, i ), 1 )
                 call stdlib_csscal( n, scl, vl( 1, i ), 1 )
                 do k = 1, n
                    rwork( irwork+k-1 ) = real( vl( k, i ),KIND=sp)**2 +aimag( vl( k, i ) )&
                              **2
                 end do
                 k = stdlib_isamax( n, rwork( irwork ), 1 )
                 tmp = conjg( vl( k, i ) ) / sqrt( rwork( irwork+k-1 ) )
                 call stdlib_cscal( n, tmp, vl( 1, i ), 1 )
                 vl( k, i ) = cmplx( real( vl( k, i ),KIND=sp), zero,KIND=sp)
              end do
           end if
           if( wantvr ) then
              ! undo balancing of right eigenvectors
              ! (cworkspace: none)
              ! (rworkspace: need n)
              call stdlib_cgebak( 'B', 'R', n, ilo, ihi, rwork( ibal ), n, vr, ldvr,ierr )
              ! normalize right eigenvectors and make largest component real
              do i = 1, n
                 scl = one / stdlib_scnrm2( n, vr( 1, i ), 1 )
                 call stdlib_csscal( n, scl, vr( 1, i ), 1 )
                 do k = 1, n
                    rwork( irwork+k-1 ) = real( vr( k, i ),KIND=sp)**2 +aimag( vr( k, i ) )&
                              **2
                 end do
                 k = stdlib_isamax( n, rwork( irwork ), 1 )
                 tmp = conjg( vr( k, i ) ) / sqrt( rwork( irwork+k-1 ) )
                 call stdlib_cscal( n, tmp, vr( 1, i ), 1 )
                 vr( k, i ) = cmplx( real( vr( k, i ),KIND=sp), zero,KIND=sp)
              end do
           end if
           ! undo scaling if necessary
           50 continue
           if( scalea ) then
              call stdlib_clascl( 'G', 0, 0, cscale, anrm, n-info, 1, w( info+1 ),max( n-info, 1 )&
                        , ierr )
              if( info>0 ) then
                 call stdlib_clascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, w, n, ierr )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_cgeev


     subroutine stdlib_cgeevx( balanc, jobvl, jobvr, sense, n, a, lda, w, vl,ldvl, vr, ldvr, ilo, &
     !! CGEEVX computes for an N-by-N complex nonsymmetric matrix A, the
     !! eigenvalues and, optionally, the left and/or right eigenvectors.
     !! Optionally also, it computes a balancing transformation to improve
     !! the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     !! SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
     !! (RCONDE), and reciprocal condition numbers for the right
     !! eigenvectors (RCONDV).
     !! The right eigenvector v(j) of A satisfies
     !! A * v(j) = lambda(j) * v(j)
     !! where lambda(j) is its eigenvalue.
     !! The left eigenvector u(j) of A satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H
     !! where u(j)**H denotes the conjugate transpose of u(j).
     !! The computed eigenvectors are normalized to have Euclidean norm
     !! equal to 1 and largest component real.
     !! Balancing a matrix means permuting the rows and columns to make it
     !! more nearly upper triangular, and applying a diagonal similarity
     !! transformation D * A * D**(-1), where D is a diagonal matrix, to
     !! make its rows and columns closer in norm and the condition numbers
     !! of its eigenvalues and eigenvectors smaller.  The computed
     !! reciprocal condition numbers correspond to the balanced matrix.
     !! Permuting rows and columns will not change the condition numbers
     !! (in exact arithmetic) but diagonal scaling will.  For further
     !! explanation of balancing, see section 4.10.2_sp of the LAPACK
     !! Users' Guide.
               ihi, scale, abnrm, rconde,rcondv, work, lwork, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(sp), intent(out) :: abnrm
           ! Array Arguments 
           real(sp), intent(out) :: rconde(*), rcondv(*), rwork(*), scale(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: vl(ldvl,*), vr(ldvr,*), w(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantvl, wantvr, wntsnb, wntsne, wntsnn, wntsnv
           character :: job, side
           integer(ilp) :: hswork, i, icond, ierr, itau, iwrk, k, lwork_trevc, maxwrk, minwrk, &
                     nout
           real(sp) :: anrm, bignum, cscale, eps, scl, smlnum
           complex(sp) :: tmp
           ! Local Arrays 
           logical(lk) :: select(1)
           real(sp) :: dum(1)
           ! Intrinsic Functions 
           intrinsic :: real,cmplx,conjg,aimag,max,sqrt
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvl = stdlib_lsame( jobvl, 'V' )
           wantvr = stdlib_lsame( jobvr, 'V' )
           wntsnn = stdlib_lsame( sense, 'N' )
           wntsne = stdlib_lsame( sense, 'E' )
           wntsnv = stdlib_lsame( sense, 'V' )
           wntsnb = stdlib_lsame( sense, 'B' )
           if( .not.( stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc, 'S' ) &
                     .or.stdlib_lsame( balanc, 'P' ) .or. stdlib_lsame( balanc, 'B' ) ) ) then
              info = -1
           else if( ( .not.wantvl ) .and. ( .not.stdlib_lsame( jobvl, 'N' ) ) ) then
              info = -2
           else if( ( .not.wantvr ) .and. ( .not.stdlib_lsame( jobvr, 'N' ) ) ) then
              info = -3
           else if( .not.( wntsnn .or. wntsne .or. wntsnb .or. wntsnv ) .or.( ( wntsne .or. &
                     wntsnb ) .and. .not.( wantvl .and.wantvr ) ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( wantvl .and. ldvl<n ) ) then
              info = -10
           else if( ldvr<1 .or. ( wantvr .and. ldvr<n ) ) then
              info = -12
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to real
             ! workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_chseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'CGEHRD', ' ', n, 1, n, 0 )
                 if( wantvl ) then
                    call stdlib_ctrevc3( 'L', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, rwork, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, lwork_trevc )
                    call stdlib_chseqr( 'S', 'V', n, 1, n, a, lda, w, vl, ldvl,work, -1, info )
                              
                 else if( wantvr ) then
                    call stdlib_ctrevc3( 'R', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, rwork, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, lwork_trevc )
                    call stdlib_chseqr( 'S', 'V', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                              
                 else
                    if( wntsnn ) then
                       call stdlib_chseqr( 'E', 'N', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                                 
                    else
                       call stdlib_chseqr( 'S', 'N', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                                 
                    end if
                 end if
                 hswork = int( work(1),KIND=ilp)
                 if( ( .not.wantvl ) .and. ( .not.wantvr ) ) then
                    minwrk = 2*n
                    if( .not.( wntsnn .or. wntsne ) )minwrk = max( minwrk, n*n + 2*n )
                    maxwrk = max( maxwrk, hswork )
                    if( .not.( wntsnn .or. wntsne ) )maxwrk = max( maxwrk, n*n + 2*n )
                 else
                    minwrk = 2*n
                    if( .not.( wntsnn .or. wntsne ) )minwrk = max( minwrk, n*n + 2*n )
                    maxwrk = max( maxwrk, hswork )
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'CUNGHR',' ', n, 1, n, -&
                              1 ) )
                    if( .not.( wntsnn .or. wntsne ) )maxwrk = max( maxwrk, n*n + 2*n )
                    maxwrk = max( maxwrk, 2*n )
                 end if
                 maxwrk = max( maxwrk, minwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           icond = 0
           anrm = stdlib_clange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_clascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! balance the matrix and compute abnrm
           call stdlib_cgebal( balanc, n, a, lda, ilo, ihi, scale, ierr )
           abnrm = stdlib_clange( '1', n, n, a, lda, dum )
           if( scalea ) then
              dum( 1 ) = abnrm
              call stdlib_slascl( 'G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr )
              abnrm = dum( 1 )
           end if
           ! reduce to upper hessenberg form
           ! (cworkspace: need 2*n, prefer n+n*nb)
           ! (rworkspace: none)
           itau = 1
           iwrk = itau + n
           call stdlib_cgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvl ) then
              ! want left eigenvectors
              ! copy householder vectors to vl
              side = 'L'
              call stdlib_clacpy( 'L', n, n, a, lda, vl, ldvl )
              ! generate unitary matrix in vl
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_cunghr( n, ilo, ihi, vl, ldvl, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vl
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_chseqr( 'S', 'V', n, ilo, ihi, a, lda, w, vl, ldvl,work( iwrk ), lwork-&
                        iwrk+1, info )
              if( wantvr ) then
                 ! want left and right eigenvectors
                 ! copy schur vectors to vr
                 side = 'B'
                 call stdlib_clacpy( 'F', n, n, vl, ldvl, vr, ldvr )
              end if
           else if( wantvr ) then
              ! want right eigenvectors
              ! copy householder vectors to vr
              side = 'R'
              call stdlib_clacpy( 'L', n, n, a, lda, vr, ldvr )
              ! generate unitary matrix in vr
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_cunghr( n, ilo, ihi, vr, ldvr, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vr
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_chseqr( 'S', 'V', n, ilo, ihi, a, lda, w, vr, ldvr,work( iwrk ), lwork-&
                        iwrk+1, info )
           else
              ! compute eigenvalues only
              ! if condition numbers desired, compute schur form
              if( wntsnn ) then
                 job = 'E'
              else
                 job = 'S'
              end if
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_chseqr( job, 'N', n, ilo, ihi, a, lda, w, vr, ldvr,work( iwrk ), lwork-&
                        iwrk+1, info )
           end if
           ! if info /= 0 from stdlib_chseqr, then quit
           if( info/=0 )go to 50
           if( wantvl .or. wantvr ) then
              ! compute left and/or right eigenvectors
              ! (cworkspace: need 2*n, prefer n + 2*n*nb)
              ! (rworkspace: need n)
              call stdlib_ctrevc3( side, 'B', select, n, a, lda, vl, ldvl, vr, ldvr,n, nout, work(&
                         iwrk ), lwork-iwrk+1,rwork, n, ierr )
           end if
           ! compute condition numbers if desired
           ! (cworkspace: need n*n+2*n unless sense = 'e')
           ! (rworkspace: need 2*n unless sense = 'e')
           if( .not.wntsnn ) then
              call stdlib_ctrsna( sense, 'A', select, n, a, lda, vl, ldvl, vr, ldvr,rconde, &
                        rcondv, n, nout, work( iwrk ), n, rwork,icond )
           end if
           if( wantvl ) then
              ! undo balancing of left eigenvectors
              call stdlib_cgebak( balanc, 'L', n, ilo, ihi, scale, n, vl, ldvl,ierr )
              ! normalize left eigenvectors and make largest component real
              do i = 1, n
                 scl = one / stdlib_scnrm2( n, vl( 1, i ), 1 )
                 call stdlib_csscal( n, scl, vl( 1, i ), 1 )
                 do k = 1, n
                    rwork( k ) = real( vl( k, i ),KIND=sp)**2 +aimag( vl( k, i ) )**2
                 end do
                 k = stdlib_isamax( n, rwork, 1 )
                 tmp = conjg( vl( k, i ) ) / sqrt( rwork( k ) )
                 call stdlib_cscal( n, tmp, vl( 1, i ), 1 )
                 vl( k, i ) = cmplx( real( vl( k, i ),KIND=sp), zero,KIND=sp)
              end do
           end if
           if( wantvr ) then
              ! undo balancing of right eigenvectors
              call stdlib_cgebak( balanc, 'R', n, ilo, ihi, scale, n, vr, ldvr,ierr )
              ! normalize right eigenvectors and make largest component real
              do i = 1, n
                 scl = one / stdlib_scnrm2( n, vr( 1, i ), 1 )
                 call stdlib_csscal( n, scl, vr( 1, i ), 1 )
                 do k = 1, n
                    rwork( k ) = real( vr( k, i ),KIND=sp)**2 +aimag( vr( k, i ) )**2
                 end do
                 k = stdlib_isamax( n, rwork, 1 )
                 tmp = conjg( vr( k, i ) ) / sqrt( rwork( k ) )
                 call stdlib_cscal( n, tmp, vr( 1, i ), 1 )
                 vr( k, i ) = cmplx( real( vr( k, i ),KIND=sp), zero,KIND=sp)
              end do
           end if
           ! undo scaling if necessary
           50 continue
           if( scalea ) then
              call stdlib_clascl( 'G', 0, 0, cscale, anrm, n-info, 1, w( info+1 ),max( n-info, 1 )&
                        , ierr )
              if( info==0 ) then
                 if( ( wntsnv .or. wntsnb ) .and. icond==0 )call stdlib_slascl( 'G', 0, 0, cscale,&
                            anrm, n, 1, rcondv, n,ierr )
              else
                 call stdlib_clascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, w, n, ierr )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_cgeevx


     pure subroutine stdlib_cgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, ldu, &
     !! CGEJSV computes the singular value decomposition (SVD) of a complex M-by-N
     !! matrix [A], where M >= N. The SVD of [A] is written as
     !! [A] = [U] * [SIGMA] * [V]^*,
     !! where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
     !! diagonal elements, [U] is an M-by-N (or M-by-M) unitary matrix, and
     !! [V] is an N-by-N unitary matrix. The diagonal elements of [SIGMA] are
     !! the singular values of [A]. The columns of [U] and [V] are the left and
     !! the right singular vectors of [A], respectively. The matrices [U] and [V]
     !! are computed and stored in the arrays U and V, respectively. The diagonal
     !! of [SIGMA] is computed and stored in the array SVA.
               v, ldv,cwork, lwork, rwork, lrwork, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldv, lwork, lrwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: u(ldu,*), v(ldv,*), cwork(lwork)
           real(sp), intent(out) :: sva(n), rwork(lrwork)
           integer(ilp), intent(out) :: iwork(*)
           character, intent(in) :: joba, jobp, jobr, jobt, jobu, jobv
        ! ===========================================================================
           
           
           ! Local Scalars 
           complex(sp) :: ctemp
           real(sp) :: aapp, aaqq, aatmax, aatmin, big, big1, cond_ok, condr1, condr2, entra, &
                     entrat, epsln, maxprj, scalem, sconda, sfmin, small, temp1, uscal1, uscal2, xsc
           integer(ilp) :: ierr, n1, nr, numrank, p, q, warning
           logical(lk) :: almort, defr, errest, goscal, jracc, kill, lquery, lsvec, l2aber, &
                     l2kill, l2pert, l2rank, l2tran, noscal, rowpiv, rsvec, transp
           integer(ilp) :: optwrk, minwrk, minrwrk, miniwrk
           integer(ilp) :: lwcon, lwlqf, lwqp3, lwqrf, lwunmlq, lwunmqr, lwunmqrm, lwsvdj, &
                     lwsvdjv, lrwqp3, lrwcon, lrwsvdj, iwoff
           integer(ilp) :: lwrk_cgelqf, lwrk_cgeqp3, lwrk_cgeqp3n, lwrk_cgeqrf, lwrk_cgesvj, &
                     lwrk_cgesvjv, lwrk_cgesvju, lwrk_cunmlq, lwrk_cunmqr, lwrk_cunmqrm
           ! Local Arrays
           complex(sp) :: cdummy(1)
           real(sp) :: rdummy(1)
           ! Intrinsic Functions 
           intrinsic :: abs,cmplx,conjg,log,max,min,real,nint,sqrt
           ! test the input arguments
           lsvec  = stdlib_lsame( jobu, 'U' ) .or. stdlib_lsame( jobu, 'F' )
           jracc  = stdlib_lsame( jobv, 'J' )
           rsvec  = stdlib_lsame( jobv, 'V' ) .or. jracc
           rowpiv = stdlib_lsame( joba, 'F' ) .or. stdlib_lsame( joba, 'G' )
           l2rank = stdlib_lsame( joba, 'R' )
           l2aber = stdlib_lsame( joba, 'A' )
           errest = stdlib_lsame( joba, 'E' ) .or. stdlib_lsame( joba, 'G' )
           l2tran = stdlib_lsame( jobt, 'T' ) .and. ( m == n )
           l2kill = stdlib_lsame( jobr, 'R' )
           defr   = stdlib_lsame( jobr, 'N' )
           l2pert = stdlib_lsame( jobp, 'P' )
           lquery = ( lwork == -1 ) .or. ( lrwork == -1 )
           if ( .not.(rowpiv .or. l2rank .or. l2aber .or.errest .or. stdlib_lsame( joba, 'C' ) )) &
                     then
              info = - 1
           else if ( .not.( lsvec .or. stdlib_lsame( jobu, 'N' ) .or.( stdlib_lsame( jobu, 'W' ) &
                     .and. rsvec .and. l2tran ) ) ) then
              info = - 2
           else if ( .not.( rsvec .or. stdlib_lsame( jobv, 'N' ) .or.( stdlib_lsame( jobv, 'W' ) &
                     .and. lsvec .and. l2tran ) ) ) then
              info = - 3
           else if ( .not. ( l2kill .or. defr ) )    then
              info = - 4
           else if ( .not. ( stdlib_lsame(jobt,'T') .or. stdlib_lsame(jobt,'N') ) ) then
              info = - 5
           else if ( .not. ( l2pert .or. stdlib_lsame( jobp, 'N' ) ) ) then
              info = - 6
           else if ( m < 0 ) then
              info = - 7
           else if ( ( n < 0 ) .or. ( n > m ) ) then
              info = - 8
           else if ( lda < m ) then
              info = - 10
           else if ( lsvec .and. ( ldu < m ) ) then
              info = - 13
           else if ( rsvec .and. ( ldv < n ) ) then
              info = - 15
           else
              ! #:)
              info = 0
           end if
           if ( info == 0 ) then
               ! Compute The Minimal And The Optimal Workspace Lengths
               ! [[the expressions for computing the minimal and the optimal
               ! values of lcwork, lrwork are written with a lot of redundancy and
               ! can be simplified. however, this verbose form is useful for
               ! maintenance and modifications of the code.]]
              ! .. minimal workspace length for stdlib_cgeqp3 of an m x n matrix,
               ! stdlib_cgeqrf of an n x n matrix, stdlib_cgelqf of an n x n matrix,
               ! stdlib_cunmlq for computing n x n matrix, stdlib_cunmqr for computing n x n
               ! matrix, stdlib_cunmqr for computing m x n matrix, respectively.
               lwqp3 = n+1
               lwqrf = max( 1, n )
               lwlqf = max( 1, n )
               lwunmlq  = max( 1, n )
               lwunmqr  = max( 1, n )
               lwunmqrm = max( 1, m )
              ! Minimal Workspace Length For Stdlib_Cpocon Of An N X N Matrix
               lwcon = 2 * n
              ! .. minimal workspace length for stdlib_cgesvj of an n x n matrix,
               ! without and with explicit accumulation of jacobi rotations
               lwsvdj  = max( 2 * n, 1 )
               lwsvdjv = max( 2 * n, 1 )
               ! .. minimal real workspace length for stdlib_cgeqp3, stdlib_cpocon, stdlib_cgesvj
               lrwqp3  = 2 * n
               lrwcon  = n
               lrwsvdj = n
               if ( lquery ) then
                   call stdlib_cgeqp3( m, n, a, lda, iwork, cdummy, cdummy, -1,rdummy, ierr )
                             
                   lwrk_cgeqp3 = real( cdummy(1),KIND=sp)
                   call stdlib_cgeqrf( n, n, a, lda, cdummy, cdummy,-1, ierr )
                   lwrk_cgeqrf = real( cdummy(1),KIND=sp)
                   call stdlib_cgelqf( n, n, a, lda, cdummy, cdummy,-1, ierr )
                   lwrk_cgelqf = real( cdummy(1),KIND=sp)
               end if
               minwrk  = 2
               optwrk  = 2
               miniwrk = n
               if ( .not. (lsvec .or. rsvec ) ) then
                   ! Minimal And Optimal Sizes Of The Complex Workspace If
                   ! only the singular values are requested
                   if ( errest ) then
                       minwrk = max( n+lwqp3, n**2+lwcon, n+lwqrf, lwsvdj )
                   else
                       minwrk = max( n+lwqp3, n+lwqrf, lwsvdj )
                   end if
                   if ( lquery ) then
                       call stdlib_cgesvj( 'L', 'N', 'N', n, n, a, lda, sva, n, v,ldv, cdummy, -1,&
                                  rdummy, -1, ierr )
                       lwrk_cgesvj = real( cdummy(1),KIND=sp)
                       if ( errest ) then
                           optwrk = max( n+lwrk_cgeqp3, n**2+lwcon,n+lwrk_cgeqrf, lwrk_cgesvj )
                                     
                       else
                           optwrk = max( n+lwrk_cgeqp3, n+lwrk_cgeqrf,lwrk_cgesvj )
                       end if
                   end if
                   if ( l2tran .or. rowpiv ) then
                       if ( errest ) then
                          minrwrk = max( 7, 2*m,  lrwqp3, lrwcon, lrwsvdj )
                       else
                          minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj )
                       end if
                   else
                       if ( errest ) then
                          minrwrk = max( 7, lrwqp3, lrwcon, lrwsvdj )
                       else
                          minrwrk = max( 7, lrwqp3, lrwsvdj )
                       end if
                   end if
                   if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
               else if ( rsvec .and. (.not.lsvec) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! singular values and the right singular vectors are requested
                  if ( errest ) then
                      minwrk = max( n+lwqp3, lwcon, lwsvdj, n+lwlqf,2*n+lwqrf, n+lwsvdj, n+&
                                lwunmlq )
                  else
                      minwrk = max( n+lwqp3, lwsvdj, n+lwlqf, 2*n+lwqrf,n+lwsvdj, n+lwunmlq )
                                
                  end if
                  if ( lquery ) then
                      call stdlib_cgesvj( 'L', 'U', 'N', n,n, u, ldu, sva, n, a,lda, cdummy, -1, &
                                rdummy, -1, ierr )
                      lwrk_cgesvj = real( cdummy(1),KIND=sp)
                      call stdlib_cunmlq( 'L', 'C', n, n, n, a, lda, cdummy,v, ldv, cdummy, -1, &
                                ierr )
                      lwrk_cunmlq = real( cdummy(1),KIND=sp)
                      if ( errest ) then
                      optwrk = max( n+lwrk_cgeqp3, lwcon, lwrk_cgesvj,n+lwrk_cgelqf, 2*n+&
                                lwrk_cgeqrf,n+lwrk_cgesvj,  n+lwrk_cunmlq )
                      else
                      optwrk = max( n+lwrk_cgeqp3, lwrk_cgesvj,n+lwrk_cgelqf,2*n+lwrk_cgeqrf, n+&
                                lwrk_cgesvj,n+lwrk_cunmlq )
                      end if
                  end if
                  if ( l2tran .or. rowpiv ) then
                       if ( errest ) then
                          minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj, lrwcon )
                       else
                          minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj )
                       end if
                  else
                       if ( errest ) then
                          minrwrk = max( 7, lrwqp3, lrwsvdj, lrwcon )
                       else
                          minrwrk = max( 7, lrwqp3, lrwsvdj )
                       end if
                  end if
                  if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
               else if ( lsvec .and. (.not.rsvec) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! singular values and the left singular vectors are requested
                  if ( errest ) then
                      minwrk = n + max( lwqp3,lwcon,n+lwqrf,lwsvdj,lwunmqrm )
                  else
                      minwrk = n + max( lwqp3, n+lwqrf, lwsvdj, lwunmqrm )
                  end if
                  if ( lquery ) then
                      call stdlib_cgesvj( 'L', 'U', 'N', n,n, u, ldu, sva, n, a,lda, cdummy, -1, &
                                rdummy, -1, ierr )
                      lwrk_cgesvj = real( cdummy(1),KIND=sp)
                      call stdlib_cunmqr( 'L', 'N', m, n, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_cunmqrm = real( cdummy(1),KIND=sp)
                      if ( errest ) then
                      optwrk = n + max( lwrk_cgeqp3, lwcon, n+lwrk_cgeqrf,lwrk_cgesvj, &
                                lwrk_cunmqrm )
                      else
                      optwrk = n + max( lwrk_cgeqp3, n+lwrk_cgeqrf,lwrk_cgesvj, lwrk_cunmqrm )
                                
                      end if
                  end if
                  if ( l2tran .or. rowpiv ) then
                      if ( errest ) then
                         minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj, lrwcon )
                      else
                         minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj )
                      end if
                  else
                      if ( errest ) then
                         minrwrk = max( 7, lrwqp3, lrwsvdj, lrwcon )
                      else
                         minrwrk = max( 7, lrwqp3, lrwsvdj )
                      end if
                  end if
                  if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
               else
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! full svd is requested
                  if ( .not. jracc ) then
                      if ( errest ) then
                         minwrk = max( n+lwqp3, n+lwcon,  2*n+n**2+lwcon,2*n+lwqrf,         2*n+&
                         lwqp3,2*n+n**2+n+lwlqf,  2*n+n**2+n+n**2+lwcon,2*n+n**2+n+lwsvdj, 2*n+&
                         n**2+n+lwsvdjv,2*n+n**2+n+lwunmqr,2*n+n**2+n+lwunmlq,n+n**2+lwsvdj,   n+&
                                   lwunmqrm )
                      else
                         minwrk = max( n+lwqp3,        2*n+n**2+lwcon,2*n+lwqrf,         2*n+&
                         lwqp3,2*n+n**2+n+lwlqf,  2*n+n**2+n+n**2+lwcon,2*n+n**2+n+lwsvdj, 2*n+&
                         n**2+n+lwsvdjv,2*n+n**2+n+lwunmqr,2*n+n**2+n+lwunmlq,n+n**2+lwsvdj,      &
                                   n+lwunmqrm )
                      end if
                      miniwrk = miniwrk + n
                      if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
                  else
                      if ( errest ) then
                         minwrk = max( n+lwqp3, n+lwcon, 2*n+lwqrf,2*n+n**2+lwsvdjv, 2*n+n**2+n+&
                                   lwunmqr,n+lwunmqrm )
                      else
                         minwrk = max( n+lwqp3, 2*n+lwqrf,2*n+n**2+lwsvdjv, 2*n+n**2+n+lwunmqr,n+&
                                   lwunmqrm )
                      end if
                      if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
                  end if
                  if ( lquery ) then
                      call stdlib_cunmqr( 'L', 'N', m, n, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_cunmqrm = real( cdummy(1),KIND=sp)
                      call stdlib_cunmqr( 'L', 'N', n, n, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_cunmqr = real( cdummy(1),KIND=sp)
                      if ( .not. jracc ) then
                          call stdlib_cgeqp3( n,n, a, lda, iwork, cdummy,cdummy, -1,rdummy, ierr )
                                    
                          lwrk_cgeqp3n = real( cdummy(1),KIND=sp)
                          call stdlib_cgesvj( 'L', 'U', 'N', n, n, u, ldu, sva,n, v, ldv, cdummy, &
                                    -1, rdummy, -1, ierr )
                          lwrk_cgesvj = real( cdummy(1),KIND=sp)
                          call stdlib_cgesvj( 'U', 'U', 'N', n, n, u, ldu, sva,n, v, ldv, cdummy, &
                                    -1, rdummy, -1, ierr )
                          lwrk_cgesvju = real( cdummy(1),KIND=sp)
                          call stdlib_cgesvj( 'L', 'U', 'V', n, n, u, ldu, sva,n, v, ldv, cdummy, &
                                    -1, rdummy, -1, ierr )
                          lwrk_cgesvjv = real( cdummy(1),KIND=sp)
                          call stdlib_cunmlq( 'L', 'C', n, n, n, a, lda, cdummy,v, ldv, cdummy, -&
                                    1, ierr )
                          lwrk_cunmlq = real( cdummy(1),KIND=sp)
                          if ( errest ) then
                            optwrk = max( n+lwrk_cgeqp3, n+lwcon,2*n+n**2+lwcon, 2*n+lwrk_cgeqrf,&
                            2*n+lwrk_cgeqp3n,2*n+n**2+n+lwrk_cgelqf,2*n+n**2+n+n**2+lwcon,2*n+&
                            n**2+n+lwrk_cgesvj,2*n+n**2+n+lwrk_cgesvjv,2*n+n**2+n+lwrk_cunmqr,2*n+&
                                      n**2+n+lwrk_cunmlq,n+n**2+lwrk_cgesvju,n+lwrk_cunmqrm )
                          else
                            optwrk = max( n+lwrk_cgeqp3,2*n+n**2+lwcon, 2*n+lwrk_cgeqrf,2*n+&
                            lwrk_cgeqp3n,2*n+n**2+n+lwrk_cgelqf,2*n+n**2+n+n**2+lwcon,2*n+n**2+n+&
                            lwrk_cgesvj,2*n+n**2+n+lwrk_cgesvjv,2*n+n**2+n+lwrk_cunmqr,2*n+n**2+n+&
                                      lwrk_cunmlq,n+n**2+lwrk_cgesvju,n+lwrk_cunmqrm )
                          end if
                      else
                          call stdlib_cgesvj( 'L', 'U', 'V', n, n, u, ldu, sva,n, v, ldv, cdummy, &
                                    -1, rdummy, -1, ierr )
                          lwrk_cgesvjv = real( cdummy(1),KIND=sp)
                          call stdlib_cunmqr( 'L', 'N', n, n, n, cdummy, n, cdummy,v, ldv, cdummy,&
                                     -1, ierr )
                          lwrk_cunmqr = real( cdummy(1),KIND=sp)
                          call stdlib_cunmqr( 'L', 'N', m, n, n, a, lda, cdummy, u,ldu, cdummy, -&
                                    1, ierr )
                          lwrk_cunmqrm = real( cdummy(1),KIND=sp)
                          if ( errest ) then
                             optwrk = max( n+lwrk_cgeqp3, n+lwcon,2*n+lwrk_cgeqrf, 2*n+n**2,2*n+&
                                       n**2+lwrk_cgesvjv,2*n+n**2+n+lwrk_cunmqr,n+lwrk_cunmqrm )
                          else
                             optwrk = max( n+lwrk_cgeqp3, 2*n+lwrk_cgeqrf,2*n+n**2, 2*n+n**2+&
                                       lwrk_cgesvjv,2*n+n**2+n+lwrk_cunmqr,n+lwrk_cunmqrm )
                          end if
                      end if
                  end if
                  if ( l2tran .or. rowpiv ) then
                      minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj, lrwcon )
                  else
                      minrwrk = max( 7, lrwqp3, lrwsvdj, lrwcon )
                  end if
               end if
               minwrk = max( 2, minwrk )
               optwrk = max( optwrk, minwrk )
               if ( lwork  < minwrk  .and. (.not.lquery) ) info = - 17
               if ( lrwork < minrwrk .and. (.not.lquery) ) info = - 19
           end if
           if ( info /= 0 ) then
             ! #:(
              call stdlib_xerbla( 'CGEJSV', - info )
              return
           else if ( lquery ) then
               cwork(1) = optwrk
               cwork(2) = minwrk
               rwork(1) = minrwrk
               iwork(1) = max( 4, miniwrk )
               return
           end if
           ! quick return for void matrix (y3k safe)
       ! #:)
           if ( ( m == 0 ) .or. ( n == 0 ) ) then
              iwork(1:4) = 0
              rwork(1:7) = 0
              return
           endif
           ! determine whether the matrix u should be m x n or m x m
           if ( lsvec ) then
              n1 = n
              if ( stdlib_lsame( jobu, 'F' ) ) n1 = m
           end if
           ! set numerical parameters
      ! !    note: make sure stdlib_slamch() does not fail on the target architecture.
           epsln = stdlib_slamch('EPSILON')
           sfmin = stdlib_slamch('SAFEMINIMUM')
           small = sfmin / epsln
           big   = stdlib_slamch('O')
           ! big   = one / sfmin
           ! initialize sva(1:n) = diag( ||a e_i||_2 )_1^n
      ! (!)  if necessary, scale sva() to protect the largest norm from
           ! overflow. it is possible that this scaling pushes the smallest
           ! column norm left from the underflow threshold (extreme case).
           scalem  = one / sqrt(real(m,KIND=sp)*real(n,KIND=sp))
           noscal  = .true.
           goscal  = .true.
           do p = 1, n
              aapp = zero
              aaqq = one
              call stdlib_classq( m, a(1,p), 1, aapp, aaqq )
              if ( aapp > big ) then
                 info = - 9
                 call stdlib_xerbla( 'CGEJSV', -info )
                 return
              end if
              aaqq = sqrt(aaqq)
              if ( ( aapp < (big / aaqq) ) .and. noscal  ) then
                 sva(p)  = aapp * aaqq
              else
                 noscal  = .false.
                 sva(p)  = aapp * ( aaqq * scalem )
                 if ( goscal ) then
                    goscal = .false.
                    call stdlib_sscal( p-1, scalem, sva, 1 )
                 end if
              end if
           end do
           if ( noscal ) scalem = one
           aapp = zero
           aaqq = big
           do p = 1, n
              aapp = max( aapp, sva(p) )
              if ( sva(p) /= zero ) aaqq = min( aaqq, sva(p) )
           end do
           ! quick return for zero m x n matrix
       ! #:)
           if ( aapp == zero ) then
              if ( lsvec ) call stdlib_claset( 'G', m, n1, czero, cone, u, ldu )
              if ( rsvec ) call stdlib_claset( 'G', n, n,  czero, cone, v, ldv )
              rwork(1) = one
              rwork(2) = one
              if ( errest ) rwork(3) = one
              if ( lsvec .and. rsvec ) then
                 rwork(4) = one
                 rwork(5) = one
              end if
              if ( l2tran ) then
                 rwork(6) = zero
                 rwork(7) = zero
              end if
              iwork(1) = 0
              iwork(2) = 0
              iwork(3) = 0
              iwork(4) = -1
              return
           end if
           ! issue warning if denormalized column norms detected. override the
           ! high relative accuracy request. issue licence to kill nonzero columns
           ! (set them to zero) whose norm is less than sigma_max / big (roughly).
       ! #:(
           warning = 0
           if ( aaqq <= sfmin ) then
              l2rank = .true.
              l2kill = .true.
              warning = 1
           end if
           ! quick return for one-column matrix
       ! #:)
           if ( n == 1 ) then
              if ( lsvec ) then
                 call stdlib_clascl( 'G',0,0,sva(1),scalem, m,1,a(1,1),lda,ierr )
                 call stdlib_clacpy( 'A', m, 1, a, lda, u, ldu )
                 ! computing all m left singular vectors of the m x 1 matrix
                 if ( n1 /= n  ) then
                   call stdlib_cgeqrf( m, n, u,ldu, cwork, cwork(n+1),lwork-n,ierr )
                   call stdlib_cungqr( m,n1,1, u,ldu,cwork,cwork(n+1),lwork-n,ierr )
                   call stdlib_ccopy( m, a(1,1), 1, u(1,1), 1 )
                 end if
              end if
              if ( rsvec ) then
                  v(1,1) = cone
              end if
              if ( sva(1) < (big*scalem) ) then
                 sva(1)  = sva(1) / scalem
                 scalem  = one
              end if
              rwork(1) = one / scalem
              rwork(2) = one
              if ( sva(1) /= zero ) then
                 iwork(1) = 1
                 if ( ( sva(1) / scalem) >= sfmin ) then
                    iwork(2) = 1
                 else
                    iwork(2) = 0
                 end if
              else
                 iwork(1) = 0
                 iwork(2) = 0
              end if
              iwork(3) = 0
              iwork(4) = -1
              if ( errest ) rwork(3) = one
              if ( lsvec .and. rsvec ) then
                 rwork(4) = one
                 rwork(5) = one
              end if
              if ( l2tran ) then
                 rwork(6) = zero
                 rwork(7) = zero
              end if
              return
           end if
           transp = .false.
           aatmax = -one
           aatmin =  big
           if ( rowpiv .or. l2tran ) then
           ! compute the row norms, needed to determine row pivoting sequence
           ! (in the case of heavily row weighted a, row pivoting is strongly
           ! advised) and to collect information needed to compare the
           ! structures of a * a^* and a^* * a (in the case l2tran==.true.).
              if ( l2tran ) then
                 do p = 1, m
                    xsc   = zero
                    temp1 = one
                    call stdlib_classq( n, a(p,1), lda, xsc, temp1 )
                    ! stdlib_classq gets both the ell_2 and the ell_infinity norm
                    ! in one pass through the vector
                    rwork(m+p)  = xsc * scalem
                    rwork(p)    = xsc * (scalem*sqrt(temp1))
                    aatmax = max( aatmax, rwork(p) )
                    if (rwork(p) /= zero)aatmin = min(aatmin,rwork(p))
                 end do
              else
                 do p = 1, m
                    rwork(m+p) = scalem*abs( a(p,stdlib_icamax(n,a(p,1),lda)) )
                    aatmax = max( aatmax, rwork(m+p) )
                    aatmin = min( aatmin, rwork(m+p) )
                 end do
              end if
           end if
           ! for square matrix a try to determine whether a^*  would be better
           ! input for the preconditioned jacobi svd, with faster convergence.
           ! the decision is based on an o(n) function of the vector of column
           ! and row norms of a, based on the shannon entropy. this should give
           ! the right choice in most cases when the difference actually matters.
           ! it may fail and pick the slower converging side.
           entra  = zero
           entrat = zero
           if ( l2tran ) then
              xsc   = zero
              temp1 = one
              call stdlib_slassq( n, sva, 1, xsc, temp1 )
              temp1 = one / temp1
              entra = zero
              do p = 1, n
                 big1  = ( ( sva(p) / xsc )**2 ) * temp1
                 if ( big1 /= zero ) entra = entra + big1 * log(big1)
              end do
              entra = - entra / log(real(n,KIND=sp))
              ! now, sva().^2/trace(a^* * a) is a point in the probability simplex.
              ! it is derived from the diagonal of  a^* * a.  do the same with the
              ! diagonal of a * a^*, compute the entropy of the corresponding
              ! probability distribution. note that a * a^* and a^* * a have the
              ! same trace.
              entrat = zero
              do p = 1, m
                 big1 = ( ( rwork(p) / xsc )**2 ) * temp1
                 if ( big1 /= zero ) entrat = entrat + big1 * log(big1)
              end do
              entrat = - entrat / log(real(m,KIND=sp))
              ! analyze the entropies and decide a or a^*. smaller entropy
              ! usually means better input for the algorithm.
              transp = ( entrat < entra )
              ! if a^* is better than a, take the adjoint of a. this is allowed
              ! only for square matrices, m=n.
              if ( transp ) then
                 ! in an optimal implementation, this trivial transpose
                 ! should be replaced with faster transpose.
                 do p = 1, n - 1
                    a(p,p) = conjg(a(p,p))
                    do q = p + 1, n
                        ctemp = conjg(a(q,p))
                       a(q,p) = conjg(a(p,q))
                       a(p,q) = ctemp
                    end do
                 end do
                 a(n,n) = conjg(a(n,n))
                 do p = 1, n
                    rwork(m+p) = sva(p)
                    sva(p) = rwork(p)
                    ! previously computed row 2-norms are now column 2-norms
                    ! of the transposed matrix
                 end do
                 temp1  = aapp
                 aapp   = aatmax
                 aatmax = temp1
                 temp1  = aaqq
                 aaqq   = aatmin
                 aatmin = temp1
                 kill   = lsvec
                 lsvec  = rsvec
                 rsvec  = kill
                 if ( lsvec ) n1 = n
                 rowpiv = .true.
              end if
           end if
           ! end if l2tran
           ! scale the matrix so that its maximal singular value remains less
           ! than sqrt(big) -- the matrix is scaled so that its maximal column
           ! has euclidean norm equal to sqrt(big/n). the only reason to keep
           ! sqrt(big) instead of big is the fact that stdlib_cgejsv uses lapack and
           ! blas routines that, in some implementations, are not capable of
           ! working in the full interval [sfmin,big] and that they may provoke
           ! overflows in the intermediate results. if the singular values spread
           ! from sfmin to big, then stdlib_cgesvj will compute them. so, in that case,
           ! one should use stdlib_cgesvj instead of stdlib_cgejsv.
           big1   = sqrt( big )
           temp1  = sqrt( big / real(n,KIND=sp) )
           ! >> for future updates: allow bigger range, i.e. the largest column
           ! will be allowed up to big/n and stdlib_cgesvj will do the rest. however, for
           ! this all other (lapack) components must allow such a range.
           ! temp1  = big/real(n,KIND=sp)
           ! temp1  = big * epsln  this should 'almost' work with current lapack components
           call stdlib_slascl( 'G', 0, 0, aapp, temp1, n, 1, sva, n, ierr )
           if ( aaqq > (aapp * sfmin) ) then
               aaqq = ( aaqq / aapp ) * temp1
           else
               aaqq = ( aaqq * temp1 ) / aapp
           end if
           temp1 = temp1 * scalem
           call stdlib_clascl( 'G', 0, 0, aapp, temp1, m, n, a, lda, ierr )
           ! to undo scaling at the end of this procedure, multiply the
           ! computed singular values with uscal2 / uscal1.
           uscal1 = temp1
           uscal2 = aapp
           if ( l2kill ) then
              ! l2kill enforces computation of nonzero singular values in
              ! the restricted range of condition number of the initial a,
              ! sigma_max(a) / sigma_min(a) approx. sqrt(big)/sqrt(sfmin).
              xsc = sqrt( sfmin )
           else
              xsc = small
              ! now, if the condition number of a is too big,
              ! sigma_max(a) / sigma_min(a) > sqrt(big/n) * epsln / sfmin,
              ! as a precaution measure, the full svd is computed using stdlib_cgesvj
              ! with accumulated jacobi rotations. this provides numerically
              ! more robust computation, at the cost of slightly increased run
              ! time. depending on the concrete implementation of blas and lapack
              ! (i.e. how they behave in presence of extreme ill-conditioning) the
              ! implementor may decide to remove this switch.
              if ( ( aaqq<sqrt(sfmin) ) .and. lsvec .and. rsvec ) then
                 jracc = .true.
              end if
           end if
           if ( aaqq < xsc ) then
              do p = 1, n
                 if ( sva(p) < xsc ) then
                    call stdlib_claset( 'A', m, 1, czero, czero, a(1,p), lda )
                    sva(p) = zero
                 end if
              end do
           end if
           ! preconditioning using qr factorization with pivoting
           if ( rowpiv ) then
              ! optional row permutation (bjoerck row pivoting):
              ! a result by cox and higham shows that the bjoerck's
              ! row pivoting combined with standard column pivoting
              ! has similar effect as powell-reid complete pivoting.
              ! the ell-infinity norms of a are made nonincreasing.
              if ( ( lsvec .and. rsvec ) .and. .not.( jracc ) ) then
                   iwoff = 2*n
              else
                   iwoff = n
              end if
              do p = 1, m - 1
                 q = stdlib_isamax( m-p+1, rwork(m+p), 1 ) + p - 1
                 iwork(iwoff+p) = q
                 if ( p /= q ) then
                    temp1      = rwork(m+p)
                    rwork(m+p) = rwork(m+q)
                    rwork(m+q) = temp1
                 end if
              end do
              call stdlib_claswp( n, a, lda, 1, m-1, iwork(iwoff+1), 1 )
           end if
           ! end of the preparation phase (scaling, optional sorting and
           ! transposing, optional flushing of small columns).
           ! preconditioning
           ! if the full svd is needed, the right singular vectors are computed
           ! from a matrix equation, and for that we need theoretical analysis
           ! of the businger-golub pivoting. so we use stdlib_cgeqp3 as the first rr qrf.
           ! in all other cases the first rr qrf can be chosen by other criteria
           ! (eg speed by replacing global with restricted window pivoting, such
           ! as in xgeqpx from toms # 782). good results will be obtained using
           ! xgeqpx with properly (!) chosen numerical parameters.
           ! any improvement of stdlib_cgeqp3 improves overall performance of stdlib_cgejsv.
           ! a * p1 = q1 * [ r1^* 0]^*:
           do p = 1, n
              ! All Columns Are Free Columns
              iwork(p) = 0
           end do
           call stdlib_cgeqp3( m, n, a, lda, iwork, cwork, cwork(n+1), lwork-n,rwork, ierr )
                     
           ! the upper triangular matrix r1 from the first qrf is inspected for
           ! rank deficiency and possibilities for deflation, or possible
           ! ill-conditioning. depending on the user specified flag l2rank,
           ! the procedure explores possibilities to reduce the numerical
           ! rank by inspecting the computed upper triangular factor. if
           ! l2rank or l2aber are up, then stdlib_cgejsv will compute the svd of
           ! a + da, where ||da|| <= f(m,n)*epsln.
           nr = 1
           if ( l2aber ) then
              ! standard absolute error bound suffices. all sigma_i with
              ! sigma_i < n*epsln*||a|| are flushed to zero. this is an
              ! aggressive enforcement of lower numerical rank by introducing a
              ! backward error of the order of n*epsln*||a||.
              temp1 = sqrt(real(n,KIND=sp))*epsln
              do p = 2, n
                 if ( abs(a(p,p)) >= (temp1*abs(a(1,1))) ) then
                    nr = nr + 1
                 else
                    go to 3002
                 end if
              end do
              3002 continue
           else if ( l2rank ) then
              ! .. similarly as above, only slightly more gentle (less aggressive).
              ! sudden drop on the diagonal of r1 is used as the criterion for
              ! close-to-rank-deficient.
              temp1 = sqrt(sfmin)
              do p = 2, n
                 if ( ( abs(a(p,p)) < (epsln*abs(a(p-1,p-1))) ) .or.( abs(a(p,p)) < small ) .or.( &
                           l2kill .and. (abs(a(p,p)) < temp1) ) ) go to 3402
                 nr = nr + 1
              end do
              3402 continue
           else
              ! the goal is high relative accuracy. however, if the matrix
              ! has high scaled condition number the relative accuracy is in
              ! general not feasible. later on, a condition number estimator
              ! will be deployed to estimate the scaled condition number.
              ! here we just remove the underflowed part of the triangular
              ! factor. this prevents the situation in which the code is
              ! working hard to get the accuracy not warranted by the data.
              temp1  = sqrt(sfmin)
              do p = 2, n
                 if ( ( abs(a(p,p)) < small ) .or.( l2kill .and. (abs(a(p,p)) < temp1) ) ) go to &
                           3302
                 nr = nr + 1
              end do
              3302 continue
           end if
           almort = .false.
           if ( nr == n ) then
              maxprj = one
              do p = 2, n
                 temp1  = abs(a(p,p)) / sva(iwork(p))
                 maxprj = min( maxprj, temp1 )
              end do
              if ( maxprj**2 >= one - real(n,KIND=sp)*epsln ) almort = .true.
           end if
           sconda = - one
           condr1 = - one
           condr2 = - one
           if ( errest ) then
              if ( n == nr ) then
                 if ( rsvec ) then
                    ! V Is Available As Workspace
                    call stdlib_clacpy( 'U', n, n, a, lda, v, ldv )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_csscal( p, one/temp1, v(1,p), 1 )
                    end do
                    if ( lsvec )then
                        call stdlib_cpocon( 'U', n, v, ldv, one, temp1,cwork(n+1), rwork, ierr )
                                  
                    else
                        call stdlib_cpocon( 'U', n, v, ldv, one, temp1,cwork, rwork, ierr )
                                  
                    end if
                 else if ( lsvec ) then
                    ! U Is Available As Workspace
                    call stdlib_clacpy( 'U', n, n, a, lda, u, ldu )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_csscal( p, one/temp1, u(1,p), 1 )
                    end do
                    call stdlib_cpocon( 'U', n, u, ldu, one, temp1,cwork(n+1), rwork, ierr )
                              
                 else
                    call stdlib_clacpy( 'U', n, n, a, lda, cwork, n )
      ! []            call stdlib_clacpy( 'u', n, n, a, lda, cwork(n+1), n )
                    ! change: here index shifted by n to the left, cwork(1:n)
                    ! not needed for sigma only computation
                    do p = 1, n
                       temp1 = sva(iwork(p))
      ! []               call stdlib_csscal( p, one/temp1, cwork(n+(p-1)*n+1), 1 )
                       call stdlib_csscal( p, one/temp1, cwork((p-1)*n+1), 1 )
                    end do
                 ! The Columns Of R Are Scaled To Have Unit Euclidean Lengths
      ! []               call stdlib_cpocon( 'u', n, cwork(n+1), n, one, temp1,
      ! []     $              cwork(n+n*n+1), rwork, ierr )
                    call stdlib_cpocon( 'U', n, cwork, n, one, temp1,cwork(n*n+1), rwork, ierr )
                              
                 end if
                 if ( temp1 /= zero ) then
                    sconda = one / sqrt(temp1)
                 else
                    sconda = - one
                 end if
                 ! sconda is an estimate of sqrt(||(r^* * r)^(-1)||_1).
                 ! n^(-1/4) * sconda <= ||r^(-1)||_2 <= n^(1/4) * sconda
              else
                 sconda = - one
              end if
           end if
           l2pert = l2pert .and. ( abs( a(1,1)/a(nr,nr) ) > sqrt(big1) )
           ! if there is no violent scaling, artificial perturbation is not needed.
           ! phase 3:
           if ( .not. ( rsvec .or. lsvec ) ) then
               ! singular values only
               ! .. transpose a(1:nr,1:n)
              do p = 1, min( n-1, nr )
                 call stdlib_ccopy( n-p, a(p,p+1), lda, a(p+1,p), 1 )
                 call stdlib_clacgv( n-p+1, a(p,p), 1 )
              end do
              if ( nr == n ) a(n,n) = conjg(a(n,n))
              ! the following two do-loops introduce small relative perturbation
              ! into the strict upper triangle of the lower triangular matrix.
              ! small entries below the main diagonal are also changed.
              ! this modification is useful if the computing environment does not
              ! provide/allow flush to zero underflow, for it prevents many
              ! annoying denormalized numbers in case of strongly scaled matrices.
              ! the perturbation is structured so that it does not introduce any
              ! new perturbation of the singular values, and it does not destroy
              ! the job done by the preconditioner.
              ! the licence for this perturbation is in the variable l2pert, which
              ! should be .false. if flush to zero underflow is active.
              if ( .not. almort ) then
                 if ( l2pert ) then
                    ! xsc = sqrt(small)
                    xsc = epsln / real(n,KIND=sp)
                    do q = 1, nr
                       ctemp = cmplx(xsc*abs(a(q,q)),zero,KIND=sp)
                       do p = 1, n
                          if ( ( (p>q) .and. (abs(a(p,q))<=temp1) ).or. ( p < q ) )a(p,q) = &
                                    ctemp
           ! $                     a(p,q) = temp1 * ( a(p,q) / abs(a(p,q)) )
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_claset( 'U', nr-1,nr-1, czero,czero, a(1,2),lda )
                 end if
                  ! Second Preconditioning Using The Qr Factorization
                 call stdlib_cgeqrf( n,nr, a,lda, cwork, cwork(n+1),lwork-n, ierr )
                 ! And Transpose Upper To Lower Triangular
                 do p = 1, nr - 1
                    call stdlib_ccopy( nr-p, a(p,p+1), lda, a(p+1,p), 1 )
                    call stdlib_clacgv( nr-p+1, a(p,p), 1 )
                 end do
              end if
                 ! row-cyclic jacobi svd algorithm with column pivoting
                 ! .. again some perturbation (a "background noise") is added
                 ! to drown denormals
                 if ( l2pert ) then
                    ! xsc = sqrt(small)
                    xsc = epsln / real(n,KIND=sp)
                    do q = 1, nr
                       ctemp = cmplx(xsc*abs(a(q,q)),zero,KIND=sp)
                       do p = 1, nr
                          if ( ( (p>q) .and. (abs(a(p,q))<=temp1) ).or. ( p < q ) )a(p,q) = &
                                    ctemp
           ! $                   a(p,q) = temp1 * ( a(p,q) / abs(a(p,q)) )
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_claset( 'U', nr-1, nr-1, czero, czero, a(1,2), lda )
                 end if
                 ! .. and one-sided jacobi rotations are started on a lower
                 ! triangular matrix (plus perturbation which is ignored in
                 ! the part which destroys triangular form (confusing?!))
                 call stdlib_cgesvj( 'L', 'N', 'N', nr, nr, a, lda, sva,n, v, ldv, cwork, lwork, &
                           rwork, lrwork, info )
                 scalem  = rwork(1)
                 numrank = nint(rwork(2),KIND=ilp)
           else if ( ( rsvec .and. ( .not. lsvec ) .and. ( .not. jracc ) ).or.( jracc .and. ( &
                     .not. lsvec ) .and. ( nr /= n ) ) ) then
              ! -> singular values and right singular vectors <-
              if ( almort ) then
                 ! In This Case Nr Equals N
                 do p = 1, nr
                    call stdlib_ccopy( n-p+1, a(p,p), lda, v(p,p), 1 )
                    call stdlib_clacgv( n-p+1, v(p,p), 1 )
                 end do
                 if (nr>1) call stdlib_claset( 'U', nr-1,nr-1, czero, czero, v(1,2), ldv )
                 call stdlib_cgesvj( 'L','U','N', n, nr, v, ldv, sva, nr, a, lda,cwork, lwork, &
                           rwork, lrwork, info )
                 scalem  = rwork(1)
                 numrank = nint(rwork(2),KIND=ilp)
              else
              ! .. two more qr factorizations ( one qrf is not enough, two require
              ! accumulated product of jacobi rotations, three are perfect )
                 if (nr>1) call stdlib_claset( 'L', nr-1,nr-1, czero, czero, a(2,1), lda )
                 call stdlib_cgelqf( nr,n, a, lda, cwork, cwork(n+1), lwork-n, ierr)
                 call stdlib_clacpy( 'L', nr, nr, a, lda, v, ldv )
                 if (nr>1) call stdlib_claset( 'U', nr-1,nr-1, czero, czero, v(1,2), ldv )
                 call stdlib_cgeqrf( nr, nr, v, ldv, cwork(n+1), cwork(2*n+1),lwork-2*n, ierr )
                           
                 do p = 1, nr
                    call stdlib_ccopy( nr-p+1, v(p,p), ldv, v(p,p), 1 )
                    call stdlib_clacgv( nr-p+1, v(p,p), 1 )
                 end do
                 if (nr>1) call stdlib_claset('U', nr-1, nr-1, czero, czero, v(1,2), ldv)
                 call stdlib_cgesvj( 'L', 'U','N', nr, nr, v,ldv, sva, nr, u,ldu, cwork(n+1), &
                           lwork-n, rwork, lrwork, info )
                 scalem  = rwork(1)
                 numrank = nint(rwork(2),KIND=ilp)
                 if ( nr < n ) then
                    call stdlib_claset( 'A',n-nr, nr, czero,czero, v(nr+1,1),  ldv )
                    call stdlib_claset( 'A',nr, n-nr, czero,czero, v(1,nr+1),  ldv )
                    call stdlib_claset( 'A',n-nr,n-nr,czero,cone, v(nr+1,nr+1),ldv )
                 end if
              call stdlib_cunmlq( 'L', 'C', n, n, nr, a, lda, cwork,v, ldv, cwork(n+1), lwork-n, &
                        ierr )
              end if
               ! Permute The Rows Of V
               ! do 8991 p = 1, n
                  ! call stdlib_ccopy( n, v(p,1), ldv, a(iwork(p),1), lda )
                  8991 continue
               ! call stdlib_clacpy( 'all', n, n, a, lda, v, ldv )
              call stdlib_clapmr( .false., n, n, v, ldv, iwork )
               if ( transp ) then
                 call stdlib_clacpy( 'A', n, n, v, ldv, u, ldu )
               end if
           else if ( jracc .and. (.not. lsvec) .and. ( nr== n ) ) then
              if (n>1) call stdlib_claset( 'L', n-1,n-1, czero, czero, a(2,1), lda )
              call stdlib_cgesvj( 'U','N','V', n, n, a, lda, sva, n, v, ldv,cwork, lwork, rwork, &
                        lrwork, info )
               scalem  = rwork(1)
               numrank = nint(rwork(2),KIND=ilp)
               call stdlib_clapmr( .false., n, n, v, ldv, iwork )
           else if ( lsvec .and. ( .not. rsvec ) ) then
              ! Singular Values And Left Singular Vectors                 
              ! Second Preconditioning Step To Avoid Need To Accumulate
              ! jacobi rotations in the jacobi iterations.
              do p = 1, nr
                 call stdlib_ccopy( n-p+1, a(p,p), lda, u(p,p), 1 )
                 call stdlib_clacgv( n-p+1, u(p,p), 1 )
              end do
              if (nr>1) call stdlib_claset( 'U', nr-1, nr-1, czero, czero, u(1,2), ldu )
              call stdlib_cgeqrf( n, nr, u, ldu, cwork(n+1), cwork(2*n+1),lwork-2*n, ierr )
                        
              do p = 1, nr - 1
                 call stdlib_ccopy( nr-p, u(p,p+1), ldu, u(p+1,p), 1 )
                 call stdlib_clacgv( n-p+1, u(p,p), 1 )
              end do
              if (nr>1) call stdlib_claset( 'U', nr-1, nr-1, czero, czero, u(1,2), ldu )
              call stdlib_cgesvj( 'L', 'U', 'N', nr,nr, u, ldu, sva, nr, a,lda, cwork(n+1), lwork-&
                        n, rwork, lrwork, info )
              scalem  = rwork(1)
              numrank = nint(rwork(2),KIND=ilp)
              if ( nr < m ) then
                 call stdlib_claset( 'A',  m-nr, nr,czero, czero, u(nr+1,1), ldu )
                 if ( nr < n1 ) then
                    call stdlib_claset( 'A',nr, n1-nr, czero, czero, u(1,nr+1),ldu )
                    call stdlib_claset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1),ldu )
                 end if
              end if
              call stdlib_cunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, cwork(n+1), lwork-n, &
                        ierr )
              if ( rowpiv )call stdlib_claswp( n1, u, ldu, 1, m-1, iwork(iwoff+1), -1 )
              do p = 1, n1
                 xsc = one / stdlib_scnrm2( m, u(1,p), 1 )
                 call stdlib_csscal( m, xsc, u(1,p), 1 )
              end do
              if ( transp ) then
                 call stdlib_clacpy( 'A', n, n, u, ldu, v, ldv )
              end if
           else
              ! Full Svd 
              if ( .not. jracc ) then
              if ( .not. almort ) then
                 ! second preconditioning step (qrf [with pivoting])
                 ! note that the composition of transpose, qrf and transpose is
                 ! equivalent to an lqf call. since in many libraries the qrf
                 ! seems to be better optimized than the lqf, we do explicit
                 ! transpose and use the qrf. this is subject to changes in an
                 ! optimized implementation of stdlib_cgejsv.
                 do p = 1, nr
                    call stdlib_ccopy( n-p+1, a(p,p), lda, v(p,p), 1 )
                    call stdlib_clacgv( n-p+1, v(p,p), 1 )
                 end do
                 ! The Following Two Loops Perturb Small Entries To Avoid
                 ! denormals in the second qr factorization, where they are
                 ! as good as zeros. this is done to avoid painfully slow
                 ! computation with denormals. the relative size of the perturbation
                 ! is a parameter that can be changed by the implementer.
                 ! this perturbation device will be obsolete on machines with
                 ! properly implemented arithmetic.
                 ! to switch it off, set l2pert=.false. to remove it from  the
                 ! code, remove the action under l2pert=.true., leave the else part.
                 ! the following two loops should be blocked and fused with the
                 ! transposed copy above.
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do q = 1, nr
                       ctemp = cmplx(xsc*abs( v(q,q) ),zero,KIND=sp)
                       do p = 1, n
                          if ( ( p > q ) .and. ( abs(v(p,q)) <= temp1 ).or. ( p < q ) )v(p,q) = &
                                    ctemp
           ! $                   v(p,q) = temp1 * ( v(p,q) / abs(v(p,q)) )
                          if ( p < q ) v(p,q) = - v(p,q)
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_claset( 'U', nr-1, nr-1, czero, czero, v(1,2), ldv )
                 end if
                 ! estimate the row scaled condition number of r1
                 ! (if r1 is rectangular, n > nr, then the condition number
                 ! of the leading nr x nr submatrix is estimated.)
                 call stdlib_clacpy( 'L', nr, nr, v, ldv, cwork(2*n+1), nr )
                 do p = 1, nr
                    temp1 = stdlib_scnrm2(nr-p+1,cwork(2*n+(p-1)*nr+p),1)
                    call stdlib_csscal(nr-p+1,one/temp1,cwork(2*n+(p-1)*nr+p),1)
                 end do
                 call stdlib_cpocon('L',nr,cwork(2*n+1),nr,one,temp1,cwork(2*n+nr*nr+1),rwork,&
                           ierr)
                 condr1 = one / sqrt(temp1)
                 ! Here Need A Second Opinion On The Condition Number
                 ! Then Assume Worst Case Scenario
                 ! r1 is ok for inverse <=> condr1 < real(n,KIND=sp)
                 ! more conservative    <=> condr1 < sqrt(real(n,KIND=sp))
                 cond_ok = sqrt(sqrt(real(nr,KIND=sp)))
      ! [tp]       cond_ok is a tuning parameter.
                 if ( condr1 < cond_ok ) then
                    ! .. the second qrf without pivoting. note: in an optimized
                    ! implementation, this qrf should be implemented as the qrf
                    ! of a lower triangular matrix.
                    ! r1^* = q2 * r2
                    call stdlib_cgeqrf( n, nr, v, ldv, cwork(n+1), cwork(2*n+1),lwork-2*n, ierr )
                              
                    if ( l2pert ) then
                       xsc = sqrt(small)/epsln
                       do p = 2, nr
                          do q = 1, p - 1
                             ctemp=cmplx(xsc*min(abs(v(p,p)),abs(v(q,q))),zero,KIND=sp)
                             if ( abs(v(q,p)) <= temp1 )v(q,p) = ctemp
           ! $                     v(q,p) = temp1 * ( v(q,p) / abs(v(q,p)) )
                          end do
                       end do
                    end if
                    if ( nr /= n )call stdlib_clacpy( 'A', n, nr, v, ldv, cwork(2*n+1), n )
                              
                    ! .. save ...
                 ! This Transposed Copy Should Be Better Than Naive
                    do p = 1, nr - 1
                       call stdlib_ccopy( nr-p, v(p,p+1), ldv, v(p+1,p), 1 )
                       call stdlib_clacgv(nr-p+1, v(p,p), 1 )
                    end do
                    v(nr,nr)=conjg(v(nr,nr))
                    condr2 = condr1
                 else
                    ! .. ill-conditioned case: second qrf with pivoting
                    ! note that windowed pivoting would be equally good
                    ! numerically, and more run-time efficient. so, in
                    ! an optimal implementation, the next call to stdlib_cgeqp3
                    ! should be replaced with eg. call cgeqpx (acm toms #782)
                    ! with properly (carefully) chosen parameters.
                    ! r1^* * p2 = q2 * r2
                    do p = 1, nr
                       iwork(n+p) = 0
                    end do
                    call stdlib_cgeqp3( n, nr, v, ldv, iwork(n+1), cwork(n+1),cwork(2*n+1), lwork-&
                              2*n, rwork, ierr )
      ! *               call stdlib_cgeqrf( n, nr, v, ldv, cwork(n+1), cwork(2*n+1),
      ! *     $              lwork-2*n, ierr )
                    if ( l2pert ) then
                       xsc = sqrt(small)
                       do p = 2, nr
                          do q = 1, p - 1
                             ctemp=cmplx(xsc*min(abs(v(p,p)),abs(v(q,q))),zero,KIND=sp)
                             if ( abs(v(q,p)) <= temp1 )v(q,p) = ctemp
           ! $                     v(q,p) = temp1 * ( v(q,p) / abs(v(q,p)) )
                          end do
                       end do
                    end if
                    call stdlib_clacpy( 'A', n, nr, v, ldv, cwork(2*n+1), n )
                    if ( l2pert ) then
                       xsc = sqrt(small)
                       do p = 2, nr
                          do q = 1, p - 1
                             ctemp=cmplx(xsc*min(abs(v(p,p)),abs(v(q,q))),zero,KIND=sp)
                              ! v(p,q) = - temp1*( v(q,p) / abs(v(q,p)) )
                             v(p,q) = - ctemp
                          end do
                       end do
                    else
                       if (nr>1) call stdlib_claset( 'L',nr-1,nr-1,czero,czero,v(2,1),ldv )
                    end if
                    ! now, compute r2 = l3 * q3, the lq factorization.
                    call stdlib_cgelqf( nr, nr, v, ldv, cwork(2*n+n*nr+1),cwork(2*n+n*nr+nr+1), &
                              lwork-2*n-n*nr-nr, ierr )
                    ! And Estimate The Condition Number
                    call stdlib_clacpy( 'L',nr,nr,v,ldv,cwork(2*n+n*nr+nr+1),nr )
                    do p = 1, nr
                       temp1 = stdlib_scnrm2( p, cwork(2*n+n*nr+nr+p), nr )
                       call stdlib_csscal( p, one/temp1, cwork(2*n+n*nr+nr+p), nr )
                    end do
                    call stdlib_cpocon( 'L',nr,cwork(2*n+n*nr+nr+1),nr,one,temp1,cwork(2*n+n*nr+&
                              nr+nr*nr+1),rwork,ierr )
                    condr2 = one / sqrt(temp1)
                    if ( condr2 >= cond_ok ) then
                       ! Save The Householder Vectors Used For Q3
                       ! (this overwrites the copy of r2, as it will not be
                       ! needed in this branch, but it does not overwritte the
                       ! huseholder vectors of q2.).
                       call stdlib_clacpy( 'U', nr, nr, v, ldv, cwork(2*n+1), n )
                       ! And The Rest Of The Information On Q3 Is In
                       ! work(2*n+n*nr+1:2*n+n*nr+n)
                    end if
                 end if
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do q = 2, nr
                       ctemp = xsc * v(q,q)
                       do p = 1, q - 1
                           ! v(p,q) = - temp1*( v(p,q) / abs(v(p,q)) )
                          v(p,q) = - ctemp
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_claset( 'U', nr-1,nr-1, czero,czero, v(1,2), ldv )
                 end if
              ! second preconditioning finished; continue with jacobi svd
              ! the input matrix is lower trinagular.
              ! recover the right singular vectors as solution of a well
              ! conditioned triangular matrix equation.
                 if ( condr1 < cond_ok ) then
                    call stdlib_cgesvj( 'L','U','N',nr,nr,v,ldv,sva,nr,u, ldu,cwork(2*n+n*nr+nr+1)&
                              ,lwork-2*n-n*nr-nr,rwork,lrwork, info )
                    scalem  = rwork(1)
                    numrank = nint(rwork(2),KIND=ilp)
                    do p = 1, nr
                       call stdlib_ccopy(  nr, v(1,p), 1, u(1,p), 1 )
                       call stdlib_csscal( nr, sva(p),    v(1,p), 1 )
                    end do
              ! Pick The Right Matrix Equation And Solve It
                    if ( nr == n ) then
       ! :))             .. best case, r1 is inverted. the solution of this matrix
                       ! equation is q2*v2 = the product of the jacobi rotations
                       ! used in stdlib_cgesvj, premultiplied with the orthogonal matrix
                       ! from the second qr factorization.
                       call stdlib_ctrsm('L','U','N','N', nr,nr,cone, a,lda, v,ldv)
                    else
                       ! .. r1 is well conditioned, but non-square. adjoint of r2
                       ! is inverted to get the product of the jacobi rotations
                       ! used in stdlib_cgesvj. the q-factor from the second qr
                       ! factorization is then built in explicitly.
                       call stdlib_ctrsm('L','U','C','N',nr,nr,cone,cwork(2*n+1),n,v,ldv)
                       if ( nr < n ) then
                       call stdlib_claset('A',n-nr,nr,czero,czero,v(nr+1,1),ldv)
                       call stdlib_claset('A',nr,n-nr,czero,czero,v(1,nr+1),ldv)
                       call stdlib_claset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                       end if
                       call stdlib_cunmqr('L','N',n,n,nr,cwork(2*n+1),n,cwork(n+1),v,ldv,cwork(&
                                 2*n+n*nr+nr+1),lwork-2*n-n*nr-nr,ierr)
                    end if
                 else if ( condr2 < cond_ok ) then
                    ! the matrix r2 is inverted. the solution of the matrix equation
                    ! is q3^* * v3 = the product of the jacobi rotations (appplied to
                    ! the lower triangular l3 from the lq factorization of
                    ! r2=l3*q3), pre-multiplied with the transposed q3.
                    call stdlib_cgesvj( 'L', 'U', 'N', nr, nr, v, ldv, sva, nr, u,ldu, cwork(2*n+&
                              n*nr+nr+1), lwork-2*n-n*nr-nr,rwork, lrwork, info )
                    scalem  = rwork(1)
                    numrank = nint(rwork(2),KIND=ilp)
                    do p = 1, nr
                       call stdlib_ccopy( nr, v(1,p), 1, u(1,p), 1 )
                       call stdlib_csscal( nr, sva(p),    u(1,p), 1 )
                    end do
                    call stdlib_ctrsm('L','U','N','N',nr,nr,cone,cwork(2*n+1),n,u,ldu)
                    ! Apply The Permutation From The Second Qr Factorization
                    do q = 1, nr
                       do p = 1, nr
                          cwork(2*n+n*nr+nr+iwork(n+p)) = u(p,q)
                       end do
                       do p = 1, nr
                          u(p,q) = cwork(2*n+n*nr+nr+p)
                       end do
                    end do
                    if ( nr < n ) then
                       call stdlib_claset( 'A',n-nr,nr,czero,czero,v(nr+1,1),ldv )
                       call stdlib_claset( 'A',nr,n-nr,czero,czero,v(1,nr+1),ldv )
                       call stdlib_claset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                    end if
                    call stdlib_cunmqr( 'L','N',n,n,nr,cwork(2*n+1),n,cwork(n+1),v,ldv,cwork(2*n+&
                              n*nr+nr+1),lwork-2*n-n*nr-nr,ierr )
                 else
                    ! last line of defense.
       ! #:(          this is a rather pathological case: no scaled condition
                    ! improvement after two pivoted qr factorizations. other
                    ! possibility is that the rank revealing qr factorization
                    ! or the condition estimator has failed, or the cond_ok
                    ! is set very close to one (which is unnecessary). normally,
                    ! this branch should never be executed, but in rare cases of
                    ! failure of the rrqr or condition estimator, the last line of
                    ! defense ensures that stdlib_cgejsv completes the task.
                    ! compute the full svd of l3 using stdlib_cgesvj with explicit
                    ! accumulation of jacobi rotations.
                    call stdlib_cgesvj( 'L', 'U', 'V', nr, nr, v, ldv, sva, nr, u,ldu, cwork(2*n+&
                              n*nr+nr+1), lwork-2*n-n*nr-nr,rwork, lrwork, info )
                    scalem  = rwork(1)
                    numrank = nint(rwork(2),KIND=ilp)
                    if ( nr < n ) then
                       call stdlib_claset( 'A',n-nr,nr,czero,czero,v(nr+1,1),ldv )
                       call stdlib_claset( 'A',nr,n-nr,czero,czero,v(1,nr+1),ldv )
                       call stdlib_claset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                    end if
                    call stdlib_cunmqr( 'L','N',n,n,nr,cwork(2*n+1),n,cwork(n+1),v,ldv,cwork(2*n+&
                              n*nr+nr+1),lwork-2*n-n*nr-nr,ierr )
                    call stdlib_cunmlq( 'L', 'C', nr, nr, nr, cwork(2*n+1), n,cwork(2*n+n*nr+1), &
                              u, ldu, cwork(2*n+n*nr+nr+1),lwork-2*n-n*nr-nr, ierr )
                    do q = 1, nr
                       do p = 1, nr
                          cwork(2*n+n*nr+nr+iwork(n+p)) = u(p,q)
                       end do
                       do p = 1, nr
                          u(p,q) = cwork(2*n+n*nr+nr+p)
                       end do
                    end do
                 end if
                 ! permute the rows of v using the (column) permutation from the
                 ! first qrf. also, scale the columns to make them unit in
                 ! euclidean norm. this applies to all cases.
                 temp1 = sqrt(real(n,KIND=sp)) * epsln
                 do q = 1, n
                    do p = 1, n
                       cwork(2*n+n*nr+nr+iwork(p)) = v(p,q)
                    end do
                    do p = 1, n
                       v(p,q) = cwork(2*n+n*nr+nr+p)
                    end do
                    xsc = one / stdlib_scnrm2( n, v(1,q), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_csscal( n, xsc,&
                               v(1,q), 1 )
                 end do
                 ! at this moment, v contains the right singular vectors of a.
                 ! next, assemble the left singular vector matrix u (m x n).
                 if ( nr < m ) then
                    call stdlib_claset('A', m-nr, nr, czero, czero, u(nr+1,1), ldu)
                    if ( nr < n1 ) then
                       call stdlib_claset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                       call stdlib_claset('A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1),ldu)
                    end if
                 end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! matrix u. this applies to all cases.
                 call stdlib_cunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, cwork(n+1), lwork-&
                           n, ierr )
                 ! the columns of u are normalized. the cost is o(m*n) flops.
                 temp1 = sqrt(real(m,KIND=sp)) * epsln
                 do p = 1, nr
                    xsc = one / stdlib_scnrm2( m, u(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_csscal( m, xsc,&
                               u(1,p), 1 )
                 end do
                 ! if the initial qrf is computed with row pivoting, the left
                 ! singular vectors must be adjusted.
                 if ( rowpiv )call stdlib_claswp( n1, u, ldu, 1, m-1, iwork(iwoff+1), -1 )
              else
              ! The Initial Matrix A Has Almost Orthogonal Columns And
              ! the second qrf is not needed
                 call stdlib_clacpy( 'U', n, n, a, lda, cwork(n+1), n )
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do p = 2, n
                       ctemp = xsc * cwork( n + (p-1)*n + p )
                       do q = 1, p - 1
                           ! cwork(n+(q-1)*n+p)=-temp1 * ( cwork(n+(p-1)*n+q) /
           ! $                                        abs(cwork(n+(p-1)*n+q)) )
                          cwork(n+(q-1)*n+p)=-ctemp
                       end do
                    end do
                 else
                    call stdlib_claset( 'L',n-1,n-1,czero,czero,cwork(n+2),n )
                 end if
                 call stdlib_cgesvj( 'U', 'U', 'N', n, n, cwork(n+1), n, sva,n, u, ldu, cwork(n+&
                           n*n+1), lwork-n-n*n, rwork, lrwork,info )
                 scalem  = rwork(1)
                 numrank = nint(rwork(2),KIND=ilp)
                 do p = 1, n
                    call stdlib_ccopy( n, cwork(n+(p-1)*n+1), 1, u(1,p), 1 )
                    call stdlib_csscal( n, sva(p), cwork(n+(p-1)*n+1), 1 )
                 end do
                 call stdlib_ctrsm( 'L', 'U', 'N', 'N', n, n,cone, a, lda, cwork(n+1), n )
                 do p = 1, n
                    call stdlib_ccopy( n, cwork(n+p), n, v(iwork(p),1), ldv )
                 end do
                 temp1 = sqrt(real(n,KIND=sp))*epsln
                 do p = 1, n
                    xsc = one / stdlib_scnrm2( n, v(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_csscal( n, xsc,&
                               v(1,p), 1 )
                 end do
                 ! assemble the left singular vector matrix u (m x n).
                 if ( n < m ) then
                    call stdlib_claset( 'A',  m-n, n, czero, czero, u(n+1,1), ldu )
                    if ( n < n1 ) then
                       call stdlib_claset('A',n,  n1-n, czero, czero,  u(1,n+1),ldu)
                       call stdlib_claset( 'A',m-n,n1-n, czero, cone,u(n+1,n+1),ldu)
                    end if
                 end if
                 call stdlib_cunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, cwork(n+1), lwork-&
                           n, ierr )
                 temp1 = sqrt(real(m,KIND=sp))*epsln
                 do p = 1, n1
                    xsc = one / stdlib_scnrm2( m, u(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_csscal( m, xsc,&
                               u(1,p), 1 )
                 end do
                 if ( rowpiv )call stdlib_claswp( n1, u, ldu, 1, m-1, iwork(iwoff+1), -1 )
              end if
              ! end of the  >> almost orthogonal case <<  in the full svd
              else
              ! this branch deploys a preconditioned jacobi svd with explicitly
              ! accumulated rotations. it is included as optional, mainly for
              ! experimental purposes. it does perform well, and can also be used.
              ! in this implementation, this branch will be automatically activated
              ! if the  condition number sigma_max(a) / sigma_min(a) is predicted
              ! to be greater than the overflow threshold. this is because the
              ! a posteriori computation of the singular vectors assumes robust
              ! implementation of blas and some lapack procedures, capable of working
              ! in presence of extreme values, e.g. when the singular values spread from
              ! the underflow to the overflow threshold.
              do p = 1, nr
                 call stdlib_ccopy( n-p+1, a(p,p), lda, v(p,p), 1 )
                 call stdlib_clacgv( n-p+1, v(p,p), 1 )
              end do
              if ( l2pert ) then
                 xsc = sqrt(small/epsln)
                 do q = 1, nr
                    ctemp = cmplx(xsc*abs( v(q,q) ),zero,KIND=sp)
                    do p = 1, n
                       if ( ( p > q ) .and. ( abs(v(p,q)) <= temp1 ).or. ( p < q ) )v(p,q) = &
                                 ctemp
           ! $                v(p,q) = temp1 * ( v(p,q) / abs(v(p,q)) )
                       if ( p < q ) v(p,q) = - v(p,q)
                    end do
                 end do
              else
                 if (nr>1) call stdlib_claset( 'U', nr-1, nr-1, czero, czero, v(1,2), ldv )
              end if
              call stdlib_cgeqrf( n, nr, v, ldv, cwork(n+1), cwork(2*n+1),lwork-2*n, ierr )
                        
              call stdlib_clacpy( 'L', n, nr, v, ldv, cwork(2*n+1), n )
              do p = 1, nr
                 call stdlib_ccopy( nr-p+1, v(p,p), ldv, u(p,p), 1 )
                 call stdlib_clacgv( nr-p+1, u(p,p), 1 )
              end do
              if ( l2pert ) then
                 xsc = sqrt(small/epsln)
                 do q = 2, nr
                    do p = 1, q - 1
                       ctemp = cmplx(xsc * min(abs(u(p,p)),abs(u(q,q))),zero,KIND=sp)
                        ! u(p,q) = - temp1 * ( u(q,p) / abs(u(q,p)) )
                       u(p,q) = - ctemp
                    end do
                 end do
              else
                 if (nr>1) call stdlib_claset('U', nr-1, nr-1, czero, czero, u(1,2), ldu )
              end if
              call stdlib_cgesvj( 'L', 'U', 'V', nr, nr, u, ldu, sva,n, v, ldv, cwork(2*n+n*nr+1),&
                         lwork-2*n-n*nr,rwork, lrwork, info )
              scalem  = rwork(1)
              numrank = nint(rwork(2),KIND=ilp)
              if ( nr < n ) then
                 call stdlib_claset( 'A',n-nr,nr,czero,czero,v(nr+1,1),ldv )
                 call stdlib_claset( 'A',nr,n-nr,czero,czero,v(1,nr+1),ldv )
                 call stdlib_claset( 'A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv )
              end if
              call stdlib_cunmqr( 'L','N',n,n,nr,cwork(2*n+1),n,cwork(n+1),v,ldv,cwork(2*n+n*nr+&
                        nr+1),lwork-2*n-n*nr-nr,ierr )
                 ! permute the rows of v using the (column) permutation from the
                 ! first qrf. also, scale the columns to make them unit in
                 ! euclidean norm. this applies to all cases.
                 temp1 = sqrt(real(n,KIND=sp)) * epsln
                 do q = 1, n
                    do p = 1, n
                       cwork(2*n+n*nr+nr+iwork(p)) = v(p,q)
                    end do
                    do p = 1, n
                       v(p,q) = cwork(2*n+n*nr+nr+p)
                    end do
                    xsc = one / stdlib_scnrm2( n, v(1,q), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_csscal( n, xsc,&
                               v(1,q), 1 )
                 end do
                 ! at this moment, v contains the right singular vectors of a.
                 ! next, assemble the left singular vector matrix u (m x n).
              if ( nr < m ) then
                 call stdlib_claset( 'A',  m-nr, nr, czero, czero, u(nr+1,1), ldu )
                 if ( nr < n1 ) then
                    call stdlib_claset('A',nr,  n1-nr, czero, czero,  u(1,nr+1),ldu)
                    call stdlib_claset('A',m-nr,n1-nr, czero, cone,u(nr+1,nr+1),ldu)
                 end if
              end if
              call stdlib_cunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, cwork(n+1), lwork-n, &
                        ierr )
                 if ( rowpiv )call stdlib_claswp( n1, u, ldu, 1, m-1, iwork(iwoff+1), -1 )
              end if
              if ( transp ) then
                 ! .. swap u and v because the procedure worked on a^*
                 do p = 1, n
                    call stdlib_cswap( n, u(1,p), 1, v(1,p), 1 )
                 end do
              end if
           end if
           ! end of the full svd
           ! undo scaling, if necessary (and possible)
           if ( uscal2 <= (big/sva(1))*uscal1 ) then
              call stdlib_slascl( 'G', 0, 0, uscal1, uscal2, nr, 1, sva, n, ierr )
              uscal1 = one
              uscal2 = one
           end if
           if ( nr < n ) then
              do p = nr+1, n
                 sva(p) = zero
              end do
           end if
           rwork(1) = uscal2 * scalem
           rwork(2) = uscal1
           if ( errest ) rwork(3) = sconda
           if ( lsvec .and. rsvec ) then
              rwork(4) = condr1
              rwork(5) = condr2
           end if
           if ( l2tran ) then
              rwork(6) = entra
              rwork(7) = entrat
           end if
           iwork(1) = nr
           iwork(2) = numrank
           iwork(3) = warning
           if ( transp ) then
               iwork(4) =  1
           else
               iwork(4) = -1
           end if
           return
     end subroutine stdlib_cgejsv


     pure subroutine stdlib_cgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, cwork, lwork, &
     !! CGESVJ computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N unitary matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
               rwork, lrwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, lrwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), v(ldv,*), cwork(lwork)
           real(sp), intent(inout) :: rwork(lrwork)
           real(sp), intent(out) :: sva(n)
        ! =====================================================================
           ! Local Parameters 
           integer(ilp), parameter :: nsweep = 30
           
           
           
           ! Local Scalars 
           complex(sp) :: aapq, ompq
           real(sp) :: aapp, aapp0, aapq1, aaqq, apoaq, aqoap, big, bigtheta, cs, ctol, epsln, &
           mxaapq, mxsinj, rootbig, rooteps, rootsfmin, roottol, skl, sfmin, small, sn, t, temp1, &
                     theta, thsign, tol
           integer(ilp) :: blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1, iswrot, jbc, jgl, kbl, &
                     lkahead, mvl, n2, n34, n4, nbl, notrot, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, goscale, lower, lquery, lsvec, noscale, rotok, rsvec, uctol, &
                     upper
           ! Intrinsic Functions 
           intrinsic :: abs,max,min,conjg,real,sign,sqrt
           ! from lapack
           ! from lapack
           ! Executable Statements 
           ! test the input arguments
           lsvec = stdlib_lsame( jobu, 'U' ) .or. stdlib_lsame( jobu, 'F' )
           uctol = stdlib_lsame( jobu, 'C' )
           rsvec = stdlib_lsame( jobv, 'V' ) .or. stdlib_lsame( jobv, 'J' )
           applv = stdlib_lsame( jobv, 'A' )
           upper = stdlib_lsame( joba, 'U' )
           lower = stdlib_lsame( joba, 'L' )
           lquery = ( lwork == -1 ) .or. ( lrwork == -1 )
           if( .not.( upper .or. lower .or. stdlib_lsame( joba, 'G' ) ) ) then
              info = -1
           else if( .not.( lsvec .or. uctol .or. stdlib_lsame( jobu, 'N' ) ) ) then
              info = -2
           else if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -5
           else if( lda<m ) then
              info = -7
           else if( mv<0 ) then
              info = -9
           else if( ( rsvec .and. ( ldv<n ) ) .or.( applv .and. ( ldv<mv ) ) ) then
              info = -11
           else if( uctol .and. ( rwork( 1 )<=one ) ) then
              info = -12
           else if( lwork<( m+n ) .and. ( .not.lquery ) ) then
              info = -13
           else if( lrwork<max( n, 6 ) .and. ( .not.lquery ) ) then
              info = -15
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'CGESVJ', -info )
              return
           else if ( lquery ) then
              cwork(1) = m + n
              rwork(1) = max( n, 6 )
              return
           end if
       ! #:) quick return for void matrix
           if( ( m==0 ) .or. ( n==0 ) )return
           ! set numerical parameters
           ! the stopping criterion for jacobi rotations is
           ! max_{i<>j}|a(:,i)^* * a(:,j)| / (||a(:,i)||*||a(:,j)||) < ctol*eps
           ! where eps is the round-off and ctol is defined as follows:
           if( uctol ) then
              ! ... user controlled
              ctol = rwork( 1 )
           else
              ! ... default
              if( lsvec .or. rsvec .or. applv ) then
                 ctol = sqrt( real( m,KIND=sp) )
              else
                 ctol = real( m,KIND=sp)
              end if
           end if
           ! ... and the machine dependent parameters are
      ! [!]  (make sure that stdlib_slamch() works properly on the target machine.)
           epsln = stdlib_slamch( 'EPSILON' )
           rooteps = sqrt( epsln )
           sfmin = stdlib_slamch( 'SAFEMINIMUM' )
           rootsfmin = sqrt( sfmin )
           small = sfmin / epsln
            ! big = stdlib_slamch( 'overflow' )
           big     = one  / sfmin
           rootbig = one / rootsfmin
           ! large = big / sqrt( real( m*n,KIND=sp) )
           bigtheta = one / rooteps
           tol = ctol*epsln
           roottol = sqrt( tol )
           if( real( m,KIND=sp)*epsln>=one ) then
              info = -4
              call stdlib_xerbla( 'CGESVJ', -info )
              return
           end if
           ! initialize the right singular vector matrix.
           if( rsvec ) then
              mvl = n
              call stdlib_claset( 'A', mvl, n, czero, cone, v, ldv )
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           ! initialize sva( 1:n ) = ( ||a e_i||_2, i = 1:n )
      ! (!)  if necessary, scale a to protect the largest singular value
           ! from overflow. it is possible that saving the largest singular
           ! value destroys the information about the small ones.
           ! this initial scaling is almost minimal in the sense that the
           ! goal is to make sure that no column norm overflows, and that
           ! sqrt(n)*max_i sva(i) does not overflow. if infinite entries
           ! in a are detected, the procedure returns with info=-6.
           skl = one / sqrt( real( m,KIND=sp)*real( n,KIND=sp) )
           noscale = .true.
           goscale = .true.
           if( lower ) then
              ! the input matrix is m-by-n lower triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_classq( m-p+1, a( p, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'CGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else if( upper ) then
              ! the input matrix is m-by-n upper triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_classq( p, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'CGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else
              ! the input matrix is m-by-n general dense
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_classq( m, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'CGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           end if
           if( noscale )skl = one
           ! move the smaller part of the spectrum from the underflow threshold
      ! (!)  start by determining the position of the nonzero entries of the
           ! array sva() relative to ( sfmin, big ).
           aapp = zero
           aaqq = big
           do p = 1, n
              if( sva( p )/=zero )aaqq = min( aaqq, sva( p ) )
              aapp = max( aapp, sva( p ) )
           end do
       ! #:) quick return for zero matrix
           if( aapp==zero ) then
              if( lsvec )call stdlib_claset( 'G', m, n, czero, cone, a, lda )
              rwork( 1 ) = one
              rwork( 2 ) = zero
              rwork( 3 ) = zero
              rwork( 4 ) = zero
              rwork( 5 ) = zero
              rwork( 6 ) = zero
              return
           end if
       ! #:) quick return for one-column matrix
           if( n==1 ) then
              if( lsvec )call stdlib_clascl( 'G', 0, 0, sva( 1 ), skl, m, 1,a( 1, 1 ), lda, ierr )
                        
              rwork( 1 ) = one / skl
              if( sva( 1 )>=sfmin ) then
                 rwork( 2 ) = one
              else
                 rwork( 2 ) = zero
              end if
              rwork( 3 ) = zero
              rwork( 4 ) = zero
              rwork( 5 ) = zero
              rwork( 6 ) = zero
              return
           end if
           ! protect small singular values from underflow, and try to
           ! avoid underflows/overflows in computing jacobi rotations.
           sn = sqrt( sfmin / epsln )
           temp1 = sqrt( big / real( n,KIND=sp) )
           if( ( aapp<=sn ) .or. ( aaqq>=temp1 ) .or.( ( sn<=aaqq ) .and. ( aapp<=temp1 ) ) ) &
                     then
              temp1 = min( big, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp<=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( aapp*sqrt( real( n,KIND=sp) ) ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq>=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = max( sn / aaqq, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( sqrt( real( n,KIND=sp) )*aapp ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else
              temp1 = one
           end if
           ! scale, if necessary
           if( temp1/=one ) then
              call stdlib_slascl( 'G', 0, 0, one, temp1, n, 1, sva, n, ierr )
           end if
           skl = temp1*skl
           if( skl/=one ) then
              call stdlib_clascl( joba, 0, 0, one, skl, m, n, a, lda, ierr )
              skl = one / skl
           end if
           ! row-cyclic jacobi svd algorithm with column pivoting
           emptsw = ( n*( n-1 ) ) / 2
           notrot = 0
           do q = 1, n
              cwork( q ) = cone
           end do
           swband = 3
      ! [tp] swband is a tuning parameter [tp]. it is meaningful and effective
           ! if stdlib_cgesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_cgejsv. for sweeps i=1:swband the procedure
           ! works on pivots inside a band-like region around the diagonal.
           ! the boundaries are determined dynamically, based on the number of
           ! pivots above a threshold.
           kbl = min( 8, n )
      ! [tp] kbl is a tuning parameter that defines the tile size in the
           ! tiling of the p-q loops of pivot pairs. in general, an optimal
           ! value of kbl depends on the matrix dimensions and on the
           ! parameters of the computer's memory.
           nbl = n / kbl
           if( ( nbl*kbl )/=n )nbl = nbl + 1
           blskip = kbl**2
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           lkahead = 1
      ! [tp] lkahead is a tuning parameter.
           ! quasi block transformations, using the lower (upper) triangular
           ! structure of the input matrix. the quasi-block-cycling usually
           ! invokes cubic convergence. big part of this cycle is done inside
           ! canonical subspaces of dimensions less than m.
           if( ( lower .or. upper ) .and. ( n>max( 64, 4*kbl ) ) ) then
      ! [tp] the number of partition levels and the actual partition are
           ! tuning parameters.
              n4 = n / 4
              n2 = n / 2
              n34 = 3*n4
              if( applv ) then
                 q = 0
              else
                 q = 1
              end if
              if( lower ) then
           ! this works very well on lower triangular matrices, in particular
           ! in the framework of the preconditioned jacobi svd (xgejsv).
           ! the idea is simple:
           ! [+ 0 0 0]   note that jacobi transformations of [0 0]
           ! [+ + 0 0]                                       [0 0]
           ! [+ + x 0]   actually work on [x 0]              [x 0]
           ! [+ + x x]                    [x x].             [x x]
                 call stdlib_cgsvj0( jobv, m-n34, n-n34, a( n34+1, n34+1 ), lda,cwork( n34+1 ), &
                 sva( n34+1 ), mvl,v( n34*q+1, n34+1 ), ldv, epsln, sfmin, tol,2, cwork( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_cgsvj0( jobv, m-n2, n34-n2, a( n2+1, n2+1 ), lda,cwork( n2+1 ), sva( &
                 n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 2,cwork( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_cgsvj1( jobv, m-n2, n-n2, n4, a( n2+1, n2+1 ), lda,cwork( n2+1 ), &
                 sva( n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_cgsvj0( jobv, m-n4, n2-n4, a( n4+1, n4+1 ), lda,cwork( n4+1 ), sva( &
                 n4+1 ), mvl,v( n4*q+1, n4+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_cgsvj0( jobv, m, n4, a, lda, cwork, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 1, cwork( n+1 ), lwork-n,ierr )
                 call stdlib_cgsvj1( jobv, m, n2, n4, a, lda, cwork, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, cwork( n+1 ),lwork-n, ierr )
              else if( upper ) then
                 call stdlib_cgsvj0( jobv, n4, n4, a, lda, cwork, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 2, cwork( n+1 ), lwork-n,ierr )
                 call stdlib_cgsvj0( jobv, n2, n4, a( 1, n4+1 ), lda, cwork( n4+1 ),sva( n4+1 ), &
                 mvl, v( n4*q+1, n4+1 ), ldv,epsln, sfmin, tol, 1, cwork( n+1 ), lwork-n,ierr )
                           
                 call stdlib_cgsvj1( jobv, n2, n2, n4, a, lda, cwork, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, cwork( n+1 ),lwork-n, ierr )
                 call stdlib_cgsvj0( jobv, n2+n4, n4, a( 1, n2+1 ), lda,cwork( n2+1 ), sva( n2+1 )&
                 , mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), lwork-n, ierr )
                           
              end if
           end if
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
           ! each sweep is unrolled using kbl-by-kbl tiles over the pivot pairs
           ! 1 <= p < q <= n. this is the first step toward a blocked implementation
           ! of the rotations. new implementation, based on block transformations,
           ! is under development.
              loop_2000: do ibr = 1, nbl
                 igl = ( ibr-1 )*kbl + 1
                 loop_1002: do ir1 = 0, min( lkahead, nbl-ibr )
                    igl = igl + ir1*kbl
                    loop_2001: do p = igl, min( igl+kbl-1, n-1 )
           ! .. de rijk's pivoting
                       q = stdlib_isamax( n-p+1, sva( p ), 1 ) + p - 1
                       if( p/=q ) then
                          call stdlib_cswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                          if( rsvec )call stdlib_cswap( mvl, v( 1, p ), 1,v( 1, q ), 1 )
                          temp1 = sva( p )
                          sva( p ) = sva( q )
                          sva( q ) = temp1
                          aapq = cwork(p)
                          cwork(p) = cwork(q)
                          cwork(q) = aapq
                       end if
                       if( ir1==0 ) then
              ! column norms are periodically updated by explicit
              ! norm computation.
      ! [!]     caveat:
              ! unfortunately, some blas implementations compute stdlib_scnrm2(m,a(1,p),1)
              ! as sqrt(s=stdlib_cdotc(m,a(1,p),1,a(1,p),1)), which may cause the result to
              ! overflow for ||a(:,p)||_2 > sqrt(overflow_threshold), and to
              ! underflow for ||a(:,p)||_2 < sqrt(underflow_threshold).
              ! hence, stdlib_scnrm2 cannot be trusted, not even in the case when
              ! the true norm is far from the under(over)flow boundaries.
              ! if properly implemented stdlib_scnrm2 is available, the if-then-else-end if
              ! below should be replaced with "aapp = stdlib_scnrm2( m, a(1,p), 1 )".
                          if( ( sva( p )<rootbig ) .and.( sva( p )>rootsfmin ) ) then
                             sva( p ) = stdlib_scnrm2( m, a( 1, p ), 1 )
                          else
                             temp1 = zero
                             aapp = one
                             call stdlib_classq( m, a( 1, p ), 1, temp1, aapp )
                             sva( p ) = temp1*sqrt( aapp )
                          end if
                          aapp = sva( p )
                       else
                          aapp = sva( p )
                       end if
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2002: do q = p + 1, min( igl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
                                if( aaqq>=one ) then
                                   rotok = ( small*aapp )<=aaqq
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_ccopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_clascl( 'G', 0, 0, aapp, one,m, 1, cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_cdotc( m, cwork(n+1), 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   rotok = aapp<=( aaqq / small )
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aapp ) / aaqq
                                   else
                                      call stdlib_ccopy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                      call stdlib_clascl( 'G', 0, 0, aaqq,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_cdotc( m, a(1, p ), 1,cwork(n+1), 1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg( cwork(p) ) * cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                    ompq = aapq / abs(aapq)
                 ! Rotate
      ! [rtd]      rotated = rotated + one
                                   if( ir1==0 ) then
                                      notrot = 0
                                      pskipped = 0
                                      iswrot = iswrot + 1
                                   end if
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/aapq1
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if ( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if ( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      cwork(p) = -cwork(q) * ompq
                                      else
                    ! .. have to use modified gram-schmidt like transformation
                                      call stdlib_ccopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_clascl( 'G', 0, 0, aapp, one, m,1, cwork(n+1), &
                                                lda,ierr )
                                      call stdlib_clascl( 'G', 0, 0, aaqq, one, m,1, a( 1, q ), &
                                                lda, ierr )
                                      call stdlib_caxpy( m, -aapq, cwork(n+1), 1,a( 1, q ), 1 )
                                                
                                      call stdlib_clascl( 'G', 0, 0, one, aaqq, m,1, a( 1, q ), &
                                                lda, ierr )
                                      sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                      mxsinj = max( mxsinj, sfmin )
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! recompute sva(q), sva(p).
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_scnrm2( m, a( 1, q ), 1 )
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_classq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_scnrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_classq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                                else
                                   ! a(:,p) and a(:,q) already numerically orthogonal
                                   if( ir1==0 )notrot = notrot + 1
      ! [rtd]      skipped  = skipped + 1
                                   pskipped = pskipped + 1
                                end if
                             else
                                ! a(:,q) is zero column
                                if( ir1==0 )notrot = notrot + 1
                                pskipped = pskipped + 1
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                if( ir1==0 )aapp = -aapp
                                notrot = 0
                                go to 2103
                             end if
                          end do loop_2002
           ! end q-loop
           2103 continue
           ! bailed out of q-loop
                          sva( p ) = aapp
                       else
                          sva( p ) = aapp
                          if( ( ir1==0 ) .and. ( aapp==zero ) )notrot = notrot + min( igl+kbl-1, &
                                    n ) - p
                       end if
                    end do loop_2001
           ! end of the p-loop
           ! end of doing the block ( ibr, ibr )
                 end do loop_1002
           ! end of ir1-loop
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = ibr + 1, nbl
                    jgl = ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! safe gram matrix computation
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_ccopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_clascl( 'G', 0, 0, aapp,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_cdotc( m, cwork(n+1), 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / max(&
                                                aaqq,aapp) )/ min(aaqq,aapp)
                                   else
                                      call stdlib_ccopy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                      call stdlib_clascl( 'G', 0, 0, aaqq,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_cdotc( m, a( 1, p ), 1,cwork(n+1),  1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg(cwork(p))*cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                   ompq = aapq / abs(aapq)
                                   notrot = 0
      ! [rtd]      rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/ aapq1
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      cwork(p) = -cwork(q) * ompq
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                    if( aapp>aaqq ) then
                                         call stdlib_ccopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                                   
                                         call stdlib_clascl( 'G', 0, 0, aapp, one,m, 1, cwork(n+1)&
                                                   ,lda,ierr )
                                         call stdlib_clascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         call stdlib_caxpy( m, -aapq, cwork(n+1),1, a( 1, q ), 1 )
                                                   
                                         call stdlib_clascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    else
                                        call stdlib_ccopy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                         call stdlib_clascl( 'G', 0, 0, aaqq, one,m, 1, cwork(n+1)&
                                                   ,lda,ierr )
                                         call stdlib_clascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         call stdlib_caxpy( m, -conjg(aapq),cwork(n+1), 1, a( 1, &
                                                   p ), 1 )
                                         call stdlib_clascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! .. recompute sva(q), sva(p)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_scnrm2( m, a( 1, q ), 1)
                                       else
                                         t = zero
                                         aaqq = one
                                         call stdlib_classq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_scnrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_classq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_scnrm2( m, a( 1, n ), 1 )
              else
                 t = zero
                 aapp = one
                 call stdlib_classq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<sqrt( real( n,KIND=sp) )*tol ) .and. ( real( n,&
                        KIND=sp)*mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:( reaching this point means that the procedure has not converged.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means numerical convergence after the i-th
           ! sweep.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the singular values and find how many are above
           ! the underflow threshold.
           n2 = 0
           n4 = 0
           do p = 1, n - 1
              q = stdlib_isamax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 call stdlib_cswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_cswap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
              if( sva( p )/=zero ) then
                 n4 = n4 + 1
                 if( sva( p )*skl>sfmin )n2 = n2 + 1
              end if
           end do
           if( sva( n )/=zero ) then
              n4 = n4 + 1
              if( sva( n )*skl>sfmin )n2 = n2 + 1
           end if
           ! normalize the left singular vectors.
           if( lsvec .or. uctol ) then
              do p = 1, n4
                 ! call stdlib_csscal( m, one / sva( p ), a( 1, p ), 1 )
                 call stdlib_clascl( 'G',0,0, sva(p), one, m, 1, a(1,p), m, ierr )
              end do
           end if
           ! scale the product of jacobi rotations.
           if( rsvec ) then
                 do p = 1, n
                    temp1 = one / stdlib_scnrm2( mvl, v( 1, p ), 1 )
                    call stdlib_csscal( mvl, temp1, v( 1, p ), 1 )
                 end do
           end if
           ! undo scaling, if necessary (and possible).
           if( ( ( skl>one ) .and. ( sva( 1 )<( big / skl ) ) ).or. ( ( skl<one ) .and. ( sva( &
                     max( n2, 1 ) ) >( sfmin / skl ) ) ) ) then
              do p = 1, n
                 sva( p ) = skl*sva( p )
              end do
              skl = one
           end if
           rwork( 1 ) = skl
           ! the singular values of a are skl*sva(1:n). if skl/=one
           ! then some of the singular values may overflow or underflow and
           ! the spectrum is given in this factored representation.
           rwork( 2 ) = real( n4,KIND=sp)
           ! n4 is the number of computed nonzero singular values of a.
           rwork( 3 ) = real( n2,KIND=sp)
           ! n2 is the number of singular values of a greater than sfmin.
           ! if n2<n, sva(n2:n) contains zeros and/or denormalized numbers
           ! that may carry some information.
           rwork( 4 ) = real( i,KIND=sp)
           ! i is the index of the last sweep before declaring convergence.
           rwork( 5 ) = mxaapq
           ! mxaapq is the largest absolute value of scaled pivots in the
           ! last sweep
           rwork( 6 ) = mxsinj
           ! mxsinj is the largest absolute value of the sines of jacobi angles
           ! in the last sweep
           return
     end subroutine stdlib_cgesvj


     subroutine stdlib_cgges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,ldb, sdim, alpha, beta, &
     !! CGGES3 computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, the generalized complex Schur
     !! form (S, T), and optionally left and/or right Schur vectors (VSL
     !! and VSR). This gives the generalized Schur factorization
     !! (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )
     !! where (VSR)**H is the conjugate-transpose of VSR.
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! triangular matrix S and the upper triangular matrix T. The leading
     !! columns of VSL and VSR then form an unitary basis for the
     !! corresponding left and right eigenspaces (deflating subspaces).
     !! (If only the generalized eigenvalues are needed, use the driver
     !! CGGEV instead, which is faster.)
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0, and even for both being zero.
     !! A pair of matrices (S,T) is in generalized complex Schur form if S
     !! and T are upper triangular and, in addition, the diagonal elements
     !! of T are non-negative real numbers.
               vsl, ldvsl, vsr, ldvsr,work, lwork, rwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           ! Function Arguments 
           procedure(stdlib_selctg_c) :: selctg
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, wantst
           integer(ilp) :: i, icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, iright, irows, irwrk, &
                     itau, iwrk, lwkopt
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl, pvsr, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(sp) :: dif(2)
           ! Intrinsic Functions 
           intrinsic :: max,sqrt
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -14
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -16
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -18
           end if
           ! compute workspace
           if( info==0 ) then
              call stdlib_cgeqrf( n, n, b, ldb, work, work, -1, ierr )
              lwkopt = max( 1,  n + int( work( 1 ),KIND=ilp) )
              call stdlib_cunmqr( 'L', 'C', n, n, n, b, ldb, work, a, lda, work,-1, ierr )
              lwkopt = max( lwkopt, n + int( work( 1 ),KIND=ilp) )
              if( ilvsl ) then
                 call stdlib_cungqr( n, n, n, vsl, ldvsl, work, work, -1,ierr )
                 lwkopt = max( lwkopt, n + int( work( 1 ),KIND=ilp) )
              end if
              call stdlib_cgghd3( jobvsl, jobvsr, n, 1, n, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr, &
                        work, -1, ierr )
              lwkopt = max( lwkopt, n + int( work( 1 ),KIND=ilp) )
              call stdlib_claqz0( 'S', jobvsl, jobvsr, n, 1, n, a, lda, b, ldb,alpha, beta, vsl, &
                        ldvsl, vsr, ldvsr, work, -1,rwork, 0, ierr )
              lwkopt = max( lwkopt, int( work( 1 ),KIND=ilp) )
              if( wantst ) then
                 call stdlib_ctgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb,alpha, beta, vsl, &
                           ldvsl, vsr, ldvsr, sdim,pvsl, pvsr, dif, work, -1, idum, 1, ierr )
                 lwkopt = max( lwkopt, int( work( 1 ),KIND=ilp) )
              end if
              work( 1 ) = cmplx( lwkopt,KIND=sp)
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGES3 ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_clange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_cggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = 1
           iwrk = itau + irows
           call stdlib_cgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           call stdlib_cunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           if( ilvsl ) then
              call stdlib_claset( 'FULL', n, n, czero, cone, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_clacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_cungqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_claset( 'FULL', n, n, czero, cone, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           call stdlib_cgghd3( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      work( iwrk ), lwork+1-iwrk, ierr )
           sdim = 0
           ! perform qz algorithm, computing schur vectors if desired
           iwrk = itau
           call stdlib_claqz0( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vsl, &
                     ldvsl, vsr, ldvsr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), 0, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 30
           end if
           ! sort eigenvalues alpha/beta if desired
           if( wantst ) then
              ! undo scaling on eigenvalues before selecting
              if( ilascl )call stdlib_clascl( 'G', 0, 0, anrm, anrmto, n, 1, alpha, n, ierr )
                        
              if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrm, bnrmto, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alpha( i ), beta( i ) )
              end do
              call stdlib_ctgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb, alpha,beta, vsl, &
              ldvsl, vsr, ldvsr, sdim, pvsl, pvsr,dif, work( iwrk ), lwork-iwrk+1, idum, 1, ierr )
                        
              if( ierr==1 )info = n + 3
           end if
           ! apply back-permutation to vsl and vsr
           if( ilvsl )call stdlib_cggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_cggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsr, ldvsr, ierr )
           ! undo scaling
           if( ilascl ) then
              call stdlib_clascl( 'U', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_clascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_clascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_clascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              sdim = 0
              do i = 1, n
                 cursl = selctg( alpha( i ), beta( i ) )
                 if( cursl )sdim = sdim + 1
                 if( cursl .and. .not.lastsl )info = n + 2
                 lastsl = cursl
              end do
           end if
           30 continue
           work( 1 ) = cmplx( lwkopt,KIND=sp)
           return
     end subroutine stdlib_cgges3


     subroutine stdlib_cggev3( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
     !! CGGEV3 computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, and optionally, the left and/or
     !! right generalized eigenvectors.
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right generalized eigenvector v(j) corresponding to the
     !! generalized eigenvalue lambda(j) of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j).
     !! The left generalized eigenvector u(j) corresponding to the
     !! generalized eigenvalues lambda(j) of (A,B) satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H * B
     !! where u(j)**H is the conjugate-transpose of u(j).
               work, lwork, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery
           character :: chtemp
           integer(ilp) :: icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, in, iright, irows, irwrk,&
                      itau, iwrk, jc, jr, lwkopt
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           complex(sp) :: x
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,max,real,sqrt
           ! Statement Functions 
           real(sp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=sp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -11
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -13
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -15
           end if
           ! compute workspace
           if( info==0 ) then
              call stdlib_cgeqrf( n, n, b, ldb, work, work, -1, ierr )
              lwkopt = max( n,  n+int( work( 1 ),KIND=ilp) )
              call stdlib_cunmqr( 'L', 'C', n, n, n, b, ldb, work, a, lda, work,-1, ierr )
              lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
              if( ilvl ) then
                 call stdlib_cungqr( n, n, n, vl, ldvl, work, work, -1, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
              end if
              if( ilv ) then
                 call stdlib_cgghd3( jobvl, jobvr, n, 1, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                           work, -1, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
                 call stdlib_claqz0( 'S', jobvl, jobvr, n, 1, n, a, lda, b, ldb,alpha, beta, vl, &
                           ldvl, vr, ldvr, work, -1,rwork, 0, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
              else
                 call stdlib_cgghd3( 'N', 'N', n, 1, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, work, -&
                           1, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
                 call stdlib_claqz0( 'E', jobvl, jobvr, n, 1, n, a, lda, b, ldb,alpha, beta, vl, &
                           ldvl, vr, ldvr, work, -1,rwork, 0, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
              end if
              work( 1 ) = cmplx( lwkopt,KIND=sp)
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGEV3 ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'E' )*stdlib_slamch( 'B' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_clange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrices a, b to isolate eigenvalues if possible
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_cggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           irows = ihi + 1 - ilo
           if( ilv ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = 1
           iwrk = itau + irows
           call stdlib_cgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           call stdlib_cunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl
           if( ilvl ) then
              call stdlib_claset( 'FULL', n, n, czero, cone, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_clacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_cungqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vr
           if( ilvr )call stdlib_claset( 'FULL', n, n, czero, cone, vr, ldvr )
           ! reduce to generalized hessenberg form
           if( ilv ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_cgghd3( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        work( iwrk ), lwork+1-iwrk,ierr )
           else
              call stdlib_cgghd3( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr,work( iwrk ), lwork+1-iwrk, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur form and schur vectors)
           iwrk = itau
           if( ilv ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_claqz0( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vl, &
                     ldvl, vr, ldvr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), 0, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 70
           end if
           ! compute eigenvectors
           if( ilv ) then
              if( ilvl ) then
                 if( ilvr ) then
                    chtemp = 'B'
                 else
                    chtemp = 'L'
                 end if
              else
                 chtemp = 'R'
              end if
              call stdlib_ctgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, n, &
                        in, work( iwrk ), rwork( irwrk ),ierr )
              if( ierr/=0 ) then
                 info = n + 2
                 go to 70
              end if
              ! undo balancing on vl and vr and normalization
              if( ilvl ) then
                 call stdlib_cggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), n, vl,&
                            ldvl, ierr )
                 loop_30: do jc = 1, n
                    temp = zero
                    do jr = 1, n
                       temp = max( temp, abs1( vl( jr, jc ) ) )
                    end do
                    if( temp<smlnum )cycle loop_30
                    temp = one / temp
                    do jr = 1, n
                       vl( jr, jc ) = vl( jr, jc )*temp
                    end do
                 end do loop_30
              end if
              if( ilvr ) then
                 call stdlib_cggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), n, vr,&
                            ldvr, ierr )
                 loop_60: do jc = 1, n
                    temp = zero
                    do jr = 1, n
                       temp = max( temp, abs1( vr( jr, jc ) ) )
                    end do
                    if( temp<smlnum )cycle loop_60
                    temp = one / temp
                    do jr = 1, n
                       vr( jr, jc ) = vr( jr, jc )*temp
                    end do
                 end do loop_60
              end if
           end if
           ! undo scaling if necessary
           70 continue
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           work( 1 ) = cmplx( lwkopt,KIND=sp)
           return
     end subroutine stdlib_cggev3


     pure subroutine stdlib_cgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
     !! CGSVJ0 is called from CGESVJ as a pre-processor and that is its main
     !! purpose. It applies Jacobi rotations in the same way as CGESVJ does, but
     !! it does not check convergence (stopping criterion). Few tuning
     !! parameters (marked by [TP]) are available for the implementer.
               nsweep, work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, m, mv, n, nsweep
           real(sp), intent(in) :: eps, sfmin, tol
           character, intent(in) :: jobv
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), d(n), v(ldv,*)
           complex(sp), intent(out) :: work(lwork)
           real(sp), intent(inout) :: sva(n)
        ! =====================================================================
           
           
           ! Local Scalars 
           complex(sp) :: aapq, ompq
           real(sp) :: aapp, aapp0, aapq1, aaqq, apoaq, aqoap, big, bigtheta, cs, mxaapq, mxsinj, &
                     rootbig, rooteps, rootsfmin, roottol, small, sn, t, temp1, theta, thsign
           integer(ilp) :: blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1, iswrot, jbc, jgl, kbl, &
                     lkahead, mvl, nbl, notrot, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, rotok, rsvec
           ! Intrinsic Functions 
           intrinsic :: abs,max,conjg,real,min,sign,sqrt
           ! from lapack
           ! Executable Statements 
           ! test the input parameters.
           applv = stdlib_lsame( jobv, 'A' )
           rsvec = stdlib_lsame( jobv, 'V' )
           if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -3
           else if( lda<m ) then
              info = -5
           else if( ( rsvec.or.applv ) .and. ( mv<0 ) ) then
              info = -8
           else if( ( rsvec.and.( ldv<n ) ).or.( applv.and.( ldv<mv ) ) ) then
              info = -10
           else if( tol<=eps ) then
              info = -13
           else if( nsweep<0 ) then
              info = -14
           else if( lwork<m ) then
              info = -16
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'CGSVJ0', -info )
              return
           end if
           if( rsvec ) then
              mvl = n
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           rooteps = sqrt( eps )
           rootsfmin = sqrt( sfmin )
           small = sfmin / eps
           big = one / sfmin
           rootbig = one / rootsfmin
           bigtheta = one / rooteps
           roottol = sqrt( tol )
           ! .. row-cyclic jacobi svd algorithm with column pivoting ..
           emptsw = ( n*( n-1 ) ) / 2
           notrot = 0
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           swband = 0
      ! [tp] swband is a tuning parameter [tp]. it is meaningful and effective
           ! if stdlib_cgesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_cgejsv. for sweeps i=1:swband the procedure
           ! works on pivots inside a band-like region around the diagonal.
           ! the boundaries are determined dynamically, based on the number of
           ! pivots above a threshold.
           kbl = min( 8, n )
      ! [tp] kbl is a tuning parameter that defines the tile size in the
           ! tiling of the p-q loops of pivot pairs. in general, an optimal
           ! value of kbl depends on the matrix dimensions and on the
           ! parameters of the computer's memory.
           nbl = n / kbl
           if( ( nbl*kbl )/=n )nbl = nbl + 1
           blskip = kbl**2
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           lkahead = 1
      ! [tp] lkahead is a tuning parameter.
           ! quasi block transformations, using the lower (upper) triangular
           ! structure of the input matrix. the quasi-block-cycling usually
           ! invokes cubic convergence. big part of this cycle is done inside
           ! canonical subspaces of dimensions less than m.
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
           ! each sweep is unrolled using kbl-by-kbl tiles over the pivot pairs
           ! 1 <= p < q <= n. this is the first step toward a blocked implementation
           ! of the rotations. new implementation, based on block transformations,
           ! is under development.
              loop_2000: do ibr = 1, nbl
                 igl = ( ibr-1 )*kbl + 1
                 loop_1002: do ir1 = 0, min( lkahead, nbl-ibr )
                    igl = igl + ir1*kbl
                    loop_2001: do p = igl, min( igl+kbl-1, n-1 )
           ! .. de rijk's pivoting
                       q = stdlib_isamax( n-p+1, sva( p ), 1 ) + p - 1
                       if( p/=q ) then
                          call stdlib_cswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                          if( rsvec )call stdlib_cswap( mvl, v( 1, p ), 1,v( 1, q ), 1 )
                          temp1 = sva( p )
                          sva( p ) = sva( q )
                          sva( q ) = temp1
                          aapq = d(p)
                          d(p) = d(q)
                          d(q) = aapq
                       end if
                       if( ir1==0 ) then
              ! column norms are periodically updated by explicit
              ! norm computation.
              ! caveat:
              ! unfortunately, some blas implementations compute sncrm2(m,a(1,p),1)
              ! as sqrt(s=stdlib_cdotc(m,a(1,p),1,a(1,p),1)), which may cause the result to
              ! overflow for ||a(:,p)||_2 > sqrt(overflow_threshold), and to
              ! underflow for ||a(:,p)||_2 < sqrt(underflow_threshold).
              ! hence, stdlib_scnrm2 cannot be trusted, not even in the case when
              ! the true norm is far from the under(over)flow boundaries.
              ! if properly implemented stdlib_scnrm2 is available, the if-then-else-end if
              ! below should be replaced with "aapp = stdlib_scnrm2( m, a(1,p), 1 )".
                          if( ( sva( p )<rootbig ) .and.( sva( p )>rootsfmin ) ) then
                             sva( p ) = stdlib_scnrm2( m, a( 1, p ), 1 )
                          else
                             temp1 = zero
                             aapp = one
                             call stdlib_classq( m, a( 1, p ), 1, temp1, aapp )
                             sva( p ) = temp1*sqrt( aapp )
                          end if
                          aapp = sva( p )
                       else
                          aapp = sva( p )
                       end if
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2002: do q = p + 1, min( igl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
                                if( aaqq>=one ) then
                                   rotok = ( small*aapp )<=aaqq
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_ccopy( m, a( 1, p ), 1,work, 1 )
                                      call stdlib_clascl( 'G', 0, 0, aapp, one,m, 1, work, lda, &
                                                ierr )
                                      aapq = stdlib_cdotc( m, work, 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   rotok = aapp<=( aaqq / small )
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aapp ) / aaqq
                                   else
                                      call stdlib_ccopy( m, a( 1, q ), 1,work, 1 )
                                      call stdlib_clascl( 'G', 0, 0, aaqq,one, m, 1,work, lda, &
                                                ierr )
                                      aapq = stdlib_cdotc( m, a( 1, p ), 1,work, 1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg( cwork(p) ) * cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                   ompq = aapq / abs(aapq)
                 ! Rotate
      ! [rtd]      rotated = rotated + one
                                   if( ir1==0 ) then
                                      notrot = 0
                                      pskipped = 0
                                      iswrot = iswrot + 1
                                   end if
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/aapq1
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if ( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if ( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      d(p) = -d(q) * ompq
                                      else
                    ! .. have to use modified gram-schmidt like transformation
                                      call stdlib_ccopy( m, a( 1, p ), 1,work, 1 )
                                      call stdlib_clascl( 'G', 0, 0, aapp, one, m,1, work, lda,&
                                                ierr )
                                      call stdlib_clascl( 'G', 0, 0, aaqq, one, m,1, a( 1, q ), &
                                                lda, ierr )
                                      call stdlib_caxpy( m, -aapq, work, 1,a( 1, q ), 1 )
                                      call stdlib_clascl( 'G', 0, 0, one, aaqq, m,1, a( 1, q ), &
                                                lda, ierr )
                                      sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                      mxsinj = max( mxsinj, sfmin )
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! recompute sva(q), sva(p).
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_scnrm2( m, a( 1, q ), 1 )
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_classq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_scnrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_classq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                                else
              ! a(:,p) and a(:,q) already numerically orthogonal
                                   if( ir1==0 )notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                end if
                             else
              ! a(:,q) is zero column
                                if( ir1==0 )notrot = notrot + 1
                                pskipped = pskipped + 1
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                if( ir1==0 )aapp = -aapp
                                notrot = 0
                                go to 2103
                             end if
                          end do loop_2002
           ! end q-loop
           2103 continue
           ! bailed out of q-loop
                          sva( p ) = aapp
                       else
                          sva( p ) = aapp
                          if( ( ir1==0 ) .and. ( aapp==zero ) )notrot = notrot + min( igl+kbl-1, &
                                    n ) - p
                       end if
                    end do loop_2001
           ! end of the p-loop
           ! end of doing the block ( ibr, ibr )
                 end do loop_1002
           ! end of ir1-loop
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = ibr + 1, nbl
                    jgl = ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! safe gram matrix computation
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_ccopy( m, a( 1, p ), 1,work, 1 )
                                      call stdlib_clascl( 'G', 0, 0, aapp,one, m, 1,work, lda, &
                                                ierr )
                                      aapq = stdlib_cdotc( m, work, 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / max(&
                                                aaqq,aapp) )/ min(aaqq,aapp)
                                   else
                                      call stdlib_ccopy( m, a( 1, q ), 1,work, 1 )
                                      call stdlib_clascl( 'G', 0, 0, aaqq,one, m, 1,work, lda, &
                                                ierr )
                                      aapq = stdlib_cdotc( m, a( 1, p ), 1,work, 1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg(cwork(p))*cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                   ompq = aapq / abs(aapq)
                                   notrot = 0
      ! [rtd]      rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/ aapq1
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      d(p) = -d(q) * ompq
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                    if( aapp>aaqq ) then
                                         call stdlib_ccopy( m, a( 1, p ), 1,work, 1 )
                                         call stdlib_clascl( 'G', 0, 0, aapp, one,m, 1, work,lda,&
                                                   ierr )
                                         call stdlib_clascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         call stdlib_caxpy( m, -aapq, work,1, a( 1, q ), 1 )
                                                   
                                         call stdlib_clascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    else
                                        call stdlib_ccopy( m, a( 1, q ), 1,work, 1 )
                                         call stdlib_clascl( 'G', 0, 0, aaqq, one,m, 1, work,lda,&
                                                   ierr )
                                         call stdlib_clascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         call stdlib_caxpy( m, -conjg(aapq),work, 1, a( 1, p ), 1 &
                                                   )
                                         call stdlib_clascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! .. recompute sva(q), sva(p)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_scnrm2( m, a( 1, q ), 1)
                                       else
                                         t = zero
                                         aaqq = one
                                         call stdlib_classq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_scnrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_classq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_scnrm2( m, a( 1, n ), 1 )
              else
                 t = zero
                 aapp = one
                 call stdlib_classq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<sqrt( real( n,KIND=sp) )*tol ) .and. ( real( n,&
                        KIND=sp)*mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:( reaching this point means that the procedure has not converged.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means numerical convergence after the i-th
           ! sweep.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the vector sva() of column norms.
           do p = 1, n - 1
              q = stdlib_isamax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 aapq = d( p )
                 d( p ) = d( q )
                 d( q ) = aapq
                 call stdlib_cswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_cswap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
           end do
           return
     end subroutine stdlib_cgsvj0


     pure subroutine stdlib_cgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol, &
     !! CGSVJ1 is called from CGESVJ as a pre-processor and that is its main
     !! purpose. It applies Jacobi rotations in the same way as CGESVJ does, but
     !! it targets only particular pivots and it does not check convergence
     !! (stopping criterion). Few tuning parameters (marked by [TP]) are
     !! available for the implementer.
     !! Further Details
     !! ~~~~~~~~~~~~~~~
     !! CGSVJ1 applies few sweeps of Jacobi rotations in the column space of
     !! the input M-by-N matrix A. The pivot pairs are taken from the (1,2)
     !! off-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The
     !! block-entries (tiles) of the (1,2) off-diagonal block are marked by the
     !! [x]'s in the following scheme:
     !! | *  *  * [x] [x] [x]|
     !! | *  *  * [x] [x] [x]|    Row-cycling in the nblr-by-nblc [x] blocks.
     !! | *  *  * [x] [x] [x]|    Row-cyclic pivoting inside each [x] block.
     !! |[x] [x] [x] *  *  * |
     !! |[x] [x] [x] *  *  * |
     !! |[x] [x] [x] *  *  * |
     !! In terms of the columns of A, the first N1 columns are rotated 'against'
     !! the remaining N-N1 columns, trying to increase the angle between the
     !! corresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is
     !! tiled using quadratic tiles of side KBL. Here, KBL is a tuning parameter.
     !! The number of sweeps is given in NSWEEP and the orthogonality threshold
     !! is given in TOL.
               nsweep, work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           real(sp), intent(in) :: eps, sfmin, tol
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, m, mv, n, n1, nsweep
           character, intent(in) :: jobv
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), d(n), v(ldv,*)
           complex(sp), intent(out) :: work(lwork)
           real(sp), intent(inout) :: sva(n)
        ! =====================================================================
           
           ! Local Scalars 
           complex(sp) :: aapq, ompq
           real(sp) :: aapp, aapp0, aapq1, aaqq, apoaq, aqoap, big, bigtheta, cs, mxaapq, mxsinj, &
                     rootbig, rooteps, rootsfmin, roottol, small, sn, t, temp1, theta, thsign
           integer(ilp) :: blskip, emptsw, i, ibr, igl, ierr, ijblsk, iswrot, jbc, jgl, kbl, mvl, &
                     notrot, nblc, nblr, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, rotok, rsvec
           ! Intrinsic Functions 
           intrinsic :: abs,max,conjg,real,min,sign,sqrt
           ! From Lapack
           ! Executable Statements 
           ! test the input parameters.
           applv = stdlib_lsame( jobv, 'A' )
           rsvec = stdlib_lsame( jobv, 'V' )
           if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -3
           else if( n1<0 ) then
              info = -4
           else if( lda<m ) then
              info = -6
           else if( ( rsvec.or.applv ) .and. ( mv<0 ) ) then
              info = -9
           else if( ( rsvec.and.( ldv<n ) ).or.( applv.and.( ldv<mv ) )  ) then
              info = -11
           else if( tol<=eps ) then
              info = -14
           else if( nsweep<0 ) then
              info = -15
           else if( lwork<m ) then
              info = -17
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'CGSVJ1', -info )
              return
           end if
           if( rsvec ) then
              mvl = n
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           rooteps = sqrt( eps )
           rootsfmin = sqrt( sfmin )
           small = sfmin / eps
           big = one / sfmin
           rootbig = one / rootsfmin
           ! large = big / sqrt( real( m*n,KIND=sp) )
           bigtheta = one / rooteps
           roottol = sqrt( tol )
           ! Initialize The Right Singular Vector Matrix 
           ! rsvec = stdlib_lsame( jobv, 'y' )
           emptsw = n1*( n-n1 )
           notrot = 0
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           kbl = min( 8, n )
           nblr = n1 / kbl
           if( ( nblr*kbl )/=n1 )nblr = nblr + 1
           ! .. the tiling is nblr-by-nblc [tiles]
           nblc = ( n-n1 ) / kbl
           if( ( nblc*kbl )/=( n-n1 ) )nblc = nblc + 1
           blskip = ( kbl**2 ) + 1
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           swband = 0
      ! [tp] swband is a tuning parameter. it is meaningful and effective
           ! if stdlib_cgesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_cgejsv.
           ! | *   *   * [x] [x] [x]|
           ! | *   *   * [x] [x] [x]|    row-cycling in the nblr-by-nblc [x] blocks.
           ! | *   *   * [x] [x] [x]|    row-cyclic pivoting inside each [x] block.
           ! |[x] [x] [x] *   *   * |
           ! |[x] [x] [x] *   *   * |
           ! |[x] [x] [x] *   *   * |
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
           ! each sweep is unrolled using kbl-by-kbl tiles over the pivot pairs
           ! 1 <= p < q <= n. this is the first step toward a blocked implementation
           ! of the rotations. new implementation, based on block transformations,
           ! is under development.
              loop_2000: do ibr = 1, nblr
                 igl = ( ibr-1 )*kbl + 1
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                  ! do 2010 jbc = ibr + 1, nbl
                 loop_2010: do jbc = 1, nblc
                    jgl = ( jbc-1 )*kbl + n1 + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n1 )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! safe gram matrix computation
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_ccopy( m, a( 1, p ), 1,work, 1 )
                                      call stdlib_clascl( 'G', 0, 0, aapp,one, m, 1,work, lda, &
                                                ierr )
                                      aapq = stdlib_cdotc( m, work, 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / max(&
                                                aaqq,aapp) )/ min(aaqq,aapp)
                                   else
                                      call stdlib_ccopy( m, a( 1, q ), 1,work, 1 )
                                      call stdlib_clascl( 'G', 0, 0, aaqq,one, m, 1,work, lda, &
                                                ierr )
                                      aapq = stdlib_cdotc( m, a( 1, p ), 1,work, 1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg(cwork(p))*cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                   ompq = aapq / abs(aapq)
                                   notrot = 0
      ! [rtd]      rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/ aapq1
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      d(p) = -d(q) * ompq
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                    if( aapp>aaqq ) then
                                         call stdlib_ccopy( m, a( 1, p ), 1,work, 1 )
                                         call stdlib_clascl( 'G', 0, 0, aapp, one,m, 1, work,lda,&
                                                   ierr )
                                         call stdlib_clascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         call stdlib_caxpy( m, -aapq, work,1, a( 1, q ), 1 )
                                                   
                                         call stdlib_clascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    else
                                        call stdlib_ccopy( m, a( 1, q ), 1,work, 1 )
                                         call stdlib_clascl( 'G', 0, 0, aaqq, one,m, 1, work,lda,&
                                                   ierr )
                                         call stdlib_clascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         call stdlib_caxpy( m, -conjg(aapq),work, 1, a( 1, p ), 1 &
                                                   )
                                         call stdlib_clascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! .. recompute sva(q), sva(p)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_scnrm2( m, a( 1, q ), 1)
                                       else
                                         t = zero
                                         aaqq = one
                                         call stdlib_classq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_scnrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_classq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_scnrm2( m, a( 1, n ), 1 )
              else
                 t = zero
                 aapp = one
                 call stdlib_classq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<sqrt( real( n,KIND=sp) )*tol ) .and. ( real( n,&
                        KIND=sp)*mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:( reaching this point means that the procedure has not converged.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means numerical convergence after the i-th
           ! sweep.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the vector sva() of column norms.
           do p = 1, n - 1
              q = stdlib_isamax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 aapq = d( p )
                 d( p ) = d( q )
                 d( q ) = aapq
                 call stdlib_cswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_cswap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
           end do
           return
     end subroutine stdlib_cgsvj1


     pure subroutine stdlib_chesv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CHESV_AA computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**H * T * U,  if UPLO = 'U', or
     !! A = L * T * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is Hermitian and tridiagonal. The factored form
     !! of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_hetrf, lwkopt_hetrs
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 2*n, 3*n-2 ) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_chetrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_hetrf = int( work(1),KIND=ilp)
              call stdlib_chetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_hetrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_hetrf, lwkopt_hetrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHESV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**h*t*u or a = l*t*l**h.
           call stdlib_chetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_chetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chesv_aa


     pure subroutine stdlib_chetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
     !! CHETRF_AA computes the factorization of a complex hermitian matrix A
     !! using the Aasen's algorithm.  The form of the factorization is
     !! A = U**H*T*U  or  A = L*T*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is a hermitian tridiagonal matrix.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: j, lwkopt
           integer(ilp) :: nb, mj, nj, k1, k2, j1, j2, j3, jb
           complex(sp) :: alpha
           ! Intrinsic Functions 
           intrinsic :: real,conjg,max
           ! Executable Statements 
           ! determine the block size
           nb = stdlib_ilaenv( 1, 'CHETRF_AA', uplo, n, -1, -1, -1 )
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<( 2*n ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              lwkopt = (nb+1)*n
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRF_AA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return
           if ( n==0 ) then
               return
           endif
           ipiv( 1 ) = 1
           if ( n==1 ) then
              a( 1, 1 ) = real( a( 1, 1 ),KIND=sp)
              return
           end if
           ! adjust block size based on the workspace size
           if( lwork<((1+nb)*n) ) then
              nb = ( lwork-n ) / n
           end if
           if( upper ) then
              ! .....................................................
              ! factorize a as u**h*d*u using the upper triangle of a
              ! .....................................................
              ! copy first row a(1, 1:n) into h(1:n) (stored in work(1:n))
              call stdlib_ccopy( n, a( 1, 1 ), lda, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_clahef;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              10 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j + 1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_clahef_aa( uplo, 2-k1, n-j, jb,a( max(1, j), j+1 ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_cswap( j1-k1-2, a( 1, j2 ), 1,a( 1, ipiv(j2) ), 1 )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
               ! the row a(j1-1, j2-1:n) stores u(j1, j2+1:n) and
               ! work stores the current block of the auxiriarly matrix h
              if( j<n ) then
                ! if the first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = conjg( a( j, j+1 ) )
                    a( j, j+1 ) = cone
                    call stdlib_ccopy( n-j, a( j-1, j+1 ), lda,work( (j+1-j1+1)+jb*n ), 1 )
                              
                    call stdlib_cscal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=0 and k2=1 for the first panel,
                     ! and k1=1 and k2=0 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_cgemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_cgemm( 'CONJUGATE TRANSPOSE', 'TRANSPOSE',1, mj, jb+1,-cone,&
                           a( j1-k2, j3 ), lda,work( (j3-j1+1)+k1*n ), n,cone, a( j3, j3 ), lda )
                                     
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block of j2-th block row with stdlib_cgemm
                       call stdlib_cgemm( 'CONJUGATE TRANSPOSE', 'TRANSPOSE',nj, n-j3+1, jb+1,-&
                       cone, a( j1-k2, j2 ), lda,work( (j3-j1+1)+k1*n ), n,cone, a( j2, j3 ), lda &
                                 )
                    end do
                    ! recover t( j, j+1 )
                    a( j, j+1 ) = conjg( alpha )
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_ccopy( n-j, a( j+1, j+1 ), lda, work( 1 ), 1 )
              end if
              go to 10
           else
              ! .....................................................
              ! factorize a as l*d*l**h using the lower triangle of a
              ! .....................................................
              ! copy first column a(1:n, 1) into h(1:n, 1)
               ! (stored in work(1:n))
              call stdlib_ccopy( n, a( 1, 1 ), 1, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_clahef;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              11 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j+1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_clahef_aa( uplo, 2-k1, n-j, jb,a( j+1, max(1, j) ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_cswap( j1-k1-2, a( j2, 1 ), lda,a( ipiv(j2), 1 ), lda )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
                ! a(j2+1, j1-1) stores l(j2+1, j1) and
                ! work(j2+1, 1) stores h(j2+1, 1)
              if( j<n ) then
                ! if the first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = conjg( a( j+1, j ) )
                    a( j+1, j ) = cone
                    call stdlib_ccopy( n-j, a( j+1, j-1 ), 1,work( (j+1-j1+1)+jb*n ), 1 )
                    call stdlib_cscal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=0 and k2=1 for the first panel,
                     ! and k1=1 and k2=0 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_cgemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',mj, 1, jb+1,-&
                          cone, work( (j3-j1+1)+k1*n ), n,a( j3, j1-k2 ), lda,cone, a( j3, j3 ), &
                                    lda )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block of j2-th block column with stdlib_cgemm
                       call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',n-j3+1, nj, jb+1,-&
                       cone, work( (j3-j1+1)+k1*n ), n,a( j2, j1-k2 ), lda,cone, a( j3, j2 ), lda &
                                 )
                    end do
                    ! recover t( j+1, j )
                    a( j+1, j ) = conjg( alpha )
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_ccopy( n-j, a( j+1, j+1 ), 1, work( 1 ), 1 )
              end if
              go to 11
           end if
           20 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chetrf_aa


     pure subroutine stdlib_chseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,work, lwork, info )
     !! CHSEQR computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           character, intent(in) :: compz, job
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: w(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: nl = 49
           real(sp), parameter :: rzero = 0.0_sp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_clahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== nl allocates some local workspace to help small matrices
           ! .    through a rare stdlib_clahqr failure.  nl > ntiny = 15 is
           ! .    required and nl <= nmin = stdlib_ilaenv(ispec=12,...) is recom-
           ! .    mended.  (the default value of nmin is 75.)  using nl = 49
           ! .    allows up to six simultaneous shifts and a 16-by-16
           ! .    deflation window.  ====
           
           
           
           ! Local Arrays 
           complex(sp) :: hl(nl,nl), workl(nl)
           ! Local Scalars 
           integer(ilp) :: kbot, nmin
           logical(lk) :: initz, lquery, wantt, wantz
           ! Intrinsic Functions 
           intrinsic :: cmplx,max,min,real
           ! Executable Statements 
           ! ==== decode and check the input parameters. ====
           wantt = stdlib_lsame( job, 'S' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           work( 1 ) = cmplx( real( max( 1, n ),KIND=sp), rzero,KIND=sp)
           lquery = lwork==-1
           info = 0
           if( .not.stdlib_lsame( job, 'E' ) .and. .not.wantt ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldz<1 .or. ( wantz .and. ldz<max( 1, n ) ) ) then
              info = -10
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -12
           end if
           if( info/=0 ) then
              ! ==== quick return in case of invalid argument. ====
              call stdlib_xerbla( 'CHSEQR', -info )
              return
           else if( n==0 ) then
              ! ==== quick return in case n = 0; nothing to do. ====
              return
           else if( lquery ) then
              ! ==== quick return in case of a workspace query ====
              call stdlib_claqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi, z,ldz, work, &
                        lwork, info )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = cmplx( max( real( work( 1 ),KIND=sp), real( max( 1,n ),KIND=sp) ), &
                        rzero,KIND=sp)
              return
           else
              ! ==== copy eigenvalues isolated by stdlib_cgebal ====
              if( ilo>1 )call stdlib_ccopy( ilo-1, h, ldh+1, w, 1 )
              if( ihi<n )call stdlib_ccopy( n-ihi, h( ihi+1, ihi+1 ), ldh+1, w( ihi+1 ), 1 )
                        
              ! ==== initialize z, if requested ====
              if( initz )call stdlib_claset( 'A', n, n, czero, cone, z, ldz )
              ! ==== quick return if possible ====
              if( ilo==ihi ) then
                 w( ilo ) = h( ilo, ilo )
                 return
              end if
              ! ==== stdlib_clahqr/stdlib_claqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'CHSEQR', job( : 1 ) // compz( : 1 ), n,ilo, ihi, lwork )
                        
              nmin = max( ntiny, nmin )
              ! ==== stdlib_claqr0 for big matrices; stdlib_clahqr for small ones ====
              if( n>nmin ) then
                 call stdlib_claqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi,z, ldz, work, &
                           lwork, info )
              else
                 ! ==== small matrix ====
                 call stdlib_clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi,z, ldz, info )
                           
                 if( info>0 ) then
                    ! ==== a rare stdlib_clahqr failure!  stdlib_claqr0 sometimes succeeds
                    ! .    when stdlib_clahqr fails. ====
                    kbot = info
                    if( n>=nl ) then
                       ! ==== larger matrices have enough subdiagonal scratch
                       ! .    space to call stdlib_claqr0 directly. ====
                       call stdlib_claqr0( wantt, wantz, n, ilo, kbot, h, ldh, w,ilo, ihi, z, ldz,&
                                  work, lwork, info )
                    else
                       ! ==== tiny matrices don't have enough subdiagonal
                       ! .    scratch space to benefit from stdlib_claqr0.  hence,
                       ! .    tiny matrices must be copied into a larger
                       ! .    array before calling stdlib_claqr0. ====
                       call stdlib_clacpy( 'A', n, n, h, ldh, hl, nl )
                       hl( n+1, n ) = czero
                       call stdlib_claset( 'A', nl, nl-n, czero, czero, hl( 1, n+1 ),nl )
                       call stdlib_claqr0( wantt, wantz, nl, ilo, kbot, hl, nl, w,ilo, ihi, z, &
                                 ldz, workl, nl, info )
                       if( wantt .or. info/=0 )call stdlib_clacpy( 'A', n, n, hl, nl, h, ldh )
                                 
                    end if
                 end if
              end if
              ! ==== clear out the trash, if necessary. ====
              if( ( wantt .or. info/=0 ) .and. n>2 )call stdlib_claset( 'L', n-2, n-2, czero, &
                        czero, h( 3, 1 ), ldh )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = cmplx( max( real( max( 1, n ),KIND=sp),real( work( 1 ),KIND=sp) ), &
                        rzero,KIND=sp)
           end if
     end subroutine stdlib_chseqr


     pure subroutine stdlib_clahef_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
     !! CLAHEF_AA factorizes a panel of a complex hermitian matrix A using
     !! the Aasen's algorithm. The panel consists of a set of NB rows of A
     !! when UPLO is U, or a set of NB columns when UPLO is L.
     !! In order to factorize the panel, the Aasen's algorithm requires the
     !! last row, or column, of the previous panel. The first row, or column,
     !! of A is set to be the first row, or column, of an identity matrix,
     !! which is used to factorize the first panel.
     !! The resulting J-th row of U, or J-th column of L, is stored in the
     !! (J-1)-th row, or column, of A (without the unit diagonals), while
     !! the diagonal and subdiagonal of A are overwritten by those of T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: m, nb, j1, lda, ldh
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), h(ldh,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, k, k1, i1, i2, mj
           complex(sp) :: piv, alpha
           ! Intrinsic Functions 
           intrinsic :: real,conjg,max
           ! Executable Statements 
           j = 1
           ! k1 is the first column of the panel to be factorized
           ! i.e.,  k1 is 2 for the first block column, and 1 for the rest of the blocks
           k1 = (2-j1)+1
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              10 continue
              if ( j>min(m, nb) )go to 20
              ! k is the column to be factorized
               ! when being called from stdlib_chetrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:n, j) := a(j, j:n) - h(j:n, 1:(j-1)) * l(j1:(j-1), j),
               ! where h(j:n, j) has been initialized to be a(j, j:n)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_clacgv( j-k1, a( 1, j ), 1 )
                 call stdlib_cgemv( 'NO TRANSPOSE', mj, j-k1,-cone, h( j, k1 ), ldh,a( 1, j ), 1,&
                           cone, h( j, j ), 1 )
                 call stdlib_clacgv( j-k1, a( 1, j ), 1 )
              end if
              ! copy h(i:n, i) into work
              call stdlib_ccopy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j-1, j:n) * t(j-1,j),
                  ! where a(j-1, j) stores t(j-1, j) and a(j-2, j:n) stores u(j-1, j:n)
                 alpha = -conjg( a( k-1, j ) )
                 call stdlib_caxpy( mj, alpha, a( k-2, j ), lda, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( k, j ) = real( work( 1 ),KIND=sp)
              if( j<m ) then
                 ! compute work(2:n) = t(j, j) l(j, (j+1):n)
                  ! where a(j, j) stores t(j, j) and a(j-1, (j+1):n) stores u(j, (j+1):n)
                 if( k>1 ) then
                    alpha = -a( k, j )
                    call stdlib_caxpy( m-j, alpha, a( k-1, j+1 ), lda,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:n)|)
                 i2 = stdlib_icamax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply hermitian pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1, i1+1:n) with a(i1+1:n, i2)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_cswap( i2-i1-1, a( j1+i1-1, i1+1 ), lda,a( j1+i1, i2 ), 1 )
                              
                    call stdlib_clacgv( i2-i1, a( j1+i1-1, i1+1 ), lda )
                    call stdlib_clacgv( i2-i1-1, a( j1+i1, i2 ), 1 )
                    ! swap a(i1, i2+1:n) with a(i2, i2+1:n)
                    if( i2<m )call stdlib_cswap( m-i2, a( j1+i1-1, i2+1 ), lda,a( j1+i2-1, i2+1 ),&
                               lda )
                    ! swap a(i1, i1) with a(i2,i2)
                    piv = a( i1+j1-1, i1 )
                    a( j1+i1-1, i1 ) = a( j1+i2-1, i2 )
                    a( j1+i2-1, i2 ) = piv
                    ! swap h(i1, 1:j1) with h(i2, 1:j1)
                    call stdlib_cswap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_cswap( i1-k1+1, a( 1, i1 ), 1,a( 1, i2 ), 1 )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j, j+1) = t(j, j+1)
                 a( k, j+1 ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:n, j+1) into h(j:n, j),
                    call stdlib_ccopy( m-j, a( k+1, j+1 ), lda,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:n ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:n, j) = l(j+2:n, j+1)
                 if( j<(m-1) ) then
                    if( a( k, j+1 )/=czero ) then
                       alpha = cone / a( k, j+1 )
                       call stdlib_ccopy( m-j-1, work( 3 ), 1, a( k, j+2 ), lda )
                       call stdlib_cscal( m-j-1, alpha, a( k, j+2 ), lda )
                    else
                       call stdlib_claset( 'FULL', 1, m-j-1, czero, czero,a( k, j+2 ), lda)
                                 
                    end if
                 end if
              end if
              j = j + 1
              go to 10
              20 continue
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              30 continue
              if( j>min( m, nb ) )go to 40
              ! k is the column to be factorized
               ! when being called from stdlib_chetrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:n, j) := a(j:n, j) - h(j:n, 1:(j-1)) * l(j, j1:(j-1))^t,
               ! where h(j:n, j) has been initialized to be a(j:n, j)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_clacgv( j-k1, a( j, 1 ), lda )
                 call stdlib_cgemv( 'NO TRANSPOSE', mj, j-k1,-cone, h( j, k1 ), ldh,a( j, 1 ), &
                           lda,cone, h( j, j ), 1 )
                 call stdlib_clacgv( j-k1, a( j, 1 ), lda )
              end if
              ! copy h(j:n, j) into work
              call stdlib_ccopy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j:n, j-1) * t(j-1,j),
                  ! where a(j-1, j) = t(j-1, j) and a(j, j-2) = l(j, j-1)
                 alpha = -conjg( a( j, k-1 ) )
                 call stdlib_caxpy( mj, alpha, a( j, k-2 ), 1, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( j, k ) = real( work( 1 ),KIND=sp)
              if( j<m ) then
                 ! compute work(2:n) = t(j, j) l((j+1):n, j)
                  ! where a(j, j) = t(j, j) and a((j+1):n, j-1) = l((j+1):n, j)
                 if( k>1 ) then
                    alpha = -a( j, k )
                    call stdlib_caxpy( m-j, alpha, a( j+1, k-1 ), 1,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:n)|)
                 i2 = stdlib_icamax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply hermitian pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1+1:n, i1) with a(i2, i1+1:n)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_cswap( i2-i1-1, a( i1+1, j1+i1-1 ), 1,a( i2, j1+i1 ), lda )
                              
                    call stdlib_clacgv( i2-i1, a( i1+1, j1+i1-1 ), 1 )
                    call stdlib_clacgv( i2-i1-1, a( i2, j1+i1 ), lda )
                    ! swap a(i2+1:n, i1) with a(i2+1:n, i2)
                    if( i2<m )call stdlib_cswap( m-i2, a( i2+1, j1+i1-1 ), 1,a( i2+1, j1+i2-1 ), &
                              1 )
                    ! swap a(i1, i1) with a(i2, i2)
                    piv = a( i1, j1+i1-1 )
                    a( i1, j1+i1-1 ) = a( i2, j1+i2-1 )
                    a( i2, j1+i2-1 ) = piv
                    ! swap h(i1, i1:j1) with h(i2, i2:j1)
                    call stdlib_cswap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_cswap( i1-k1+1, a( i1, 1 ), lda,a( i2, 1 ), lda )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j+1, j) = t(j+1, j)
                 a( j+1, k ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:n, j+1) into h(j+1:n, j),
                    call stdlib_ccopy( m-j, a( j+1, k+1 ), 1,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:n ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:n, j) = l(j+2:n, j+1)
                 if( j<(m-1) ) then
                    if( a( j+1, k )/=czero ) then
                       alpha = cone / a( j+1, k )
                       call stdlib_ccopy( m-j-1, work( 3 ), 1, a( j+2, k ), 1 )
                       call stdlib_cscal( m-j-1, alpha, a( j+2, k ), 1 )
                    else
                       call stdlib_claset( 'FULL', m-j-1, 1, czero, czero,a( j+2, k ), lda )
                                 
                    end if
                 end if
              end if
              j = j + 1
              go to 30
              40 continue
           end if
           return
     end subroutine stdlib_clahef_aa


     pure subroutine stdlib_claqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work,&
     !! CLAQR0 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
                lwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: w(*), work(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(sp), parameter :: wilk1 = 0.75_sp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_clahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constant wilk1 is used to form the exceptional
           ! .    shifts. ====
           
           
           
           ! Local Scalars 
           complex(sp) :: aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
           real(sp) :: s
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           complex(sp) :: zdum(1,1)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,int,max,min,mod,real,sqrt
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = cone
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_clahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, &
                        z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'CLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'CLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_claqr3 ====
              call stdlib_claqr3( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, w, h, ldh, n, h, ldh, n, h,ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_claqr5, stdlib_claqr3) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
                 return
              end if
              ! ==== stdlib_clahqr/stdlib_claqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'CLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'CLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'CLAQR0', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_70: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 80
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==czero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( cabs1( h( kwtop, kwtop-1 ) )>cabs1( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_claqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, w, h( kv, 1 ), ldh, nho,h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh, work,&
                           lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_claqr3
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_claqr3 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, ks + 1, -2
                          w( i ) = h( i, i ) + wilk1*cabs1( h( i, i-1 ) )
                          w( i-1 ) = w( i )
                       end do
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_claqr4 or
                       ! .    stdlib_clahqr on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_clacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          if( ns>nmin ) then
                             call stdlib_claqr4( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( &
                                       ks ), 1, 1,zdum, 1, work, lwork, inf )
                          else
                             call stdlib_clahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( &
                                       ks ), 1, 1,zdum, 1, inf )
                          end if
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  scale to avoid
                          ! .    overflows, underflows and subnormals.
                          ! .    (the scale factor s can not be czero,
                          ! .    because h(kbot,kbot-1) is nonzero.) ====
                          if( ks>=kbot ) then
                             s = cabs1( h( kbot-1, kbot-1 ) ) +cabs1( h( kbot, kbot-1 ) ) +cabs1( &
                                       h( kbot-1, kbot ) ) +cabs1( h( kbot, kbot ) )
                             aa = h( kbot-1, kbot-1 ) / s
                             cc = h( kbot, kbot-1 ) / s
                             bb = h( kbot-1, kbot ) / s
                             dd = h( kbot, kbot ) / s
                             tr2 = ( aa+dd ) / two
                             det = ( aa-tr2 )*( dd-tr2 ) - bb*cc
                             rtdisc = sqrt( -det )
                             w( kbot-1 ) = ( tr2+rtdisc )*s
                             w( kbot ) = ( tr2-rtdisc )*s
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little) ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( cabs1( w( i ) )<cabs1( w( i+1 ) ) )then
                                   sorted = .false.
                                   swap = w( i )
                                   w( i ) = w( i+1 )
                                   w( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                    end if
                    ! ==== if there are only two shifts, then use
                    ! .    only cone.  ====
                    if( kbot-ks+1==2 ) then
                       if( cabs1( w( kbot )-h( kbot, kbot ) )<cabs1( w( kbot-1 )-h( kbot, kbot ) )&
                                  ) then
                          w( kbot-1 ) = w( kbot )
                       else
                          w( kbot ) = w( kbot-1 )
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping cone to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_claqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,w( ks ), h, ldh, &
                    iloz, ihiz, z, ldz, work,3, h( ku, 1 ), ldh, nve, h( kwv, 1 ), ldh,nho, h( ku,&
                               kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_70
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              80 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
     end subroutine stdlib_claqr0


     pure subroutine stdlib_claqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
     !! Aggressive early deflation:
     !! CLAQR3 accepts as input an upper Hessenberg matrix
     !! H and performs an unitary similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an unitary similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0_sp
           real(sp), parameter :: rone = 1.0_sp
           
           
           ! Local Scalars 
           complex(sp) :: beta, cdum, s, tau
           real(sp) :: foo, safmax, safmin, smlnum, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, kcol, kln, knt, krow, kwtop, ltop, &
                     lwk1, lwk2, lwk3, lwkopt, nmin
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,conjg,int,max,min,real
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_cgehrd ====
              call stdlib_cgehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_cunmhr ====
              call stdlib_cunmhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_claqr4 ====
              call stdlib_claqr4( .true., .true., jw, 1, jw, t, ldt, sh, 1, jw, v,ldv, work, -1, &
                        infqr )
              lwk3 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = max( jw+max( lwk1, lwk2 ), lwk3 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = cone
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = czero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sh( kwtop ) = h( kwtop, kwtop )
              ns = 1
              nd = 0
              if( cabs1( s )<=max( smlnum, ulp*cabs1( h( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = czero
              end if
              work( 1 ) = cone
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_clacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_ccopy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_claset( 'A', jw, jw, czero, cone, v, ldv )
           nmin = stdlib_ilaenv( 12, 'CLAQR3', 'SV', jw, 1, jw, lwork )
           if( jw>nmin ) then
              call stdlib_claqr4( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                        work, lwork, infqr )
           else
              call stdlib_clahqr( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                        infqr )
           end if
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           do knt = infqr + 1, jw
              ! ==== small spike tip deflation test ====
              foo = cabs1( t( ns, ns ) )
              if( foo==rzero )foo = cabs1( s )
              if( cabs1( s )*cabs1( v( 1, ns ) )<=max( smlnum, ulp*foo ) )then
                 ! ==== cone more converged eigenvalue ====
                 ns = ns - 1
              else
                 ! ==== cone undeflatable eigenvalue.  move it up out of the
                 ! .    way.   (stdlib_ctrexc can not fail in this case.) ====
                 ifst = ns
                 call stdlib_ctrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                 ilst = ilst + 1
              end if
           end do
              ! ==== return to hessenberg form ====
           if( ns==0 )s = czero
           if( ns<jw ) then
              ! ==== sorting the diagonal of t improves accuracy for
              ! .    graded matrices.  ====
              do i = infqr + 1, ns
                 ifst = i
                 do j = i + 1, ns
                    if( cabs1( t( j, j ) )>cabs1( t( ifst, ifst ) ) )ifst = j
                 end do
                 ilst = i
                 if( ifst/=ilst )call stdlib_ctrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                           
              end do
           end if
           ! ==== restore shift/eigenvalue array from t ====
           do i = infqr + 1, jw
              sh( kwtop+i-1 ) = t( i, i )
           end do
           if( ns<jw .or. s==czero ) then
              if( ns>1 .and. s/=czero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_ccopy( ns, v, ldv, work, 1 )
                 do i = 1, ns
                    work( i ) = conjg( work( i ) )
                 end do
                 beta = work( 1 )
                 call stdlib_clarfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = cone
                 call stdlib_claset( 'L', jw-2, jw-2, czero, czero, t( 3, 1 ), ldt )
                 call stdlib_clarf( 'L', ns, jw, work, 1, conjg( tau ), t, ldt,work( jw+1 ) )
                           
                 call stdlib_clarf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_clarf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_cgehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*conjg( v( 1, 1 ) )
              call stdlib_clacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_ccopy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=czero )call stdlib_cunmhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_cgemm( 'N', 'N', kln, jw, jw, cone, h( krow, kwtop ),ldh, v, ldv, &
                           czero, wv, ldwv )
                 call stdlib_clacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_cgemm( 'C', 'N', jw, kln, jw, cone, v, ldv,h( kwtop, kcol ), ldh, &
                              czero, t, ldt )
                    call stdlib_clacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_cgemm( 'N', 'N', kln, jw, jw, cone, z( krow, kwtop ),ldz, v, ldv, &
                              czero, wv, ldwv )
                    call stdlib_clacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
     end subroutine stdlib_claqr3


     pure subroutine stdlib_claqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work,&
     !! CLAQR4 implements one level of recursion for CLAQR0.
     !! It is a complete implementation of the small bulge multi-shift
     !! QR algorithm.  It may be called by CLAQR0 and, for large enough
     !! deflation window size, it may be called by CLAQR3.  This
     !! subroutine is identical to CLAQR0 except that it calls CLAQR2
     !! instead of CLAQR3.
     !! CLAQR4 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
                lwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: w(*), work(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(sp), parameter :: wilk1 = 0.75_sp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_clahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constant wilk1 is used to form the exceptional
           ! .    shifts. ====
           
           
           
           ! Local Scalars 
           complex(sp) :: aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
           real(sp) :: s
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           complex(sp) :: zdum(1,1)
           ! Intrinsic Functions 
           intrinsic :: abs,aimag,cmplx,int,max,min,mod,real,sqrt
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = cone
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_clahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, &
                        z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'CLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'CLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_claqr2 ====
              call stdlib_claqr2( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, w, h, ldh, n, h, ldh, n, h,ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_claqr5, stdlib_claqr2) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
                 return
              end if
              ! ==== stdlib_clahqr/stdlib_claqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'CLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'CLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'CLAQR4', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_70: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 80
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==czero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( cabs1( h( kwtop, kwtop-1 ) )>cabs1( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_claqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, w, h( kv, 1 ), ldh, nho,h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh, work,&
                           lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_claqr2
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_claqr2 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, ks + 1, -2
                          w( i ) = h( i, i ) + wilk1*cabs1( h( i, i-1 ) )
                          w( i-1 ) = w( i )
                       end do
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_clahqr
                       ! .    on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_clacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          call stdlib_clahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( ks )&
                                    , 1, 1, zdum,1, inf )
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  scale to avoid
                          ! .    overflows, underflows and subnormals.
                          ! .    (the scale factor s can not be czero,
                          ! .    because h(kbot,kbot-1) is nonzero.) ====
                          if( ks>=kbot ) then
                             s = cabs1( h( kbot-1, kbot-1 ) ) +cabs1( h( kbot, kbot-1 ) ) +cabs1( &
                                       h( kbot-1, kbot ) ) +cabs1( h( kbot, kbot ) )
                             aa = h( kbot-1, kbot-1 ) / s
                             cc = h( kbot, kbot-1 ) / s
                             bb = h( kbot-1, kbot ) / s
                             dd = h( kbot, kbot ) / s
                             tr2 = ( aa+dd ) / two
                             det = ( aa-tr2 )*( dd-tr2 ) - bb*cc
                             rtdisc = sqrt( -det )
                             w( kbot-1 ) = ( tr2+rtdisc )*s
                             w( kbot ) = ( tr2-rtdisc )*s
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little) ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( cabs1( w( i ) )<cabs1( w( i+1 ) ) )then
                                   sorted = .false.
                                   swap = w( i )
                                   w( i ) = w( i+1 )
                                   w( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                    end if
                    ! ==== if there are only two shifts, then use
                    ! .    only cone.  ====
                    if( kbot-ks+1==2 ) then
                       if( cabs1( w( kbot )-h( kbot, kbot ) )<cabs1( w( kbot-1 )-h( kbot, kbot ) )&
                                  ) then
                          w( kbot-1 ) = w( kbot )
                       else
                          w( kbot ) = w( kbot-1 )
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping cone to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_claqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,w( ks ), h, ldh, &
                    iloz, ihiz, z, ldz, work,3, h( ku, 1 ), ldh, nve, h( kwv, 1 ), ldh,nho, h( ku,&
                               kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_70
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              80 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
     end subroutine stdlib_claqr4


     recursive subroutine stdlib_claqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, alpha, &
     !! CLAQZ0 computes the eigenvalues of a matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the double-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a matrix pair (A,B):
     !! A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
     !! as computed by CGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**H,  T = Q*P*Z**H,
     !! where Q and Z are unitary matrices, P and S are an upper triangular
     !! matrices.
     !! Optionally, the unitary matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! unitary matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the unitary matrices from CGGHRD that reduced
     !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
     !! output matrices Q1*Q and Z1*Z are the unitary factors from the
     !! generalized Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
     !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
     !! complex and beta real.
     !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
     !! generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! Eigenvalues can be read directly from the generalized Schur
     !! form:
     !! alpha = S(i,i), beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
     !! Ref: B. Kagstrom, D. Kressner, "Multishift Variants of the QZ
     !! Algorithm with Aggressive Early Deflation", SIAM J. Numer.
     !! Anal., 29(2006), pp. 199--227.
     !! Ref: T. Steel, D. Camps, K. Meerbergen, R. Vandebril "A multishift,
     !! multipole rational QZ method with agressive early deflation"
               beta, q, ldq, z,ldz, work, lwork, rwork, rec,info )
           ! arguments
           character, intent( in ) :: wants, wantq, wantz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,rec
           integer(ilp), intent( out ) :: info
           complex(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), &
                     alpha( * ), beta( * ), work( * )
           real(sp), intent( out ) :: rwork( * )
           
           
           ! local scalars
           real(sp) :: smlnum, ulp, safmin, safmax, c1, tempr
           complex(sp) :: eshift, s1, temp
           integer(ilp) :: istart, istop, iiter, maxit, istart2, k, ld, nshifts, nblock, nw, nmin,&
            nibble, n_undeflated, n_deflated, ns, sweep_info, shiftpos, lworkreq, k2, istartm, &
            istopm, iwants, iwantq, iwantz, norm_info, aed_info, nwr, nbr, nsr, itemp1, itemp2, &
                      rcost
           logical(lk) :: ilschur, ilq, ilz
           character :: jbcmpz*3
           if( stdlib_lsame( wants, 'E' ) ) then
              ilschur = .false.
              iwants = 1
           else if( stdlib_lsame( wants, 'S' ) ) then
              ilschur = .true.
              iwants = 2
           else
              iwants = 0
           end if
           if( stdlib_lsame( wantq, 'N' ) ) then
              ilq = .false.
              iwantq = 1
           else if( stdlib_lsame( wantq, 'V' ) ) then
              ilq = .true.
              iwantq = 2
           else if( stdlib_lsame( wantq, 'I' ) ) then
              ilq = .true.
              iwantq = 3
           else
              iwantq = 0
           end if
           if( stdlib_lsame( wantz, 'N' ) ) then
              ilz = .false.
              iwantz = 1
           else if( stdlib_lsame( wantz, 'V' ) ) then
              ilz = .true.
              iwantz = 2
           else if( stdlib_lsame( wantz, 'I' ) ) then
              ilz = .true.
              iwantz = 3
           else
              iwantz = 0
           end if
           ! check argument values
           info = 0
           if( iwants==0 ) then
              info = -1
           else if( iwantq==0 ) then
              info = -2
           else if( iwantz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( lda<n ) then
              info = -8
           else if( ldb<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -15
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -17
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAQZ0', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = real( 1,KIND=sp)
              return
           end if
           ! get the parameters
           jbcmpz( 1:1 ) = wants
           jbcmpz( 2:2 ) = wantq
           jbcmpz( 3:3 ) = wantz
           nmin = stdlib_ilaenv( 12, 'CLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nwr = stdlib_ilaenv( 13, 'CLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nwr = max( 2, nwr )
           nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
           nibble = stdlib_ilaenv( 14, 'CLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nsr = stdlib_ilaenv( 15, 'CLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nsr = min( nsr, ( n+6 ) / 9, ihi-ilo )
           nsr = max( 2, nsr-mod( nsr, 2 ) )
           rcost = stdlib_ilaenv( 17, 'CLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           itemp1 = int( nsr/sqrt( 1+2*nsr/( real( rcost,KIND=sp)/100*n ) ),KIND=ilp)
           itemp1 = ( ( itemp1-1 )/4 )*4+4
           nbr = nsr+itemp1
           if( n < nmin .or. rec >= 2 ) then
              call stdlib_chgeqz( wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb,alpha, beta, q,&
                         ldq, z, ldz, work, lwork, rwork,info )
              return
           end if
           ! find out required workspace
           ! workspace query to stdlib_claqz2
           nw = max( nwr, nmin )
           call stdlib_claqz2( ilschur, ilq, ilz, n, ilo, ihi, nw, a, lda, b, ldb,q, ldq, z, ldz, &
           n_undeflated, n_deflated, alpha,beta, work, nw, work, nw, work, -1, rwork, rec,&
                     aed_info )
           itemp1 = int( work( 1 ),KIND=ilp)
           ! workspace query to stdlib_claqz3
           call stdlib_claqz3( ilschur, ilq, ilz, n, ilo, ihi, nsr, nbr, alpha,beta, a, lda, b, &
                     ldb, q, ldq, z, ldz, work, nbr,work, nbr, work, -1, sweep_info )
           itemp2 = int( work( 1 ),KIND=ilp)
           lworkreq = max( itemp1+2*nw**2, itemp2+2*nbr**2 )
           if ( lwork ==-1 ) then
              work( 1 ) = real( lworkreq,KIND=sp)
              return
           else if ( lwork < lworkreq ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAQZ0', info )
              return
           end if
           ! initialize q and z
           if( iwantq==3 ) call stdlib_claset( 'FULL', n, n, czero, cone, q,ldq )
           if( iwantz==3 ) call stdlib_claset( 'FULL', n, n, czero, cone, z,ldz )
           ! get machine constants
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp)/ulp )
           istart = ilo
           istop = ihi
           maxit = 30*( ihi-ilo+1 )
           ld = 0
           do iiter = 1, maxit
              if( iiter >= maxit ) then
                 info = istop+1
                 goto 80
              end if
              if ( istart+1 >= istop ) then
                 istop = istart
                 exit
              end if
              ! check deflations at the end
              if ( abs( a( istop, istop-1 ) ) <= max( smlnum,ulp*( abs( a( istop, istop ) )+abs( &
                        a( istop-1,istop-1 ) ) ) ) ) then
                 a( istop, istop-1 ) = czero
                 istop = istop-1
                 ld = 0
                 eshift = czero
              end if
              ! check deflations at the start
              if ( abs( a( istart+1, istart ) ) <= max( smlnum,ulp*( abs( a( istart, istart ) )+&
                        abs( a( istart+1,istart+1 ) ) ) ) ) then
                 a( istart+1, istart ) = czero
                 istart = istart+1
                 ld = 0
                 eshift = czero
              end if
              if ( istart+1 >= istop ) then
                 exit
              end if
              ! check interior deflations
              istart2 = istart
              do k = istop, istart+1, -1
                 if ( abs( a( k, k-1 ) ) <= max( smlnum, ulp*( abs( a( k,k ) )+abs( a( k-1, k-1 ) &
                           ) ) ) ) then
                    a( k, k-1 ) = czero
                    istart2 = k
                    exit
                 end if
              end do
              ! get range to apply rotations to
              if ( ilschur ) then
                 istartm = 1
                 istopm = n
              else
                 istartm = istart2
                 istopm = istop
              end if
              ! check infinite eigenvalues, this is done without blocking so might
              ! slow down the method when many infinite eigenvalues are present
              k = istop
              do while ( k>=istart2 )
                 tempr = zero
                 if( k < istop ) then
                    tempr = tempr+abs( b( k, k+1 ) )
                 end if
                 if( k > istart2 ) then
                    tempr = tempr+abs( b( k-1, k ) )
                 end if
                 if( abs( b( k, k ) ) < max( smlnum, ulp*tempr ) ) then
                    ! a diagonal element of b is negligable, move it
                    ! to the top and deflate it
                    do k2 = k, istart2+1, -1
                       call stdlib_clartg( b( k2-1, k2 ), b( k2-1, k2-1 ), c1, s1,temp )
                       b( k2-1, k2 ) = temp
                       b( k2-1, k2-1 ) = czero
                       call stdlib_crot( k2-2-istartm+1, b( istartm, k2 ), 1,b( istartm, k2-1 ), &
                                 1, c1, s1 )
                       call stdlib_crot( min( k2+1, istop )-istartm+1, a( istartm,k2 ), 1, a( &
                                 istartm, k2-1 ), 1, c1, s1 )
                       if ( ilz ) then
                          call stdlib_crot( n, z( 1, k2 ), 1, z( 1, k2-1 ), 1, c1,s1 )
                       end if
                       if( k2<istop ) then
                          call stdlib_clartg( a( k2, k2-1 ), a( k2+1, k2-1 ), c1,s1, temp )
                                    
                          a( k2, k2-1 ) = temp
                          a( k2+1, k2-1 ) = czero
                          call stdlib_crot( istopm-k2+1, a( k2, k2 ), lda, a( k2+1,k2 ), lda, c1, &
                                    s1 )
                          call stdlib_crot( istopm-k2+1, b( k2, k2 ), ldb, b( k2+1,k2 ), ldb, c1, &
                                    s1 )
                          if( ilq ) then
                             call stdlib_crot( n, q( 1, k2 ), 1, q( 1, k2+1 ), 1,c1, conjg( s1 ) )
                                       
                          end if
                       end if
                    end do
                    if( istart2<istop )then
                       call stdlib_clartg( a( istart2, istart2 ), a( istart2+1,istart2 ), c1, s1, &
                                 temp )
                       a( istart2, istart2 ) = temp
                       a( istart2+1, istart2 ) = czero
                       call stdlib_crot( istopm-( istart2+1 )+1, a( istart2,istart2+1 ), lda, a( &
                                 istart2+1,istart2+1 ), lda, c1, s1 )
                       call stdlib_crot( istopm-( istart2+1 )+1, b( istart2,istart2+1 ), ldb, b( &
                                 istart2+1,istart2+1 ), ldb, c1, s1 )
                       if( ilq ) then
                          call stdlib_crot( n, q( 1, istart2 ), 1, q( 1,istart2+1 ), 1, c1, conjg(&
                                     s1 ) )
                       end if
                    end if
                    istart2 = istart2+1
                 end if
                 k = k-1
              end do
              ! istart2 now points to the top of the bottom right
              ! unreduced hessenberg block
              if ( istart2 >= istop ) then
                 istop = istart2-1
                 ld = 0
                 eshift = czero
                 cycle
              end if
              nw = nwr
              nshifts = nsr
              nblock = nbr
              if ( istop-istart2+1 < nmin ) then
                 ! setting nw to the size of the subblock will make aed deflate
                 ! all the eigenvalues. this is slightly more efficient than just
                 ! using stdlib_chgeqz because the off diagonal part gets updated via blas.
                 if ( istop-istart+1 < nmin ) then
                    nw = istop-istart+1
                    istart2 = istart
                 else
                    nw = istop-istart2+1
                 end if
              end if
              ! time for aed
              call stdlib_claqz2( ilschur, ilq, ilz, n, istart2, istop, nw, a, lda,b, ldb, q, ldq,&
               z, ldz, n_undeflated, n_deflated,alpha, beta, work, nw, work( nw**2+1 ), nw,work( &
                         2*nw**2+1 ), lwork-2*nw**2, rwork, rec,aed_info )
              if ( n_deflated > 0 ) then
                 istop = istop-n_deflated
                 ld = 0
                 eshift = czero
              end if
              if ( 100*n_deflated > nibble*( n_deflated+n_undeflated ) .or.istop-istart2+1 < nmin &
                        ) then
                 ! aed has uncovered many eigenvalues. skip a qz sweep and run
                 ! aed again.
                 cycle
              end if
              ld = ld+1
              ns = min( nshifts, istop-istart2 )
              ns = min( ns, n_undeflated )
              shiftpos = istop-n_deflated-n_undeflated+1
              if ( mod( ld, 6 ) == 0 ) then
                 ! exceptional shift.  chosen for no particularly good reason.
                 if( ( real( maxit,KIND=sp)*safmin )*abs( a( istop,istop-1 ) )<abs( a( istop-1, &
                           istop-1 ) ) ) then
                    eshift = a( istop, istop-1 )/b( istop-1, istop-1 )
                 else
                    eshift = eshift+cone/( safmin*real( maxit,KIND=sp) )
                 end if
                 alpha( shiftpos ) = cone
                 beta( shiftpos ) = eshift
                 ns = 1
              end if
              ! time for a qz sweep
              call stdlib_claqz3( ilschur, ilq, ilz, n, istart2, istop, ns, nblock,alpha( &
              shiftpos ), beta( shiftpos ), a, lda, b,ldb, q, ldq, z, ldz, work, nblock, work( &
                        nblock**2+1 ), nblock, work( 2*nblock**2+1 ),lwork-2*nblock**2, sweep_info )
           end do
           ! call stdlib_chgeqz to normalize the eigenvalue blocks and set the eigenvalues
           ! if all the eigenvalues have been found, stdlib_chgeqz will not do any iterations
           ! and only normalize the blocks. in case of a rare convergence failure,
           ! the single shift might perform better.
        80 call stdlib_chgeqz( wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb,alpha, beta, q, &
                  ldq, z, ldz, work, lwork, rwork,norm_info )
           info = norm_info
     end subroutine stdlib_claqz0


     recursive subroutine stdlib_claqz2( ilschur, ilq, ilz, n, ilo, ihi, nw,a, lda, b, ldb, q, &
     !! CLAQZ2 performs AED
               ldq, z, ldz, ns,nd, alpha, beta, qc, ldqc, zc, ldzc,work, lwork, rwork, rec, info )
           ! arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, nw, lda, ldb, ldq, ldz,ldqc, ldzc, lwork, &
                     rec
           complex(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), &
                     alpha( * ), beta( * )
           integer(ilp), intent( out ) :: ns, nd, info
           complex(sp), intent(inout) :: qc(ldqc,*), zc(ldzc,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(out) :: rwork(*)
           
           
           ! local scalars
           integer(ilp) :: jw, kwtop, kwbot, istopm, istartm, k, k2, ctgexc_info, ifst, ilst, &
                     lworkreq, qz_small_info
           real(sp) :: smlnum, ulp, safmin, safmax, c1, tempr
           complex(sp) :: s, s1, temp
           info = 0
           ! set up deflation window
           jw = min( nw, ihi-ilo+1 )
           kwtop = ihi-jw+1
           if ( kwtop == ilo ) then
              s = czero
           else
              s = a( kwtop, kwtop-1 )
           end if
           ! determine required workspace
           ifst = 1
           ilst = jw
           call stdlib_claqz0( 'S', 'V', 'V', jw, 1, jw, a( kwtop, kwtop ), lda,b( kwtop, kwtop ),&
                      ldb, alpha, beta, qc, ldqc, zc,ldzc, work, -1, rwork, rec+1, qz_small_info )
           lworkreq = int( work( 1 ),KIND=ilp)+2*jw**2
           lworkreq = max( lworkreq, n*nw, 2*nw**2+n )
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = lworkreq
              return
           else if ( lwork < lworkreq ) then
              info = -26
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAQZ2', -info )
              return
           end if
           ! get machine constants
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp)/ulp )
           if ( ihi == kwtop ) then
              ! 1 by 1 deflation window, just try a regular deflation
              alpha( kwtop ) = a( kwtop, kwtop )
              beta( kwtop ) = b( kwtop, kwtop )
              ns = 1
              nd = 0
              if ( abs( s ) <= max( smlnum, ulp*abs( a( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if ( kwtop > ilo ) then
                    a( kwtop, kwtop-1 ) = czero
                 end if
              end if
           end if
           ! store window in case of convergence failure
           call stdlib_clacpy( 'ALL', jw, jw, a( kwtop, kwtop ), lda, work, jw )
           call stdlib_clacpy( 'ALL', jw, jw, b( kwtop, kwtop ), ldb, work( jw**2+1 ), jw )
                     
           ! transform window to real schur form
           call stdlib_claset( 'FULL', jw, jw, czero, cone, qc, ldqc )
           call stdlib_claset( 'FULL', jw, jw, czero, cone, zc, ldzc )
           call stdlib_claqz0( 'S', 'V', 'V', jw, 1, jw, a( kwtop, kwtop ), lda,b( kwtop, kwtop ),&
            ldb, alpha, beta, qc, ldqc, zc,ldzc, work( 2*jw**2+1 ), lwork-2*jw**2, rwork,rec+1, &
                      qz_small_info )
           if( qz_small_info /= 0 ) then
              ! convergence failure, restore the window and exit
              nd = 0
              ns = jw-qz_small_info
              call stdlib_clacpy( 'ALL', jw, jw, work, jw, a( kwtop, kwtop ), lda )
              call stdlib_clacpy( 'ALL', jw, jw, work( jw**2+1 ), jw, b( kwtop,kwtop ), ldb )
                        
              return
           end if
           ! deflation detection loop
           if ( kwtop == ilo .or. s == czero ) then
              kwbot = kwtop-1
           else
              kwbot = ihi
              k = 1
              k2 = 1
              do while ( k <= jw )
                    ! try to deflate eigenvalue
                    tempr = abs( a( kwbot, kwbot ) )
                    if( tempr == zero ) then
                       tempr = abs( s )
                    end if
                    if ( ( abs( s*qc( 1, kwbot-kwtop+1 ) ) ) <= max( ulp*tempr, smlnum ) ) &
                              then
                       ! deflatable
                       kwbot = kwbot-1
                    else
                       ! not deflatable, move out of the way
                       ifst = kwbot-kwtop+1
                       ilst = k2
                       call stdlib_ctgexc( .true., .true., jw, a( kwtop, kwtop ),lda, b( kwtop, &
                                 kwtop ), ldb, qc, ldqc,zc, ldzc, ifst, ilst, ctgexc_info )
                       k2 = k2+1
                    end if
                    k = k+1
              end do
           end if
           ! store eigenvalues
           nd = ihi-kwbot
           ns = jw-nd
           k = kwtop
           do while ( k <= ihi )
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
              k = k+1
           end do
           if ( kwtop /= ilo .and. s /= czero ) then
              ! reflect spike back, this will create optimally packed bulges
              a( kwtop:kwbot, kwtop-1 ) = a( kwtop, kwtop-1 ) *conjg( qc( 1,1:jw-nd ) )
              do k = kwbot-1, kwtop, -1
                 call stdlib_clartg( a( k, kwtop-1 ), a( k+1, kwtop-1 ), c1, s1,temp )
                 a( k, kwtop-1 ) = temp
                 a( k+1, kwtop-1 ) = czero
                 k2 = max( kwtop, k-1 )
                 call stdlib_crot( ihi-k2+1, a( k, k2 ), lda, a( k+1, k2 ), lda, c1,s1 )
                 call stdlib_crot( ihi-( k-1 )+1, b( k, k-1 ), ldb, b( k+1, k-1 ),ldb, c1, s1 )
                           
                 call stdlib_crot( jw, qc( 1, k-kwtop+1 ), 1, qc( 1, k+1-kwtop+1 ),1, c1, conjg( &
                           s1 ) )
              end do
              ! chase bulges down
              istartm = kwtop
              istopm = ihi
              k = kwbot-1
              do while ( k >= kwtop )
                 ! move bulge down and remove it
                 do k2 = k, kwbot-1
                    call stdlib_claqz1( .true., .true., k2, kwtop, kwtop+jw-1,kwbot, a, lda, b, &
                              ldb, jw, kwtop, qc, ldqc,jw, kwtop, zc, ldzc )
                 end do
                 k = k-1
              end do
           end if
           ! apply qc and zc to rest of the matrix
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           if ( istopm-ihi > 0 ) then
              call stdlib_cgemm( 'C', 'N', jw, istopm-ihi, jw, cone, qc, ldqc,a( kwtop, ihi+1 ), &
                        lda, czero, work, jw )
              call stdlib_clacpy( 'ALL', jw, istopm-ihi, work, jw, a( kwtop,ihi+1 ), lda )
              call stdlib_cgemm( 'C', 'N', jw, istopm-ihi, jw, cone, qc, ldqc,b( kwtop, ihi+1 ), &
                        ldb, czero, work, jw )
              call stdlib_clacpy( 'ALL', jw, istopm-ihi, work, jw, b( kwtop,ihi+1 ), ldb )
           end if
           if ( ilq ) then
              call stdlib_cgemm( 'N', 'N', n, jw, jw, cone, q( 1, kwtop ), ldq, qc,ldqc, czero, &
                        work, n )
              call stdlib_clacpy( 'ALL', n, jw, work, n, q( 1, kwtop ), ldq )
           end if
           if ( kwtop-1-istartm+1 > 0 ) then
              call stdlib_cgemm( 'N', 'N', kwtop-istartm, jw, jw, cone, a( istartm,kwtop ), lda, &
                        zc, ldzc, czero, work,kwtop-istartm )
             call stdlib_clacpy( 'ALL', kwtop-istartm, jw, work, kwtop-istartm,a( istartm, kwtop )&
                       , lda )
              call stdlib_cgemm( 'N', 'N', kwtop-istartm, jw, jw, cone, b( istartm,kwtop ), ldb, &
                        zc, ldzc, czero, work,kwtop-istartm )
             call stdlib_clacpy( 'ALL', kwtop-istartm, jw, work, kwtop-istartm,b( istartm, kwtop )&
                       , ldb )
           end if
           if ( ilz ) then
              call stdlib_cgemm( 'N', 'N', n, jw, jw, cone, z( 1, kwtop ), ldz, zc,ldzc, czero, &
                        work, n )
              call stdlib_clacpy( 'ALL', n, jw, work, n, z( 1, kwtop ), ldz )
           end if
     end subroutine stdlib_claqz2


     pure subroutine stdlib_clasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
     !! DLATRF_AA factorizes a panel of a complex symmetric matrix A using
     !! the Aasen's algorithm. The panel consists of a set of NB rows of A
     !! when UPLO is U, or a set of NB columns when UPLO is L.
     !! In order to factorize the panel, the Aasen's algorithm requires the
     !! last row, or column, of the previous panel. The first row, or column,
     !! of A is set to be the first row, or column, of an identity matrix,
     !! which is used to factorize the first panel.
     !! The resulting J-th row of U, or J-th column of L, is stored in the
     !! (J-1)-th row, or column, of A (without the unit diagonals), while
     !! the diagonal and subdiagonal of A are overwritten by those of T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: m, nb, j1, lda, ldh
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), h(ldh,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, k, k1, i1, i2, mj
           complex(sp) :: piv, alpha
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           j = 1
           ! k1 is the first column of the panel to be factorized
           ! i.e.,  k1 is 2 for the first block column, and 1 for the rest of the blocks
           k1 = (2-j1)+1
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              10 continue
              if ( j>min(m, nb) )go to 20
              ! k is the column to be factorized
               ! when being called from stdlib_csytrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:m, j) := a(j, j:m) - h(j:m, 1:(j-1)) * l(j1:(j-1), j),
               ! where h(j:m, j) has been initialized to be a(j, j:m)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_cgemv( 'NO TRANSPOSE', mj, j-k1,-cone, h( j, k1 ), ldh,a( 1, j ), 1,&
                           cone, h( j, j ), 1 )
              end if
              ! copy h(i:m, i) into work
              call stdlib_ccopy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j-1, j:m) * t(j-1,j),
                  ! where a(j-1, j) stores t(j-1, j) and a(j-2, j:m) stores u(j-1, j:m)
                 alpha = -a( k-1, j )
                 call stdlib_caxpy( mj, alpha, a( k-2, j ), lda, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( k, j ) = work( 1 )
              if( j<m ) then
                 ! compute work(2:m) = t(j, j) l(j, (j+1):m)
                  ! where a(j, j) stores t(j, j) and a(j-1, (j+1):m) stores u(j, (j+1):m)
                 if( k>1 ) then
                    alpha = -a( k, j )
                    call stdlib_caxpy( m-j, alpha, a( k-1, j+1 ), lda,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:m)|)
                 i2 = stdlib_icamax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply symmetric pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1, i1+1:m) with a(i1+1:m, i2)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_cswap( i2-i1-1, a( j1+i1-1, i1+1 ), lda,a( j1+i1, i2 ), 1 )
                              
                    ! swap a(i1, i2+1:m) with a(i2, i2+1:m)
                    if( i2<m )call stdlib_cswap( m-i2, a( j1+i1-1, i2+1 ), lda,a( j1+i2-1, i2+1 ),&
                               lda )
                    ! swap a(i1, i1) with a(i2,i2)
                    piv = a( i1+j1-1, i1 )
                    a( j1+i1-1, i1 ) = a( j1+i2-1, i2 )
                    a( j1+i2-1, i2 ) = piv
                    ! swap h(i1, 1:j1) with h(i2, 1:j1)
                    call stdlib_cswap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_cswap( i1-k1+1, a( 1, i1 ), 1,a( 1, i2 ), 1 )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j, j+1) = t(j, j+1)
                 a( k, j+1 ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:m, j+1) into h(j:m, j),
                    call stdlib_ccopy( m-j, a( k+1, j+1 ), lda,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:m ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:m, j) = l(j+2:m, j+1)
                 if( j<(m-1) ) then
                    if( a( k, j+1 )/=czero ) then
                       alpha = cone / a( k, j+1 )
                       call stdlib_ccopy( m-j-1, work( 3 ), 1, a( k, j+2 ), lda )
                       call stdlib_cscal( m-j-1, alpha, a( k, j+2 ), lda )
                    else
                       call stdlib_claset( 'FULL', 1, m-j-1, czero, czero,a( k, j+2 ), lda)
                                 
                    end if
                 end if
              end if
              j = j + 1
              go to 10
              20 continue
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              30 continue
              if( j>min( m, nb ) )go to 40
              ! k is the column to be factorized
               ! when being called from stdlib_csytrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:m, j) := a(j:m, j) - h(j:m, 1:(j-1)) * l(j, j1:(j-1))^t,
               ! where h(j:m, j) has been initialized to be a(j:m, j)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_cgemv( 'NO TRANSPOSE', mj, j-k1,-cone, h( j, k1 ), ldh,a( j, 1 ), &
                           lda,cone, h( j, j ), 1 )
              end if
              ! copy h(j:m, j) into work
              call stdlib_ccopy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j:m, j-1) * t(j-1,j),
                  ! where a(j-1, j) = t(j-1, j) and a(j, j-2) = l(j, j-1)
                 alpha = -a( j, k-1 )
                 call stdlib_caxpy( mj, alpha, a( j, k-2 ), 1, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( j, k ) = work( 1 )
              if( j<m ) then
                 ! compute work(2:m) = t(j, j) l((j+1):m, j)
                  ! where a(j, j) = t(j, j) and a((j+1):m, j-1) = l((j+1):m, j)
                 if( k>1 ) then
                    alpha = -a( j, k )
                    call stdlib_caxpy( m-j, alpha, a( j+1, k-1 ), 1,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:m)|)
                 i2 = stdlib_icamax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply symmetric pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1+1:m, i1) with a(i2, i1+1:m)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_cswap( i2-i1-1, a( i1+1, j1+i1-1 ), 1,a( i2, j1+i1 ), lda )
                              
                    ! swap a(i2+1:m, i1) with a(i2+1:m, i2)
                    if( i2<m )call stdlib_cswap( m-i2, a( i2+1, j1+i1-1 ), 1,a( i2+1, j1+i2-1 ), &
                              1 )
                    ! swap a(i1, i1) with a(i2, i2)
                    piv = a( i1, j1+i1-1 )
                    a( i1, j1+i1-1 ) = a( i2, j1+i2-1 )
                    a( i2, j1+i2-1 ) = piv
                    ! swap h(i1, i1:j1) with h(i2, i2:j1)
                    call stdlib_cswap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_cswap( i1-k1+1, a( i1, 1 ), lda,a( i2, 1 ), lda )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j+1, j) = t(j+1, j)
                 a( j+1, k ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:m, j+1) into h(j+1:m, j),
                    call stdlib_ccopy( m-j, a( j+1, k+1 ), 1,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:m ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:m, j) = l(j+2:m, j+1)
                 if( j<(m-1) ) then
                    if( a( j+1, k )/=czero ) then
                       alpha = cone / a( j+1, k )
                       call stdlib_ccopy( m-j-1, work( 3 ), 1, a( j+2, k ), 1 )
                       call stdlib_cscal( m-j-1, alpha, a( j+2, k ), 1 )
                    else
                       call stdlib_claset( 'FULL', m-j-1, 1, czero, czero,a( j+2, k ), lda )
                                 
                    end if
                 end if
              end if
              j = j + 1
              go to 30
              40 continue
           end if
           return
     end subroutine stdlib_clasyf_aa


     pure subroutine stdlib_csysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CSYSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**T * T * U,  if UPLO = 'U', or
     !! A = L * T * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is symmetric tridiagonal. The factored
     !! form of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_sytrf, lwkopt_sytrs
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_csytrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_sytrf = int( work(1),KIND=ilp)
              call stdlib_csytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_sytrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_sytrf, lwkopt_sytrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYSV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**t*t*u or a = l*t*l**t.
           call stdlib_csytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_csytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csysv_aa


     pure subroutine stdlib_csytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
     !! CSYTRF_AA computes the factorization of a complex symmetric matrix A
     !! using the Aasen's algorithm.  The form of the factorization is
     !! A = U**T*T*U  or  A = L*T*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is a complex symmetric tridiagonal matrix.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: j, lwkopt
           integer(ilp) :: nb, mj, nj, k1, k2, j1, j2, j3, jb
           complex(sp) :: alpha
           ! Intrinsic Functions 
           intrinsic :: max
           ! Executable Statements 
           ! determine the block size
           nb = stdlib_ilaenv( 1, 'CSYTRF_AA', uplo, n, -1, -1, -1 )
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              lwkopt = (nb+1)*n
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRF_AA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return
           if ( n==0 ) then
               return
           endif
           ipiv( 1 ) = 1
           if ( n==1 ) then
              return
           end if
           ! adjust block size based on the workspace size
           if( lwork<((1+nb)*n) ) then
              nb = ( lwork-n ) / n
           end if
           if( upper ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              ! copy first row a(1, 1:n) into h(1:n) (stored in work(1:n))
              call stdlib_ccopy( n, a( 1, 1 ), lda, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_clasyf;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              10 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j + 1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_clasyf_aa( uplo, 2-k1, n-j, jb,a( max(1, j), j+1 ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_cswap( j1-k1-2, a( 1, j2 ), 1,a( 1, ipiv(j2) ), 1 )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
               ! the row a(j1-1, j2-1:n) stores u(j1, j2+1:n) and
               ! work stores the current block of the auxiriarly matrix h
              if( j<n ) then
                 ! if first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = a( j, j+1 )
                    a( j, j+1 ) = cone
                    call stdlib_ccopy( n-j, a( j-1, j+1 ), lda,work( (j+1-j1+1)+jb*n ), 1 )
                              
                    call stdlib_cscal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=1 and k2= 0 for the first panel,
                     ! while k1=0 and k2=1 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_cgemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_cgemv( 'NO TRANSPOSE', mj, jb+1,-cone, work( j3-j1+1+k1*n ),&
                                     n,a( j1-k2, j3 ), 1,cone, a( j3, j3 ), lda )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block of j2-th block row with stdlib_cgemm
                       call stdlib_cgemm( 'TRANSPOSE', 'TRANSPOSE',nj, n-j3+1, jb+1,-cone, a( j1-&
                                 k2, j2 ), lda,work( j3-j1+1+k1*n ), n,cone, a( j2, j3 ), lda )
                    end do
                    ! recover t( j, j+1 )
                    a( j, j+1 ) = alpha
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_ccopy( n-j, a( j+1, j+1 ), lda, work( 1 ), 1 )
              end if
              go to 10
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              ! copy first column a(1:n, 1) into h(1:n, 1)
               ! (stored in work(1:n))
              call stdlib_ccopy( n, a( 1, 1 ), 1, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_clasyf;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              11 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j+1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_clasyf_aa( uplo, 2-k1, n-j, jb,a( j+1, max(1, j) ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_cswap( j1-k1-2, a( j2, 1 ), lda,a( ipiv(j2), 1 ), lda )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
                ! a(j2+1, j1-1) stores l(j2+1, j1) and
                ! work(j2+1, 1) stores h(j2+1, 1)
              if( j<n ) then
                 ! if first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = a( j+1, j )
                    a( j+1, j ) = cone
                    call stdlib_ccopy( n-j, a( j+1, j-1 ), 1,work( (j+1-j1+1)+jb*n ), 1 )
                    call stdlib_cscal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=1 and k2= 0 for the first panel,
                     ! while k1=0 and k2=1 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_cgemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_cgemv( 'NO TRANSPOSE', mj, jb+1,-cone, work( j3-j1+1+k1*n ),&
                                     n,a( j3, j1-k2 ), lda,cone, a( j3, j3 ), 1 )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block in j2-th block column with stdlib_cgemm
                       call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE',n-j3+1, nj, jb+1,-cone, &
                       work( j3-j1+1+k1*n ), n,a( j2, j1-k2 ), lda,cone, a( j3, j2 ), lda )
                                 
                    end do
                    ! recover t( j+1, j )
                    a( j+1, j ) = alpha
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_ccopy( n-j, a( j+1, j+1 ), 1, work( 1 ), 1 )
              end if
              go to 11
           end if
           20 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csytrf_aa



end module stdlib_linalg_lapack_c
