#:include "common.fypp"
#:set I_KINDS_TYPES = list(zip(INT_KINDS, INT_TYPES, INT_KINDS))
#:set R_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES, REAL_SUFFIX))
#:set C_KINDS_TYPES = list(zip(CMPLX_KINDS, CMPLX_TYPES, CMPLX_SUFFIX))

submodule (stdlib_intrinsics) stdlib_intrinsics_matmul
    implicit none

contains

    ! Algorithm for the optimal parenthesization of matrices
    ! Reference: Cormen, "Introduction to Algorithms", 4ed, ch-14, section-2
    ! Internal use only!
    pure function matmul_chain_order(p) result(s)
        integer, intent(in) :: p(:)
        integer :: s(1:size(p) - 2, 2: size(p) - 1), m(1: size(p) - 1, 1: size(p) - 1)
        integer :: n, l, i, j, k, q
        n = size(p) - 1
        m(:,:) = 0
        s(:,:) = 0

        do l = 2, n
            do i = 1, n - l + 1
                j = i + l - 1
                m(i,j) = huge(1)
                
                do k = i, j - 1
                    q = m(i,k) + m(k+1,j) + p(i)*p(k+1)*p(j+1)

                    if (q < m(i, j)) then
                        m(i,j) = q
                        s(i,j) = k
                    end if
                end do
            end do
        end do
    end function matmul_chain_order

#:for k, t, s in I_KINDS_TYPES + R_KINDS_TYPES + C_KINDS_TYPES
    
    pure function matmul_chain_mult_${s}$_3 (m1, m2, m3, start, s) result(r)
        ${t}$, intent(in) :: m1(:,:), m2(:,:), m3(:,:)
        integer, intent(in) :: start, s(:,:)
        ${t}$, allocatable :: r(:,:)

        select case (s(start, start + 2))
            case (1)
                r = matmul(m1, matmul(m2, m3)) 
            case (2)
                r = matmul(matmul(m1, m2), m3)
            case default
                error stop "stdlib_matmul: unexpected error unexpected s(i,j)"
        end select
    end function matmul_chain_mult_${s}$_3

    pure function matmul_chain_mult_${s}$_4 (m1, m2, m3, m4, start, s) result(r)
        ${t}$, intent(in) :: m1(:,:), m2(:,:), m3(:,:), m4(:,:)
        integer, intent(in) :: start, s(:,:)
        ${t}$, allocatable :: r(:,:)

        select case (s(start, start + 3))
            case (1)
                r = matmul(m1, matmul_chain_mult_${s}$_3(m2, m3, m4, start + 1, s))
            case (2)
                r = matmul(matmul(m1, m2), matmul(m3, m4))
            case (3)
                r = matmul(matmul_chain_mult_${s}$_3(m1, m2, m3, start, s), m4)
            case default
                error stop "stdlib_matmul: unexpected error unexpected s(i,j)"
        end select
    end function matmul_chain_mult_${s}$_4

#:endfor
end submodule stdlib_intrinsics_matmul
