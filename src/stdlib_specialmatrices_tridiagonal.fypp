#:include "common.fypp"
#:set RANKS = range(1, 2+1)
#:set R_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES, REAL_SUFFIX))
#:set C_KINDS_TYPES = list(zip(CMPLX_KINDS, CMPLX_TYPES, CMPLX_SUFFIX))
#:set KINDS_TYPES = R_KINDS_TYPES+C_KINDS_TYPES
submodule (stdlib_specialmatrices) tridiagonal_matrices
    use stdlib_linalg_lapack, only: lagtm
    contains

    !--------------------------------
    !-----                      -----
    !-----     CONSTRUCTORS     -----
    !-----                      -----
    !--------------------------------

    #:for k1, t1, s1 in (KINDS_TYPES)
    pure module function initialize_tridiagonal_${s1}$(dl, dv, du) result(A)
        !! Construct a `Tridiagonal` matrix from the rank-1 arrays
        !! `dl`, `dv` and `du`.
        ${t1}$, intent(in) :: dl(:), dv(:), du(:)
        !! Tridiagonal matrix elements.
        type(Tridiagonal_${s1}$_type) :: A
        !! Corresponding Tridiagonal matrix.

        ! Internal variables.
        integer(ilp) :: n

        ! Sanity check.
        n = size(dv)
        if (size(dl) /= n-1) error stop "Vector dl does not have the correct length."
        if (size(du) /= n-1) error stop "Vector du does not have the correct length."

        ! Description of the matrix.
        A%n = n
        ! Matrix elements.
        A%dl = dl ; A%dv = dv ; A%du = du
    end function

    pure module function initialize_constant_tridiagonal_${s1}$(dl, dv, du, n) result(A)
        !! Construct a `Tridiagonal` matrix with constant elements.
        ${t1}$, intent(in) :: dl, dv, du
        !! Tridiagonal matrix elements.
        integer(ilp), intent(in) :: n
        !! Matrix dimension.
        type(Tridiagonal_${s1}$_type) :: A
        !! Corresponding Tridiagonal matrix.

        ! Internal variables.
        integer(ilp) :: i

        ! Description of the matrix.
        A%n = n
        ! Matrix elements.
        A%dl = [(dl, i = 1, n-1)]
        A%dv = [(dv, i = 1, n)]
        A%du = [(du, i = 1, n-1)]
    end function
    #:endfor

    !-----------------------------------------
    !-----                               -----
    !-----     MATRIX-VECTOR PRODUCT     -----
    !-----                               -----
    !-----------------------------------------

    !! spmv_tridiag
    #:for k1, t1, s1 in (KINDS_TYPES)
    #:for rank in RANKS
    module subroutine spmv_tridiag_${rank}$d_${s1}$(A, x, y, alpha, beta, op)
        type(Tridiagonal_${s1}$_type), intent(in) :: A
        ${t1}$, intent(in), contiguous, target :: x${ranksuffix(rank)}$
        ${t1}$, intent(inout), contiguous, target :: y${ranksuffix(rank)}$
        real(${k1}$), intent(in), optional :: alpha
        real(${k1}$), intent(in), optional :: beta
        character(1), intent(in), optional :: op

        ! Internal variables.
        real(${k1}$) :: alpha_, beta_
        integer(ilp) :: n, nrhs, ldx, ldy
        character(1) :: op_
        #:if rank == 1
        ${t1}$, pointer :: xmat(:, :), ymat(:, :)
        #:endif

        ! Deal with optional arguments.
        alpha_ = 1.0_${k1}$ ; if (present(alpha)) alpha_ = alpha
        beta_  = 0.0_${k1}$ ; if (present(beta))  beta_  = beta
        op_    = "N"        ; if (present(op))    op_    = op

        ! Prepare Lapack arguments.
        n = A%n ; ldx = n ; ldy = n ; y = 0.0_${k1}$
        nrhs = #{if rank==1}# 1 #{else}# size(x, 2) #{endif}#

        #:if rank == 1
        ! Pointer trick.
        xmat(1:n, 1:nrhs) => x ; ymat(1:n, 1:nrhs) => y
        call lagtm(op_, n, nrhs, alpha_, A%dl, A%dv, A%du, xmat, ldx, beta_, ymat, ldy)
        #:else
        call lagtm(op_, n, nrhs, alpha_, A%dl, A%dv, A%du, x, ldx, beta_, y, ldy)
        #:endif
    end subroutine
    #:endfor
    #:endfor

    !-------------------------------------
    !-----                           -----
    !-----     UTILITY FUNCTIONS     -----
    !-----                           -----
    !-------------------------------------

    #:for k1, t1, s1 in (KINDS_TYPES)
    pure module function tridiagonal_to_dense_${s1}$(A) result(B)
        !! Convert a `Tridiagonal` matrix to its dense representation.
        type(Tridiagonal_${s1}$_type), intent(in) :: A
        !! Input Tridiagonal matrix.
        ${t1}$, allocatable :: B(:, :)
        !! Corresponding dense matrix.

        ! Internal variables.
        integer(ilp) :: i

        associate (n => A%n)
        #:if t1.startswith('complex')
        allocate(B(n, n), source=zero_c${k1}$)
        #:else
        allocate(B(n, n), source=zero_${k1}$)
        #:endif
        B(1, 1) = A%dv(1) ; B(1, 2) = A%du(1)
        do concurrent (i=2:n-1)
            B(i, i-1) = A%dl(i-1)
            B(i, i) = A%dv(i)
            B(i, i+1) = A%du(i)
        enddo
        B(n, n-1) = A%dl(n-1) ; B(n, n) = A%dv(n)
        end associate
    end function
    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    pure module function transpose_tridiagonal_${s1}$(A) result(B)
        type(Tridiagonal_${s1}$_type), intent(in) :: A
        !! Input matrix.
        type(Tridiagonal_${s1}$_type) :: B
        B%n = A%n ; B%dv = A%dv ; B%du = A%dl ; B%dl = A%du
    end function
    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    pure module function hermitian_tridiagonal_${s1}$(A) result(B)
        type(Tridiagonal_${s1}$_type), intent(in) :: A
        !! Input matrix.
        type(Tridiagonal_${s1}$_type) :: B
        B%n = A%n
        #:if t1.startswith("complex")
        B%dv = conjg(A%dv) ; B%du = conjg(A%dl) ; B%dl = conjg(A%du)
        #:else
        B%dv = A%dv ; B%du = A%dl ; B%dl = A%du
        #:endif
    end function
    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    pure module function scalar_multiplication_tridiagonal_${s1}$(alpha, A) result(B)
        ${t1}$, intent(in) :: alpha
        type(Tridiagonal_${s1}$_type), intent(in) :: A
        type(Tridiagonal_${s1}$_type) :: B
        B = Tridiagonal(alpha*A%dl, alpha*A%dv, alpha*A%du)
    end function

    pure module function scalar_multiplication_bis_tridiagonal_${s1}$(A, alpha) result(B)
        type(Tridiagonal_${s1}$_type), intent(in) :: A
        ${t1}$, intent(in) :: alpha
        type(Tridiagonal_${s1}$_type) :: B
        B = Tridiagonal(alpha*A%dl, alpha*A%dv, alpha*A%du)
    end function
    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    pure module function matrix_add_tridiagonal_${s1}$(A, B) result(C)
        type(Tridiagonal_${s1}$_type), intent(in) :: A
        type(Tridiagonal_${s1}$_type), intent(in) :: B
        type(Tridiagonal_${s1}$_type) :: C
        C = Tridiagonal(A%dl+B%dl, A%dv+B%dv, A%du+B%du)
    end function

    pure module function matrix_sub_tridiagonal_${s1}$(A, B) result(C)
        type(Tridiagonal_${s1}$_type), intent(in) :: A
        type(Tridiagonal_${s1}$_type), intent(in) :: B
        type(Tridiagonal_${s1}$_type) :: C
        C = Tridiagonal(A%dl-B%dl, A%dv-B%dv, A%du-B%du)
    end function
    #:endfor

end submodule
