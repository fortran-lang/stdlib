#:include "common.fypp"

#:set INT_TYPES_ALT_NAME = list(zip(INT_TYPES, INT_TYPES, INT_KINDS))
#:set REAL_TYPES_ALT_NAME = list(zip(REAL_TYPES, REAL_TYPES, REAL_KINDS))
#:set STRING_TYPES_ALT_NAME = list(zip(STRING_TYPES, STRING_TYPES, STRING_KINDS))
#:set CHAR_TYPES_ALT_NAME = list(zip(["character(len=*)"], ["character(len=len(array))"], ["char"]))
#:set COMPLEX_TYPES_ALT_NAME = list(zip(CMPLX_TYPES, CMPLX_TYPES, CMPLX_KINDS))

#! For better code reuse in fypp, make lists that contain the input types,
#! with each having output types and a separate name prefix for subroutines
#! This approach allows us to have the same code for all input types.
#:set IRSC_TYPES_ALT_NAME = INT_TYPES_ALT_NAME + REAL_TYPES_ALT_NAME + STRING_TYPES_ALT_NAME + CHAR_TYPES_ALT_NAME + COMPLEX_TYPES_ALT_NAME

!! Licensing:
!!
!! This file is subject to the Fortran Standard Library license.
!!
!! The Fortran Standard Library, including this file, is distributed under
!! the MIT license that should be included with the library's distribution.
!!
!!   Copyright (c) 2024 Fortran stdlib developers
!!
!!   Permission is hereby granted, free of charge, to any person obtaining a
!!   copy of this software and associated documentation files (the
!!   "Software"),  to deal in the Software without restriction, including
!!   without limitation the rights to use, copy, modify, merge, publish,
!!   distribute, sublicense, and/or sellcopies of the Software, and to permit
!!   persons to whom the Software is furnished to do so, subject to the
!!   following conditions:
!!
!!   The above copyright notice and this permission notice shall be included
!!   in all copies or substantial portions of the Software.
!!
!!   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
!!   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
!!   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
!!   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
!!   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
!!   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
!!   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

submodule (stdlib_sorting) stdlib_sorting_unique
    use stdlib_kinds, only: &
        int8,               &
        int16,              &
        int32,              &
        int64,              &
        sp,                 &
        dp,                 &
        xdp,                &
        qp,                 &
        lk
    use stdlib_optval, only: optval
    use stdlib_string_type, only: string_type, assignment(=), operator(==)
    implicit none

contains

#:for t1, t2, name1 in IRSC_TYPES_ALT_NAME
    pure module procedure ${name1}$_unique(array, sorted) result(unique_values)
!! Version: experimental
!!
!! `${name1}$_unique(array, sorted)` returns an array of unique values
!! from the input `array` of type `${t1}$`. If the optional argument `sorted`
!! is present with value `.true.`, the function assumes the input is already sorted
!! and skips the sorting step.
        ${t1}$, intent(in) :: array(:)
        logical(lk), intent(in), optional :: sorted
        ${t2}$, allocatable :: unique_values(:)

        ${t2}$ :: temp_array(size(array))
        logical :: mask(size(array))
        integer :: i, n
        logical :: is_input_sorted

        n = size(array)
        
        ! Handle edge cases first
        if (n == 0) then
            ! Return empty array for empty input
            allocate(unique_values(0))
            return
        else if (n == 1) then
            ! For single-element arrays, return that element directly
            allocate(unique_values(1))
            unique_values(1) = array(1)
            return
        endif

        ! Determine if the input is already sorted
        is_input_sorted = optval(sorted, .false.)

        ! Create a temporary copy and sort it if needed
        temp_array = array
        if (.not. is_input_sorted) call sort(temp_array)

        ! Find unique elements using a mask
        ! Start with first element always marked as unique
        mask(1) = .true.

        ! Compare each element with previous to mark duplicates
        do concurrent (i=2:n)
            mask(i) = temp_array(i) /= temp_array(i-1)
        end do

        ! Extract unique elements to result array using pack
        unique_values = pack(temp_array, mask)
    end procedure ${name1}$_unique
#:endfor

end submodule stdlib_sorting_unique 