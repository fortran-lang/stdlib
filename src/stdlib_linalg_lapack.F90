module stdlib_linalg_lapack
     use stdlib_linalg_constants
     use stdlib_linalg_blas
     use stdlib_linalg_lapack_aux

     use stdlib_lapack_base
     use stdlib_lapack_solve
     use stdlib_lapack_others
     use stdlib_lapack_orthogonal_factors
     use stdlib_lapack_eig_svd_lsq
     
     implicit none
     public
         
          interface bbcsd
          !! BBCSD computes the CS decomposition of a unitary matrix in
          !! bidiagonal-block form,
          !!     [ B11 | B12 0  0 ]
          !!     [  0  |  0 -I  0 ]
          !! X = [----------------]
          !!     [ B21 | B22 0  0 ]
          !!     [  0  |  0  0  I ]
          !!     [  C  | -S  0  0 ]
          !! 
          !!     [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**H
          !!   = [---------] [---------------] [---------]   .
          !!     [    | U2 ] [  S |  C  0  0 ] [    | V2 ]
          !!                 [  0 |  0  0  I ]
          !! X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
          !! than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
          !! transposed and/or permuted. This can be done in constant time using
          !! the TRANS and SIGNS options. See CUNCSD for details.)
          !! The bidiagonal matrices B11, B12, B21, and B22 are represented
          !! implicitly by angles THETA(1:Q) and PHI(1:Q-1).
          !! The unitary matrices U1, U2, V1T, and V2T are input/output.
          !! The input matrices are pre- or post-multiplied by the appropriate
          !! singular vector matrices.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, &
               u1, ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d,&
                          b22e, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,lrwork,m,p,q
                    real(sp), intent(out) :: b11d(*),b11e(*),b12d(*),b12e(*),b21d(*),b21e(*),&
                              b22d(*),b22e(*),rwork(*)
                    real(sp), intent(inout) :: phi(*),theta(*)
                    real(sp), intent(inout) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*)

               end subroutine sbbcsd
#else
               module procedure stdlib_sbbcsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, &
               u1, ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d,&
                          b22e, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,lrwork,m,p,q
                    real(dp), intent(out) :: b11d(*),b11e(*),b12d(*),b12e(*),b21d(*),b21e(*),&
                              b22d(*),b22e(*),rwork(*)
                    real(dp), intent(inout) :: phi(*),theta(*)
                    real(dp), intent(inout) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*)

               end subroutine dbbcsd
#else
               module procedure stdlib_dbbcsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, &
               u1, ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d,&
                          b22e, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,lrwork,m,p,q
                    real(sp), intent(out) :: b11d(*),b11e(*),b12d(*),b12e(*),b21d(*),b21e(*),&
                              b22d(*),b22e(*),rwork(*)
                    real(sp), intent(inout) :: phi(*),theta(*)
                    complex(sp), intent(inout) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*)

               end subroutine cbbcsd
#else
               module procedure stdlib_cbbcsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, &
               u1, ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d,&
                          b22e, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,lrwork,m,p,q
                    real(dp), intent(out) :: b11d(*),b11e(*),b12d(*),b12e(*),b21d(*),b21e(*),&
                              b22d(*),b22e(*),rwork(*)
                    real(dp), intent(inout) :: phi(*),theta(*)
                    complex(dp), intent(inout) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*)

               end subroutine zbbcsd
#else
               module procedure stdlib_zbbcsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, &
               u1, ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d,&
                          b22e, rwork, lrwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,lrwork,m,p,q
                    real(sp), intent(out) :: b11d(*),b11e(*),b12d(*),b12e(*),b21d(*),b21e(*),&
                              b22d(*),b22e(*),rwork(*)
                    real(sp), intent(inout) :: phi(*),theta(*)
                    real(sp), intent(inout) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*)

               end subroutine sbbcsd
#else
               module procedure stdlib_I64_sbbcsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, &
               u1, ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d,&
                          b22e, rwork, lrwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,lrwork,m,p,q
                    real(dp), intent(out) :: b11d(*),b11e(*),b12d(*),b12e(*),b21d(*),b21e(*),&
                              b22d(*),b22e(*),rwork(*)
                    real(dp), intent(inout) :: phi(*),theta(*)
                    real(dp), intent(inout) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*)

               end subroutine dbbcsd
#else
               module procedure stdlib_I64_dbbcsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, &
               u1, ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d,&
                          b22e, rwork, lrwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,lrwork,m,p,q
                    real(sp), intent(out) :: b11d(*),b11e(*),b12d(*),b12e(*),b21d(*),b21e(*),&
                              b22d(*),b22e(*),rwork(*)
                    real(sp), intent(inout) :: phi(*),theta(*)
                    complex(sp), intent(inout) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*)

               end subroutine cbbcsd
#else
               module procedure stdlib_I64_cbbcsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, &
               u1, ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d,&
                          b22e, rwork, lrwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,lrwork,m,p,q
                    real(dp), intent(out) :: b11d(*),b11e(*),b12d(*),b12e(*),b21d(*),b21e(*),&
                              b22d(*),b22e(*),rwork(*)
                    real(dp), intent(inout) :: phi(*),theta(*)
                    complex(dp), intent(inout) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*)

               end subroutine zbbcsd
#else
               module procedure stdlib_I64_zbbcsd
#endif
          end interface bbcsd

          interface bdsdc
          !! BDSDC computes the singular value decomposition (SVD) of a real
          !! N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
          !! using a divide and conquer method, where S is a diagonal matrix
          !! with non-negative diagonal elements (the singular values of B), and
          !! U and VT are orthogonal matrices of left and right singular vectors,
          !! respectively. BDSDC can be used to compute all singular values,
          !! and optionally, singular vectors or singular vectors in compact form.
          !! This code makes very mild assumptions about floating point
          !! arithmetic. It will work on machines with a guard digit in
          !! add/subtract, or on those binary machines without guard digits
          !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
          !! It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.  See DLASD3 for details.
          !! The code currently calls DLASDQ if singular values only are desired.
          !! However, it can be slightly modified to compute singular values
          !! using the divide and conquer method.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dbdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,work, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq,uplo
                    integer(ilp), intent(out) :: info,iq(*),iwork(*)
                    integer(ilp), intent(in) :: ldu,ldvt,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: q(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine dbdsdc
#else
               module procedure stdlib_dbdsdc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sbdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,work, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq,uplo
                    integer(ilp), intent(out) :: info,iq(*),iwork(*)
                    integer(ilp), intent(in) :: ldu,ldvt,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: q(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine sbdsdc
#else
               module procedure stdlib_sbdsdc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dbdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,work, iwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq,uplo
                    integer(ilp64), intent(out) :: info,iq(*),iwork(*)
                    integer(ilp64), intent(in) :: ldu,ldvt,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: q(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine dbdsdc
#else
               module procedure stdlib_I64_dbdsdc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sbdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,work, iwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq,uplo
                    integer(ilp64), intent(out) :: info,iq(*),iwork(*)
                    integer(ilp64), intent(in) :: ldu,ldvt,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: q(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine sbdsdc
#else
               module procedure stdlib_I64_sbdsdc
#endif
          end interface bdsdc

          interface bdsqr
          !! BDSQR computes the singular values and, optionally, the right and/or
          !! left singular vectors from the singular value decomposition (SVD) of
          !! a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
          !! zero-shift QR algorithm.  The SVD of B has the form
          !! B = Q * S * P**H
          !! where S is the diagonal matrix of singular values, Q is an orthogonal
          !! matrix of left singular vectors, and P is an orthogonal matrix of
          !! right singular vectors.  If left singular vectors are requested, this
          !! subroutine actually returns U*Q instead of Q, and, if right singular
          !! vectors are requested, this subroutine returns P**H*VT instead of
          !! P**H, for given complex input matrices U and VT.  When U and VT are
          !! the unitary matrices that reduce a general matrix A to bidiagonal
          !! form: A = U*B*VT, as computed by CGEBRD, then
          !! A = (U*Q) * S * (P**H*VT)
          !! is the SVD of A.  Optionally, the subroutine may also compute Q**H*C
          !! for a given complex input matrix C.
          !! See "Computing  Small Singular Values of Bidiagonal Matrices With
          !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
          !! LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
          !! no. 5, pp. 873-912, Sept 1990) and
          !! "Accurate singular values and differential qd algorithms," by
          !! B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
          !! Department, University of California at Berkeley, July 1992
          !! for a detailed description of the algorithm.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: c(ldc,*),u(ldu,*),vt(ldvt,*)
               end subroutine cbdsqr
#else
               module procedure stdlib_cbdsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, &
                         work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru
                    real(dp), intent(inout) :: c(ldc,*),d(*),e(*),u(ldu,*),vt(ldvt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dbdsqr
#else
               module procedure stdlib_dbdsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, &
                         work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru
                    real(sp), intent(inout) :: c(ldc,*),d(*),e(*),u(ldu,*),vt(ldvt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sbdsqr
#else
               module procedure stdlib_sbdsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: c(ldc,*),u(ldu,*),vt(ldvt,*)
               end subroutine zbdsqr
#else
               module procedure stdlib_zbdsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, &
                         rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: c(ldc,*),u(ldu,*),vt(ldvt,*)
               end subroutine cbdsqr
#else
               module procedure stdlib_I64_cbdsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, &
                         work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru
                    real(dp), intent(inout) :: c(ldc,*),d(*),e(*),u(ldu,*),vt(ldvt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dbdsqr
#else
               module procedure stdlib_I64_dbdsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, &
                         work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru
                    real(sp), intent(inout) :: c(ldc,*),d(*),e(*),u(ldu,*),vt(ldvt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sbdsqr
#else
               module procedure stdlib_I64_sbdsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, &
                         rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: c(ldc,*),u(ldu,*),vt(ldvt,*)
               end subroutine zbdsqr
#else
               module procedure stdlib_I64_zbdsqr
#endif
          end interface bdsqr

          interface disna
          !! DISNA computes the reciprocal condition numbers for the eigenvectors
          !! of a real symmetric or complex Hermitian matrix or for the left or
          !! right singular vectors of a general m-by-n matrix. The reciprocal
          !! condition number is the 'gap' between the corresponding eigenvalue or
          !! singular value and the nearest other one.
          !! The bound on the error, measured by angle in radians, in the I-th
          !! computed vector is given by
          !! DLAMCH( 'E' ) * ( ANORM / SEP( I ) )
          !! where ANORM = 2-norm(A) = max( abs( D(j) ) ).  SEP(I) is not allowed
          !! to be smaller than DLAMCH( 'E' )*ANORM in order to limit the size of
          !! the error bound.
          !! DISNA may also be used to compute error bounds for eigenvectors of
          !! the generalized symmetric definite eigenproblem.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ddisna( job, m, n, d, sep, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: m,n
                    real(dp), intent(in) :: d(*)
                    real(dp), intent(out) :: sep(*)
               end subroutine ddisna
#else
               module procedure stdlib_ddisna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sdisna( job, m, n, d, sep, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: m,n
                    real(sp), intent(in) :: d(*)
                    real(sp), intent(out) :: sep(*)
               end subroutine sdisna
#else
               module procedure stdlib_sdisna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ddisna( job, m, n, d, sep, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: m,n
                    real(dp), intent(in) :: d(*)
                    real(dp), intent(out) :: sep(*)
               end subroutine ddisna
#else
               module procedure stdlib_I64_ddisna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sdisna( job, m, n, d, sep, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: m,n
                    real(sp), intent(in) :: d(*)
                    real(sp), intent(out) :: sep(*)
               end subroutine sdisna
#else
               module procedure stdlib_I64_sdisna
#endif
          end interface disna

          interface gbbrd
          !! GBBRD reduces a complex general m-by-n band matrix A to real upper
          !! bidiagonal form B by a unitary transformation: Q**H * A * P = B.
          !! The routine computes B, and optionally forms Q or P**H, or computes
          !! Q**H*C for a given matrix C.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, &
                         c, ldc, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldc,ldpt,ldq,m,n,ncc
                    real(sp), intent(out) :: d(*),e(*),rwork(*)
                    complex(sp), intent(inout) :: ab(ldab,*),c(ldc,*)
                    complex(sp), intent(out) :: pt(ldpt,*),q(ldq,*),work(*)
               end subroutine cgbbrd
#else
               module procedure stdlib_cgbbrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, &
                         c, ldc, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldc,ldpt,ldq,m,n,ncc
                    real(dp), intent(inout) :: ab(ldab,*),c(ldc,*)
                    real(dp), intent(out) :: d(*),e(*),pt(ldpt,*),q(ldq,*),work(*)
               end subroutine dgbbrd
#else
               module procedure stdlib_dgbbrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, &
                         c, ldc, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldc,ldpt,ldq,m,n,ncc
                    real(sp), intent(inout) :: ab(ldab,*),c(ldc,*)
                    real(sp), intent(out) :: d(*),e(*),pt(ldpt,*),q(ldq,*),work(*)
               end subroutine sgbbrd
#else
               module procedure stdlib_sgbbrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, &
                         c, ldc, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldc,ldpt,ldq,m,n,ncc
                    real(dp), intent(out) :: d(*),e(*),rwork(*)
                    complex(dp), intent(inout) :: ab(ldab,*),c(ldc,*)
                    complex(dp), intent(out) :: pt(ldpt,*),q(ldq,*),work(*)
               end subroutine zgbbrd
#else
               module procedure stdlib_zgbbrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, &
                         c, ldc, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,ldc,ldpt,ldq,m,n,ncc
                    real(sp), intent(out) :: d(*),e(*),rwork(*)
                    complex(sp), intent(inout) :: ab(ldab,*),c(ldc,*)
                    complex(sp), intent(out) :: pt(ldpt,*),q(ldq,*),work(*)
               end subroutine cgbbrd
#else
               module procedure stdlib_I64_cgbbrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, &
                         c, ldc, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,ldc,ldpt,ldq,m,n,ncc
                    real(dp), intent(inout) :: ab(ldab,*),c(ldc,*)
                    real(dp), intent(out) :: d(*),e(*),pt(ldpt,*),q(ldq,*),work(*)
               end subroutine dgbbrd
#else
               module procedure stdlib_I64_dgbbrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, &
                         c, ldc, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,ldc,ldpt,ldq,m,n,ncc
                    real(sp), intent(inout) :: ab(ldab,*),c(ldc,*)
                    real(sp), intent(out) :: d(*),e(*),pt(ldpt,*),q(ldq,*),work(*)
               end subroutine sgbbrd
#else
               module procedure stdlib_I64_sgbbrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, &
                         c, ldc, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,ldc,ldpt,ldq,m,n,ncc
                    real(dp), intent(out) :: d(*),e(*),rwork(*)
                    complex(dp), intent(inout) :: ab(ldab,*),c(ldc,*)
                    complex(dp), intent(out) :: pt(ldpt,*),q(ldq,*),work(*)
               end subroutine zgbbrd
#else
               module procedure stdlib_I64_zgbbrd
#endif
          end interface gbbrd

          interface gbcon
          !! GBCON estimates the reciprocal of the condition number of a complex
          !! general band matrix A, in either the 1-norm or the infinity-norm,
          !! using the LU factorization computed by CGBTRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as
          !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,work, rwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgbcon
#else
               module procedure stdlib_cgbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,work, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,n,ipiv(*)
                    real(dp), intent(in) :: anorm,ab(ldab,*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dgbcon
#else
               module procedure stdlib_dgbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,work, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,n,ipiv(*)
                    real(sp), intent(in) :: anorm,ab(ldab,*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine sgbcon
#else
               module procedure stdlib_sgbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,work, rwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgbcon
#else
               module procedure stdlib_zgbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,work, rwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgbcon
#else
               module procedure stdlib_I64_cgbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,work, iwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: kl,ku,ldab,n,ipiv(*)
                    real(dp), intent(in) :: anorm,ab(ldab,*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dgbcon
#else
               module procedure stdlib_I64_dgbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,work, iwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: kl,ku,ldab,n,ipiv(*)
                    real(sp), intent(in) :: anorm,ab(ldab,*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine sgbcon
#else
               module procedure stdlib_I64_sgbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,work, rwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgbcon
#else
               module procedure stdlib_I64_zgbcon
#endif
          end interface gbcon

          interface gbequ
          !! GBEQU computes row and column scalings intended to equilibrate an
          !! M-by-N band matrix A and reduce its condition number.  R returns the
          !! row scale factors and C the column scale factors, chosen to try to
          !! make the largest element in each row and column of the matrix B with
          !! elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
          !! R(i) and C(j) are restricted to be between SMLNUM = smallest safe
          !! number and BIGNUM = largest safe number.  Use of these scaling
          !! factors is not guaranteed to reduce the condition number of A but
          !! works well in practice.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end subroutine cgbequ
#else
               module procedure stdlib_cgbequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(in) :: ab(ldab,*)
               end subroutine dgbequ
#else
               module procedure stdlib_dgbequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(in) :: ab(ldab,*)
               end subroutine sgbequ
#else
               module procedure stdlib_sgbequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end subroutine zgbequ
#else
               module procedure stdlib_zgbequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end subroutine cgbequ
#else
               module procedure stdlib_I64_cgbequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(in) :: ab(ldab,*)
               end subroutine dgbequ
#else
               module procedure stdlib_I64_dgbequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(in) :: ab(ldab,*)
               end subroutine sgbequ
#else
               module procedure stdlib_I64_sgbequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end subroutine zgbequ
#else
               module procedure stdlib_I64_zgbequ
#endif
          end interface gbequ

          interface gbequb
          !! GBEQUB computes row and column scalings intended to equilibrate an
          !! M-by-N matrix A and reduce its condition number.  R returns the row
          !! scale factors and C the column scale factors, chosen to try to make
          !! the largest element in each row and column of the matrix B with
          !! elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
          !! the radix.
          !! R(i) and C(j) are restricted to be a power of the radix between
          !! SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use
          !! of these scaling factors is not guaranteed to reduce the condition
          !! number of A but works well in practice.
          !! This routine differs from CGEEQU by restricting the scaling factors
          !! to a power of the radix.  Barring over- and underflow, scaling by
          !! these factors introduces no additional rounding errors.  However, the
          !! scaled entries' magnitudes are no longer approximately 1 but lie
          !! between sqrt(radix) and 1/sqrt(radix).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end subroutine cgbequb
#else
               module procedure stdlib_cgbequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(in) :: ab(ldab,*)
               end subroutine dgbequb
#else
               module procedure stdlib_dgbequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(in) :: ab(ldab,*)
               end subroutine sgbequb
#else
               module procedure stdlib_sgbequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end subroutine zgbequb
#else
               module procedure stdlib_zgbequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end subroutine cgbequb
#else
               module procedure stdlib_I64_cgbequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(in) :: ab(ldab,*)
               end subroutine dgbequb
#else
               module procedure stdlib_I64_dgbequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(in) :: ab(ldab,*)
               end subroutine sgbequb
#else
               module procedure stdlib_I64_sgbequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end subroutine zgbequb
#else
               module procedure stdlib_I64_zgbequb
#endif
          end interface gbequb

          interface gbrfs
          !! GBRFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is banded, and provides
          !! error bounds and backward error estimates for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, rwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldafb,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cgbrfs
#else
               module procedure stdlib_cgbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,ldafb,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dgbrfs
#else
               module procedure stdlib_dgbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,ldafb,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine sgbrfs
#else
               module procedure stdlib_sgbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, rwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldafb,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zgbrfs
#else
               module procedure stdlib_zgbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, rwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,ldafb,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cgbrfs
#else
               module procedure stdlib_I64_cgbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: kl,ku,ldab,ldafb,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dgbrfs
#else
               module procedure stdlib_I64_dgbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: kl,ku,ldab,ldafb,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine sgbrfs
#else
               module procedure stdlib_I64_sgbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, rwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,ldafb,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zgbrfs
#else
               module procedure stdlib_I64_zgbrfs
#endif
          end interface gbrfs

          interface gbsv
          !! GBSV computes the solution to a complex system of linear equations
          !! A * X = B, where A is a band matrix of order N with KL subdiagonals
          !! and KU superdiagonals, and X and B are N-by-NRHS matrices.
          !! The LU decomposition with partial pivoting and row interchanges is
          !! used to factor A as A = L * U, where L is a product of permutation
          !! and unit lower triangular matrices with KL subdiagonals, and U is
          !! upper triangular with KL+KU superdiagonals.  The factored form of A
          !! is then used to solve the system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,ldb,n,nrhs
                    complex(sp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine cgbsv
#else
               module procedure stdlib_cgbsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,ldb,n,nrhs
                    real(dp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine dgbsv
#else
               module procedure stdlib_dgbsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,ldb,n,nrhs
                    real(sp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine sgbsv
#else
               module procedure stdlib_sgbsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,ldb,n,nrhs
                    complex(dp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine zgbsv
#else
               module procedure stdlib_zgbsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: kl,ku,ldab,ldb,n,nrhs
                    complex(sp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine cgbsv
#else
               module procedure stdlib_I64_cgbsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: kl,ku,ldab,ldb,n,nrhs
                    real(dp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine dgbsv
#else
               module procedure stdlib_I64_dgbsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: kl,ku,ldab,ldb,n,nrhs
                    real(sp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine sgbsv
#else
               module procedure stdlib_I64_sgbsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: kl,ku,ldab,ldb,n,nrhs
                    complex(dp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine zgbsv
#else
               module procedure stdlib_I64_zgbsv
#endif
          end interface gbsv

          interface gbtrf
          !! GBTRF computes an LU factorization of a complex m-by-n band matrix A
          !! using partial pivoting with row interchanges.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine cgbtrf
#else
               module procedure stdlib_cgbtrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dgbtrf
#else
               module procedure stdlib_dgbtrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine sgbtrf
#else
               module procedure stdlib_sgbtrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zgbtrf
#else
               module procedure stdlib_zgbtrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: kl,ku,ldab,m,n
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine cgbtrf
#else
               module procedure stdlib_I64_cgbtrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dgbtrf
#else
               module procedure stdlib_I64_dgbtrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine sgbtrf
#else
               module procedure stdlib_I64_sgbtrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: kl,ku,ldab,m,n
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zgbtrf
#else
               module procedure stdlib_I64_zgbtrf
#endif
          end interface gbtrf

          interface gbtrs
          !! GBTRS solves a system of linear equations
          !! A * X = B,  A**T * X = B,  or  A**H * X = B
          !! with a general band matrix A using the LU factorization computed
          !! by CGBTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cgbtrs
#else
               module procedure stdlib_cgbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dgbtrs
#else
               module procedure stdlib_dgbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine sgbtrs
#else
               module procedure stdlib_sgbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zgbtrs
#else
               module procedure stdlib_zgbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cgbtrs
#else
               module procedure stdlib_I64_cgbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dgbtrs
#else
               module procedure stdlib_I64_dgbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine sgbtrs
#else
               module procedure stdlib_I64_sgbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,ldab,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zgbtrs
#else
               module procedure stdlib_I64_zgbtrs
#endif
          end interface gbtrs

          interface gebak
          !! GEBAK forms the right or left eigenvectors of a complex general
          !! matrix by backward transformation on the computed eigenvectors of the
          !! balanced matrix output by CGEBAL.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job,side
                    integer(ilp), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: scale(*)
                    complex(sp), intent(inout) :: v(ldv,*)
               end subroutine cgebak
#else
               module procedure stdlib_cgebak
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job,side
                    integer(ilp), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: scale(*)
                    real(dp), intent(inout) :: v(ldv,*)
               end subroutine dgebak
#else
               module procedure stdlib_dgebak
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job,side
                    integer(ilp), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(inout) :: v(ldv,*)
                    real(sp), intent(in) :: scale(*)
               end subroutine sgebak
#else
               module procedure stdlib_sgebak
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job,side
                    integer(ilp), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: scale(*)
                    complex(dp), intent(inout) :: v(ldv,*)
               end subroutine zgebak
#else
               module procedure stdlib_zgebak
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job,side
                    integer(ilp64), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(in) :: scale(*)
                    complex(sp), intent(inout) :: v(ldv,*)
               end subroutine cgebak
#else
               module procedure stdlib_I64_cgebak
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job,side
                    integer(ilp64), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(in) :: scale(*)
                    real(dp), intent(inout) :: v(ldv,*)
               end subroutine dgebak
#else
               module procedure stdlib_I64_dgebak
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job,side
                    integer(ilp64), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(inout) :: v(ldv,*)
                    real(sp), intent(in) :: scale(*)
               end subroutine sgebak
#else
               module procedure stdlib_I64_sgebak
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job,side
                    integer(ilp64), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(in) :: scale(*)
                    complex(dp), intent(inout) :: v(ldv,*)
               end subroutine zgebak
#else
               module procedure stdlib_I64_zgebak
#endif
          end interface gebak

          interface gebal
          !! GEBAL balances a general complex matrix A.  This involves, first,
          !! permuting A by a similarity transformation to isolate eigenvalues
          !! in the first 1 to ILO-1 and last IHI+1 to N elements on the
          !! diagonal; and second, applying a diagonal similarity transformation
          !! to rows and columns ILO to IHI to make the rows and columns as
          !! close in norm as possible.  Both steps are optional.
          !! Balancing may reduce the 1-norm of the matrix, and improve the
          !! accuracy of the computed eigenvalues and/or eigenvectors.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgebal( job, n, a, lda, ilo, ihi, scale, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: ihi,ilo,info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: scale(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cgebal
#else
               module procedure stdlib_cgebal
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgebal( job, n, a, lda, ilo, ihi, scale, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: ihi,ilo,info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: scale(*)
               end subroutine dgebal
#else
               module procedure stdlib_dgebal
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgebal( job, n, a, lda, ilo, ihi, scale, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: ihi,ilo,info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: scale(*)
               end subroutine sgebal
#else
               module procedure stdlib_sgebal
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgebal( job, n, a, lda, ilo, ihi, scale, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: ihi,ilo,info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: scale(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zgebal
#else
               module procedure stdlib_zgebal
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgebal( job, n, a, lda, ilo, ihi, scale, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp64), intent(out) :: ihi,ilo,info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(out) :: scale(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cgebal
#else
               module procedure stdlib_I64_cgebal
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgebal( job, n, a, lda, ilo, ihi, scale, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp64), intent(out) :: ihi,ilo,info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: scale(*)
               end subroutine dgebal
#else
               module procedure stdlib_I64_dgebal
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgebal( job, n, a, lda, ilo, ihi, scale, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp64), intent(out) :: ihi,ilo,info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: scale(*)
               end subroutine sgebal
#else
               module procedure stdlib_I64_sgebal
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgebal( job, n, a, lda, ilo, ihi, scale, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp64), intent(out) :: ihi,ilo,info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(out) :: scale(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zgebal
#else
               module procedure stdlib_I64_zgebal
#endif
          end interface gebal

          interface gebrd
          !! GEBRD reduces a general complex M-by-N matrix A to upper or lower
          !! bidiagonal form B by a unitary transformation: Q**H * A * P = B.
          !! If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: taup(*),tauq(*),work(*)
               end subroutine cgebrd
#else
               module procedure stdlib_cgebrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*),e(*),taup(*),tauq(*),work(*)
               end subroutine dgebrd
#else
               module procedure stdlib_dgebrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*),e(*),taup(*),tauq(*),work(*)
               end subroutine sgebrd
#else
               module procedure stdlib_sgebrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: taup(*),tauq(*),work(*)
               end subroutine zgebrd
#else
               module procedure stdlib_zgebrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: taup(*),tauq(*),work(*)
               end subroutine cgebrd
#else
               module procedure stdlib_I64_cgebrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*),e(*),taup(*),tauq(*),work(*)
               end subroutine dgebrd
#else
               module procedure stdlib_I64_dgebrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*),e(*),taup(*),tauq(*),work(*)
               end subroutine sgebrd
#else
               module procedure stdlib_I64_sgebrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: taup(*),tauq(*),work(*)
               end subroutine zgebrd
#else
               module procedure stdlib_I64_zgebrd
#endif
          end interface gebrd

          interface gecon
          !! GECON estimates the reciprocal of the condition number of a general
          !! complex matrix A, in either the 1-norm or the infinity-norm, using
          !! the LU factorization computed by CGETRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as
          !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgecon( norm, n, a, lda, anorm, rcond, work, rwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgecon
#else
               module procedure stdlib_cgecon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgecon( norm, n, a, lda, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,work(*)
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dgecon
#else
               module procedure stdlib_dgecon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgecon( norm, n, a, lda, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,work(*)
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine sgecon
#else
               module procedure stdlib_sgecon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgecon( norm, n, a, lda, anorm, rcond, work, rwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgecon
#else
               module procedure stdlib_zgecon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgecon( norm, n, a, lda, anorm, rcond, work, rwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgecon
#else
               module procedure stdlib_I64_cgecon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgecon( norm, n, a, lda, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,work(*)
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dgecon
#else
               module procedure stdlib_I64_dgecon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgecon( norm, n, a, lda, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,work(*)
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine sgecon
#else
               module procedure stdlib_I64_sgecon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgecon( norm, n, a, lda, anorm, rcond, work, rwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgecon
#else
               module procedure stdlib_I64_zgecon
#endif
          end interface gecon

          interface geequ
          !! GEEQU computes row and column scalings intended to equilibrate an
          !! M-by-N matrix A and reduce its condition number.  R returns the row
          !! scale factors and C the column scale factors, chosen to try to make
          !! the largest element in each row and column of the matrix B with
          !! elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
          !! R(i) and C(j) are restricted to be between SMLNUM = smallest safe
          !! number and BIGNUM = largest safe number.  Use of these scaling
          !! factors is not guaranteed to reduce the condition number of A but
          !! works well in practice.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(in) :: a(lda,*)
               end subroutine cgeequ
#else
               module procedure stdlib_cgeequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dgeequ
#else
               module procedure stdlib_dgeequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(in) :: a(lda,*)
               end subroutine sgeequ
#else
               module procedure stdlib_sgeequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(in) :: a(lda,*)
               end subroutine zgeequ
#else
               module procedure stdlib_zgeequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(in) :: a(lda,*)
               end subroutine cgeequ
#else
               module procedure stdlib_I64_cgeequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dgeequ
#else
               module procedure stdlib_I64_dgeequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(in) :: a(lda,*)
               end subroutine sgeequ
#else
               module procedure stdlib_I64_sgeequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(in) :: a(lda,*)
               end subroutine zgeequ
#else
               module procedure stdlib_I64_zgeequ
#endif
          end interface geequ

          interface geequb
          !! GEEQUB computes row and column scalings intended to equilibrate an
          !! M-by-N matrix A and reduce its condition number.  R returns the row
          !! scale factors and C the column scale factors, chosen to try to make
          !! the largest element in each row and column of the matrix B with
          !! elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
          !! the radix.
          !! R(i) and C(j) are restricted to be a power of the radix between
          !! SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use
          !! of these scaling factors is not guaranteed to reduce the condition
          !! number of A but works well in practice.
          !! This routine differs from CGEEQU by restricting the scaling factors
          !! to a power of the radix.  Barring over- and underflow, scaling by
          !! these factors introduces no additional rounding errors.  However, the
          !! scaled entries' magnitudes are no longer approximately 1 but lie
          !! between sqrt(radix) and 1/sqrt(radix).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(in) :: a(lda,*)
               end subroutine cgeequb
#else
               module procedure stdlib_cgeequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dgeequb
#else
               module procedure stdlib_dgeequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(in) :: a(lda,*)
               end subroutine sgeequb
#else
               module procedure stdlib_sgeequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(in) :: a(lda,*)
               end subroutine zgeequb
#else
               module procedure stdlib_zgeequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(in) :: a(lda,*)
               end subroutine cgeequb
#else
               module procedure stdlib_I64_cgeequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dgeequb
#else
               module procedure stdlib_I64_dgeequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(in) :: a(lda,*)
               end subroutine sgeequb
#else
               module procedure stdlib_I64_sgeequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(in) :: a(lda,*)
               end subroutine zgeequb
#else
               module procedure stdlib_I64_zgeequb
#endif
          end interface geequb

          interface gees
          !! GEES computes for an N-by-N complex nonsymmetric matrix A, the
          !! eigenvalues, the Schur form T, and, optionally, the matrix of Schur
          !! vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).
          !! Optionally, it also orders the eigenvalues on the diagonal of the
          !! Schur form so that selected eigenvalues are at the top left.
          !! The leading columns of Z then form an orthonormal basis for the
          !! invariant subspace corresponding to the selected eigenvalues.
          !! A complex matrix is in Schur form if it is upper triangular.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgees( jobvs, sort, select, n, a, lda, sdim, w, vs,ldvs, work, lwork, &
                         rwork, bwork, info )
                    import sp,dp,qp,ilp,lk,stdlib_select_c
                    implicit none
                    character, intent(in) :: jobvs,sort
                    integer(ilp), intent(out) :: info,sdim
                    integer(ilp), intent(in) :: lda,ldvs,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: vs(ldvs,*),w(*),work(*)
                    procedure(stdlib_select_c) :: select
               end subroutine cgees
#else
               module procedure stdlib_cgees
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgees( jobvs, sort, select, n, a, lda, sdim, wr, wi,vs, ldvs, work, &
                         lwork, bwork, info )
                    import sp,dp,qp,ilp,lk,stdlib_select_d
                    implicit none
                    character, intent(in) :: jobvs,sort
                    integer(ilp), intent(out) :: info,sdim
                    integer(ilp), intent(in) :: lda,ldvs,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: vs(ldvs,*),wi(*),work(*),wr(*)
                    procedure(stdlib_select_d) :: select
               end subroutine dgees
#else
               module procedure stdlib_dgees
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgees( jobvs, sort, select, n, a, lda, sdim, wr, wi,vs, ldvs, work, &
                         lwork, bwork, info )
                    import sp,dp,qp,ilp,lk,stdlib_select_s
                    implicit none
                    character, intent(in) :: jobvs,sort
                    integer(ilp), intent(out) :: info,sdim
                    integer(ilp), intent(in) :: lda,ldvs,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: vs(ldvs,*),wi(*),work(*),wr(*)
                    procedure(stdlib_select_s) :: select
               end subroutine sgees
#else
               module procedure stdlib_sgees
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgees( jobvs, sort, select, n, a, lda, sdim, w, vs,ldvs, work, lwork, &
                         rwork, bwork, info )
                    import sp,dp,qp,ilp,lk,stdlib_select_z
                    implicit none
                    character, intent(in) :: jobvs,sort
                    integer(ilp), intent(out) :: info,sdim
                    integer(ilp), intent(in) :: lda,ldvs,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: vs(ldvs,*),w(*),work(*)
                    procedure(stdlib_select_z) :: select
               end subroutine zgees
#else
               module procedure stdlib_zgees
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cgees( jobvs, sort, select, n, a, lda, sdim, w, vs,ldvs, work, lwork, &
                         rwork, bwork, info )
                    import sp,dp,qp,ilp64,lk,stdlib_select_c
                    implicit none
                    character, intent(in) :: jobvs,sort
                    integer(ilp64), intent(out) :: info,sdim
                    integer(ilp64), intent(in) :: lda,ldvs,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: vs(ldvs,*),w(*),work(*)
                    procedure(stdlib_select_c) :: select
               end subroutine cgees
#else
               module procedure stdlib_I64_cgees
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dgees( jobvs, sort, select, n, a, lda, sdim, wr, wi,vs, ldvs, work, &
                         lwork, bwork, info )
                    import sp,dp,qp,ilp64,lk,stdlib_select_d
                    implicit none
                    character, intent(in) :: jobvs,sort
                    integer(ilp64), intent(out) :: info,sdim
                    integer(ilp64), intent(in) :: lda,ldvs,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: vs(ldvs,*),wi(*),work(*),wr(*)
                    procedure(stdlib_select_d) :: select
               end subroutine dgees
#else
               module procedure stdlib_I64_dgees
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sgees( jobvs, sort, select, n, a, lda, sdim, wr, wi,vs, ldvs, work, &
                         lwork, bwork, info )
                    import sp,dp,qp,ilp64,lk,stdlib_select_s
                    implicit none
                    character, intent(in) :: jobvs,sort
                    integer(ilp64), intent(out) :: info,sdim
                    integer(ilp64), intent(in) :: lda,ldvs,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: vs(ldvs,*),wi(*),work(*),wr(*)
                    procedure(stdlib_select_s) :: select
               end subroutine sgees
#else
               module procedure stdlib_I64_sgees
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zgees( jobvs, sort, select, n, a, lda, sdim, w, vs,ldvs, work, lwork, &
                         rwork, bwork, info )
                    import sp,dp,qp,ilp64,lk,stdlib_select_z
                    implicit none
                    character, intent(in) :: jobvs,sort
                    integer(ilp64), intent(out) :: info,sdim
                    integer(ilp64), intent(in) :: lda,ldvs,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: vs(ldvs,*),w(*),work(*)
                    procedure(stdlib_select_z) :: select
               end subroutine zgees
#else
               module procedure stdlib_I64_zgees
#endif
          end interface gees

          interface geev
          !! GEEV computes for an N-by-N complex nonsymmetric matrix A, the
          !! eigenvalues and, optionally, the left and/or right eigenvectors.
          !! The right eigenvector v(j) of A satisfies
          !! A * v(j) = lambda(j) * v(j)
          !! where lambda(j) is its eigenvalue.
          !! The left eigenvector u(j) of A satisfies
          !! u(j)**H * A = lambda(j) * u(j)**H
          !! where u(j)**H denotes the conjugate transpose of u(j).
          !! The computed eigenvectors are normalized to have Euclidean norm
          !! equal to 1 and largest component real.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgeev( jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr,work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldvl,ldvr,lwork,n
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: vl(ldvl,*),vr(ldvr,*),w(*),work(*)
               end subroutine cgeev
#else
               module procedure stdlib_cgeev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgeev( jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr,ldvr, work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldvl,ldvr,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: vl(ldvl,*),vr(ldvr,*),wi(*),work(*),wr(*)
               end subroutine dgeev
#else
               module procedure stdlib_dgeev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgeev( jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr,ldvr, work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldvl,ldvr,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: vl(ldvl,*),vr(ldvr,*),wi(*),work(*),wr(*)
               end subroutine sgeev
#else
               module procedure stdlib_sgeev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgeev( jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr,work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldvl,ldvr,lwork,n
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: vl(ldvl,*),vr(ldvr,*),w(*),work(*)
               end subroutine zgeev
#else
               module procedure stdlib_zgeev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cgeev( jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr,work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldvl,ldvr,lwork,n
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: vl(ldvl,*),vr(ldvr,*),w(*),work(*)
               end subroutine cgeev
#else
               module procedure stdlib_I64_cgeev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dgeev( jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr,ldvr, work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldvl,ldvr,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: vl(ldvl,*),vr(ldvr,*),wi(*),work(*),wr(*)
               end subroutine dgeev
#else
               module procedure stdlib_I64_dgeev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sgeev( jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr,ldvr, work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldvl,ldvr,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: vl(ldvl,*),vr(ldvr,*),wi(*),work(*),wr(*)
               end subroutine sgeev
#else
               module procedure stdlib_I64_sgeev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zgeev( jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr,work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldvl,ldvr,lwork,n
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: vl(ldvl,*),vr(ldvr,*),w(*),work(*)
               end subroutine zgeev
#else
               module procedure stdlib_I64_zgeev
#endif
          end interface geev

          interface gehrd
          !! GEHRD reduces a complex general matrix A to upper Hessenberg form H by
          !! an unitary similarity transformation:  Q**H * A * Q = H .
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgehrd
#else
               module procedure stdlib_cgehrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgehrd
#else
               module procedure stdlib_dgehrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgehrd
#else
               module procedure stdlib_sgehrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgehrd
#else
               module procedure stdlib_zgehrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgehrd
#else
               module procedure stdlib_I64_cgehrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgehrd
#else
               module procedure stdlib_I64_dgehrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgehrd
#else
               module procedure stdlib_I64_sgehrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgehrd
#else
               module procedure stdlib_I64_zgehrd
#endif
          end interface gehrd

          interface gejsv
          !! GEJSV computes the singular value decomposition (SVD) of a complex M-by-N
          !! matrix [A], where M >= N. The SVD of [A] is written as
          !! [A] = [U] * [SIGMA] * [V]^*,
          !! where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
          !! diagonal elements, [U] is an M-by-N (or M-by-M) unitary matrix, and
          !! [V] is an N-by-N unitary matrix. The diagonal elements of [SIGMA] are
          !! the singular values of [A]. The columns of [U] and [V] are the left and
          !! the right singular vectors of [A], respectively. The matrices [U] and [V]
          !! are computed and stored in the arrays U and V, respectively. The diagonal
          !! of [SIGMA] is computed and stored in the array SVA.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, &
                         ldu, v, ldv,cwork, lwork, rwork, lrwork, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldu,ldv,lwork,lrwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: u(ldu,*),v(ldv,*),cwork(lwork)
                    real(sp), intent(out) :: sva(n),rwork(lrwork)
                    character, intent(in) :: joba,jobp,jobr,jobt,jobu,jobv
               end subroutine cgejsv
#else
               module procedure stdlib_cgejsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, &
                         ldu, v, ldv,work, lwork, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldu,ldv,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: sva(n),u(ldu,*),v(ldv,*),work(lwork)
                    character, intent(in) :: joba,jobp,jobr,jobt,jobu,jobv
               end subroutine dgejsv
#else
               module procedure stdlib_dgejsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, &
                         ldu, v, ldv,work, lwork, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldu,ldv,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: sva(n),u(ldu,*),v(ldv,*),work(lwork)
                    character, intent(in) :: joba,jobp,jobr,jobt,jobu,jobv
               end subroutine sgejsv
#else
               module procedure stdlib_sgejsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, &
                         ldu, v, ldv,cwork, lwork, rwork, lrwork, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldu,ldv,lwork,lrwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: u(ldu,*),v(ldv,*),cwork(lwork)
                    real(dp), intent(out) :: sva(n),rwork(lrwork)
                    character, intent(in) :: joba,jobp,jobr,jobt,jobu,jobv
               end subroutine zgejsv
#else
               module procedure stdlib_zgejsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, &
                         ldu, v, ldv,cwork, lwork, rwork, lrwork, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldu,ldv,lwork,lrwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: u(ldu,*),v(ldv,*),cwork(lwork)
                    real(sp), intent(out) :: sva(n),rwork(lrwork)
                    character, intent(in) :: joba,jobp,jobr,jobt,jobu,jobv
               end subroutine cgejsv
#else
               module procedure stdlib_I64_cgejsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, &
                         ldu, v, ldv,work, lwork, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldu,ldv,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: sva(n),u(ldu,*),v(ldv,*),work(lwork)
                    character, intent(in) :: joba,jobp,jobr,jobt,jobu,jobv
               end subroutine dgejsv
#else
               module procedure stdlib_I64_dgejsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, &
                         ldu, v, ldv,work, lwork, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldu,ldv,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: sva(n),u(ldu,*),v(ldv,*),work(lwork)
                    character, intent(in) :: joba,jobp,jobr,jobt,jobu,jobv
               end subroutine sgejsv
#else
               module procedure stdlib_I64_sgejsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, &
                         ldu, v, ldv,cwork, lwork, rwork, lrwork, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldu,ldv,lwork,lrwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: u(ldu,*),v(ldv,*),cwork(lwork)
                    real(dp), intent(out) :: sva(n),rwork(lrwork)
                    character, intent(in) :: joba,jobp,jobr,jobt,jobu,jobv
               end subroutine zgejsv
#else
               module procedure stdlib_I64_zgejsv
#endif
          end interface gejsv

          interface gelq
          !! GELQ computes an LQ factorization of a complex M-by-N matrix A:
          !! A = ( L 0 ) *  Q
          !! where:
          !! Q is a N-by-N orthogonal matrix;
          !! L is a lower-triangular M-by-M matrix;
          !! 0 is a M-by-(N-M) zero matrix, if M < N.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgelq( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,tsize,lwork
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(*),work(*)
               end subroutine cgelq
#else
               module procedure stdlib_cgelq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgelq( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,tsize,lwork
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(*),work(*)
               end subroutine dgelq
#else
               module procedure stdlib_dgelq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgelq( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,tsize,lwork
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(*),work(*)
               end subroutine sgelq
#else
               module procedure stdlib_sgelq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgelq( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,tsize,lwork
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(*),work(*)
               end subroutine zgelq
#else
               module procedure stdlib_zgelq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgelq( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,tsize,lwork
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(*),work(*)
               end subroutine cgelq
#else
               module procedure stdlib_I64_cgelq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgelq( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,tsize,lwork
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(*),work(*)
               end subroutine dgelq
#else
               module procedure stdlib_I64_dgelq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgelq( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,tsize,lwork
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(*),work(*)
               end subroutine sgelq
#else
               module procedure stdlib_I64_sgelq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgelq( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,tsize,lwork
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(*),work(*)
               end subroutine zgelq
#else
               module procedure stdlib_I64_zgelq
#endif
          end interface gelq

          interface gelqf
          !! GELQF computes an LQ factorization of a complex M-by-N matrix A:
          !! A = ( L 0 ) *  Q
          !! where:
          !! Q is a N-by-N orthogonal matrix;
          !! L is a lower-triangular M-by-M matrix;
          !! 0 is a M-by-(N-M) zero matrix, if M < N.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgelqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgelqf
#else
               module procedure stdlib_cgelqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgelqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgelqf
#else
               module procedure stdlib_dgelqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgelqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgelqf
#else
               module procedure stdlib_sgelqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgelqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgelqf
#else
               module procedure stdlib_zgelqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgelqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgelqf
#else
               module procedure stdlib_I64_cgelqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgelqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgelqf
#else
               module procedure stdlib_I64_dgelqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgelqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgelqf
#else
               module procedure stdlib_I64_sgelqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgelqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgelqf
#else
               module procedure stdlib_I64_zgelqf
#endif
          end interface gelqf

          interface gelqt
          !! GELQT computes a blocked LQ factorization of a complex M-by-N matrix A
          !! using the compact WY representation of Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgelqt( m, n, mb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,mb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine cgelqt
#else
               module procedure stdlib_cgelqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgelqt( m, n, mb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,mb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine dgelqt
#else
               module procedure stdlib_dgelqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgelqt( m, n, mb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,mb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine sgelqt
#else
               module procedure stdlib_sgelqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgelqt( m, n, mb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,mb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine zgelqt
#else
               module procedure stdlib_zgelqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgelqt( m, n, mb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,m,n,mb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine cgelqt
#else
               module procedure stdlib_I64_cgelqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgelqt( m, n, mb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,m,n,mb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine dgelqt
#else
               module procedure stdlib_I64_dgelqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgelqt( m, n, mb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,m,n,mb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine sgelqt
#else
               module procedure stdlib_I64_sgelqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgelqt( m, n, mb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,m,n,mb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine zgelqt
#else
               module procedure stdlib_I64_zgelqt
#endif
          end interface gelqt

          interface gelqt3
          !! GELQT3 recursively computes a LQ factorization of a complex M-by-N
          !! matrix A, using the compact WY representation of Q.
          !! Based on the algorithm of Elmroth and Gustavson,
          !! IBM J. Res. Develop. Vol 44 No. 4 July 2000.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine cgelqt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,ldt
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*)
               end subroutine cgelqt3
#else
               module procedure stdlib_cgelqt3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine dgelqt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,ldt
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*)
               end subroutine dgelqt3
#else
               module procedure stdlib_dgelqt3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine sgelqt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,ldt
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*)
               end subroutine sgelqt3
#else
               module procedure stdlib_sgelqt3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine zgelqt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,ldt
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*)
               end subroutine zgelqt3
#else
               module procedure stdlib_zgelqt3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine cgelqt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,ldt
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*)
               end subroutine cgelqt3
#else
               module procedure stdlib_I64_cgelqt3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine dgelqt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,ldt
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*)
               end subroutine dgelqt3
#else
               module procedure stdlib_I64_dgelqt3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine sgelqt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,ldt
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*)
               end subroutine sgelqt3
#else
               module procedure stdlib_I64_sgelqt3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine zgelqt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,ldt
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*)
               end subroutine zgelqt3
#else
               module procedure stdlib_I64_zgelqt3
#endif
          end interface gelqt3

          interface gels
          !! GELS solves overdetermined or underdetermined complex linear systems
          !! involving an M-by-N matrix A, or its conjugate-transpose, using a QR
          !! or LQ factorization of A.  It is assumed that A has full rank.
          !! The following options are provided:
          !! 1. If TRANS = 'N' and m >= n:  find the least squares solution of
          !! an overdetermined system, i.e., solve the least squares problem
          !! minimize || B - A*X ||.
          !! 2. If TRANS = 'N' and m < n:  find the minimum norm solution of
          !! an underdetermined system A * X = B.
          !! 3. If TRANS = 'C' and m >= n:  find the minimum norm solution of
          !! an underdetermined system A**H * X = B.
          !! 4. If TRANS = 'C' and m < n:  find the least squares solution of
          !! an overdetermined system, i.e., solve the least squares problem
          !! minimize || B - A**H * X ||.
          !! Several right hand side vectors b and solution vectors x can be
          !! handled in a single call; they are stored as the columns of the
          !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution
          !! matrix X.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgels
#else
               module procedure stdlib_cgels
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgels
#else
               module procedure stdlib_dgels
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgels
#else
               module procedure stdlib_sgels
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgels
#else
               module procedure stdlib_zgels
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgels
#else
               module procedure stdlib_I64_cgels
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgels
#else
               module procedure stdlib_I64_dgels
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgels
#else
               module procedure stdlib_I64_sgels
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgels
#else
               module procedure stdlib_I64_zgels
#endif
          end interface gels

          interface gelsd
          !! GELSD computes the minimum-norm solution to a real linear least
          !! squares problem:
          !! minimize 2-norm(| b - A*x |)
          !! using the singular value decomposition (SVD) of A. A is an M-by-N
          !! matrix which may be rank-deficient.
          !! Several right hand side vectors b and solution vectors x can be
          !! handled in a single call; they are stored as the columns of the
          !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution
          !! matrix X.
          !! The problem is solved in three steps:
          !! (1) Reduce the coefficient matrix A to bidiagonal form with
          !! Householder transformations, reducing the original problem
          !! into a "bidiagonal least squares problem" (BLS)
          !! (2) Solve the BLS using a divide and conquer approach.
          !! (3) Apply back all the Householder transformations to solve
          !! the original least squares problem.
          !! The effective rank of A is determined by treating as zero those
          !! singular values which are less than RCOND times the largest singular
          !! value.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
                         iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,rank,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    real(sp), intent(out) :: rwork(*),s(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgelsd
#else
               module procedure stdlib_cgelsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,rank,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: s(*),work(*)
               end subroutine dgelsd
#else
               module procedure stdlib_dgelsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond,rank, work, lwork, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,rank,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: s(*),work(*)
               end subroutine sgelsd
#else
               module procedure stdlib_sgelsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
                         iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,rank,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    real(dp), intent(out) :: rwork(*),s(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgelsd
#else
               module procedure stdlib_zgelsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
                         iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,rank,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    real(sp), intent(out) :: rwork(*),s(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgelsd
#else
               module procedure stdlib_I64_cgelsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, iwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,rank,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: s(*),work(*)
               end subroutine dgelsd
#else
               module procedure stdlib_I64_dgelsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond,rank, work, lwork, iwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,rank,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: s(*),work(*)
               end subroutine sgelsd
#else
               module procedure stdlib_I64_sgelsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
                         iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,rank,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    real(dp), intent(out) :: rwork(*),s(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgelsd
#else
               module procedure stdlib_I64_zgelsd
#endif
          end interface gelsd

          interface gelss
          !! GELSS computes the minimum norm solution to a complex linear
          !! least squares problem:
          !! Minimize 2-norm(| b - A*x |).
          !! using the singular value decomposition (SVD) of A. A is an M-by-N
          !! matrix which may be rank-deficient.
          !! Several right hand side vectors b and solution vectors x can be
          !! handled in a single call; they are stored as the columns of the
          !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
          !! X.
          !! The effective rank of A is determined by treating as zero those
          !! singular values which are less than RCOND times the largest singular
          !! value.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,rank
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    real(sp), intent(out) :: rwork(*),s(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgelss
#else
               module procedure stdlib_cgelss
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,rank
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: s(*),work(*)
               end subroutine dgelss
#else
               module procedure stdlib_dgelss
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,rank
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: s(*),work(*)
               end subroutine sgelss
#else
               module procedure stdlib_sgelss
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,rank
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    real(dp), intent(out) :: rwork(*),s(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgelss
#else
               module procedure stdlib_zgelss
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,rank
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    real(sp), intent(out) :: rwork(*),s(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgelss
#else
               module procedure stdlib_I64_cgelss
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,rank
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: s(*),work(*)
               end subroutine dgelss
#else
               module procedure stdlib_I64_dgelss
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,rank
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: s(*),work(*)
               end subroutine sgelss
#else
               module procedure stdlib_I64_sgelss
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,rank
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    real(dp), intent(out) :: rwork(*),s(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgelss
#else
               module procedure stdlib_I64_zgelss
#endif
          end interface gelss

          interface gelsy
          !! GELSY computes the minimum-norm solution to a complex linear least
          !! squares problem:
          !! minimize || A * X - B ||
          !! using a complete orthogonal factorization of A.  A is an M-by-N
          !! matrix which may be rank-deficient.
          !! Several right hand side vectors b and solution vectors x can be
          !! handled in a single call; they are stored as the columns of the
          !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution
          !! matrix X.
          !! The routine first computes a QR factorization with column pivoting:
          !! A * P = Q * [ R11 R12 ]
          !! [  0  R22 ]
          !! with R11 defined as the largest leading submatrix whose estimated
          !! condition number is less than 1/RCOND.  The order of R11, RANK,
          !! is the effective rank of A.
          !! Then, R22 is considered to be negligible, and R12 is annihilated
          !! by unitary transformations from the right, arriving at the
          !! complete orthogonal factorization:
          !! A * P = Q * [ T11 0 ] * Z
          !! [  0  0 ]
          !! The minimum-norm solution is then
          !! X = P * Z**H [ inv(T11)*Q1**H*B ]
          !! [        0         ]
          !! where Q1 consists of the first RANK columns of Q.
          !! This routine is basically identical to the original xGELSX except
          !! three differences:
          !! o The permutation of matrix B (the right hand side) is faster and
          !! more simple.
          !! o The call to the subroutine xGEQPF has been substituted by the
          !! the call to the subroutine xGEQP3. This subroutine is a Blas-3
          !! version of the QR factorization with column pivoting.
          !! o Matrix B (the right hand side) is updated with Blas-3.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,rank
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    integer(ilp), intent(inout) :: jpvt(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgelsy
#else
               module procedure stdlib_cgelsy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,rank
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    integer(ilp), intent(inout) :: jpvt(*)
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgelsy
#else
               module procedure stdlib_dgelsy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,rank
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    integer(ilp), intent(inout) :: jpvt(*)
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgelsy
#else
               module procedure stdlib_sgelsy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,rank
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    integer(ilp), intent(inout) :: jpvt(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgelsy
#else
               module procedure stdlib_zgelsy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,rank
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    integer(ilp64), intent(inout) :: jpvt(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgelsy
#else
               module procedure stdlib_I64_cgelsy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,rank
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    integer(ilp64), intent(inout) :: jpvt(*)
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgelsy
#else
               module procedure stdlib_I64_dgelsy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,rank
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    integer(ilp64), intent(inout) :: jpvt(*)
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgelsy
#else
               module procedure stdlib_I64_sgelsy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,rank
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    integer(ilp64), intent(inout) :: jpvt(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgelsy
#else
               module procedure stdlib_I64_zgelsy
#endif
          end interface gelsy

          interface gemlq
          !! GEMLQ overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product
          !! of blocked elementary reflectors computed by short wide
          !! LQ factorization (CGELQ)
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgemlq( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    complex(sp), intent(in) :: a(lda,*),t(*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgemlq
#else
               module procedure stdlib_cgemlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgemlq( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    real(dp), intent(in) :: a(lda,*),t(*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgemlq
#else
               module procedure stdlib_dgemlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgemlq( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    real(sp), intent(in) :: a(lda,*),t(*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgemlq
#else
               module procedure stdlib_sgemlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgemlq( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    complex(dp), intent(in) :: a(lda,*),t(*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgemlq
#else
               module procedure stdlib_zgemlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgemlq( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    complex(sp), intent(in) :: a(lda,*),t(*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgemlq
#else
               module procedure stdlib_I64_cgemlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgemlq( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    real(dp), intent(in) :: a(lda,*),t(*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgemlq
#else
               module procedure stdlib_I64_dgemlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgemlq( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    real(sp), intent(in) :: a(lda,*),t(*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgemlq
#else
               module procedure stdlib_I64_sgemlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgemlq( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    complex(dp), intent(in) :: a(lda,*),t(*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgemlq
#else
               module procedure stdlib_I64_zgemlq
#endif
          end interface gemlq

          interface gemlqt
          !! GEMLQT overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q C            C Q
          !! TRANS = 'C':   Q**H C            C Q**H
          !! where Q is a complex unitary matrix defined as the product of K
          !! elementary reflectors:
          !! Q = H(1) H(2) . . . H(K) = I - V T V**H
          !! generated using the compact WY representation as returned by CGELQT.
          !! Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgemlqt( side, trans, m, n, k, mb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,ldc,m,n,mb,ldt
                    complex(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgemlqt
#else
               module procedure stdlib_cgemlqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgemlqt( side, trans, m, n, k, mb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,ldc,m,n,mb,ldt
                    real(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgemlqt
#else
               module procedure stdlib_dgemlqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgemlqt( side, trans, m, n, k, mb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,ldc,m,n,mb,ldt
                    real(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgemlqt
#else
               module procedure stdlib_sgemlqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgemlqt( side, trans, m, n, k, mb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,ldc,m,n,mb,ldt
                    complex(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgemlqt
#else
               module procedure stdlib_zgemlqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgemlqt( side, trans, m, n, k, mb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,ldv,ldc,m,n,mb,ldt
                    complex(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgemlqt
#else
               module procedure stdlib_I64_cgemlqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgemlqt( side, trans, m, n, k, mb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,ldv,ldc,m,n,mb,ldt
                    real(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgemlqt
#else
               module procedure stdlib_I64_dgemlqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgemlqt( side, trans, m, n, k, mb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,ldv,ldc,m,n,mb,ldt
                    real(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgemlqt
#else
               module procedure stdlib_I64_sgemlqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgemlqt( side, trans, m, n, k, mb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,ldv,ldc,m,n,mb,ldt
                    complex(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgemlqt
#else
               module procedure stdlib_I64_zgemlqt
#endif
          end interface gemlqt

          interface gemqr
          !! GEMQR overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product
          !! of blocked elementary reflectors computed by tall skinny
          !! QR factorization (CGEQR)
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgemqr( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    complex(sp), intent(in) :: a(lda,*),t(*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgemqr
#else
               module procedure stdlib_cgemqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgemqr( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    real(dp), intent(in) :: a(lda,*),t(*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgemqr
#else
               module procedure stdlib_dgemqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgemqr( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    real(sp), intent(in) :: a(lda,*),t(*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgemqr
#else
               module procedure stdlib_sgemqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgemqr( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    complex(dp), intent(in) :: a(lda,*),t(*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgemqr
#else
               module procedure stdlib_zgemqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgemqr( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    complex(sp), intent(in) :: a(lda,*),t(*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgemqr
#else
               module procedure stdlib_I64_cgemqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgemqr( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    real(dp), intent(in) :: a(lda,*),t(*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgemqr
#else
               module procedure stdlib_I64_dgemqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgemqr( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    real(sp), intent(in) :: a(lda,*),t(*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgemqr
#else
               module procedure stdlib_I64_sgemqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgemqr( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    complex(dp), intent(in) :: a(lda,*),t(*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgemqr
#else
               module procedure stdlib_I64_zgemqr
#endif
          end interface gemqr

          interface gemqrt
          !! GEMQRT overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q C            C Q
          !! TRANS = 'C':    Q**H C            C Q**H
          !! where Q is a complex orthogonal matrix defined as the product of K
          !! elementary reflectors:
          !! Q = H(1) H(2) . . . H(K) = I - V T V**H
          !! generated using the compact WY representation as returned by CGEQRT.
          !! Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,ldc,m,n,nb,ldt
                    complex(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgemqrt
#else
               module procedure stdlib_cgemqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,ldc,m,n,nb,ldt
                    real(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgemqrt
#else
               module procedure stdlib_dgemqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,ldc,m,n,nb,ldt
                    real(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgemqrt
#else
               module procedure stdlib_sgemqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,ldc,m,n,nb,ldt
                    complex(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgemqrt
#else
               module procedure stdlib_zgemqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,ldv,ldc,m,n,nb,ldt
                    complex(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgemqrt
#else
               module procedure stdlib_I64_cgemqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,ldv,ldc,m,n,nb,ldt
                    real(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgemqrt
#else
               module procedure stdlib_I64_dgemqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,ldv,ldc,m,n,nb,ldt
                    real(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgemqrt
#else
               module procedure stdlib_I64_sgemqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,ldv,ldc,m,n,nb,ldt
                    complex(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgemqrt
#else
               module procedure stdlib_I64_zgemqrt
#endif
          end interface gemqrt

          interface geqlf
          !! GEQLF computes a QL factorization of a complex M-by-N matrix A:
          !! A = Q * L.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgeqlf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgeqlf
#else
               module procedure stdlib_cgeqlf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgeqlf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgeqlf
#else
               module procedure stdlib_dgeqlf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgeqlf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgeqlf
#else
               module procedure stdlib_sgeqlf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgeqlf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgeqlf
#else
               module procedure stdlib_zgeqlf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgeqlf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgeqlf
#else
               module procedure stdlib_I64_cgeqlf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgeqlf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgeqlf
#else
               module procedure stdlib_I64_dgeqlf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgeqlf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgeqlf
#else
               module procedure stdlib_I64_sgeqlf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgeqlf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgeqlf
#else
               module procedure stdlib_I64_zgeqlf
#endif
          end interface geqlf

          interface geqr
          !! GEQR computes a QR factorization of a complex M-by-N matrix A:
          !! A = Q * ( R ),
          !! ( 0 )
          !! where:
          !! Q is a M-by-M orthogonal matrix;
          !! R is an upper-triangular N-by-N matrix;
          !! 0 is a (M-N)-by-N zero matrix, if M > N.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgeqr( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,tsize,lwork
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(*),work(*)
               end subroutine cgeqr
#else
               module procedure stdlib_cgeqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgeqr( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,tsize,lwork
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(*),work(*)
               end subroutine dgeqr
#else
               module procedure stdlib_dgeqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgeqr( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,tsize,lwork
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(*),work(*)
               end subroutine sgeqr
#else
               module procedure stdlib_sgeqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgeqr( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,tsize,lwork
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(*),work(*)
               end subroutine zgeqr
#else
               module procedure stdlib_zgeqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgeqr( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,tsize,lwork
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(*),work(*)
               end subroutine cgeqr
#else
               module procedure stdlib_I64_cgeqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgeqr( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,tsize,lwork
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(*),work(*)
               end subroutine dgeqr
#else
               module procedure stdlib_I64_dgeqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgeqr( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,tsize,lwork
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(*),work(*)
               end subroutine sgeqr
#else
               module procedure stdlib_I64_sgeqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgeqr( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,tsize,lwork
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(*),work(*)
               end subroutine zgeqr
#else
               module procedure stdlib_I64_zgeqr
#endif
          end interface geqr

          interface geqr2p
          !! GEQR2P computes a QR factorization of a complex m-by-n matrix A:
          !! A = Q * ( R ),
          !! ( 0 )
          !! where:
          !! Q is a m-by-m orthogonal matrix;
          !! R is an upper-triangular n-by-n matrix with nonnegative diagonal
          !! entries;
          !! 0 is a (m-n)-by-n zero matrix, if m > n.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgeqr2p( m, n, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgeqr2p
#else
               module procedure stdlib_cgeqr2p
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgeqr2p( m, n, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgeqr2p
#else
               module procedure stdlib_dgeqr2p
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgeqr2p( m, n, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgeqr2p
#else
               module procedure stdlib_sgeqr2p
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgeqr2p( m, n, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgeqr2p
#else
               module procedure stdlib_zgeqr2p
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cgeqr2p( m, n, a, lda, tau, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgeqr2p
#else
               module procedure stdlib_I64_cgeqr2p
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dgeqr2p( m, n, a, lda, tau, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgeqr2p
#else
               module procedure stdlib_I64_dgeqr2p
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sgeqr2p( m, n, a, lda, tau, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgeqr2p
#else
               module procedure stdlib_I64_sgeqr2p
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zgeqr2p( m, n, a, lda, tau, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgeqr2p
#else
               module procedure stdlib_I64_zgeqr2p
#endif
          end interface geqr2p

          interface geqrf
          !! GEQRF computes a QR factorization of a complex M-by-N matrix A:
          !! A = Q * ( R ),
          !! ( 0 )
          !! where:
          !! Q is a M-by-M orthogonal matrix;
          !! R is an upper-triangular N-by-N matrix;
          !! 0 is a (M-N)-by-N zero matrix, if M > N.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgeqrf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgeqrf
#else
               module procedure stdlib_cgeqrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgeqrf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgeqrf
#else
               module procedure stdlib_dgeqrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgeqrf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgeqrf
#else
               module procedure stdlib_sgeqrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgeqrf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgeqrf
#else
               module procedure stdlib_zgeqrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgeqrf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgeqrf
#else
               module procedure stdlib_I64_cgeqrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgeqrf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgeqrf
#else
               module procedure stdlib_I64_dgeqrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgeqrf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgeqrf
#else
               module procedure stdlib_I64_sgeqrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgeqrf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgeqrf
#else
               module procedure stdlib_I64_zgeqrf
#endif
          end interface geqrf

          interface geqrfp
          !! CGEQR2P computes a QR factorization of a complex M-by-N matrix A:
          !! A = Q * ( R ),
          !! ( 0 )
          !! where:
          !! Q is a M-by-M orthogonal matrix;
          !! R is an upper-triangular N-by-N matrix with nonnegative diagonal
          !! entries;
          !! 0 is a (M-N)-by-N zero matrix, if M > N.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgeqrfp( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgeqrfp
#else
               module procedure stdlib_cgeqrfp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgeqrfp( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgeqrfp
#else
               module procedure stdlib_dgeqrfp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgeqrfp( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgeqrfp
#else
               module procedure stdlib_sgeqrfp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgeqrfp( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgeqrfp
#else
               module procedure stdlib_zgeqrfp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cgeqrfp( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgeqrfp
#else
               module procedure stdlib_I64_cgeqrfp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dgeqrfp( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgeqrfp
#else
               module procedure stdlib_I64_dgeqrfp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sgeqrfp( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgeqrfp
#else
               module procedure stdlib_I64_sgeqrfp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zgeqrfp( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgeqrfp
#else
               module procedure stdlib_I64_zgeqrfp
#endif
          end interface geqrfp

          interface geqrt
          !! GEQRT computes a blocked QR factorization of a complex M-by-N matrix A
          !! using the compact WY representation of Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgeqrt( m, n, nb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine cgeqrt
#else
               module procedure stdlib_cgeqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgeqrt( m, n, nb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine dgeqrt
#else
               module procedure stdlib_dgeqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgeqrt( m, n, nb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine sgeqrt
#else
               module procedure stdlib_sgeqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgeqrt( m, n, nb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine zgeqrt
#else
               module procedure stdlib_zgeqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgeqrt( m, n, nb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,m,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine cgeqrt
#else
               module procedure stdlib_I64_cgeqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgeqrt( m, n, nb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,m,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine dgeqrt
#else
               module procedure stdlib_I64_dgeqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgeqrt( m, n, nb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,m,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine sgeqrt
#else
               module procedure stdlib_I64_sgeqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgeqrt( m, n, nb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,m,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine zgeqrt
#else
               module procedure stdlib_I64_zgeqrt
#endif
          end interface geqrt

          interface geqrt2
          !! GEQRT2 computes a QR factorization of a complex M-by-N matrix A,
          !! using the compact WY representation of Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgeqrt2( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*)
               end subroutine cgeqrt2
#else
               module procedure stdlib_cgeqrt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgeqrt2( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*)
               end subroutine dgeqrt2
#else
               module procedure stdlib_dgeqrt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgeqrt2( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*)
               end subroutine sgeqrt2
#else
               module procedure stdlib_sgeqrt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgeqrt2( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*)
               end subroutine zgeqrt2
#else
               module procedure stdlib_zgeqrt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgeqrt2( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*)
               end subroutine cgeqrt2
#else
               module procedure stdlib_I64_cgeqrt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgeqrt2( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*)
               end subroutine dgeqrt2
#else
               module procedure stdlib_I64_dgeqrt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgeqrt2( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*)
               end subroutine sgeqrt2
#else
               module procedure stdlib_I64_sgeqrt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgeqrt2( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*)
               end subroutine zgeqrt2
#else
               module procedure stdlib_I64_zgeqrt2
#endif
          end interface geqrt2

          interface geqrt3
          !! GEQRT3 recursively computes a QR factorization of a complex M-by-N matrix A,
          !! using the compact WY representation of Q.
          !! Based on the algorithm of Elmroth and Gustavson,
          !! IBM J. Res. Develop. Vol 44 No. 4 July 2000.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine cgeqrt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,ldt
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*)
               end subroutine cgeqrt3
#else
               module procedure stdlib_cgeqrt3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine dgeqrt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,ldt
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*)
               end subroutine dgeqrt3
#else
               module procedure stdlib_dgeqrt3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine sgeqrt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,ldt
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*)
               end subroutine sgeqrt3
#else
               module procedure stdlib_sgeqrt3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine zgeqrt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,ldt
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*)
               end subroutine zgeqrt3
#else
               module procedure stdlib_zgeqrt3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine cgeqrt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,ldt
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*)
               end subroutine cgeqrt3
#else
               module procedure stdlib_I64_cgeqrt3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine dgeqrt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,ldt
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*)
               end subroutine dgeqrt3
#else
               module procedure stdlib_I64_dgeqrt3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine sgeqrt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,ldt
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*)
               end subroutine sgeqrt3
#else
               module procedure stdlib_I64_sgeqrt3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine zgeqrt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,ldt
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*)
               end subroutine zgeqrt3
#else
               module procedure stdlib_I64_zgeqrt3
#endif
          end interface geqrt3

          interface gerfs
          !! GERFS improves the computed solution to a system of linear
          !! equations and provides error bounds and backward error estimates for
          !! the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cgerfs
#else
               module procedure stdlib_cgerfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dgerfs
#else
               module procedure stdlib_dgerfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine sgerfs
#else
               module procedure stdlib_sgerfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zgerfs
#else
               module procedure stdlib_zgerfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cgerfs
#else
               module procedure stdlib_I64_cgerfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dgerfs
#else
               module procedure stdlib_I64_dgerfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine sgerfs
#else
               module procedure stdlib_I64_sgerfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zgerfs
#else
               module procedure stdlib_I64_zgerfs
#endif
          end interface gerfs

          interface gerqf
          !! GERQF computes an RQ factorization of a complex M-by-N matrix A:
          !! A = R * Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgerqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgerqf
#else
               module procedure stdlib_cgerqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgerqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgerqf
#else
               module procedure stdlib_dgerqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgerqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgerqf
#else
               module procedure stdlib_sgerqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgerqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgerqf
#else
               module procedure stdlib_zgerqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgerqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgerqf
#else
               module procedure stdlib_I64_cgerqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgerqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgerqf
#else
               module procedure stdlib_I64_dgerqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgerqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgerqf
#else
               module procedure stdlib_I64_sgerqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgerqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgerqf
#else
               module procedure stdlib_I64_zgerqf
#endif
          end interface gerqf

          interface gesdd
          !! GESDD computes the singular value decomposition (SVD) of a complex
          !! M-by-N matrix A, optionally computing the left and/or right singular
          !! vectors, by using divide-and-conquer method. The SVD is written
          !! A = U * SIGMA * conjugate-transpose(V)
          !! where SIGMA is an M-by-N matrix which is zero except for its
          !! min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
          !! V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
          !! are the singular values of A; they are real and non-negative, and
          !! are returned in descending order.  The first min(m,n) columns of
          !! U and V are the left and right singular vectors of A.
          !! Note that the routine returns VT = V**H, not V.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, rwork, &
                         iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(sp), intent(out) :: rwork(*),s(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine cgesdd
#else
               module procedure stdlib_cgesdd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: s(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine dgesdd
#else
               module procedure stdlib_dgesdd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: s(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine sgesdd
#else
               module procedure stdlib_sgesdd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, rwork, &
                         iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(dp), intent(out) :: rwork(*),s(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine zgesdd
#else
               module procedure stdlib_zgesdd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, rwork, &
                         iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(sp), intent(out) :: rwork(*),s(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine cgesdd
#else
               module procedure stdlib_I64_cgesdd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, iwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: s(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine dgesdd
#else
               module procedure stdlib_I64_dgesdd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, iwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: s(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine sgesdd
#else
               module procedure stdlib_I64_sgesdd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, rwork, &
                         iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(dp), intent(out) :: rwork(*),s(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine zgesdd
#else
               module procedure stdlib_I64_zgesdd
#endif
          end interface gesdd

          interface gesv
          !! GESV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
          !! The LU decomposition with partial pivoting and row interchanges is
          !! used to factor A as
          !! A = P * L * U,
          !! where P is a permutation matrix, L is unit lower triangular, and U is
          !! upper triangular.  The factored form of A is then used to solve the
          !! system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine cgesv
#else
               module procedure stdlib_cgesv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine dgesv
#else
               module procedure stdlib_dgesv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine sgesv
#else
               module procedure stdlib_sgesv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine zgesv
#else
               module procedure stdlib_zgesv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine cgesv
#else
               module procedure stdlib_I64_cgesv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine dgesv
#else
               module procedure stdlib_I64_dgesv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine sgesv
#else
               module procedure stdlib_I64_sgesv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine zgesv
#else
               module procedure stdlib_I64_zgesv
#endif
          end interface gesv

          interface gesvd
          !! GESVD computes the singular value decomposition (SVD) of a complex
          !! M-by-N matrix A, optionally computing the left and/or right singular
          !! vectors. The SVD is written
          !! A = U * SIGMA * conjugate-transpose(V)
          !! where SIGMA is an M-by-N matrix which is zero except for its
          !! min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
          !! V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
          !! are the singular values of A; they are real and non-negative, and
          !! are returned in descending order.  The first min(m,n) columns of
          !! U and V are the left and right singular vectors of A.
          !! Note that the routine returns V**H, not V.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobu,jobvt
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(sp), intent(out) :: rwork(*),s(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine cgesvd
#else
               module procedure stdlib_cgesvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,vt, ldvt, work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobu,jobvt
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: s(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine dgesvd
#else
               module procedure stdlib_dgesvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobu,jobvt
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: s(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine sgesvd
#else
               module procedure stdlib_sgesvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,vt, ldvt, work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobu,jobvt
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(dp), intent(out) :: rwork(*),s(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine zgesvd
#else
               module procedure stdlib_zgesvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobu,jobvt
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(sp), intent(out) :: rwork(*),s(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine cgesvd
#else
               module procedure stdlib_I64_cgesvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,vt, ldvt, work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobu,jobvt
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: s(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine dgesvd
#else
               module procedure stdlib_I64_dgesvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobu,jobvt
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: s(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine sgesvd
#else
               module procedure stdlib_I64_sgesvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,vt, ldvt, work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobu,jobvt
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(dp), intent(out) :: rwork(*),s(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine zgesvd
#else
               module procedure stdlib_I64_zgesvd
#endif
          end interface gesvd

          interface gesvdq
          !! GESVDQ computes the singular value decomposition (SVD) of a complex
          !! M-by-N matrix A, where M >= N. The SVD of A is written as
          !! [++]   [xx]   [x0]   [xx]
          !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
          !! [++]   [xx]
          !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
          !! matrix, and V is an N-by-N unitary matrix. The diagonal elements
          !! of SIGMA are the singular values of A. The columns of U and V are the
          !! left and the right singular vectors of A, respectively.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
                         numrank, iwork, liwork,cwork, lcwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: joba,jobp,jobr,jobu,jobv
                    integer(ilp), intent(in) :: m,n,lda,ldu,ldv,liwork,lrwork
                    integer(ilp), intent(out) :: numrank,info,iwork(*)
                    integer(ilp), intent(inout) :: lcwork
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: u(ldu,*),v(ldv,*),cwork(*)
                    real(sp), intent(out) :: s(*),rwork(*)
               end subroutine cgesvdq
#else
               module procedure stdlib_cgesvdq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
                         numrank, iwork, liwork,work, lwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: joba,jobp,jobr,jobu,jobv
                    integer(ilp), intent(in) :: m,n,lda,ldu,ldv,liwork,lrwork
                    integer(ilp), intent(out) :: numrank,info,iwork(*)
                    integer(ilp), intent(inout) :: lwork
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: u(ldu,*),v(ldv,*),work(*),s(*),rwork(*)
               end subroutine dgesvdq
#else
               module procedure stdlib_dgesvdq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
                         numrank, iwork, liwork,work, lwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: joba,jobp,jobr,jobu,jobv
                    integer(ilp), intent(in) :: m,n,lda,ldu,ldv,liwork,lrwork
                    integer(ilp), intent(out) :: numrank,info,iwork(*)
                    integer(ilp), intent(inout) :: lwork
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: u(ldu,*),v(ldv,*),work(*),s(*),rwork(*)
               end subroutine sgesvdq
#else
               module procedure stdlib_sgesvdq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
                         numrank, iwork, liwork,cwork, lcwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: joba,jobp,jobr,jobu,jobv
                    integer(ilp), intent(in) :: m,n,lda,ldu,ldv,liwork,lrwork
                    integer(ilp), intent(out) :: numrank,info,iwork(*)
                    integer(ilp), intent(inout) :: lcwork
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: u(ldu,*),v(ldv,*),cwork(*)
                    real(dp), intent(out) :: s(*),rwork(*)
               end subroutine zgesvdq
#else
               module procedure stdlib_zgesvdq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
                         numrank, iwork, liwork,cwork, lcwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: joba,jobp,jobr,jobu,jobv
                    integer(ilp64), intent(in) :: m,n,lda,ldu,ldv,liwork,lrwork
                    integer(ilp64), intent(out) :: numrank,info,iwork(*)
                    integer(ilp64), intent(inout) :: lcwork
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: u(ldu,*),v(ldv,*),cwork(*)
                    real(sp), intent(out) :: s(*),rwork(*)
               end subroutine cgesvdq
#else
               module procedure stdlib_I64_cgesvdq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
                         numrank, iwork, liwork,work, lwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: joba,jobp,jobr,jobu,jobv
                    integer(ilp64), intent(in) :: m,n,lda,ldu,ldv,liwork,lrwork
                    integer(ilp64), intent(out) :: numrank,info,iwork(*)
                    integer(ilp64), intent(inout) :: lwork
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: u(ldu,*),v(ldv,*),work(*),s(*),rwork(*)
               end subroutine dgesvdq
#else
               module procedure stdlib_I64_dgesvdq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
                         numrank, iwork, liwork,work, lwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: joba,jobp,jobr,jobu,jobv
                    integer(ilp64), intent(in) :: m,n,lda,ldu,ldv,liwork,lrwork
                    integer(ilp64), intent(out) :: numrank,info,iwork(*)
                    integer(ilp64), intent(inout) :: lwork
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: u(ldu,*),v(ldv,*),work(*),s(*),rwork(*)
               end subroutine sgesvdq
#else
               module procedure stdlib_I64_sgesvdq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
                         numrank, iwork, liwork,cwork, lcwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: joba,jobp,jobr,jobu,jobv
                    integer(ilp64), intent(in) :: m,n,lda,ldu,ldv,liwork,lrwork
                    integer(ilp64), intent(out) :: numrank,info,iwork(*)
                    integer(ilp64), intent(inout) :: lcwork
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: u(ldu,*),v(ldv,*),cwork(*)
                    real(dp), intent(out) :: s(*),rwork(*)
               end subroutine zgesvdq
#else
               module procedure stdlib_I64_zgesvdq
#endif
          end interface gesvdq

          interface gesvj
          !! GESVJ computes the singular value decomposition (SVD) of a complex
          !! M-by-N matrix A, where M >= N. The SVD of A is written as
          !! [++]   [xx]   [x0]   [xx]
          !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
          !! [++]   [xx]
          !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
          !! matrix, and V is an N-by-N unitary matrix. The diagonal elements
          !! of SIGMA are the singular values of A. The columns of U and V are the
          !! left and the right singular vectors of A, respectively.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, cwork, &
                         lwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,lrwork,m,mv,n
                    character, intent(in) :: joba,jobu,jobv
                    complex(sp), intent(inout) :: a(lda,*),v(ldv,*),cwork(lwork)
                    real(sp), intent(inout) :: rwork(lrwork)
                    real(sp), intent(out) :: sva(n)
               end subroutine cgesvj
#else
               module procedure stdlib_cgesvj
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n
                    character, intent(in) :: joba,jobu,jobv
                    real(dp), intent(inout) :: a(lda,*),v(ldv,*),work(lwork)
                    real(dp), intent(out) :: sva(n)
               end subroutine dgesvj
#else
               module procedure stdlib_dgesvj
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n
                    character, intent(in) :: joba,jobu,jobv
                    real(sp), intent(inout) :: a(lda,*),v(ldv,*),work(lwork)
                    real(sp), intent(out) :: sva(n)
               end subroutine sgesvj
#else
               module procedure stdlib_sgesvj
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, cwork, &
                         lwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,lrwork,m,mv,n
                    character, intent(in) :: joba,jobu,jobv
                    complex(dp), intent(inout) :: a(lda,*),v(ldv,*),cwork(lwork)
                    real(dp), intent(inout) :: rwork(lrwork)
                    real(dp), intent(out) :: sva(n)
               end subroutine zgesvj
#else
               module procedure stdlib_zgesvj
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, cwork, &
                         lwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldv,lwork,lrwork,m,mv,n
                    character, intent(in) :: joba,jobu,jobv
                    complex(sp), intent(inout) :: a(lda,*),v(ldv,*),cwork(lwork)
                    real(sp), intent(inout) :: rwork(lrwork)
                    real(sp), intent(out) :: sva(n)
               end subroutine cgesvj
#else
               module procedure stdlib_I64_cgesvj
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldv,lwork,m,mv,n
                    character, intent(in) :: joba,jobu,jobv
                    real(dp), intent(inout) :: a(lda,*),v(ldv,*),work(lwork)
                    real(dp), intent(out) :: sva(n)
               end subroutine dgesvj
#else
               module procedure stdlib_I64_dgesvj
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldv,lwork,m,mv,n
                    character, intent(in) :: joba,jobu,jobv
                    real(sp), intent(inout) :: a(lda,*),v(ldv,*),work(lwork)
                    real(sp), intent(out) :: sva(n)
               end subroutine sgesvj
#else
               module procedure stdlib_I64_sgesvj
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, cwork, &
                         lwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldv,lwork,lrwork,m,mv,n
                    character, intent(in) :: joba,jobu,jobv
                    complex(dp), intent(inout) :: a(lda,*),v(ldv,*),cwork(lwork)
                    real(dp), intent(inout) :: rwork(lrwork)
                    real(dp), intent(out) :: sva(n)
               end subroutine zgesvj
#else
               module procedure stdlib_I64_zgesvj
#endif
          end interface gesvj

          interface getrf
          !! GETRF computes an LU factorization of a general M-by-N matrix A
          !! using partial pivoting with row interchanges.
          !! The factorization has the form
          !! A = P * L * U
          !! where P is a permutation matrix, L is lower triangular with unit
          !! diagonal elements (lower trapezoidal if m > n), and U is upper
          !! triangular (upper trapezoidal if m < n).
          !! This is the right-looking Level 3 BLAS version of the algorithm.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgetrf( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cgetrf
#else
               module procedure stdlib_cgetrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgetrf( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dgetrf
#else
               module procedure stdlib_dgetrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgetrf( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine sgetrf
#else
               module procedure stdlib_sgetrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgetrf( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zgetrf
#else
               module procedure stdlib_zgetrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgetrf( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cgetrf
#else
               module procedure stdlib_I64_cgetrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgetrf( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dgetrf
#else
               module procedure stdlib_I64_dgetrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgetrf( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine sgetrf
#else
               module procedure stdlib_I64_sgetrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgetrf( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zgetrf
#else
               module procedure stdlib_I64_zgetrf
#endif
          end interface getrf

          interface getrf2
          !! GETRF2 computes an LU factorization of a general M-by-N matrix A
          !! using partial pivoting with row interchanges.
          !! The factorization has the form
          !! A = P * L * U
          !! where P is a permutation matrix, L is lower triangular with unit
          !! diagonal elements (lower trapezoidal if m > n), and U is upper
          !! triangular (upper trapezoidal if m < n).
          !! This is the recursive version of the algorithm. It divides
          !! the matrix into four submatrices:
          !! [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2
          !! A = [ -----|----- ]  with n1 = min(m,n)/2
          !! [  A21 | A22  ]       n2 = n-n1
          !! [ A11 ]
          !! The subroutine calls itself to factor [ --- ],
          !! [ A12 ]
          !! [ A12 ]
          !! do the swaps on [ --- ], solve A12, update A22,
          !! [ A22 ]
          !! then calls itself to factor A22 and do the swaps on A21.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine cgetrf2( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cgetrf2
#else
               module procedure stdlib_cgetrf2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine dgetrf2( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dgetrf2
#else
               module procedure stdlib_dgetrf2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine sgetrf2( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine sgetrf2
#else
               module procedure stdlib_sgetrf2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine zgetrf2( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zgetrf2
#else
               module procedure stdlib_zgetrf2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine cgetrf2( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cgetrf2
#else
               module procedure stdlib_I64_cgetrf2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine dgetrf2( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dgetrf2
#else
               module procedure stdlib_I64_dgetrf2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine sgetrf2( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine sgetrf2
#else
               module procedure stdlib_I64_sgetrf2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine zgetrf2( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zgetrf2
#else
               module procedure stdlib_I64_zgetrf2
#endif
          end interface getrf2

          interface getri
          !! GETRI computes the inverse of a matrix using the LU factorization
          !! computed by CGETRF.
          !! This method inverts U and then computes inv(A) by solving the system
          !! inv(A)*L = inv(U) for inv(A).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgetri( n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgetri
#else
               module procedure stdlib_cgetri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgetri( n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgetri
#else
               module procedure stdlib_dgetri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgetri( n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgetri
#else
               module procedure stdlib_sgetri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgetri( n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgetri
#else
               module procedure stdlib_zgetri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgetri( n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgetri
#else
               module procedure stdlib_I64_cgetri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgetri( n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgetri
#else
               module procedure stdlib_I64_dgetri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgetri( n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgetri
#else
               module procedure stdlib_I64_sgetri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgetri( n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgetri
#else
               module procedure stdlib_I64_zgetri
#endif
          end interface getri

          interface getrs
          !! GETRS solves a system of linear equations
          !! A * X = B,  A**T * X = B,  or  A**H * X = B
          !! with a general N-by-N matrix A using the LU factorization computed
          !! by CGETRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cgetrs
#else
               module procedure stdlib_cgetrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dgetrs
#else
               module procedure stdlib_dgetrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine sgetrs
#else
               module procedure stdlib_sgetrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zgetrs
#else
               module procedure stdlib_zgetrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cgetrs
#else
               module procedure stdlib_I64_cgetrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dgetrs
#else
               module procedure stdlib_I64_dgetrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine sgetrs
#else
               module procedure stdlib_I64_sgetrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zgetrs
#else
               module procedure stdlib_I64_zgetrs
#endif
          end interface getrs

          interface getsls
          !! GETSLS solves overdetermined or underdetermined complex linear systems
          !! involving an M-by-N matrix A, using a tall skinny QR or short wide LQ
          !! factorization of A.  It is assumed that A has full rank.
          !! The following options are provided:
          !! 1. If TRANS = 'N' and m >= n:  find the least squares solution of
          !! an overdetermined system, i.e., solve the least squares problem
          !! minimize || B - A*X ||.
          !! 2. If TRANS = 'N' and m < n:  find the minimum norm solution of
          !! an underdetermined system A * X = B.
          !! 3. If TRANS = 'C' and m >= n:  find the minimum norm solution of
          !! an undetermined system A**T * X = B.
          !! 4. If TRANS = 'C' and m < n:  find the least squares solution of
          !! an overdetermined system, i.e., solve the least squares problem
          !! minimize || B - A**T * X ||.
          !! Several right hand side vectors b and solution vectors x can be
          !! handled in a single call; they are stored as the columns of the
          !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution
          !! matrix X.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgetsls
#else
               module procedure stdlib_cgetsls
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgetsls
#else
               module procedure stdlib_dgetsls
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgetsls
#else
               module procedure stdlib_sgetsls
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgetsls
#else
               module procedure stdlib_zgetsls
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgetsls
#else
               module procedure stdlib_I64_cgetsls
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgetsls
#else
               module procedure stdlib_I64_dgetsls
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgetsls
#else
               module procedure stdlib_I64_sgetsls
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgetsls
#else
               module procedure stdlib_I64_zgetsls
#endif
          end interface getsls

          interface getsqrhrt
          !! GETSQRHRT computes a NB2-sized column blocked QR-factorization
          !! of a complex M-by-N matrix A with M >= N,
          !! A = Q * R.
          !! The routine uses internally a NB1-sized column blocked and MB1-sized
          !! row blocked TSQR-factorization and perfors the reconstruction
          !! of the Householder vectors from the TSQR output. The routine also
          !! converts the R_tsqr factor from the TSQR-factorization output into
          !! the R factor that corresponds to the Householder QR-factorization,
          !! A = Q_tsqr * R_tsqr = Q * R.
          !! The output Q and R factors are stored in the same format as in CGEQRT
          !! (Q is in blocked compact WY-representation). See the documentation
          !! of CGEQRT for more details on the format.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgetsqrhrt( m, n, mb1, nb1, nb2, a, lda, t, ldt, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,nb1,nb2,mb1
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine cgetsqrhrt
#else
               module procedure stdlib_cgetsqrhrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgetsqrhrt( m, n, mb1, nb1, nb2, a, lda, t, ldt, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,nb1,nb2,mb1
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine dgetsqrhrt
#else
               module procedure stdlib_dgetsqrhrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgetsqrhrt( m, n, mb1, nb1, nb2, a, lda, t, ldt, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,nb1,nb2,mb1
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine sgetsqrhrt
#else
               module procedure stdlib_sgetsqrhrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgetsqrhrt( m, n, mb1, nb1, nb2, a, lda, t, ldt, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,nb1,nb2,mb1
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine zgetsqrhrt
#else
               module procedure stdlib_zgetsqrhrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgetsqrhrt( m, n, mb1, nb1, nb2, a, lda, t, ldt, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,lwork,m,n,nb1,nb2,mb1
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine cgetsqrhrt
#else
               module procedure stdlib_I64_cgetsqrhrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgetsqrhrt( m, n, mb1, nb1, nb2, a, lda, t, ldt, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,lwork,m,n,nb1,nb2,mb1
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine dgetsqrhrt
#else
               module procedure stdlib_I64_dgetsqrhrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgetsqrhrt( m, n, mb1, nb1, nb2, a, lda, t, ldt, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,lwork,m,n,nb1,nb2,mb1
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine sgetsqrhrt
#else
               module procedure stdlib_I64_sgetsqrhrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgetsqrhrt( m, n, mb1, nb1, nb2, a, lda, t, ldt, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,lwork,m,n,nb1,nb2,mb1
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine zgetsqrhrt
#else
               module procedure stdlib_I64_zgetsqrhrt
#endif
          end interface getsqrhrt

          interface ggbak
          !! GGBAK forms the right or left eigenvectors of a complex generalized
          !! eigenvalue problem A*x = lambda*B*x, by backward transformation on
          !! the computed eigenvectors of the balanced pair of matrices output by
          !! CGGBAL.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job,side
                    integer(ilp), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: lscale(*),rscale(*)
                    complex(sp), intent(inout) :: v(ldv,*)
               end subroutine cggbak
#else
               module procedure stdlib_cggbak
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job,side
                    integer(ilp), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: lscale(*),rscale(*)
                    real(dp), intent(inout) :: v(ldv,*)
               end subroutine dggbak
#else
               module procedure stdlib_dggbak
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job,side
                    integer(ilp), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: lscale(*),rscale(*)
                    real(sp), intent(inout) :: v(ldv,*)
               end subroutine sggbak
#else
               module procedure stdlib_sggbak
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job,side
                    integer(ilp), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: lscale(*),rscale(*)
                    complex(dp), intent(inout) :: v(ldv,*)
               end subroutine zggbak
#else
               module procedure stdlib_zggbak
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job,side
                    integer(ilp64), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(in) :: lscale(*),rscale(*)
                    complex(sp), intent(inout) :: v(ldv,*)
               end subroutine cggbak
#else
               module procedure stdlib_I64_cggbak
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job,side
                    integer(ilp64), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(in) :: lscale(*),rscale(*)
                    real(dp), intent(inout) :: v(ldv,*)
               end subroutine dggbak
#else
               module procedure stdlib_I64_dggbak
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job,side
                    integer(ilp64), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(in) :: lscale(*),rscale(*)
                    real(sp), intent(inout) :: v(ldv,*)
               end subroutine sggbak
#else
               module procedure stdlib_I64_sggbak
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job,side
                    integer(ilp64), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(in) :: lscale(*),rscale(*)
                    complex(dp), intent(inout) :: v(ldv,*)
               end subroutine zggbak
#else
               module procedure stdlib_I64_zggbak
#endif
          end interface ggbak

          interface ggbal
          !! GGBAL balances a pair of general complex matrices (A,B).  This
          !! involves, first, permuting A and B by similarity transformations to
          !! isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
          !! elements on the diagonal; and second, applying a diagonal similarity
          !! transformation to rows and columns ILO to IHI to make the rows
          !! and columns as close in norm as possible. Both steps are optional.
          !! Balancing may reduce the 1-norm of the matrices, and improve the
          !! accuracy of the computed eigenvalues and/or eigenvectors in the
          !! generalized eigenvalue problem A*x = lambda*B*x.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: ihi,ilo,info
                    integer(ilp), intent(in) :: lda,ldb,n
                    real(sp), intent(out) :: lscale(*),rscale(*),work(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine cggbal
#else
               module procedure stdlib_cggbal
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: ihi,ilo,info
                    integer(ilp), intent(in) :: lda,ldb,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: lscale(*),rscale(*),work(*)
               end subroutine dggbal
#else
               module procedure stdlib_dggbal
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: ihi,ilo,info
                    integer(ilp), intent(in) :: lda,ldb,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: lscale(*),rscale(*),work(*)
               end subroutine sggbal
#else
               module procedure stdlib_sggbal
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: ihi,ilo,info
                    integer(ilp), intent(in) :: lda,ldb,n
                    real(dp), intent(out) :: lscale(*),rscale(*),work(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine zggbal
#else
               module procedure stdlib_zggbal
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp64), intent(out) :: ihi,ilo,info
                    integer(ilp64), intent(in) :: lda,ldb,n
                    real(sp), intent(out) :: lscale(*),rscale(*),work(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine cggbal
#else
               module procedure stdlib_I64_cggbal
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp64), intent(out) :: ihi,ilo,info
                    integer(ilp64), intent(in) :: lda,ldb,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: lscale(*),rscale(*),work(*)
               end subroutine dggbal
#else
               module procedure stdlib_I64_dggbal
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp64), intent(out) :: ihi,ilo,info
                    integer(ilp64), intent(in) :: lda,ldb,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: lscale(*),rscale(*),work(*)
               end subroutine sggbal
#else
               module procedure stdlib_I64_sggbal
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: job
                    integer(ilp64), intent(out) :: ihi,ilo,info
                    integer(ilp64), intent(in) :: lda,ldb,n
                    real(dp), intent(out) :: lscale(*),rscale(*),work(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine zggbal
#else
               module procedure stdlib_I64_zggbal
#endif
          end interface ggbal

          interface gges
          !! GGES computes for a pair of N-by-N complex nonsymmetric matrices
          !! (A,B), the generalized eigenvalues, the generalized complex Schur
          !! form (S, T), and optionally left and/or right Schur vectors (VSL
          !! and VSR). This gives the generalized Schur factorization
          !! (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )
          !! where (VSR)**H is the conjugate-transpose of VSR.
          !! Optionally, it also orders the eigenvalues so that a selected cluster
          !! of eigenvalues appears in the leading diagonal blocks of the upper
          !! triangular matrix S and the upper triangular matrix T. The leading
          !! columns of VSL and VSR then form an unitary basis for the
          !! corresponding left and right eigenspaces (deflating subspaces).
          !! (If only the generalized eigenvalues are needed, use the driver
          !! CGGEV instead, which is faster.)
          !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
          !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
          !! usually represented as the pair (alpha,beta), as there is a
          !! reasonable interpretation for beta=0, and even for both being zero.
          !! A pair of matrices (S,T) is in generalized complex Schur form if S
          !! and T are upper triangular and, in addition, the diagonal elements
          !! of T are non-negative real numbers.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alpha, &
                         beta, vsl, ldvsl, vsr, ldvsr, work,lwork, rwork, bwork, info )
                    import sp,dp,qp,ilp,lk,stdlib_selctg_c
                    implicit none
                    character, intent(in) :: jobvsl,jobvsr,sort
                    integer(ilp), intent(out) :: info,sdim
                    integer(ilp), intent(in) :: lda,ldb,ldvsl,ldvsr,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: alpha(*),beta(*),vsl(ldvsl,*),vsr(ldvsr,*),work(*)

                    procedure(stdlib_selctg_c) :: selctg
               end subroutine cgges
#else
               module procedure stdlib_cgges
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alphar, &
                         alphai, beta, vsl, ldvsl, vsr,ldvsr, work, lwork, bwork, info )
                    import sp,dp,qp,ilp,lk,stdlib_selctg_d
                    implicit none
                    character, intent(in) :: jobvsl,jobvsr,sort
                    integer(ilp), intent(out) :: info,sdim
                    integer(ilp), intent(in) :: lda,ldb,ldvsl,ldvsr,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: alphai(*),alphar(*),beta(*),vsl(ldvsl,*),vsr(ldvsr,*)&
                              ,work(*)
                    procedure(stdlib_selctg_d) :: selctg
               end subroutine dgges
#else
               module procedure stdlib_dgges
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alphar, &
                         alphai, beta, vsl, ldvsl, vsr,ldvsr, work, lwork, bwork, info )
                    import sp,dp,qp,ilp,lk,stdlib_selctg_s
                    implicit none
                    character, intent(in) :: jobvsl,jobvsr,sort
                    integer(ilp), intent(out) :: info,sdim
                    integer(ilp), intent(in) :: lda,ldb,ldvsl,ldvsr,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: alphai(*),alphar(*),beta(*),vsl(ldvsl,*),vsr(ldvsr,*)&
                              ,work(*)
                    procedure(stdlib_selctg_s) :: selctg
               end subroutine sgges
#else
               module procedure stdlib_sgges
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alpha, &
                         beta, vsl, ldvsl, vsr, ldvsr, work,lwork, rwork, bwork, info )
                    import sp,dp,qp,ilp,lk,stdlib_selctg_z
                    implicit none
                    character, intent(in) :: jobvsl,jobvsr,sort
                    integer(ilp), intent(out) :: info,sdim
                    integer(ilp), intent(in) :: lda,ldb,ldvsl,ldvsr,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: alpha(*),beta(*),vsl(ldvsl,*),vsr(ldvsr,*),work(*)

                    procedure(stdlib_selctg_z) :: selctg
               end subroutine zgges
#else
               module procedure stdlib_zgges
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alpha, &
                         beta, vsl, ldvsl, vsr, ldvsr, work,lwork, rwork, bwork, info )
                    import sp,dp,qp,ilp64,lk,stdlib_selctg_c
                    implicit none
                    character, intent(in) :: jobvsl,jobvsr,sort
                    integer(ilp64), intent(out) :: info,sdim
                    integer(ilp64), intent(in) :: lda,ldb,ldvsl,ldvsr,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: alpha(*),beta(*),vsl(ldvsl,*),vsr(ldvsr,*),work(*)

                    procedure(stdlib_selctg_c) :: selctg
               end subroutine cgges
#else
               module procedure stdlib_I64_cgges
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alphar, &
                         alphai, beta, vsl, ldvsl, vsr,ldvsr, work, lwork, bwork, info )
                    import sp,dp,qp,ilp64,lk,stdlib_selctg_d
                    implicit none
                    character, intent(in) :: jobvsl,jobvsr,sort
                    integer(ilp64), intent(out) :: info,sdim
                    integer(ilp64), intent(in) :: lda,ldb,ldvsl,ldvsr,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: alphai(*),alphar(*),beta(*),vsl(ldvsl,*),vsr(ldvsr,*)&
                              ,work(*)
                    procedure(stdlib_selctg_d) :: selctg
               end subroutine dgges
#else
               module procedure stdlib_I64_dgges
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alphar, &
                         alphai, beta, vsl, ldvsl, vsr,ldvsr, work, lwork, bwork, info )
                    import sp,dp,qp,ilp64,lk,stdlib_selctg_s
                    implicit none
                    character, intent(in) :: jobvsl,jobvsr,sort
                    integer(ilp64), intent(out) :: info,sdim
                    integer(ilp64), intent(in) :: lda,ldb,ldvsl,ldvsr,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: alphai(*),alphar(*),beta(*),vsl(ldvsl,*),vsr(ldvsr,*)&
                              ,work(*)
                    procedure(stdlib_selctg_s) :: selctg
               end subroutine sgges
#else
               module procedure stdlib_I64_sgges
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alpha, &
                         beta, vsl, ldvsl, vsr, ldvsr, work,lwork, rwork, bwork, info )
                    import sp,dp,qp,ilp64,lk,stdlib_selctg_z
                    implicit none
                    character, intent(in) :: jobvsl,jobvsr,sort
                    integer(ilp64), intent(out) :: info,sdim
                    integer(ilp64), intent(in) :: lda,ldb,ldvsl,ldvsr,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: alpha(*),beta(*),vsl(ldvsl,*),vsr(ldvsr,*),work(*)

                    procedure(stdlib_selctg_z) :: selctg
               end subroutine zgges
#else
               module procedure stdlib_I64_zgges
#endif
          end interface gges

          interface ggev
          !! GGEV computes for a pair of N-by-N complex nonsymmetric matrices
          !! (A,B), the generalized eigenvalues, and optionally, the left and/or
          !! right generalized eigenvectors.
          !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
          !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
          !! singular. It is usually represented as the pair (alpha,beta), as
          !! there is a reasonable interpretation for beta=0, and even for both
          !! being zero.
          !! The right generalized eigenvector v(j) corresponding to the
          !! generalized eigenvalue lambda(j) of (A,B) satisfies
          !! A * v(j) = lambda(j) * B * v(j).
          !! The left generalized eigenvector u(j) corresponding to the
          !! generalized eigenvalues lambda(j) of (A,B) satisfies
          !! u(j)**H * A = lambda(j) * u(j)**H * B
          !! where u(j)**H is the conjugate-transpose of u(j).
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cggev( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
                         work, lwork, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldvl,ldvr,lwork,n
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: alpha(*),beta(*),vl(ldvl,*),vr(ldvr,*),work(*)

               end subroutine cggev
#else
               module procedure stdlib_cggev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,beta, vl, ldvl, &
                         vr, ldvr, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldvl,ldvr,lwork,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: alphai(*),alphar(*),beta(*),vl(ldvl,*),vr(ldvr,*),&
                              work(*)
               end subroutine dggev
#else
               module procedure stdlib_dggev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,beta, vl, ldvl, &
                         vr, ldvr, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldvl,ldvr,lwork,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: alphai(*),alphar(*),beta(*),vl(ldvl,*),vr(ldvr,*),&
                              work(*)
               end subroutine sggev
#else
               module procedure stdlib_sggev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zggev( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
                         work, lwork, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldvl,ldvr,lwork,n
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: alpha(*),beta(*),vl(ldvl,*),vr(ldvr,*),work(*)

               end subroutine zggev
#else
               module procedure stdlib_zggev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cggev( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
                         work, lwork, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldvl,ldvr,lwork,n
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: alpha(*),beta(*),vl(ldvl,*),vr(ldvr,*),work(*)

               end subroutine cggev
#else
               module procedure stdlib_I64_cggev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,beta, vl, ldvl, &
                         vr, ldvr, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldvl,ldvr,lwork,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: alphai(*),alphar(*),beta(*),vl(ldvl,*),vr(ldvr,*),&
                              work(*)
               end subroutine dggev
#else
               module procedure stdlib_I64_dggev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,beta, vl, ldvl, &
                         vr, ldvr, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldvl,ldvr,lwork,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: alphai(*),alphar(*),beta(*),vl(ldvl,*),vr(ldvr,*),&
                              work(*)
               end subroutine sggev
#else
               module procedure stdlib_I64_sggev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zggev( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
                         work, lwork, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldvl,ldvr,lwork,n
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: alpha(*),beta(*),vl(ldvl,*),vr(ldvr,*),work(*)

               end subroutine zggev
#else
               module procedure stdlib_I64_zggev
#endif
          end interface ggev

          interface ggglm
          !! GGGLM solves a general Gauss-Markov linear model (GLM) problem:
          !! minimize || y ||_2   subject to   d = A*x + B*y
          !! x
          !! where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
          !! given N-vector. It is assumed that M <= N <= M+P, and
          !! rank(A) = M    and    rank( A B ) = N.
          !! Under these assumptions, the constrained equation is always
          !! consistent, and there is a unique solution x and a minimal 2-norm
          !! solution y, which is obtained using a generalized QR factorization
          !! of the matrices (A, B) given by
          !! A = Q*(R),   B = Q*T*Z.
          !! (0)
          !! In particular, if matrix B is square nonsingular, then the problem
          !! GLM is equivalent to the following weighted linear least squares
          !! problem
          !! minimize || inv(B)*(d-A*x) ||_2
          !! x
          !! where inv(B) denotes the inverse of B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),d(*)
                    complex(sp), intent(out) :: work(*),x(*),y(*)
               end subroutine cggglm
#else
               module procedure stdlib_cggglm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),d(*)
                    real(dp), intent(out) :: work(*),x(*),y(*)
               end subroutine dggglm
#else
               module procedure stdlib_dggglm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),d(*)
                    real(sp), intent(out) :: work(*),x(*),y(*)
               end subroutine sggglm
#else
               module procedure stdlib_sggglm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),d(*)
                    complex(dp), intent(out) :: work(*),x(*),y(*)
               end subroutine zggglm
#else
               module procedure stdlib_zggglm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),d(*)
                    complex(sp), intent(out) :: work(*),x(*),y(*)
               end subroutine cggglm
#else
               module procedure stdlib_I64_cggglm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,p
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),d(*)
                    real(dp), intent(out) :: work(*),x(*),y(*)
               end subroutine dggglm
#else
               module procedure stdlib_I64_dggglm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,p
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),d(*)
                    real(sp), intent(out) :: work(*),x(*),y(*)
               end subroutine sggglm
#else
               module procedure stdlib_I64_sggglm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),d(*)
                    complex(dp), intent(out) :: work(*),x(*),y(*)
               end subroutine zggglm
#else
               module procedure stdlib_I64_zggglm
#endif
          end interface ggglm

          interface gghrd
          !! GGHRD reduces a pair of complex matrices (A,B) to generalized upper
          !! Hessenberg form using unitary transformations, where A is a
          !! general matrix and B is upper triangular.  The form of the generalized
          !! eigenvalue problem is
          !! A*x = lambda*B*x,
          !! and B is typically made upper triangular by computing its QR
          !! factorization and moving the unitary matrix Q to the left side
          !! of the equation.
          !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
          !! Q**H*A*Z = H
          !! and transforms B to another upper triangular matrix T:
          !! Q**H*B*Z = T
          !! in order to reduce the problem to its standard form
          !! H*y = lambda*T*y
          !! where y = Z**H*x.
          !! The unitary matrices Q and Z are determined as products of Givens
          !! rotations.  They may either be formed explicitly, or they may be
          !! postmultiplied into input matrices Q1 and Z1, so that
          !! Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
          !! Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
          !! If Q1 is the unitary matrix from the QR factorization of B in the
          !! original equation A*x = lambda*B*x, then GGHRD reduces the original
          !! problem to generalized Hessenberg form.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq,compz
                    integer(ilp), intent(in) :: ihi,ilo,lda,ldb,ldq,ldz,n
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine cgghrd
#else
               module procedure stdlib_cgghrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq,compz
                    integer(ilp), intent(in) :: ihi,ilo,lda,ldb,ldq,ldz,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine dgghrd
#else
               module procedure stdlib_dgghrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq,compz
                    integer(ilp), intent(in) :: ihi,ilo,lda,ldb,ldq,ldz,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine sgghrd
#else
               module procedure stdlib_sgghrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq,compz
                    integer(ilp), intent(in) :: ihi,ilo,lda,ldb,ldq,ldz,n
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine zgghrd
#else
               module procedure stdlib_zgghrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq,compz
                    integer(ilp64), intent(in) :: ihi,ilo,lda,ldb,ldq,ldz,n
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine cgghrd
#else
               module procedure stdlib_I64_cgghrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq,compz
                    integer(ilp64), intent(in) :: ihi,ilo,lda,ldb,ldq,ldz,n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine dgghrd
#else
               module procedure stdlib_I64_dgghrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq,compz
                    integer(ilp64), intent(in) :: ihi,ilo,lda,ldb,ldq,ldz,n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine sgghrd
#else
               module procedure stdlib_I64_sgghrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq,compz
                    integer(ilp64), intent(in) :: ihi,ilo,lda,ldb,ldq,ldz,n
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine zgghrd
#else
               module procedure stdlib_I64_zgghrd
#endif
          end interface gghrd

          interface gglse
          !! GGLSE solves the linear equality-constrained least squares (LSE)
          !! problem:
          !! minimize || c - A*x ||_2   subject to   B*x = d
          !! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
          !! M-vector, and d is a given P-vector. It is assumed that
          !! P <= N <= M+P, and
          !! rank(B) = P and  rank( (A) ) = N.
          !! ( (B) )
          !! These conditions ensure that the LSE problem has a unique solution,
          !! which is obtained using a generalized RQ factorization of the
          !! matrices (B, A) given by
          !! B = (0 R)*Q,   A = Z*T*Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),c(*),d(*)
                    complex(sp), intent(out) :: work(*),x(*)
               end subroutine cgglse
#else
               module procedure stdlib_cgglse
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),c(*),d(*)
                    real(dp), intent(out) :: work(*),x(*)
               end subroutine dgglse
#else
               module procedure stdlib_dgglse
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),c(*),d(*)
                    real(sp), intent(out) :: work(*),x(*)
               end subroutine sgglse
#else
               module procedure stdlib_sgglse
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),c(*),d(*)
                    complex(dp), intent(out) :: work(*),x(*)
               end subroutine zgglse
#else
               module procedure stdlib_zgglse
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),c(*),d(*)
                    complex(sp), intent(out) :: work(*),x(*)
               end subroutine cgglse
#else
               module procedure stdlib_I64_cgglse
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,p
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),c(*),d(*)
                    real(dp), intent(out) :: work(*),x(*)
               end subroutine dgglse
#else
               module procedure stdlib_I64_dgglse
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,p
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),c(*),d(*)
                    real(sp), intent(out) :: work(*),x(*)
               end subroutine sgglse
#else
               module procedure stdlib_I64_sgglse
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),c(*),d(*)
                    complex(dp), intent(out) :: work(*),x(*)
               end subroutine zgglse
#else
               module procedure stdlib_I64_zgglse
#endif
          end interface gglse

          interface ggqrf
          !! GGQRF computes a generalized QR factorization of an N-by-M matrix A
          !! and an N-by-P matrix B:
          !! A = Q*R,        B = Q*T*Z,
          !! where Q is an N-by-N unitary matrix, Z is a P-by-P unitary matrix,
          !! and R and T assume one of the forms:
          !! if N >= M,  R = ( R11 ) M  ,   or if N < M,  R = ( R11  R12 ) N,
          !! (  0  ) N-M                         N   M-N
          !! M
          !! where R11 is upper triangular, and
          !! if N <= P,  T = ( 0  T12 ) N,   or if N > P,  T = ( T11 ) N-P,
          !! P-N  N                           ( T21 ) P
          !! P
          !! where T12 or T21 is upper triangular.
          !! In particular, if B is square and nonsingular, the GQR factorization
          !! of A and B implicitly gives the QR factorization of inv(B)*A:
          !! inv(B)*A = Z**H * (inv(T)*R)
          !! where inv(B) denotes the inverse of the matrix B, and Z' denotes the
          !! conjugate transpose of matrix Z.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine cggqrf
#else
               module procedure stdlib_cggqrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine dggqrf
#else
               module procedure stdlib_dggqrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine sggqrf
#else
               module procedure stdlib_sggqrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine zggqrf
#else
               module procedure stdlib_zggqrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine cggqrf
#else
               module procedure stdlib_I64_cggqrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,p
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine dggqrf
#else
               module procedure stdlib_I64_dggqrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,p
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine sggqrf
#else
               module procedure stdlib_I64_sggqrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine zggqrf
#else
               module procedure stdlib_I64_zggqrf
#endif
          end interface ggqrf

          interface ggrqf
          !! GGRQF computes a generalized RQ factorization of an M-by-N matrix A
          !! and a P-by-N matrix B:
          !! A = R*Q,        B = Z*T*Q,
          !! where Q is an N-by-N unitary matrix, Z is a P-by-P unitary
          !! matrix, and R and T assume one of the forms:
          !! if M <= N,  R = ( 0  R12 ) M,   or if M > N,  R = ( R11 ) M-N,
          !! N-M  M                           ( R21 ) N
          !! N
          !! where R12 or R21 is upper triangular, and
          !! if P >= N,  T = ( T11 ) N  ,   or if P < N,  T = ( T11  T12 ) P,
          !! (  0  ) P-N                         P   N-P
          !! N
          !! where T11 is upper triangular.
          !! In particular, if B is square and nonsingular, the GRQ factorization
          !! of A and B implicitly gives the RQ factorization of A*inv(B):
          !! A*inv(B) = (R*inv(T))*Z**H
          !! where inv(B) denotes the inverse of the matrix B, and Z**H denotes the
          !! conjugate transpose of the matrix Z.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine cggrqf
#else
               module procedure stdlib_cggrqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine dggrqf
#else
               module procedure stdlib_dggrqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine sggrqf
#else
               module procedure stdlib_sggrqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine zggrqf
#else
               module procedure stdlib_zggrqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine cggrqf
#else
               module procedure stdlib_I64_cggrqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,p
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine dggrqf
#else
               module procedure stdlib_I64_dggrqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,p
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine sggrqf
#else
               module procedure stdlib_I64_sggrqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine zggrqf
#else
               module procedure stdlib_I64_zggrqf
#endif
          end interface ggrqf

          interface gsvj0
          !! GSVJ0 is called from CGESVJ as a pre-processor and that is its main
          !! purpose. It applies Jacobi rotations in the same way as CGESVJ does, but
          !! it does not check convergence (stopping criterion). Few tuning
          !! parameters (marked by [TP]) are available for the implementer.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
                         nsweep, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n,nsweep
                    real(sp), intent(in) :: eps,sfmin,tol
                    character, intent(in) :: jobv
                    complex(sp), intent(inout) :: a(lda,*),d(n),v(ldv,*)
                    complex(sp), intent(out) :: work(lwork)
                    real(sp), intent(inout) :: sva(n)
               end subroutine cgsvj0
#else
               module procedure stdlib_cgsvj0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
                         nsweep, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n,nsweep
                    real(dp), intent(in) :: eps,sfmin,tol
                    character, intent(in) :: jobv
                    real(dp), intent(inout) :: a(lda,*),sva(n),d(n),v(ldv,*)
                    real(dp), intent(out) :: work(lwork)
               end subroutine dgsvj0
#else
               module procedure stdlib_dgsvj0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
                         nsweep, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n,nsweep
                    real(sp), intent(in) :: eps,sfmin,tol
                    character, intent(in) :: jobv
                    real(sp), intent(inout) :: a(lda,*),sva(n),d(n),v(ldv,*)
                    real(sp), intent(out) :: work(lwork)
               end subroutine sgsvj0
#else
               module procedure stdlib_sgsvj0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
                         nsweep, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n,nsweep
                    real(dp), intent(in) :: eps,sfmin,tol
                    character, intent(in) :: jobv
                    complex(dp), intent(inout) :: a(lda,*),d(n),v(ldv,*)
                    complex(dp), intent(out) :: work(lwork)
                    real(dp), intent(inout) :: sva(n)
               end subroutine zgsvj0
#else
               module procedure stdlib_zgsvj0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
                         nsweep, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldv,lwork,m,mv,n,nsweep
                    real(sp), intent(in) :: eps,sfmin,tol
                    character, intent(in) :: jobv
                    complex(sp), intent(inout) :: a(lda,*),d(n),v(ldv,*)
                    complex(sp), intent(out) :: work(lwork)
                    real(sp), intent(inout) :: sva(n)
               end subroutine cgsvj0
#else
               module procedure stdlib_I64_cgsvj0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
                         nsweep, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldv,lwork,m,mv,n,nsweep
                    real(dp), intent(in) :: eps,sfmin,tol
                    character, intent(in) :: jobv
                    real(dp), intent(inout) :: a(lda,*),sva(n),d(n),v(ldv,*)
                    real(dp), intent(out) :: work(lwork)
               end subroutine dgsvj0
#else
               module procedure stdlib_I64_dgsvj0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
                         nsweep, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldv,lwork,m,mv,n,nsweep
                    real(sp), intent(in) :: eps,sfmin,tol
                    character, intent(in) :: jobv
                    real(sp), intent(inout) :: a(lda,*),sva(n),d(n),v(ldv,*)
                    real(sp), intent(out) :: work(lwork)
               end subroutine sgsvj0
#else
               module procedure stdlib_I64_sgsvj0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
                         nsweep, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldv,lwork,m,mv,n,nsweep
                    real(dp), intent(in) :: eps,sfmin,tol
                    character, intent(in) :: jobv
                    complex(dp), intent(inout) :: a(lda,*),d(n),v(ldv,*)
                    complex(dp), intent(out) :: work(lwork)
                    real(dp), intent(inout) :: sva(n)
               end subroutine zgsvj0
#else
               module procedure stdlib_I64_zgsvj0
#endif
          end interface gsvj0

          interface gsvj1
          !! GSVJ1 is called from CGESVJ as a pre-processor and that is its main
          !! purpose. It applies Jacobi rotations in the same way as CGESVJ does, but
          !! it targets only particular pivots and it does not check convergence
          !! (stopping criterion). Few tuning parameters (marked by [TP]) are
          !! available for the implementer.
          !! Further Details
          !! ~~~~~~~~~~~~~~~
          !! GSVJ1 applies few sweeps of Jacobi rotations in the column space of
          !! the input M-by-N matrix A. The pivot pairs are taken from the (1,2)
          !! off-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The
          !! block-entries (tiles) of the (1,2) off-diagonal block are marked by the
          !! [x]'s in the following scheme:
          !! | *  *  * [x] [x] [x]|
          !! | *  *  * [x] [x] [x]|    Row-cycling in the nblr-by-nblc [x] blocks.
          !! | *  *  * [x] [x] [x]|    Row-cyclic pivoting inside each [x] block.
          !! |[x] [x] [x] *  *  * |
          !! |[x] [x] [x] *  *  * |
          !! |[x] [x] [x] *  *  * |
          !! In terms of the columns of A, the first N1 columns are rotated 'against'
          !! the remaining N-N1 columns, trying to increase the angle between the
          !! corresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is
          !! tiled using quadratic tiles of side KBL. Here, KBL is a tuning parameter.
          !! The number of sweeps is given in NSWEEP and the orthogonality threshold
          !! is given in TOL.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol,&
                          nsweep, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: eps,sfmin,tol
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n,n1,nsweep
                    character, intent(in) :: jobv
                    complex(sp), intent(inout) :: a(lda,*),d(n),v(ldv,*)
                    complex(sp), intent(out) :: work(lwork)
                    real(sp), intent(inout) :: sva(n)
               end subroutine cgsvj1
#else
               module procedure stdlib_cgsvj1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol,&
                          nsweep, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: eps,sfmin,tol
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n,n1,nsweep
                    character, intent(in) :: jobv
                    real(dp), intent(inout) :: a(lda,*),d(n),sva(n),v(ldv,*)
                    real(dp), intent(out) :: work(lwork)
               end subroutine dgsvj1
#else
               module procedure stdlib_dgsvj1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol,&
                          nsweep, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: eps,sfmin,tol
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n,n1,nsweep
                    character, intent(in) :: jobv
                    real(sp), intent(inout) :: a(lda,*),d(n),sva(n),v(ldv,*)
                    real(sp), intent(out) :: work(lwork)
               end subroutine sgsvj1
#else
               module procedure stdlib_sgsvj1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol,&
                          nsweep, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: eps,sfmin,tol
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n,n1,nsweep
                    character, intent(in) :: jobv
                    complex(dp), intent(inout) :: a(lda,*),d(n),v(ldv,*)
                    complex(dp), intent(out) :: work(lwork)
                    real(dp), intent(inout) :: sva(n)
               end subroutine zgsvj1
#else
               module procedure stdlib_zgsvj1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol,&
                          nsweep, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: eps,sfmin,tol
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldv,lwork,m,mv,n,n1,nsweep
                    character, intent(in) :: jobv
                    complex(sp), intent(inout) :: a(lda,*),d(n),v(ldv,*)
                    complex(sp), intent(out) :: work(lwork)
                    real(sp), intent(inout) :: sva(n)
               end subroutine cgsvj1
#else
               module procedure stdlib_I64_cgsvj1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol,&
                          nsweep, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: eps,sfmin,tol
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldv,lwork,m,mv,n,n1,nsweep
                    character, intent(in) :: jobv
                    real(dp), intent(inout) :: a(lda,*),d(n),sva(n),v(ldv,*)
                    real(dp), intent(out) :: work(lwork)
               end subroutine dgsvj1
#else
               module procedure stdlib_I64_dgsvj1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol,&
                          nsweep, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: eps,sfmin,tol
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldv,lwork,m,mv,n,n1,nsweep
                    character, intent(in) :: jobv
                    real(sp), intent(inout) :: a(lda,*),d(n),sva(n),v(ldv,*)
                    real(sp), intent(out) :: work(lwork)
               end subroutine sgsvj1
#else
               module procedure stdlib_I64_sgsvj1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol,&
                          nsweep, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: eps,sfmin,tol
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldv,lwork,m,mv,n,n1,nsweep
                    character, intent(in) :: jobv
                    complex(dp), intent(inout) :: a(lda,*),d(n),v(ldv,*)
                    complex(dp), intent(out) :: work(lwork)
                    real(dp), intent(inout) :: sva(n)
               end subroutine zgsvj1
#else
               module procedure stdlib_I64_zgsvj1
#endif
          end interface gsvj1

          interface gtcon
          !! GTCON estimates the reciprocal of the condition number of a complex
          !! tridiagonal matrix A using the LU factorization as computed by
          !! CGTTRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,work, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: d(*),dl(*),du(*),du2(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgtcon
#else
               module procedure stdlib_cgtcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,work, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(dp), intent(in) :: anorm,d(*),dl(*),du(*),du2(*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dgtcon
#else
               module procedure stdlib_dgtcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,work, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(sp), intent(in) :: anorm,d(*),dl(*),du(*),du2(*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine sgtcon
#else
               module procedure stdlib_sgtcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,work, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: d(*),dl(*),du(*),du2(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgtcon
#else
               module procedure stdlib_zgtcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,work, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: d(*),dl(*),du(*),du2(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgtcon
#else
               module procedure stdlib_I64_cgtcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,work, iwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: n,ipiv(*)
                    real(dp), intent(in) :: anorm,d(*),dl(*),du(*),du2(*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dgtcon
#else
               module procedure stdlib_I64_dgtcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,work, iwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: n,ipiv(*)
                    real(sp), intent(in) :: anorm,d(*),dl(*),du(*),du2(*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine sgtcon
#else
               module procedure stdlib_I64_sgtcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,work, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: d(*),dl(*),du(*),du2(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgtcon
#else
               module procedure stdlib_I64_zgtcon
#endif
          end interface gtcon

          interface gtrfs
          !! GTRFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is tridiagonal, and provides
          !! error bounds and backward error estimates for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, rwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: b(ldb,*),d(*),df(*),dl(*),dlf(*),du(*),du2(*),duf(&
                              *)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cgtrfs
#else
               module procedure stdlib_cgtrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: b(ldb,*),d(*),df(*),dl(*),dlf(*),du(*),du2(*),duf(*)

                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dgtrfs
#else
               module procedure stdlib_dgtrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: b(ldb,*),d(*),df(*),dl(*),dlf(*),du(*),du2(*),duf(*)

                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine sgtrfs
#else
               module procedure stdlib_sgtrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, rwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: b(ldb,*),d(*),df(*),dl(*),dlf(*),du(*),du2(*),duf(&
                              *)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zgtrfs
#else
               module procedure stdlib_zgtrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, rwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: b(ldb,*),d(*),df(*),dl(*),dlf(*),du(*),du2(*),duf(&
                              *)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cgtrfs
#else
               module procedure stdlib_I64_cgtrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: b(ldb,*),d(*),df(*),dl(*),dlf(*),du(*),du2(*),duf(*)

                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dgtrfs
#else
               module procedure stdlib_I64_dgtrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: b(ldb,*),d(*),df(*),dl(*),dlf(*),du(*),du2(*),duf(*)

                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine sgtrfs
#else
               module procedure stdlib_I64_sgtrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, rwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: b(ldb,*),d(*),df(*),dl(*),dlf(*),du(*),du2(*),duf(&
                              *)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zgtrfs
#else
               module procedure stdlib_I64_zgtrfs
#endif
          end interface gtrfs

          interface gtsv
          !! GTSV solves the equation
          !! A*X = B,
          !! where A is an N-by-N tridiagonal matrix, by Gaussian elimination with
          !! partial pivoting.
          !! Note that the equation  A**T *X = B  may be solved by interchanging the
          !! order of the arguments DU and DL.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgtsv( n, nrhs, dl, d, du, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(inout) :: b(ldb,*),d(*),dl(*),du(*)
               end subroutine cgtsv
#else
               module procedure stdlib_cgtsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgtsv( n, nrhs, dl, d, du, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: b(ldb,*),d(*),dl(*),du(*)
               end subroutine dgtsv
#else
               module procedure stdlib_dgtsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgtsv( n, nrhs, dl, d, du, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: b(ldb,*),d(*),dl(*),du(*)
               end subroutine sgtsv
#else
               module procedure stdlib_sgtsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgtsv( n, nrhs, dl, d, du, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(inout) :: b(ldb,*),d(*),dl(*),du(*)
               end subroutine zgtsv
#else
               module procedure stdlib_zgtsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgtsv( n, nrhs, dl, d, du, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(inout) :: b(ldb,*),d(*),dl(*),du(*)
               end subroutine cgtsv
#else
               module procedure stdlib_I64_cgtsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgtsv( n, nrhs, dl, d, du, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: b(ldb,*),d(*),dl(*),du(*)
               end subroutine dgtsv
#else
               module procedure stdlib_I64_dgtsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgtsv( n, nrhs, dl, d, du, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: b(ldb,*),d(*),dl(*),du(*)
               end subroutine sgtsv
#else
               module procedure stdlib_I64_sgtsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgtsv( n, nrhs, dl, d, du, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(inout) :: b(ldb,*),d(*),dl(*),du(*)
               end subroutine zgtsv
#else
               module procedure stdlib_I64_zgtsv
#endif
          end interface gtsv

          interface gttrf
          !! GTTRF computes an LU factorization of a complex tridiagonal matrix A
          !! using elimination with partial pivoting and row interchanges.
          !! The factorization has the form
          !! A = L * U
          !! where L is a product of permutation and unit lower bidiagonal
          !! matrices and U is upper triangular with nonzeros in only the main
          !! diagonal and first two superdiagonals.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgttrf( n, dl, d, du, du2, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: d(*),dl(*),du(*)
                    complex(sp), intent(out) :: du2(*)
               end subroutine cgttrf
#else
               module procedure stdlib_cgttrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgttrf( n, dl, d, du, du2, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: d(*),dl(*),du(*)
                    real(dp), intent(out) :: du2(*)
               end subroutine dgttrf
#else
               module procedure stdlib_dgttrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgttrf( n, dl, d, du, du2, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: d(*),dl(*),du(*)
                    real(sp), intent(out) :: du2(*)
               end subroutine sgttrf
#else
               module procedure stdlib_sgttrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgttrf( n, dl, d, du, du2, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: d(*),dl(*),du(*)
                    complex(dp), intent(out) :: du2(*)
               end subroutine zgttrf
#else
               module procedure stdlib_zgttrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgttrf( n, dl, d, du, du2, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: n
                    complex(sp), intent(inout) :: d(*),dl(*),du(*)
                    complex(sp), intent(out) :: du2(*)
               end subroutine cgttrf
#else
               module procedure stdlib_I64_cgttrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgttrf( n, dl, d, du, du2, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(inout) :: d(*),dl(*),du(*)
                    real(dp), intent(out) :: du2(*)
               end subroutine dgttrf
#else
               module procedure stdlib_I64_dgttrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgttrf( n, dl, d, du, du2, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(inout) :: d(*),dl(*),du(*)
                    real(sp), intent(out) :: du2(*)
               end subroutine sgttrf
#else
               module procedure stdlib_I64_sgttrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgttrf( n, dl, d, du, du2, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: n
                    complex(dp), intent(inout) :: d(*),dl(*),du(*)
                    complex(dp), intent(out) :: du2(*)
               end subroutine zgttrf
#else
               module procedure stdlib_I64_zgttrf
#endif
          end interface gttrf

          interface gttrs
          !! GTTRS solves one of the systems of equations
          !! A * X = B,  A**T * X = B,  or  A**H * X = B,
          !! with a tridiagonal matrix A using the LU factorization computed
          !! by CGTTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(in) :: d(*),dl(*),du(*),du2(*)
               end subroutine cgttrs
#else
               module procedure stdlib_cgttrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    real(dp), intent(inout) :: b(ldb,*)
                    real(dp), intent(in) :: d(*),dl(*),du(*),du2(*)
               end subroutine dgttrs
#else
               module procedure stdlib_dgttrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    real(sp), intent(inout) :: b(ldb,*)
                    real(sp), intent(in) :: d(*),dl(*),du(*),du2(*)
               end subroutine sgttrs
#else
               module procedure stdlib_sgttrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(in) :: d(*),dl(*),du(*),du2(*)
               end subroutine zgttrs
#else
               module procedure stdlib_zgttrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(in) :: d(*),dl(*),du(*),du2(*)
               end subroutine cgttrs
#else
               module procedure stdlib_I64_cgttrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs,ipiv(*)
                    real(dp), intent(inout) :: b(ldb,*)
                    real(dp), intent(in) :: d(*),dl(*),du(*),du2(*)
               end subroutine dgttrs
#else
               module procedure stdlib_I64_dgttrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs,ipiv(*)
                    real(sp), intent(inout) :: b(ldb,*)
                    real(sp), intent(in) :: d(*),dl(*),du(*),du2(*)
               end subroutine sgttrs
#else
               module procedure stdlib_I64_sgttrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(in) :: d(*),dl(*),du(*),du2(*)
               end subroutine zgttrs
#else
               module procedure stdlib_I64_zgttrs
#endif
          end interface gttrs

          interface hb2st_kernels
          !! HB2ST_KERNELS is an internal routine used by the CHETRD_HB2ST
          !! subroutine.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, &
                         lda, v, tau, ldvt, work)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: wantz
                    integer(ilp), intent(in) :: ttype,st,ed,sweep,n,nb,ib,lda,ldvt
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: v(*),tau(*),work(*)
               end subroutine chb2st_kernels
#else
               module procedure stdlib_chb2st_kernels
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine  zhb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, &
                         lda, v, tau, ldvt, work)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: wantz
                    integer(ilp), intent(in) :: ttype,st,ed,sweep,n,nb,ib,lda,ldvt
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: v(*),tau(*),work(*)
               end subroutine zhb2st_kernels
#else
               module procedure stdlib_zhb2st_kernels
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, &
                         lda, v, tau, ldvt, work)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: wantz
                    integer(ilp64), intent(in) :: ttype,st,ed,sweep,n,nb,ib,lda,ldvt
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: v(*),tau(*),work(*)
               end subroutine chb2st_kernels
#else
               module procedure stdlib_I64_chb2st_kernels
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine  zhb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, &
                         lda, v, tau, ldvt, work)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: wantz
                    integer(ilp64), intent(in) :: ttype,st,ed,sweep,n,nb,ib,lda,ldvt
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: v(*),tau(*),work(*)
               end subroutine zhb2st_kernels
#else
               module procedure stdlib_I64_zhb2st_kernels
#endif
          end interface hb2st_kernels

          interface hbev
          !! HBEV computes all the eigenvalues and, optionally, eigenvectors of
          !! a complex Hermitian band matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,rwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldz,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chbev
#else
               module procedure stdlib_chbev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,rwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldz,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhbev
#else
               module procedure stdlib_zhbev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine chbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,rwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldz,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chbev
#else
               module procedure stdlib_I64_chbev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zhbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,rwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldz,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhbev
#else
               module procedure stdlib_I64_zhbev
#endif
          end interface hbev

          interface hbevd
          !! HBEVD computes all the eigenvalues and, optionally, eigenvectors of
          !! a complex Hermitian band matrix A.  If eigenvectors are desired, it
          !! uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,ldz,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chbevd
#else
               module procedure stdlib_chbevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,ldz,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhbevd
#else
               module procedure stdlib_zhbevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine chbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: kd,ldab,ldz,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chbevd
#else
               module procedure stdlib_I64_chbevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zhbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: kd,ldab,ldz,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhbevd
#else
               module procedure stdlib_I64_zhbevd
#endif
          end interface hbevd

          interface hbgst
          !! HBGST reduces a complex Hermitian-definite banded generalized
          !! eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,
          !! such that C has the same bandwidth as A.
          !! B must have been previously factorized as S**H*S by CPBSTF, using a
          !! split Cholesky factorization. A is overwritten by C = X**H*A*X, where
          !! X = S**(-1)*Q and Q is a unitary matrix chosen to preserve the
          !! bandwidth of A.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldx,n
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
                    complex(sp), intent(in) :: bb(ldbb,*)
                    complex(sp), intent(out) :: work(*),x(ldx,*)
               end subroutine chbgst
#else
               module procedure stdlib_chbgst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldx,n
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
                    complex(dp), intent(in) :: bb(ldbb,*)
                    complex(dp), intent(out) :: work(*),x(ldx,*)
               end subroutine zhbgst
#else
               module procedure stdlib_zhbgst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, &
                         rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ka,kb,ldab,ldbb,ldx,n
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
                    complex(sp), intent(in) :: bb(ldbb,*)
                    complex(sp), intent(out) :: work(*),x(ldx,*)
               end subroutine chbgst
#else
               module procedure stdlib_I64_chbgst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, &
                         rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ka,kb,ldab,ldbb,ldx,n
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
                    complex(dp), intent(in) :: bb(ldbb,*)
                    complex(dp), intent(out) :: work(*),x(ldx,*)
               end subroutine zhbgst
#else
               module procedure stdlib_I64_zhbgst
#endif
          end interface hbgst

          interface hbgv
          !! HBGV computes all the eigenvalues, and optionally, the eigenvectors
          !! of a complex generalized Hermitian-definite banded eigenproblem, of
          !! the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
          !! and banded, and B is also positive definite.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldz,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chbgv
#else
               module procedure stdlib_chbgv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldz,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhbgv
#else
               module procedure stdlib_zhbgv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
                         rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ka,kb,ldab,ldbb,ldz,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chbgv
#else
               module procedure stdlib_I64_chbgv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
                         rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ka,kb,ldab,ldbb,ldz,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhbgv
#else
               module procedure stdlib_I64_zhbgv
#endif
          end interface hbgv

          interface hbgvd
          !! HBGVD computes all the eigenvalues, and optionally, the eigenvectors
          !! of a complex generalized Hermitian-definite banded eigenproblem, of
          !! the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
          !! and banded, and B is also positive definite.  If eigenvectors are
          !! desired, it uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
                         lwork, rwork, lrwork, iwork,liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldz,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chbgvd
#else
               module procedure stdlib_chbgvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
                         lwork, rwork, lrwork, iwork,liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldz,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhbgvd
#else
               module procedure stdlib_zhbgvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
                         lwork, rwork, lrwork, iwork,liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ka,kb,ldab,ldbb,ldz,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chbgvd
#else
               module procedure stdlib_I64_chbgvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
                         lwork, rwork, lrwork, iwork,liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ka,kb,ldab,ldbb,ldz,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhbgvd
#else
               module procedure stdlib_I64_zhbgvd
#endif
          end interface hbgvd

          interface hbtrd
          !! HBTRD reduces a complex Hermitian band matrix A to real symmetric
          !! tridiagonal form T by a unitary similarity transformation:
          !! Q**H * A * Q = T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldq,n
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: ab(ldab,*),q(ldq,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chbtrd
#else
               module procedure stdlib_chbtrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldq,n
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: ab(ldab,*),q(ldq,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhbtrd
#else
               module procedure stdlib_zhbtrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldq,n
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: ab(ldab,*),q(ldq,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chbtrd
#else
               module procedure stdlib_I64_chbtrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldq,n
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: ab(ldab,*),q(ldq,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhbtrd
#else
               module procedure stdlib_I64_zhbtrd
#endif
          end interface hbtrd

          interface hecon
          !! HECON estimates the reciprocal of the condition number of a complex
          !! Hermitian matrix A using the factorization A = U*D*U**H or
          !! A = L*D*L**H computed by CHETRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine checon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine checon
#else
               module procedure stdlib_checon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhecon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhecon
#else
               module procedure stdlib_zhecon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine checon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine checon
#else
               module procedure stdlib_I64_checon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhecon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhecon
#else
               module procedure stdlib_I64_zhecon
#endif
          end interface hecon

          interface hecon_rook
          !! HECON_ROOK estimates the reciprocal of the condition number of a complex
          !! Hermitian matrix A using the factorization A = U*D*U**H or
          !! A = L*D*L**H computed by CHETRF_ROOK.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine checon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine checon_rook
#else
               module procedure stdlib_checon_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhecon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhecon_rook
#else
               module procedure stdlib_zhecon_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine checon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine checon_rook
#else
               module procedure stdlib_I64_checon_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhecon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhecon_rook
#else
               module procedure stdlib_I64_zhecon_rook
#endif
          end interface hecon_rook

          interface heequb
          !! HEEQUB computes row and column scalings intended to equilibrate a
          !! Hermitian matrix A (with respect to the Euclidean norm) and reduce
          !! its condition number. The scale factors S are computed by the BIN
          !! algorithm (see references) so that the scaled matrix B with elements
          !! B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
          !! the smallest possible condition number over all possible diagonal
          !! scalings.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cheequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    character, intent(in) :: uplo
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cheequb
#else
               module procedure stdlib_cheequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zheequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    character, intent(in) :: uplo
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zheequb
#else
               module procedure stdlib_zheequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cheequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    character, intent(in) :: uplo
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cheequb
#else
               module procedure stdlib_I64_cheequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zheequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    character, intent(in) :: uplo
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zheequb
#else
               module procedure stdlib_I64_zheequb
#endif
          end interface heequb

          interface heev
          !! HEEV computes all eigenvalues and, optionally, eigenvectors of a
          !! complex Hermitian matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cheev( jobz, uplo, n, a, lda, w, work, lwork, rwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cheev
#else
               module procedure stdlib_cheev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zheev( jobz, uplo, n, a, lda, w, work, lwork, rwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zheev
#else
               module procedure stdlib_zheev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cheev( jobz, uplo, n, a, lda, w, work, lwork, rwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cheev
#else
               module procedure stdlib_I64_cheev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zheev( jobz, uplo, n, a, lda, w, work, lwork, rwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zheev
#else
               module procedure stdlib_I64_zheev
#endif
          end interface heev

          interface heevd
          !! HEEVD computes all eigenvalues and, optionally, eigenvectors of a
          !! complex Hermitian matrix A.  If eigenvectors are desired, it uses a
          !! divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cheevd( jobz, uplo, n, a, lda, w, work, lwork, rwork,lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cheevd
#else
               module procedure stdlib_cheevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zheevd( jobz, uplo, n, a, lda, w, work, lwork, rwork,lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zheevd
#else
               module procedure stdlib_zheevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cheevd( jobz, uplo, n, a, lda, w, work, lwork, rwork,lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cheevd
#else
               module procedure stdlib_I64_cheevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zheevd( jobz, uplo, n, a, lda, w, work, lwork, rwork,lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zheevd
#else
               module procedure stdlib_I64_zheevd
#endif
          end interface heevd

          interface heevr
          !! HEEVR computes selected eigenvalues and, optionally, eigenvectors
          !! of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can
          !! be selected by specifying either a range of values or a range of
          !! indices for the desired eigenvalues.
          !! HEEVR first reduces the matrix A to tridiagonal form T with a call
          !! to CHETRD.  Then, whenever possible, HEEVR calls CSTEMR to compute
          !! the eigenspectrum using Relatively Robust Representations.  CSTEMR
          !! computes eigenvalues by the dqds algorithm, while orthogonal
          !! eigenvectors are computed from various "good" L D L^T representations
          !! (also known as Relatively Robust Representations). Gram-Schmidt
          !! orthogonalization is avoided as far as possible. More specifically,
          !! the various steps of the algorithm are as follows.
          !! For each unreduced block (submatrix) of T,
          !! (a) Compute T - sigma I  = L D L^T, so that L and D
          !! define all the wanted eigenvalues to high relative accuracy.
          !! This means that small relative changes in the entries of D and L
          !! cause only small relative changes in the eigenvalues and
          !! eigenvectors. The standard (unfactored) representation of the
          !! tridiagonal matrix T does not have this property in general.
          !! (b) Compute the eigenvalues to suitable accuracy.
          !! If the eigenvectors are desired, the algorithm attains full
          !! accuracy of the computed eigenvalues only right before
          !! the corresponding vectors have to be computed, see steps c) and d).
          !! (c) For each cluster of close eigenvalues, select a new
          !! shift close to the cluster, find a new factorization, and refine
          !! the shifted eigenvalues to suitable accuracy.
          !! (d) For each eigenvalue with a large enough relative separation compute
          !! the corresponding eigenvector by forming a rank revealing twisted
          !! factorization. Go back to (c) for any clusters that remain.
          !! The desired accuracy of the output can be specified by the input
          !! parameter ABSTOL.
          !! For more details, see CSTEMR's documentation and:
          !! - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
          !! to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
          !! Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
          !! - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
          !! Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
          !! 2004.  Also LAPACK Working Note 154.
          !! - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
          !! tridiagonal eigenvalue/eigenvector problem",
          !! Computer Science Division Technical Report No. UCB/CSD-97-971,
          !! UC Berkeley, May 1997.
          !! Note 1 : HEEVR calls CSTEMR when the full spectrum is requested
          !! on machines which conform to the ieee-754 floating point standard.
          !! HEEVR calls SSTEBZ and CSTEIN on non-ieee machines and
          !! when partial spectrum requests are made.
          !! Normal execution of CSTEMR may create NaNs and infinities and
          !! hence may abort due to a floating point exception in environments
          !! which do not handle NaNs and infinities in the ieee standard default
          !! manner.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cheevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, &
                         ldz, isuppz, work, lwork,rwork, lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,range,uplo
                    integer(ilp), intent(in) :: il,iu,lda,ldz,liwork,lrwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: abstol,vl,vu
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine cheevr
#else
               module procedure stdlib_cheevr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zheevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, &
                         ldz, isuppz, work, lwork,rwork, lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,range,uplo
                    integer(ilp), intent(in) :: il,iu,lda,ldz,liwork,lrwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: abstol,vl,vu
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zheevr
#else
               module procedure stdlib_zheevr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cheevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, &
                         ldz, isuppz, work, lwork,rwork, lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,range,uplo
                    integer(ilp64), intent(in) :: il,iu,lda,ldz,liwork,lrwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: abstol,vl,vu
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine cheevr
#else
               module procedure stdlib_I64_cheevr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zheevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, &
                         ldz, isuppz, work, lwork,rwork, lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,range,uplo
                    integer(ilp64), intent(in) :: il,iu,lda,ldz,liwork,lrwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: abstol,vl,vu
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zheevr
#else
               module procedure stdlib_I64_zheevr
#endif
          end interface heevr

          interface hegst
          !! HEGST reduces a complex Hermitian-definite generalized
          !! eigenproblem to standard form.
          !! If ITYPE = 1, the problem is A*x = lambda*B*x,
          !! and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
          !! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
          !! B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.
          !! B must have been previously factorized as U**H*U or L*L**H by CPOTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chegst( itype, uplo, n, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,lda,ldb,n
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine chegst
#else
               module procedure stdlib_chegst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhegst( itype, uplo, n, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,lda,ldb,n
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine zhegst
#else
               module procedure stdlib_zhegst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chegst( itype, uplo, n, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: itype,lda,ldb,n
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine chegst
#else
               module procedure stdlib_I64_chegst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhegst( itype, uplo, n, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: itype,lda,ldb,n
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine zhegst
#else
               module procedure stdlib_I64_zhegst
#endif
          end interface hegst

          interface hegv
          !! HEGV computes all the eigenvalues, and optionally, the eigenvectors
          !! of a complex generalized Hermitian-definite eigenproblem, of the form
          !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
          !! Here A and B are assumed to be Hermitian and B is also
          !! positive definite.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chegv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,lda,ldb,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chegv
#else
               module procedure stdlib_chegv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhegv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,lda,ldb,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhegv
#else
               module procedure stdlib_zhegv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine chegv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: itype,lda,ldb,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chegv
#else
               module procedure stdlib_I64_chegv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zhegv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: itype,lda,ldb,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhegv
#else
               module procedure stdlib_I64_zhegv
#endif
          end interface hegv

          interface hegvd
          !! HEGVD computes all the eigenvalues, and optionally, the eigenvectors
          !! of a complex generalized Hermitian-definite eigenproblem, of the form
          !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
          !! B are assumed to be Hermitian and B is also positive definite.
          !! If eigenvectors are desired, it uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chegvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: itype,lda,ldb,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chegvd
#else
               module procedure stdlib_chegvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhegvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: itype,lda,ldb,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhegvd
#else
               module procedure stdlib_zhegvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine chegvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: itype,lda,ldb,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chegvd
#else
               module procedure stdlib_I64_chegvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zhegvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: itype,lda,ldb,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhegvd
#else
               module procedure stdlib_I64_zhegvd
#endif
          end interface hegvd

          interface herfs
          !! HERFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is Hermitian indefinite, and
          !! provides error bounds and backward error estimates for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cherfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cherfs
#else
               module procedure stdlib_cherfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zherfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zherfs
#else
               module procedure stdlib_zherfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cherfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cherfs
#else
               module procedure stdlib_I64_cherfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zherfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zherfs
#else
               module procedure stdlib_I64_zherfs
#endif
          end interface herfs

          interface hesv
          !! HESV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
          !! matrices.
          !! The diagonal pivoting method is used to factor A as
          !! A = U * D * U**H,  if UPLO = 'U', or
          !! A = L * D * L**H,  if UPLO = 'L',
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is Hermitian and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
          !! used to solve the system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chesv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chesv
#else
               module procedure stdlib_chesv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhesv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhesv
#else
               module procedure stdlib_zhesv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chesv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chesv
#else
               module procedure stdlib_I64_chesv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhesv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhesv
#else
               module procedure stdlib_I64_zhesv
#endif
          end interface hesv

          interface hesv_aa
          !! HESV_AA computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
          !! matrices.
          !! Aasen's algorithm is used to factor A as
          !! A = U**H * T * U,  if UPLO = 'U', or
          !! A = L * T * L**H,  if UPLO = 'L',
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and T is Hermitian and tridiagonal. The factored form
          !! of A is then used to solve the system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chesv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chesv_aa
#else
               module procedure stdlib_chesv_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhesv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhesv_aa
#else
               module procedure stdlib_zhesv_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chesv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chesv_aa
#else
               module procedure stdlib_I64_chesv_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhesv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhesv_aa
#else
               module procedure stdlib_I64_zhesv_aa
#endif
          end interface hesv_aa

          interface hesv_rk
          !! HESV_RK computes the solution to a complex system of linear
          !! equations A * X = B, where A is an N-by-N Hermitian matrix
          !! and X and B are N-by-NRHS matrices.
          !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
          !! to factor A as
          !! A = P*U*D*(U**H)*(P**T),  if UPLO = 'U', or
          !! A = P*L*D*(L**H)*(P**T),  if UPLO = 'L',
          !! where U (or L) is unit upper (or lower) triangular matrix,
          !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
          !! matrix, P**T is the transpose of P, and D is Hermitian and block
          !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! CHETRF_RK is called to compute the factorization of a complex
          !! Hermitian matrix.  The factored form of A is then used to solve
          !! the system of equations A * X = B by calling BLAS3 routine CHETRS_3.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chesv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: e(*),work(*)
               end subroutine chesv_rk
#else
               module procedure stdlib_chesv_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhesv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: e(*),work(*)
               end subroutine zhesv_rk
#else
               module procedure stdlib_zhesv_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chesv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: e(*),work(*)
               end subroutine chesv_rk
#else
               module procedure stdlib_I64_chesv_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhesv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: e(*),work(*)
               end subroutine zhesv_rk
#else
               module procedure stdlib_I64_zhesv_rk
#endif
          end interface hesv_rk

          interface hesv_rook
          !! HESV_ROOK computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
          !! matrices.
          !! The bounded Bunch-Kaufman ("rook") diagonal pivoting method is used
          !! to factor A as
          !! A = U * D * U**T,  if UPLO = 'U', or
          !! A = L * D * L**T,  if UPLO = 'L',
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is Hermitian and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.
          !! CHETRF_ROOK is called to compute the factorization of a complex
          !! Hermition matrix A using the bounded Bunch-Kaufman ("rook") diagonal
          !! pivoting method.
          !! The factored form of A is then used to solve the system
          !! of equations A * X = B by calling CHETRS_ROOK (uses BLAS 2).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chesv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chesv_rook
#else
               module procedure stdlib_chesv_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhesv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhesv_rook
#else
               module procedure stdlib_zhesv_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chesv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chesv_rook
#else
               module procedure stdlib_I64_chesv_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhesv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhesv_rook
#else
               module procedure stdlib_I64_zhesv_rook
#endif
          end interface hesv_rook

          interface heswapr
          !! HESWAPR applies an elementary permutation on the rows and the columns of
          !! a hermitian matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cheswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: i1,i2,lda,n
                    complex(sp), intent(inout) :: a(lda,n)
               end subroutine cheswapr
#else
               module procedure stdlib_cheswapr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zheswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: i1,i2,lda,n
                    complex(dp), intent(inout) :: a(lda,n)
               end subroutine zheswapr
#else
               module procedure stdlib_zheswapr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cheswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: i1,i2,lda,n
                    complex(sp), intent(inout) :: a(lda,n)
               end subroutine cheswapr
#else
               module procedure stdlib_I64_cheswapr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zheswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: i1,i2,lda,n
                    complex(dp), intent(inout) :: a(lda,n)
               end subroutine zheswapr
#else
               module procedure stdlib_I64_zheswapr
#endif
          end interface heswapr

          interface hetf2_rk
          !! HETF2_RK computes the factorization of a complex Hermitian matrix A
          !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
          !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
          !! where U (or L) is unit upper (or lower) triangular matrix,
          !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
          !! matrix, P**T is the transpose of P, and D is Hermitian and block
          !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
          !! For more information see Further Details section.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*)
               end subroutine chetf2_rk
#else
               module procedure stdlib_chetf2_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*)
               end subroutine zhetf2_rk
#else
               module procedure stdlib_zhetf2_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chetf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*)
               end subroutine chetf2_rk
#else
               module procedure stdlib_I64_chetf2_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhetf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*)
               end subroutine zhetf2_rk
#else
               module procedure stdlib_I64_zhetf2_rk
#endif
          end interface hetf2_rk

          interface hetf2_rook
          !! HETF2_ROOK computes the factorization of a complex Hermitian matrix A
          !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
          !! A = U*D*U**H  or  A = L*D*L**H
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, U**H is the conjugate transpose of U, and D is
          !! Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine chetf2_rook
#else
               module procedure stdlib_chetf2_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zhetf2_rook
#else
               module procedure stdlib_zhetf2_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chetf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine chetf2_rook
#else
               module procedure stdlib_I64_chetf2_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhetf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zhetf2_rook
#else
               module procedure stdlib_I64_zhetf2_rook
#endif
          end interface hetf2_rook

          interface hetrd
          !! HETRD reduces a complex Hermitian matrix A to real symmetric
          !! tridiagonal form T by a unitary similarity transformation:
          !! Q**H * A * Q = T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine chetrd
#else
               module procedure stdlib_chetrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zhetrd
#else
               module procedure stdlib_zhetrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chetrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,n
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine chetrd
#else
               module procedure stdlib_I64_chetrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhetrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,n
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zhetrd
#else
               module procedure stdlib_I64_zhetrd
#endif
          end interface hetrd

          interface hetrd_hb2st
          !! HETRD_HB2ST reduces a complex Hermitian band matrix A to real symmetric
          !! tridiagonal form T by a unitary similarity transformation:
          !! Q**H * A * Q = T.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chetrd_hb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, &
                         lhous, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: stage1,uplo,vect
                    integer(ilp), intent(in) :: n,kd,ldab,lhous,lwork
                    integer(ilp), intent(out) :: info
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
                    complex(sp), intent(out) :: hous(*),work(*)
               end subroutine chetrd_hb2st
#else
               module procedure stdlib_chetrd_hb2st
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhetrd_hb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, &
                         lhous, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: stage1,uplo,vect
                    integer(ilp), intent(in) :: n,kd,ldab,lhous,lwork
                    integer(ilp), intent(out) :: info
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
                    complex(dp), intent(out) :: hous(*),work(*)
               end subroutine zhetrd_hb2st
#else
               module procedure stdlib_zhetrd_hb2st
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine chetrd_hb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, &
                         lhous, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: stage1,uplo,vect
                    integer(ilp64), intent(in) :: n,kd,ldab,lhous,lwork
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
                    complex(sp), intent(out) :: hous(*),work(*)
               end subroutine chetrd_hb2st
#else
               module procedure stdlib_I64_chetrd_hb2st
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zhetrd_hb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, &
                         lhous, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: stage1,uplo,vect
                    integer(ilp64), intent(in) :: n,kd,ldab,lhous,lwork
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
                    complex(dp), intent(out) :: hous(*),work(*)
               end subroutine zhetrd_hb2st
#else
               module procedure stdlib_I64_zhetrd_hb2st
#endif
          end interface hetrd_hb2st

          interface hetrd_he2hb
          !! HETRD_HE2HB reduces a complex Hermitian matrix A to complex Hermitian
          !! band-diagonal form AB by a unitary similarity transformation:
          !! Q**H * A * Q = AB.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chetrd_he2hb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldab,lwork,n,kd
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: ab(ldab,*),tau(*),work(*)
               end subroutine chetrd_he2hb
#else
               module procedure stdlib_chetrd_he2hb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhetrd_he2hb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldab,lwork,n,kd
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: ab(ldab,*),tau(*),work(*)
               end subroutine zhetrd_he2hb
#else
               module procedure stdlib_zhetrd_he2hb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine chetrd_he2hb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldab,lwork,n,kd
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: ab(ldab,*),tau(*),work(*)
               end subroutine chetrd_he2hb
#else
               module procedure stdlib_I64_chetrd_he2hb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zhetrd_he2hb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldab,lwork,n,kd
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: ab(ldab,*),tau(*),work(*)
               end subroutine zhetrd_he2hb
#else
               module procedure stdlib_I64_zhetrd_he2hb
#endif
          end interface hetrd_he2hb

          interface hetrf
          !! HETRF computes the factorization of a complex Hermitian matrix A
          !! using the Bunch-Kaufman diagonal pivoting method.  The form of the
          !! factorization is
          !! A = U*D*U**H  or  A = L*D*L**H
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is Hermitian and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetrf
#else
               module procedure stdlib_chetrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetrf
#else
               module procedure stdlib_zhetrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chetrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetrf
#else
               module procedure stdlib_I64_chetrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhetrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetrf
#else
               module procedure stdlib_I64_zhetrf
#endif
          end interface hetrf

          interface hetrf_aa
          !! HETRF_AA computes the factorization of a complex hermitian matrix A
          !! using the Aasen's algorithm.  The form of the factorization is
          !! A = U**H*T*U  or  A = L*T*L**H
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and T is a hermitian tridiagonal matrix.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,lwork
                    integer(ilp), intent(out) :: info,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetrf_aa
#else
               module procedure stdlib_chetrf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,lwork
                    integer(ilp), intent(out) :: info,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetrf_aa
#else
               module procedure stdlib_zhetrf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,lda,lwork
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetrf_aa
#else
               module procedure stdlib_I64_chetrf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,lda,lwork
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetrf_aa
#else
               module procedure stdlib_I64_zhetrf_aa
#endif
          end interface hetrf_aa

          interface hetrf_rk
          !! HETRF_RK computes the factorization of a complex Hermitian matrix A
          !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
          !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
          !! where U (or L) is unit upper (or lower) triangular matrix,
          !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
          !! matrix, P**T is the transpose of P, and D is Hermitian and block
          !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
          !! For more information see Further Details section.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*),work(*)
               end subroutine chetrf_rk
#else
               module procedure stdlib_chetrf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*),work(*)
               end subroutine zhetrf_rk
#else
               module procedure stdlib_zhetrf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*),work(*)
               end subroutine chetrf_rk
#else
               module procedure stdlib_I64_chetrf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*),work(*)
               end subroutine zhetrf_rk
#else
               module procedure stdlib_I64_zhetrf_rk
#endif
          end interface hetrf_rk

          interface hetrf_rook
          !! HETRF_ROOK computes the factorization of a complex Hermitian matrix A
          !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
          !! The form of the factorization is
          !! A = U*D*U**T  or  A = L*D*L**T
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is Hermitian and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetrf_rook
#else
               module procedure stdlib_chetrf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetrf_rook
#else
               module procedure stdlib_zhetrf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetrf_rook
#else
               module procedure stdlib_I64_chetrf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetrf_rook
#else
               module procedure stdlib_I64_zhetrf_rook
#endif
          end interface hetrf_rook

          interface hetri
          !! HETRI computes the inverse of a complex Hermitian indefinite matrix
          !! A using the factorization A = U*D*U**H or A = L*D*L**H computed by
          !! CHETRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetri
#else
               module procedure stdlib_chetri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetri
#else
               module procedure stdlib_zhetri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chetri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetri
#else
               module procedure stdlib_I64_chetri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhetri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetri
#else
               module procedure stdlib_I64_zhetri
#endif
          end interface hetri

          interface hetri_rook
          !! HETRI_ROOK computes the inverse of a complex Hermitian indefinite matrix
          !! A using the factorization A = U*D*U**H or A = L*D*L**H computed by
          !! CHETRF_ROOK.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetri_rook
#else
               module procedure stdlib_chetri_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetri_rook
#else
               module procedure stdlib_zhetri_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chetri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetri_rook
#else
               module procedure stdlib_I64_chetri_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhetri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetri_rook
#else
               module procedure stdlib_I64_zhetri_rook
#endif
          end interface hetri_rook

          interface hetrs
          !! HETRS solves a system of linear equations A*X = B with a complex
          !! Hermitian matrix A using the factorization A = U*D*U**H or
          !! A = L*D*L**H computed by CHETRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine chetrs
#else
               module procedure stdlib_chetrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zhetrs
#else
               module procedure stdlib_zhetrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine chetrs
#else
               module procedure stdlib_I64_chetrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zhetrs
#else
               module procedure stdlib_I64_zhetrs
#endif
          end interface hetrs

          interface hetrs2
          !! HETRS2 solves a system of linear equations A*X = B with a complex
          !! Hermitian matrix A using the factorization A = U*D*U**H or
          !! A = L*D*L**H computed by CHETRF and converted by CSYCONV.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetrs2
#else
               module procedure stdlib_chetrs2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetrs2
#else
               module procedure stdlib_zhetrs2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chetrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetrs2
#else
               module procedure stdlib_I64_chetrs2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhetrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetrs2
#else
               module procedure stdlib_I64_zhetrs2
#endif
          end interface hetrs2

          interface hetrs_3
          !! HETRS_3 solves a system of linear equations A * X = B with a complex
          !! Hermitian matrix A using the factorization computed
          !! by CHETRF_RK or CHETRF_BK:
          !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
          !! where U (or L) is unit upper (or lower) triangular matrix,
          !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
          !! matrix, P**T is the transpose of P, and D is Hermitian and block
          !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! This algorithm is using Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*),e(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine chetrs_3
#else
               module procedure stdlib_chetrs_3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*),e(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zhetrs_3
#else
               module procedure stdlib_zhetrs_3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*),e(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine chetrs_3
#else
               module procedure stdlib_I64_chetrs_3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*),e(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zhetrs_3
#else
               module procedure stdlib_I64_zhetrs_3
#endif
          end interface hetrs_3

          interface hetrs_aa
          !! HETRS_AA solves a system of linear equations A*X = B with a complex
          !! hermitian matrix A using the factorization A = U**H*T*U or
          !! A = L*T*L**H computed by CHETRF_AA.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetrs_aa
#else
               module procedure stdlib_chetrs_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetrs_aa
#else
               module procedure stdlib_zhetrs_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetrs_aa
#else
               module procedure stdlib_I64_chetrs_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetrs_aa
#else
               module procedure stdlib_I64_zhetrs_aa
#endif
          end interface hetrs_aa

          interface hetrs_rook
          !! HETRS_ROOK solves a system of linear equations A*X = B with a complex
          !! Hermitian matrix A using the factorization A = U*D*U**H or
          !! A = L*D*L**H computed by CHETRF_ROOK.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine chetrs_rook
#else
               module procedure stdlib_chetrs_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zhetrs_rook
#else
               module procedure stdlib_zhetrs_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine chetrs_rook
#else
               module procedure stdlib_I64_chetrs_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zhetrs_rook
#else
               module procedure stdlib_I64_zhetrs_rook
#endif
          end interface hetrs_rook

          interface hfrk
          !! Level 3 BLAS like routine for C in RFP Format.
          !! HFRK performs one of the Hermitian rank--k operations
          !! C := alpha*A*A**H + beta*C,
          !! or
          !! C := alpha*A**H*A + beta*C,
          !! where alpha and beta are real scalars, C is an n--by--n Hermitian
          !! matrix and A is an n--by--k matrix in the first case and a k--by--n
          !! matrix in the second case.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,c )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: k,lda,n
                    character, intent(in) :: trans,transr,uplo
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: c(*)
               end subroutine chfrk
#else
               module procedure stdlib_chfrk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,c )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: k,lda,n
                    character, intent(in) :: trans,transr,uplo
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: c(*)
               end subroutine zhfrk
#else
               module procedure stdlib_zhfrk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,c )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta
                    integer(ilp64), intent(in) :: k,lda,n
                    character, intent(in) :: trans,transr,uplo
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: c(*)
               end subroutine chfrk
#else
               module procedure stdlib_I64_chfrk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,c )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta
                    integer(ilp64), intent(in) :: k,lda,n
                    character, intent(in) :: trans,transr,uplo
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: c(*)
               end subroutine zhfrk
#else
               module procedure stdlib_I64_zhfrk
#endif
          end interface hfrk

          interface hgeqz
          !! HGEQZ computes the eigenvalues of a complex matrix pair (H,T),
          !! where H is an upper Hessenberg matrix and T is upper triangular,
          !! using the single-shift QZ method.
          !! Matrix pairs of this type are produced by the reduction to
          !! generalized upper Hessenberg form of a complex matrix pair (A,B):
          !! A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
          !! as computed by CGGHRD.
          !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
          !! also reduced to generalized Schur form,
          !! H = Q*S*Z**H,  T = Q*P*Z**H,
          !! where Q and Z are unitary matrices and S and P are upper triangular.
          !! Optionally, the unitary matrix Q from the generalized Schur
          !! factorization may be postmultiplied into an input matrix Q1, and the
          !! unitary matrix Z may be postmultiplied into an input matrix Z1.
          !! If Q1 and Z1 are the unitary matrices from CGGHRD that reduced
          !! the matrix pair (A,B) to generalized Hessenberg form, then the output
          !! matrices Q1*Q and Z1*Z are the unitary factors from the generalized
          !! Schur factorization of (A,B):
          !! A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
          !! To avoid overflow, eigenvalues of the matrix pair (H,T)
          !! (equivalently, of (A,B)) are computed as a pair of complex values
          !! (alpha,beta).  If beta is nonzero, lambda = alpha / beta is an
          !! eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)
          !! A*x = lambda*B*x
          !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
          !! alternate form of the GNEP
          !! mu*A*y = B*y.
          !! The values of alpha and beta for the i-th eigenvalue can be read
          !! directly from the generalized Schur form:  alpha = S(i,i),
          !! beta = P(i,i).
          !! Ref: C.B. Moler
          !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
          !! pp. 241--256.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alpha, beta, q, &
                         ldq, z, ldz, work, lwork,rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq,compz,job
                    integer(ilp), intent(in) :: ihi,ilo,ldh,ldq,ldt,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(out) :: alpha(*),beta(*),work(*)
                    complex(sp), intent(inout) :: h(ldh,*),q(ldq,*),t(ldt,*),z(ldz,*)
               end subroutine chgeqz
#else
               module procedure stdlib_chgeqz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dhgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alphar, alphai, &
                         beta, q, ldq, z, ldz, work,lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq,compz,job
                    integer(ilp), intent(in) :: ihi,ilo,ldh,ldq,ldt,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(out) :: alphai(*),alphar(*),beta(*),work(*)
                    real(dp), intent(inout) :: h(ldh,*),q(ldq,*),t(ldt,*),z(ldz,*)
               end subroutine dhgeqz
#else
               module procedure stdlib_dhgeqz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine shgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alphar, alphai, &
                         beta, q, ldq, z, ldz, work,lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq,compz,job
                    integer(ilp), intent(in) :: ihi,ilo,ldh,ldq,ldt,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(out) :: alphai(*),alphar(*),beta(*),work(*)
                    real(sp), intent(inout) :: h(ldh,*),q(ldq,*),t(ldt,*),z(ldz,*)
               end subroutine shgeqz
#else
               module procedure stdlib_shgeqz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alpha, beta, q, &
                         ldq, z, ldz, work, lwork,rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq,compz,job
                    integer(ilp), intent(in) :: ihi,ilo,ldh,ldq,ldt,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(out) :: alpha(*),beta(*),work(*)
                    complex(dp), intent(inout) :: h(ldh,*),q(ldq,*),t(ldt,*),z(ldz,*)
               end subroutine zhgeqz
#else
               module procedure stdlib_zhgeqz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine chgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alpha, beta, q, &
                         ldq, z, ldz, work, lwork,rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq,compz,job
                    integer(ilp64), intent(in) :: ihi,ilo,ldh,ldq,ldt,ldz,lwork,n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(out) :: alpha(*),beta(*),work(*)
                    complex(sp), intent(inout) :: h(ldh,*),q(ldq,*),t(ldt,*),z(ldz,*)
               end subroutine chgeqz
#else
               module procedure stdlib_I64_chgeqz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dhgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alphar, alphai, &
                         beta, q, ldq, z, ldz, work,lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq,compz,job
                    integer(ilp64), intent(in) :: ihi,ilo,ldh,ldq,ldt,ldz,lwork,n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(out) :: alphai(*),alphar(*),beta(*),work(*)
                    real(dp), intent(inout) :: h(ldh,*),q(ldq,*),t(ldt,*),z(ldz,*)
               end subroutine dhgeqz
#else
               module procedure stdlib_I64_dhgeqz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine shgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alphar, alphai, &
                         beta, q, ldq, z, ldz, work,lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq,compz,job
                    integer(ilp64), intent(in) :: ihi,ilo,ldh,ldq,ldt,ldz,lwork,n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(out) :: alphai(*),alphar(*),beta(*),work(*)
                    real(sp), intent(inout) :: h(ldh,*),q(ldq,*),t(ldt,*),z(ldz,*)
               end subroutine shgeqz
#else
               module procedure stdlib_I64_shgeqz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zhgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alpha, beta, q, &
                         ldq, z, ldz, work, lwork,rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq,compz,job
                    integer(ilp64), intent(in) :: ihi,ilo,ldh,ldq,ldt,ldz,lwork,n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(out) :: alpha(*),beta(*),work(*)
                    complex(dp), intent(inout) :: h(ldh,*),q(ldq,*),t(ldt,*),z(ldz,*)
               end subroutine zhgeqz
#else
               module procedure stdlib_I64_zhgeqz
#endif
          end interface hgeqz

          interface hpcon
          !! HPCON estimates the reciprocal of the condition number of a complex
          !! Hermitian packed matrix A using the factorization A = U*D*U**H or
          !! A = L*D*L**H computed by CHPTRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chpcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chpcon
#else
               module procedure stdlib_chpcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhpcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhpcon
#else
               module procedure stdlib_zhpcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chpcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chpcon
#else
               module procedure stdlib_I64_chpcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhpcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhpcon
#else
               module procedure stdlib_I64_zhpcon
#endif
          end interface hpcon

          interface hpev
          !! HPEV computes all the eigenvalues and, optionally, eigenvectors of a
          !! complex Hermitian matrix in packed storage.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chpev( jobz, uplo, n, ap, w, z, ldz, work, rwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chpev
#else
               module procedure stdlib_chpev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhpev( jobz, uplo, n, ap, w, z, ldz, work, rwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhpev
#else
               module procedure stdlib_zhpev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine chpev( jobz, uplo, n, ap, w, z, ldz, work, rwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldz,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chpev
#else
               module procedure stdlib_I64_chpev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zhpev( jobz, uplo, n, ap, w, z, ldz, work, rwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldz,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhpev
#else
               module procedure stdlib_I64_zhpev
#endif
          end interface hpev

          interface hpevd
          !! HPEVD computes all the eigenvalues and, optionally, eigenvectors of
          !! a complex Hermitian matrix A in packed storage.  If eigenvectors are
          !! desired, it uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chpevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,rwork, lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chpevd
#else
               module procedure stdlib_chpevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhpevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,rwork, lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhpevd
#else
               module procedure stdlib_zhpevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine chpevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,rwork, lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldz,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chpevd
#else
               module procedure stdlib_I64_chpevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zhpevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,rwork, lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldz,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhpevd
#else
               module procedure stdlib_I64_zhpevd
#endif
          end interface hpevd

          interface hpgst
          !! HPGST reduces a complex Hermitian-definite generalized
          !! eigenproblem to standard form, using packed storage.
          !! If ITYPE = 1, the problem is A*x = lambda*B*x,
          !! and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
          !! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
          !! B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.
          !! B must have been previously factorized as U**H*U or L*L**H by CPPTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chpgst( itype, uplo, n, ap, bp, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,n
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(in) :: bp(*)
               end subroutine chpgst
#else
               module procedure stdlib_chpgst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhpgst( itype, uplo, n, ap, bp, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,n
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(in) :: bp(*)
               end subroutine zhpgst
#else
               module procedure stdlib_zhpgst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chpgst( itype, uplo, n, ap, bp, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: itype,n
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(in) :: bp(*)
               end subroutine chpgst
#else
               module procedure stdlib_I64_chpgst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhpgst( itype, uplo, n, ap, bp, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: itype,n
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(in) :: bp(*)
               end subroutine zhpgst
#else
               module procedure stdlib_I64_zhpgst
#endif
          end interface hpgst

          interface hpgv
          !! HPGV computes all the eigenvalues and, optionally, the eigenvectors
          !! of a complex generalized Hermitian-definite eigenproblem, of the form
          !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
          !! Here A and B are assumed to be Hermitian, stored in packed format,
          !! and B is also positive definite.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chpgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,rwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,ldz,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ap(*),bp(*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chpgv
#else
               module procedure stdlib_chpgv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhpgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,rwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,ldz,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ap(*),bp(*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhpgv
#else
               module procedure stdlib_zhpgv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine chpgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,rwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: itype,ldz,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ap(*),bp(*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chpgv
#else
               module procedure stdlib_I64_chpgv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zhpgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,rwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: itype,ldz,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ap(*),bp(*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhpgv
#else
               module procedure stdlib_I64_zhpgv
#endif
          end interface hpgv

          interface hpgvd
          !! HPGVD computes all the eigenvalues and, optionally, the eigenvectors
          !! of a complex generalized Hermitian-definite eigenproblem, of the form
          !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
          !! B are assumed to be Hermitian, stored in packed format, and B is also
          !! positive definite.
          !! If eigenvectors are desired, it uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chpgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: itype,ldz,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ap(*),bp(*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chpgvd
#else
               module procedure stdlib_chpgvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhpgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: itype,ldz,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ap(*),bp(*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhpgvd
#else
               module procedure stdlib_zhpgvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine chpgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: itype,ldz,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ap(*),bp(*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chpgvd
#else
               module procedure stdlib_I64_chpgvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zhpgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: itype,ldz,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ap(*),bp(*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhpgvd
#else
               module procedure stdlib_I64_zhpgvd
#endif
          end interface hpgvd

          interface hprfs
          !! HPRFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is Hermitian indefinite
          !! and packed, and provides error bounds and backward error estimates
          !! for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine chprfs
#else
               module procedure stdlib_chprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zhprfs
#else
               module procedure stdlib_zhprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine chprfs
#else
               module procedure stdlib_I64_chprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zhprfs
#else
               module procedure stdlib_I64_zhprfs
#endif
          end interface hprfs

          interface hpsv
          !! HPSV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N Hermitian matrix stored in packed format and X
          !! and B are N-by-NRHS matrices.
          !! The diagonal pivoting method is used to factor A as
          !! A = U * D * U**H,  if UPLO = 'U', or
          !! A = L * D * L**H,  if UPLO = 'L',
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, D is Hermitian and block diagonal with 1-by-1
          !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
          !! solve the system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chpsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine chpsv
#else
               module procedure stdlib_chpsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhpsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine zhpsv
#else
               module procedure stdlib_zhpsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chpsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine chpsv
#else
               module procedure stdlib_I64_chpsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhpsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine zhpsv
#else
               module procedure stdlib_I64_zhpsv
#endif
          end interface hpsv

          interface hptrd
          !! HPTRD reduces a complex Hermitian matrix A stored in packed form to
          !! real symmetric tridiagonal form T by a unitary similarity
          !! transformation: Q**H * A * Q = T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chptrd( uplo, n, ap, d, e, tau, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(out) :: tau(*)
               end subroutine chptrd
#else
               module procedure stdlib_chptrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhptrd( uplo, n, ap, d, e, tau, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(out) :: tau(*)
               end subroutine zhptrd
#else
               module procedure stdlib_zhptrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chptrd( uplo, n, ap, d, e, tau, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(out) :: tau(*)
               end subroutine chptrd
#else
               module procedure stdlib_I64_chptrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhptrd( uplo, n, ap, d, e, tau, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(out) :: tau(*)
               end subroutine zhptrd
#else
               module procedure stdlib_I64_zhptrd
#endif
          end interface hptrd

          interface hptrf
          !! HPTRF computes the factorization of a complex Hermitian packed
          !! matrix A using the Bunch-Kaufman diagonal pivoting method:
          !! A = U*D*U**H  or  A = L*D*L**H
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is Hermitian and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: ap(*)
               end subroutine chptrf
#else
               module procedure stdlib_chptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zhptrf
#else
               module procedure stdlib_zhptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: n
                    complex(sp), intent(inout) :: ap(*)
               end subroutine chptrf
#else
               module procedure stdlib_I64_chptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: n
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zhptrf
#else
               module procedure stdlib_I64_zhptrf
#endif
          end interface hptrf

          interface hptri
          !! HPTRI computes the inverse of a complex Hermitian indefinite matrix
          !! A in packed storage using the factorization A = U*D*U**H or
          !! A = L*D*L**H computed by CHPTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chptri
#else
               module procedure stdlib_chptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhptri
#else
               module procedure stdlib_zhptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,ipiv(*)
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chptri
#else
               module procedure stdlib_I64_chptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,ipiv(*)
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhptri
#else
               module procedure stdlib_I64_zhptri
#endif
          end interface hptri

          interface hptrs
          !! HPTRS solves a system of linear equations A*X = B with a complex
          !! Hermitian matrix A stored in packed format using the factorization
          !! A = U*D*U**H or A = L*D*L**H computed by CHPTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine chptrs
#else
               module procedure stdlib_chptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zhptrs
#else
               module procedure stdlib_zhptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine chptrs
#else
               module procedure stdlib_I64_chptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zhptrs
#else
               module procedure stdlib_I64_zhptrs
#endif
          end interface hptrs

          interface hsein
          !! HSEIN uses inverse iteration to find specified right and/or left
          !! eigenvectors of a complex upper Hessenberg matrix H.
          !! The right eigenvector x and the left eigenvector y of the matrix H
          !! corresponding to an eigenvalue w are defined by:
          !! H * x = w * x,     y**h * H = w * y**h
          !! where y**h denotes the conjugate transpose of the vector y.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chsein( side, eigsrc, initv, select, n, h, ldh, w, vl,ldvl, vr, ldvr, &
                         mm, m, work, rwork, ifaill,ifailr, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: eigsrc,initv,side
                    integer(ilp), intent(out) :: info,m,ifaill(*),ifailr(*)
                    integer(ilp), intent(in) :: ldh,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(in) :: h(ldh,*)
                    complex(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*),w(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chsein
#else
               module procedure stdlib_chsein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dhsein( side, eigsrc, initv, select, n, h, ldh, wr, wi,vl, ldvl, vr, &
                         ldvr, mm, m, work, ifaill,ifailr, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: eigsrc,initv,side
                    integer(ilp), intent(out) :: info,m,ifaill(*),ifailr(*)
                    integer(ilp), intent(in) :: ldh,ldvl,ldvr,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(dp), intent(in) :: h(ldh,*),wi(*)
                    real(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*),wr(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dhsein
#else
               module procedure stdlib_dhsein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine shsein( side, eigsrc, initv, select, n, h, ldh, wr, wi,vl, ldvl, vr, &
                         ldvr, mm, m, work, ifaill,ifailr, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: eigsrc,initv,side
                    integer(ilp), intent(out) :: info,m,ifaill(*),ifailr(*)
                    integer(ilp), intent(in) :: ldh,ldvl,ldvr,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(sp), intent(in) :: h(ldh,*),wi(*)
                    real(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*),wr(*)
                    real(sp), intent(out) :: work(*)
               end subroutine shsein
#else
               module procedure stdlib_shsein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhsein( side, eigsrc, initv, select, n, h, ldh, w, vl,ldvl, vr, ldvr, &
                         mm, m, work, rwork, ifaill,ifailr, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: eigsrc,initv,side
                    integer(ilp), intent(out) :: info,m,ifaill(*),ifailr(*)
                    integer(ilp), intent(in) :: ldh,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(in) :: h(ldh,*)
                    complex(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*),w(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhsein
#else
               module procedure stdlib_zhsein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine chsein( side, eigsrc, initv, select, n, h, ldh, w, vl,ldvl, vr, ldvr, &
                         mm, m, work, rwork, ifaill,ifailr, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: eigsrc,initv,side
                    integer(ilp64), intent(out) :: info,m,ifaill(*),ifailr(*)
                    integer(ilp64), intent(in) :: ldh,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(in) :: h(ldh,*)
                    complex(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*),w(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chsein
#else
               module procedure stdlib_I64_chsein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dhsein( side, eigsrc, initv, select, n, h, ldh, wr, wi,vl, ldvl, vr, &
                         ldvr, mm, m, work, ifaill,ifailr, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: eigsrc,initv,side
                    integer(ilp64), intent(out) :: info,m,ifaill(*),ifailr(*)
                    integer(ilp64), intent(in) :: ldh,ldvl,ldvr,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(dp), intent(in) :: h(ldh,*),wi(*)
                    real(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*),wr(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dhsein
#else
               module procedure stdlib_I64_dhsein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine shsein( side, eigsrc, initv, select, n, h, ldh, wr, wi,vl, ldvl, vr, &
                         ldvr, mm, m, work, ifaill,ifailr, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: eigsrc,initv,side
                    integer(ilp64), intent(out) :: info,m,ifaill(*),ifailr(*)
                    integer(ilp64), intent(in) :: ldh,ldvl,ldvr,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(sp), intent(in) :: h(ldh,*),wi(*)
                    real(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*),wr(*)
                    real(sp), intent(out) :: work(*)
               end subroutine shsein
#else
               module procedure stdlib_I64_shsein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zhsein( side, eigsrc, initv, select, n, h, ldh, w, vl,ldvl, vr, ldvr, &
                         mm, m, work, rwork, ifaill,ifailr, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: eigsrc,initv,side
                    integer(ilp64), intent(out) :: info,m,ifaill(*),ifailr(*)
                    integer(ilp64), intent(in) :: ldh,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(in) :: h(ldh,*)
                    complex(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*),w(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhsein
#else
               module procedure stdlib_I64_zhsein
#endif
          end interface hsein

          interface hseqr
          !! HSEQR computes the eigenvalues of a Hessenberg matrix H
          !! and, optionally, the matrices T and Z from the Schur decomposition
          !! H = Z T Z**H, where T is an upper triangular matrix (the
          !! Schur form), and Z is the unitary matrix of Schur vectors.
          !! Optionally Z may be postmultiplied into an input unitary
          !! matrix Q so that this routine can give the Schur factorization
          !! of a matrix A which has been reduced to the Hessenberg form H
          !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ilo,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    character, intent(in) :: compz,job
                    complex(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(sp), intent(out) :: w(*),work(*)
               end subroutine chseqr
#else
               module procedure stdlib_chseqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dhseqr( job, compz, n, ilo, ihi, h, ldh, wr, wi, z,ldz, work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ilo,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    character, intent(in) :: compz,job
                    real(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(dp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine dhseqr
#else
               module procedure stdlib_dhseqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine shseqr( job, compz, n, ilo, ihi, h, ldh, wr, wi, z,ldz, work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ilo,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    character, intent(in) :: compz,job
                    real(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(sp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine shseqr
#else
               module procedure stdlib_shseqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ilo,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    character, intent(in) :: compz,job
                    complex(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(dp), intent(out) :: w(*),work(*)
               end subroutine zhseqr
#else
               module procedure stdlib_zhseqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine chseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ilo,ldh,ldz,lwork,n
                    integer(ilp64), intent(out) :: info
                    character, intent(in) :: compz,job
                    complex(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(sp), intent(out) :: w(*),work(*)
               end subroutine chseqr
#else
               module procedure stdlib_I64_chseqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dhseqr( job, compz, n, ilo, ihi, h, ldh, wr, wi, z,ldz, work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ilo,ldh,ldz,lwork,n
                    integer(ilp64), intent(out) :: info
                    character, intent(in) :: compz,job
                    real(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(dp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine dhseqr
#else
               module procedure stdlib_I64_dhseqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine shseqr( job, compz, n, ilo, ihi, h, ldh, wr, wi, z,ldz, work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ilo,ldh,ldz,lwork,n
                    integer(ilp64), intent(out) :: info
                    character, intent(in) :: compz,job
                    real(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(sp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine shseqr
#else
               module procedure stdlib_I64_shseqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zhseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ilo,ldh,ldz,lwork,n
                    integer(ilp64), intent(out) :: info
                    character, intent(in) :: compz,job
                    complex(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(dp), intent(out) :: w(*),work(*)
               end subroutine zhseqr
#else
               module procedure stdlib_I64_zhseqr
#endif
          end interface hseqr

          interface isnan
          !! ISNAN returns .TRUE. if its argument is NaN, and .FALSE.
          !! otherwise.  To be replaced by the Fortran 2003 intrinsic in the
          !! future.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure logical(lk) function disnan( din )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: din
               end function disnan
#else
               module procedure stdlib_disnan
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure logical(lk) function sisnan( sin )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: sin
               end function sisnan
#else
               module procedure stdlib_sisnan
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure logical(lk) function disnan( din )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: din
               end function disnan
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure logical(lk) function sisnan( sin )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: sin
               end function sisnan
#endif
          end interface isnan

          interface la_gbamv
          !! LA_GBAMV performs one of the matrix-vector operations
          !! y := alpha*abs(A)*abs(x) + beta*abs(y),
          !! or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),
          !! where alpha and beta are scalars, x and y are vectors and A is an
          !! m by n matrix.
          !! This function is primarily used in calculating error bounds.
          !! To protect against underflow during evaluation, components in
          !! the resulting vector are perturbed away from zero by (N+1)
          !! times the underflow threshold.  To prevent unnecessarily large
          !! errors for block-structure embedded in general matrices,
          !! "symbolically" zero components are not perturbed.  A zero
          !! entry is considered "symbolic" if all multiplications involved
          !! in computing that entry have at least one zero multiplicand.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,incx, beta, y, incy )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: incx,incy,ldab,m,n,kl,ku,trans
                    complex(sp), intent(in) :: ab(ldab,*),x(*)
                    real(sp), intent(inout) :: y(*)
               end subroutine cla_gbamv
#else
               module procedure stdlib_cla_gbamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,incx, beta, y, incy )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta,ab(ldab,*),x(*)
                    integer(ilp), intent(in) :: incx,incy,ldab,m,n,kl,ku,trans
                    real(dp), intent(inout) :: y(*)
               end subroutine dla_gbamv
#else
               module procedure stdlib_dla_gbamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,incx, beta, y, incy )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta,ab(ldab,*),x(*)
                    integer(ilp), intent(in) :: incx,incy,ldab,m,n,kl,ku,trans
                    real(sp), intent(inout) :: y(*)
               end subroutine sla_gbamv
#else
               module procedure stdlib_sla_gbamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,incx, beta, y, incy )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: incx,incy,ldab,m,n,kl,ku,trans
                    complex(dp), intent(in) :: ab(ldab,*),x(*)
                    real(dp), intent(inout) :: y(*)
               end subroutine zla_gbamv
#else
               module procedure stdlib_zla_gbamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,incx, beta, y, incy )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta
                    integer(ilp64), intent(in) :: incx,incy,ldab,m,n,kl,ku,trans
                    complex(sp), intent(in) :: ab(ldab,*),x(*)
                    real(sp), intent(inout) :: y(*)
               end subroutine cla_gbamv
#else
               module procedure stdlib_I64_cla_gbamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,incx, beta, y, incy )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta,ab(ldab,*),x(*)
                    integer(ilp64), intent(in) :: incx,incy,ldab,m,n,kl,ku,trans
                    real(dp), intent(inout) :: y(*)
               end subroutine dla_gbamv
#else
               module procedure stdlib_I64_dla_gbamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,incx, beta, y, incy )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta,ab(ldab,*),x(*)
                    integer(ilp64), intent(in) :: incx,incy,ldab,m,n,kl,ku,trans
                    real(sp), intent(inout) :: y(*)
               end subroutine sla_gbamv
#else
               module procedure stdlib_I64_sla_gbamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,incx, beta, y, incy )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta
                    integer(ilp64), intent(in) :: incx,incy,ldab,m,n,kl,ku,trans
                    complex(dp), intent(in) :: ab(ldab,*),x(*)
                    real(dp), intent(inout) :: y(*)
               end subroutine zla_gbamv
#else
               module procedure stdlib_I64_zla_gbamv
#endif
          end interface la_gbamv

          interface la_gbrcond
          !! LA_GBRCOND Estimates the Skeel condition number of  op(A) * op2(C)
          !! where op2 is determined by CMODE as follows
          !! CMODE =  1    op2(C) = C
          !! CMODE =  0    op2(C) = I
          !! CMODE = -1    op2(C) = inv(C)
          !! The Skeel condition number  cond(A) = norminf( |inv(A)||A| )
          !! is computed by computing scaling factors R such that
          !! diag(R)*A*op2(C) is row equilibrated and computing the standard
          !! infinity-norm condition number.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dla_gbrcond( trans, n, kl, ku, ab, ldab,afb, ldafb, ipiv, cmode, &
                         c,info, work, iwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: n,ldab,ldafb,kl,ku,cmode,ipiv(*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: ab(ldab,*),afb(ldafb,*),c(*)
                    real(dp), intent(out) :: work(*)
               end function dla_gbrcond
#else
               module procedure stdlib_dla_gbrcond
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function sla_gbrcond( trans, n, kl, ku, ab, ldab, afb, ldafb,ipiv, cmode, &
                         c, info, work, iwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: n,ldab,ldafb,kl,ku,cmode,ipiv(*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: ab(ldab,*),afb(ldafb,*),c(*)
                    real(sp), intent(out) :: work(*)
               end function sla_gbrcond
#else
               module procedure stdlib_sla_gbrcond
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function dla_gbrcond( trans, n, kl, ku, ab, ldab,afb, ldafb, ipiv, cmode, &
                         c,info, work, iwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(in) :: n,ldab,ldafb,kl,ku,cmode,ipiv(*)
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: ab(ldab,*),afb(ldafb,*),c(*)
                    real(dp), intent(out) :: work(*)
               end function dla_gbrcond
#else
               module procedure stdlib_I64_dla_gbrcond
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp) function sla_gbrcond( trans, n, kl, ku, ab, ldab, afb, ldafb,ipiv, cmode, &
                         c, info, work, iwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(in) :: n,ldab,ldafb,kl,ku,cmode,ipiv(*)
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: ab(ldab,*),afb(ldafb,*),c(*)
                    real(sp), intent(out) :: work(*)
               end function sla_gbrcond
#else
               module procedure stdlib_I64_sla_gbrcond
#endif
          end interface la_gbrcond

          interface la_gbrcond_c
          !! LA_GBRCOND_C Computes the infinity norm condition number of
          !! op(A) * inv(diag(C)) where C is a REAL vector.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function cla_gbrcond_c( trans, n, kl, ku, ab, ldab, afb,ldafb, ipiv, c, &
                         capply, info, work,rwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,kl,ku,ldab,ldafb,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: ab(ldab,*),afb(ldafb,*)
                    complex(sp), intent(out) :: work(*)
                    real(sp), intent(in) :: c(*)
                    real(sp), intent(out) :: rwork(*)
               end function cla_gbrcond_c
#else
               module procedure stdlib_cla_gbrcond_c
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zla_gbrcond_c( trans, n, kl, ku, ab,ldab, afb, ldafb, ipiv,c, &
                         capply, info, work,rwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,kl,ku,ldab,ldafb,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: ab(ldab,*),afb(ldafb,*)
                    complex(dp), intent(out) :: work(*)
                    real(dp), intent(in) :: c(*)
                    real(dp), intent(out) :: rwork(*)
               end function zla_gbrcond_c
#else
               module procedure stdlib_zla_gbrcond_c
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp) function cla_gbrcond_c( trans, n, kl, ku, ab, ldab, afb,ldafb, ipiv, c, &
                         capply, info, work,rwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    logical(lk), intent(in) :: capply
                    integer(ilp64), intent(in) :: n,kl,ku,ldab,ldafb,ipiv(*)
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(in) :: ab(ldab,*),afb(ldafb,*)
                    complex(sp), intent(out) :: work(*)
                    real(sp), intent(in) :: c(*)
                    real(sp), intent(out) :: rwork(*)
               end function cla_gbrcond_c
#else
               module procedure stdlib_I64_cla_gbrcond_c
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zla_gbrcond_c( trans, n, kl, ku, ab,ldab, afb, ldafb, ipiv,c, &
                         capply, info, work,rwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    logical(lk), intent(in) :: capply
                    integer(ilp64), intent(in) :: n,kl,ku,ldab,ldafb,ipiv(*)
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(in) :: ab(ldab,*),afb(ldafb,*)
                    complex(dp), intent(out) :: work(*)
                    real(dp), intent(in) :: c(*)
                    real(dp), intent(out) :: rwork(*)
               end function zla_gbrcond_c
#else
               module procedure stdlib_I64_zla_gbrcond_c
#endif
          end interface la_gbrcond_c

          interface la_gbrpvgrw
          !! LA_GBRPVGRW computes the reciprocal pivot growth factor
          !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
          !! much less than 1, the stability of the LU factorization of the
          !! (equilibrated) matrix A could be poor. This also means that the
          !! solution X, estimated condition numbers, and error bounds could be
          !! unreliable.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp) function cla_gbrpvgrw( n, kl, ku, ncols, ab, ldab, afb,ldafb )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n,kl,ku,ncols,ldab,ldafb
                    complex(sp), intent(in) :: ab(ldab,*),afb(ldafb,*)
               end function cla_gbrpvgrw
#else
               module procedure stdlib_cla_gbrpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function dla_gbrpvgrw( n, kl, ku, ncols, ab,ldab, afb, ldafb )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n,kl,ku,ncols,ldab,ldafb
                    real(dp), intent(in) :: ab(ldab,*),afb(ldafb,*)
               end function dla_gbrpvgrw
#else
               module procedure stdlib_dla_gbrpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp) function sla_gbrpvgrw( n, kl, ku, ncols, ab, ldab, afb,ldafb )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n,kl,ku,ncols,ldab,ldafb
                    real(sp), intent(in) :: ab(ldab,*),afb(ldafb,*)
               end function sla_gbrpvgrw
#else
               module procedure stdlib_sla_gbrpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function zla_gbrpvgrw( n, kl, ku, ncols, ab,ldab, afb, ldafb )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n,kl,ku,ncols,ldab,ldafb
                    complex(dp), intent(in) :: ab(ldab,*),afb(ldafb,*)
               end function zla_gbrpvgrw
#else
               module procedure stdlib_zla_gbrpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(sp) function cla_gbrpvgrw( n, kl, ku, ncols, ab, ldab, afb,ldafb )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n,kl,ku,ncols,ldab,ldafb
                    complex(sp), intent(in) :: ab(ldab,*),afb(ldafb,*)
               end function cla_gbrpvgrw
#else
               module procedure stdlib_I64_cla_gbrpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(dp) function dla_gbrpvgrw( n, kl, ku, ncols, ab,ldab, afb, ldafb )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n,kl,ku,ncols,ldab,ldafb
                    real(dp), intent(in) :: ab(ldab,*),afb(ldafb,*)
               end function dla_gbrpvgrw
#else
               module procedure stdlib_I64_dla_gbrpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(sp) function sla_gbrpvgrw( n, kl, ku, ncols, ab, ldab, afb,ldafb )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n,kl,ku,ncols,ldab,ldafb
                    real(sp), intent(in) :: ab(ldab,*),afb(ldafb,*)
               end function sla_gbrpvgrw
#else
               module procedure stdlib_I64_sla_gbrpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(dp) function zla_gbrpvgrw( n, kl, ku, ncols, ab,ldab, afb, ldafb )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n,kl,ku,ncols,ldab,ldafb
                    complex(dp), intent(in) :: ab(ldab,*),afb(ldafb,*)
               end function zla_gbrpvgrw
#else
               module procedure stdlib_I64_zla_gbrpvgrw
#endif
          end interface la_gbrpvgrw

          interface la_geamv
          !! LA_GEAMV performs one of the matrix-vector operations
          !! y := alpha*abs(A)*abs(x) + beta*abs(y),
          !! or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),
          !! where alpha and beta are scalars, x and y are vectors and A is an
          !! m by n matrix.
          !! This function is primarily used in calculating error bounds.
          !! To protect against underflow during evaluation, components in
          !! the resulting vector are perturbed away from zero by (N+1)
          !! times the underflow threshold.  To prevent unnecessarily large
          !! errors for block-structure embedded in general matrices,
          !! "symbolically" zero components are not perturbed.  A zero
          !! entry is considered "symbolic" if all multiplications involved
          !! in computing that entry have at least one zero multiplicand.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cla_geamv( trans, m, n, alpha, a, lda, x, incx, beta,y, incy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: incx,incy,lda,m,n,trans
                    complex(sp), intent(in) :: a(lda,*),x(*)
                    real(sp), intent(inout) :: y(*)
               end subroutine cla_geamv
#else
               module procedure stdlib_cla_geamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dla_geamv ( trans, m, n, alpha, a, lda, x, incx, beta,y, incy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    integer(ilp), intent(in) :: incx,incy,lda,m,n,trans
                    real(dp), intent(inout) :: y(*)
               end subroutine dla_geamv
#else
               module procedure stdlib_dla_geamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sla_geamv( trans, m, n, alpha, a, lda, x, incx, beta,y, incy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    integer(ilp), intent(in) :: incx,incy,lda,m,n,trans
                    real(sp), intent(inout) :: y(*)
               end subroutine sla_geamv
#else
               module procedure stdlib_sla_geamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zla_geamv( trans, m, n, alpha, a, lda, x, incx, beta,y, incy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: incx,incy,lda,m,n,trans
                    complex(dp), intent(in) :: a(lda,*),x(*)
                    real(dp), intent(inout) :: y(*)
               end subroutine zla_geamv
#else
               module procedure stdlib_zla_geamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cla_geamv( trans, m, n, alpha, a, lda, x, incx, beta,y, incy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta
                    integer(ilp64), intent(in) :: incx,incy,lda,m,n,trans
                    complex(sp), intent(in) :: a(lda,*),x(*)
                    real(sp), intent(inout) :: y(*)
               end subroutine cla_geamv
#else
               module procedure stdlib_I64_cla_geamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dla_geamv ( trans, m, n, alpha, a, lda, x, incx, beta,y, incy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    integer(ilp64), intent(in) :: incx,incy,lda,m,n,trans
                    real(dp), intent(inout) :: y(*)
               end subroutine dla_geamv
#else
               module procedure stdlib_I64_dla_geamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sla_geamv( trans, m, n, alpha, a, lda, x, incx, beta,y, incy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    integer(ilp64), intent(in) :: incx,incy,lda,m,n,trans
                    real(sp), intent(inout) :: y(*)
               end subroutine sla_geamv
#else
               module procedure stdlib_I64_sla_geamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zla_geamv( trans, m, n, alpha, a, lda, x, incx, beta,y, incy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta
                    integer(ilp64), intent(in) :: incx,incy,lda,m,n,trans
                    complex(dp), intent(in) :: a(lda,*),x(*)
                    real(dp), intent(inout) :: y(*)
               end subroutine zla_geamv
#else
               module procedure stdlib_I64_zla_geamv
#endif
          end interface la_geamv

          interface la_gercond
          !! LA_GERCOND estimates the Skeel condition number of op(A) * op2(C)
          !! where op2 is determined by CMODE as follows
          !! CMODE =  1    op2(C) = C
          !! CMODE =  0    op2(C) = I
          !! CMODE = -1    op2(C) = inv(C)
          !! The Skeel condition number cond(A) = norminf( |inv(A)||A| )
          !! is computed by computing scaling factors R such that
          !! diag(R)*A*op2(C) is row equilibrated and computing the standard
          !! infinity-norm condition number.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dla_gercond( trans, n, a, lda, af,ldaf, ipiv, cmode, c,info, &
                         work, iwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: n,lda,ldaf,cmode,ipiv(*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(dp), intent(out) :: work(*)
               end function dla_gercond
#else
               module procedure stdlib_dla_gercond
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function sla_gercond( trans, n, a, lda, af, ldaf, ipiv,cmode, c, info, &
                         work, iwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: n,lda,ldaf,cmode,ipiv(*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(sp), intent(out) :: work(*)
               end function sla_gercond
#else
               module procedure stdlib_sla_gercond
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function dla_gercond( trans, n, a, lda, af,ldaf, ipiv, cmode, c,info, &
                         work, iwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(in) :: n,lda,ldaf,cmode,ipiv(*)
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(dp), intent(out) :: work(*)
               end function dla_gercond
#else
               module procedure stdlib_I64_dla_gercond
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp) function sla_gercond( trans, n, a, lda, af, ldaf, ipiv,cmode, c, info, &
                         work, iwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(in) :: n,lda,ldaf,cmode,ipiv(*)
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(sp), intent(out) :: work(*)
               end function sla_gercond
#else
               module procedure stdlib_I64_sla_gercond
#endif
          end interface la_gercond

          interface la_gercond_c
          !! LA_GERCOND_C computes the infinity norm condition number of
          !! op(A) * inv(diag(C)) where C is a REAL vector.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function cla_gercond_c( trans, n, a, lda, af, ldaf, ipiv, c,capply, info, &
                         work, rwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(sp), intent(out) :: work(*)
                    real(sp), intent(in) :: c(*)
                    real(sp), intent(out) :: rwork(*)
               end function cla_gercond_c
#else
               module procedure stdlib_cla_gercond_c
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zla_gercond_c( trans, n, a, lda, af,ldaf, ipiv, c, capply,info, &
                         work, rwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(dp), intent(out) :: work(*)
                    real(dp), intent(in) :: c(*)
                    real(dp), intent(out) :: rwork(*)
               end function zla_gercond_c
#else
               module procedure stdlib_zla_gercond_c
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp) function cla_gercond_c( trans, n, a, lda, af, ldaf, ipiv, c,capply, info, &
                         work, rwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    logical(lk), intent(in) :: capply
                    integer(ilp64), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(sp), intent(out) :: work(*)
                    real(sp), intent(in) :: c(*)
                    real(sp), intent(out) :: rwork(*)
               end function cla_gercond_c
#else
               module procedure stdlib_I64_cla_gercond_c
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zla_gercond_c( trans, n, a, lda, af,ldaf, ipiv, c, capply,info, &
                         work, rwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    logical(lk), intent(in) :: capply
                    integer(ilp64), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(dp), intent(out) :: work(*)
                    real(dp), intent(in) :: c(*)
                    real(dp), intent(out) :: rwork(*)
               end function zla_gercond_c
#else
               module procedure stdlib_I64_zla_gercond_c
#endif
          end interface la_gercond_c

          interface la_gerpvgrw
          !! LA_GERPVGRW computes the reciprocal pivot growth factor
          !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
          !! much less than 1, the stability of the LU factorization of the
          !! (equilibrated) matrix A could be poor. This also means that the
          !! solution X, estimated condition numbers, and error bounds could be
          !! unreliable.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp) function cla_gerpvgrw( n, ncols, a, lda, af, ldaf )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n,ncols,lda,ldaf
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
               end function cla_gerpvgrw
#else
               module procedure stdlib_cla_gerpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function dla_gerpvgrw( n, ncols, a, lda, af,ldaf )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n,ncols,lda,ldaf
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*)
               end function dla_gerpvgrw
#else
               module procedure stdlib_dla_gerpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp) function sla_gerpvgrw( n, ncols, a, lda, af, ldaf )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n,ncols,lda,ldaf
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*)
               end function sla_gerpvgrw
#else
               module procedure stdlib_sla_gerpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function zla_gerpvgrw( n, ncols, a, lda, af,ldaf )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n,ncols,lda,ldaf
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
               end function zla_gerpvgrw
#else
               module procedure stdlib_zla_gerpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(sp) function cla_gerpvgrw( n, ncols, a, lda, af, ldaf )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n,ncols,lda,ldaf
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
               end function cla_gerpvgrw
#else
               module procedure stdlib_I64_cla_gerpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(dp) function dla_gerpvgrw( n, ncols, a, lda, af,ldaf )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n,ncols,lda,ldaf
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*)
               end function dla_gerpvgrw
#else
               module procedure stdlib_I64_dla_gerpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(sp) function sla_gerpvgrw( n, ncols, a, lda, af, ldaf )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n,ncols,lda,ldaf
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*)
               end function sla_gerpvgrw
#else
               module procedure stdlib_I64_sla_gerpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(dp) function zla_gerpvgrw( n, ncols, a, lda, af,ldaf )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n,ncols,lda,ldaf
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
               end function zla_gerpvgrw
#else
               module procedure stdlib_I64_zla_gerpvgrw
#endif
          end interface la_gerpvgrw

          interface la_heamv
          !! CLA_SYAMV  performs the matrix-vector operation
          !! y := alpha*abs(A)*abs(x) + beta*abs(y),
          !! where alpha and beta are scalars, x and y are vectors and A is an
          !! n by n symmetric matrix.
          !! This function is primarily used in calculating error bounds.
          !! To protect against underflow during evaluation, components in
          !! the resulting vector are perturbed away from zero by (N+1)
          !! times the underflow threshold.  To prevent unnecessarily large
          !! errors for block-structure embedded in general matrices,
          !! "symbolically" zero components are not perturbed.  A zero
          !! entry is considered "symbolic" if all multiplications involved
          !! in computing that entry have at least one zero multiplicand.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cla_heamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: incx,incy,lda,n,uplo
                    complex(sp), intent(in) :: a(lda,*),x(*)
                    real(sp), intent(inout) :: y(*)
               end subroutine cla_heamv
#else
               module procedure stdlib_cla_heamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zla_heamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: incx,incy,lda,n,uplo
                    complex(dp), intent(in) :: a(lda,*),x(*)
                    real(dp), intent(inout) :: y(*)
               end subroutine zla_heamv
#else
               module procedure stdlib_zla_heamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cla_heamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta
                    integer(ilp64), intent(in) :: incx,incy,lda,n,uplo
                    complex(sp), intent(in) :: a(lda,*),x(*)
                    real(sp), intent(inout) :: y(*)
               end subroutine cla_heamv
#else
               module procedure stdlib_I64_cla_heamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zla_heamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta
                    integer(ilp64), intent(in) :: incx,incy,lda,n,uplo
                    complex(dp), intent(in) :: a(lda,*),x(*)
                    real(dp), intent(inout) :: y(*)
               end subroutine zla_heamv
#else
               module procedure stdlib_I64_zla_heamv
#endif
          end interface la_heamv

          interface la_hercond_c
          !! LA_HERCOND_C computes the infinity norm condition number of
          !! op(A) * inv(diag(C)) where C is a REAL vector.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function cla_hercond_c( uplo, n, a, lda, af, ldaf, ipiv, c,capply, info, &
                         work, rwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(sp), intent(out) :: work(*)
                    real(sp), intent(in) :: c(*)
                    real(sp), intent(out) :: rwork(*)
               end function cla_hercond_c
#else
               module procedure stdlib_cla_hercond_c
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zla_hercond_c( uplo, n, a, lda, af,ldaf, ipiv, c, capply,info, &
                         work, rwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(dp), intent(out) :: work(*)
                    real(dp), intent(in) :: c(*)
                    real(dp), intent(out) :: rwork(*)
               end function zla_hercond_c
#else
               module procedure stdlib_zla_hercond_c
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp) function cla_hercond_c( uplo, n, a, lda, af, ldaf, ipiv, c,capply, info, &
                         work, rwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp64), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(sp), intent(out) :: work(*)
                    real(sp), intent(in) :: c(*)
                    real(sp), intent(out) :: rwork(*)
               end function cla_hercond_c
#else
               module procedure stdlib_I64_cla_hercond_c
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zla_hercond_c( uplo, n, a, lda, af,ldaf, ipiv, c, capply,info, &
                         work, rwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp64), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(dp), intent(out) :: work(*)
                    real(dp), intent(in) :: c(*)
                    real(dp), intent(out) :: rwork(*)
               end function zla_hercond_c
#else
               module procedure stdlib_I64_zla_hercond_c
#endif
          end interface la_hercond_c

          interface la_herpvgrw
          !! LA_HERPVGRW computes the reciprocal pivot growth factor
          !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
          !! much less than 1, the stability of the LU factorization of the
          !! (equilibrated) matrix A could be poor. This also means that the
          !! solution X, estimated condition numbers, and error bounds could be
          !! unreliable.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function cla_herpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,work )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp), intent(out) :: work(*)
               end function cla_herpvgrw
#else
               module procedure stdlib_cla_herpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zla_herpvgrw( uplo, n, info, a, lda, af,ldaf, ipiv, work )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp), intent(out) :: work(*)
               end function zla_herpvgrw
#else
               module procedure stdlib_zla_herpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp) function cla_herpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,work )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp), intent(out) :: work(*)
               end function cla_herpvgrw
#else
               module procedure stdlib_I64_cla_herpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zla_herpvgrw( uplo, n, info, a, lda, af,ldaf, ipiv, work )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp), intent(out) :: work(*)
               end function zla_herpvgrw
#else
               module procedure stdlib_I64_zla_herpvgrw
#endif
          end interface la_herpvgrw

          interface la_lin_berr
          !! LA_LIN_BERR computes componentwise relative backward error from
          !! the formula
          !! max(i) ( abs(R(i)) / ( abs(op(A_s))*abs(Y) + abs(B_s) )(i) )
          !! where abs(Z) is the componentwise absolute value of the matrix
          !! or vector Z.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cla_lin_berr( n, nz, nrhs, res, ayb, berr )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n,nz,nrhs
                    real(sp), intent(in) :: ayb(n,nrhs)
                    real(sp), intent(out) :: berr(nrhs)
                    complex(sp), intent(in) :: res(n,nrhs)
               end subroutine cla_lin_berr
#else
               module procedure stdlib_cla_lin_berr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dla_lin_berr ( n, nz, nrhs, res, ayb, berr )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n,nz,nrhs
                    real(dp), intent(in) :: ayb(n,nrhs),res(n,nrhs)
                    real(dp), intent(out) :: berr(nrhs)
               end subroutine dla_lin_berr
#else
               module procedure stdlib_dla_lin_berr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sla_lin_berr( n, nz, nrhs, res, ayb, berr )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n,nz,nrhs
                    real(sp), intent(in) :: ayb(n,nrhs),res(n,nrhs)
                    real(sp), intent(out) :: berr(nrhs)
               end subroutine sla_lin_berr
#else
               module procedure stdlib_sla_lin_berr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zla_lin_berr( n, nz, nrhs, res, ayb, berr )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n,nz,nrhs
                    real(dp), intent(in) :: ayb(n,nrhs)
                    real(dp), intent(out) :: berr(nrhs)
                    complex(dp), intent(in) :: res(n,nrhs)
               end subroutine zla_lin_berr
#else
               module procedure stdlib_zla_lin_berr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cla_lin_berr( n, nz, nrhs, res, ayb, berr )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n,nz,nrhs
                    real(sp), intent(in) :: ayb(n,nrhs)
                    real(sp), intent(out) :: berr(nrhs)
                    complex(sp), intent(in) :: res(n,nrhs)
               end subroutine cla_lin_berr
#else
               module procedure stdlib_I64_cla_lin_berr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dla_lin_berr ( n, nz, nrhs, res, ayb, berr )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n,nz,nrhs
                    real(dp), intent(in) :: ayb(n,nrhs),res(n,nrhs)
                    real(dp), intent(out) :: berr(nrhs)
               end subroutine dla_lin_berr
#else
               module procedure stdlib_I64_dla_lin_berr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sla_lin_berr( n, nz, nrhs, res, ayb, berr )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n,nz,nrhs
                    real(sp), intent(in) :: ayb(n,nrhs),res(n,nrhs)
                    real(sp), intent(out) :: berr(nrhs)
               end subroutine sla_lin_berr
#else
               module procedure stdlib_I64_sla_lin_berr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zla_lin_berr( n, nz, nrhs, res, ayb, berr )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n,nz,nrhs
                    real(dp), intent(in) :: ayb(n,nrhs)
                    real(dp), intent(out) :: berr(nrhs)
                    complex(dp), intent(in) :: res(n,nrhs)
               end subroutine zla_lin_berr
#else
               module procedure stdlib_I64_zla_lin_berr
#endif
          end interface la_lin_berr

          interface la_porcond
          !! LA_PORCOND Estimates the Skeel condition number of  op(A) * op2(C)
          !! where op2 is determined by CMODE as follows
          !! CMODE =  1    op2(C) = C
          !! CMODE =  0    op2(C) = I
          !! CMODE = -1    op2(C) = inv(C)
          !! The Skeel condition number  cond(A) = norminf( |inv(A)||A| )
          !! is computed by computing scaling factors R such that
          !! diag(R)*A*op2(C) is row equilibrated and computing the standard
          !! infinity-norm condition number.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dla_porcond( uplo, n, a, lda, af, ldaf,cmode, c, info, work,&
                         iwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,ldaf,cmode
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(dp), intent(out) :: work(*)
               end function dla_porcond
#else
               module procedure stdlib_dla_porcond
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function sla_porcond( uplo, n, a, lda, af, ldaf, cmode, c,info, work, &
                         iwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,ldaf,cmode
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(sp), intent(out) :: work(*)
               end function sla_porcond
#else
               module procedure stdlib_sla_porcond
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function dla_porcond( uplo, n, a, lda, af, ldaf,cmode, c, info, work,&
                         iwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,lda,ldaf,cmode
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(dp), intent(out) :: work(*)
               end function dla_porcond
#else
               module procedure stdlib_I64_dla_porcond
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp) function sla_porcond( uplo, n, a, lda, af, ldaf, cmode, c,info, work, &
                         iwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,lda,ldaf,cmode
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(sp), intent(out) :: work(*)
               end function sla_porcond
#else
               module procedure stdlib_I64_sla_porcond
#endif
          end interface la_porcond

          interface la_porcond_c
          !! LA_PORCOND_C Computes the infinity norm condition number of
          !! op(A) * inv(diag(C)) where C is a REAL vector
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function cla_porcond_c( uplo, n, a, lda, af, ldaf, c, capply,info, work, &
                         rwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,lda,ldaf
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(sp), intent(out) :: work(*)
                    real(sp), intent(in) :: c(*)
                    real(sp), intent(out) :: rwork(*)
               end function cla_porcond_c
#else
               module procedure stdlib_cla_porcond_c
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zla_porcond_c( uplo, n, a, lda, af,ldaf, c, capply, info,work, &
                         rwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,lda,ldaf
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(dp), intent(out) :: work(*)
                    real(dp), intent(in) :: c(*)
                    real(dp), intent(out) :: rwork(*)
               end function zla_porcond_c
#else
               module procedure stdlib_zla_porcond_c
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp) function cla_porcond_c( uplo, n, a, lda, af, ldaf, c, capply,info, work, &
                         rwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp64), intent(in) :: n,lda,ldaf
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(sp), intent(out) :: work(*)
                    real(sp), intent(in) :: c(*)
                    real(sp), intent(out) :: rwork(*)
               end function cla_porcond_c
#else
               module procedure stdlib_I64_cla_porcond_c
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zla_porcond_c( uplo, n, a, lda, af,ldaf, c, capply, info,work, &
                         rwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp64), intent(in) :: n,lda,ldaf
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(dp), intent(out) :: work(*)
                    real(dp), intent(in) :: c(*)
                    real(dp), intent(out) :: rwork(*)
               end function zla_porcond_c
#else
               module procedure stdlib_I64_zla_porcond_c
#endif
          end interface la_porcond_c

          interface la_porpvgrw
          !! LA_PORPVGRW computes the reciprocal pivot growth factor
          !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
          !! much less than 1, the stability of the LU factorization of the
          !! (equilibrated) matrix A could be poor. This also means that the
          !! solution X, estimated condition numbers, and error bounds could be
          !! unreliable.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function cla_porpvgrw( uplo, ncols, a, lda, af, ldaf, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: ncols,lda,ldaf
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp), intent(out) :: work(*)
               end function cla_porpvgrw
#else
               module procedure stdlib_cla_porpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dla_porpvgrw( uplo, ncols, a, lda, af,ldaf, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: ncols,lda,ldaf
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp), intent(out) :: work(*)
               end function dla_porpvgrw
#else
               module procedure stdlib_dla_porpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function sla_porpvgrw( uplo, ncols, a, lda, af, ldaf, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: ncols,lda,ldaf
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp), intent(out) :: work(*)
               end function sla_porpvgrw
#else
               module procedure stdlib_sla_porpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zla_porpvgrw( uplo, ncols, a, lda, af,ldaf, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: ncols,lda,ldaf
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp), intent(out) :: work(*)
               end function zla_porpvgrw
#else
               module procedure stdlib_zla_porpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp) function cla_porpvgrw( uplo, ncols, a, lda, af, ldaf, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: ncols,lda,ldaf
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp), intent(out) :: work(*)
               end function cla_porpvgrw
#else
               module procedure stdlib_I64_cla_porpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function dla_porpvgrw( uplo, ncols, a, lda, af,ldaf, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: ncols,lda,ldaf
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp), intent(out) :: work(*)
               end function dla_porpvgrw
#else
               module procedure stdlib_I64_dla_porpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp) function sla_porpvgrw( uplo, ncols, a, lda, af, ldaf, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: ncols,lda,ldaf
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp), intent(out) :: work(*)
               end function sla_porpvgrw
#else
               module procedure stdlib_I64_sla_porpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zla_porpvgrw( uplo, ncols, a, lda, af,ldaf, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: ncols,lda,ldaf
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp), intent(out) :: work(*)
               end function zla_porpvgrw
#else
               module procedure stdlib_I64_zla_porpvgrw
#endif
          end interface la_porpvgrw

          interface la_syamv
          !! LA_SYAMV performs the matrix-vector operation
          !! y := alpha*abs(A)*abs(x) + beta*abs(y),
          !! where alpha and beta are scalars, x and y are vectors and A is an
          !! n by n symmetric matrix.
          !! This function is primarily used in calculating error bounds.
          !! To protect against underflow during evaluation, components in
          !! the resulting vector are perturbed away from zero by (N+1)
          !! times the underflow threshold.  To prevent unnecessarily large
          !! errors for block-structure embedded in general matrices,
          !! "symbolically" zero components are not perturbed.  A zero
          !! entry is considered "symbolic" if all multiplications involved
          !! in computing that entry have at least one zero multiplicand.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: incx,incy,lda,n,uplo
                    complex(sp), intent(in) :: a(lda,*),x(*)
                    real(sp), intent(inout) :: y(*)
               end subroutine cla_syamv
#else
               module procedure stdlib_cla_syamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    integer(ilp), intent(in) :: incx,incy,lda,n,uplo
                    real(dp), intent(inout) :: y(*)
               end subroutine dla_syamv
#else
               module procedure stdlib_dla_syamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    integer(ilp), intent(in) :: incx,incy,lda,n,uplo
                    real(sp), intent(inout) :: y(*)
               end subroutine sla_syamv
#else
               module procedure stdlib_sla_syamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: incx,incy,lda,n,uplo
                    complex(dp), intent(in) :: a(lda,*),x(*)
                    real(dp), intent(inout) :: y(*)
               end subroutine zla_syamv
#else
               module procedure stdlib_zla_syamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta
                    integer(ilp64), intent(in) :: incx,incy,lda,n,uplo
                    complex(sp), intent(in) :: a(lda,*),x(*)
                    real(sp), intent(inout) :: y(*)
               end subroutine cla_syamv
#else
               module procedure stdlib_I64_cla_syamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    integer(ilp64), intent(in) :: incx,incy,lda,n,uplo
                    real(dp), intent(inout) :: y(*)
               end subroutine dla_syamv
#else
               module procedure stdlib_I64_dla_syamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    integer(ilp64), intent(in) :: incx,incy,lda,n,uplo
                    real(sp), intent(inout) :: y(*)
               end subroutine sla_syamv
#else
               module procedure stdlib_I64_sla_syamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta
                    integer(ilp64), intent(in) :: incx,incy,lda,n,uplo
                    complex(dp), intent(in) :: a(lda,*),x(*)
                    real(dp), intent(inout) :: y(*)
               end subroutine zla_syamv
#else
               module procedure stdlib_I64_zla_syamv
#endif
          end interface la_syamv

          interface la_syrcond
          !! LA_SYRCOND estimates the Skeel condition number of  op(A) * op2(C)
          !! where op2 is determined by CMODE as follows
          !! CMODE =  1    op2(C) = C
          !! CMODE =  0    op2(C) = I
          !! CMODE = -1    op2(C) = inv(C)
          !! The Skeel condition number cond(A) = norminf( |inv(A)||A| )
          !! is computed by computing scaling factors R such that
          !! diag(R)*A*op2(C) is row equilibrated and computing the standard
          !! infinity-norm condition number.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dla_syrcond( uplo, n, a, lda, af, ldaf,ipiv, cmode, c, info, &
                         work,iwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,ldaf,cmode,ipiv(*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(dp), intent(out) :: work(*)
               end function dla_syrcond
#else
               module procedure stdlib_dla_syrcond
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function sla_syrcond( uplo, n, a, lda, af, ldaf, ipiv, cmode,c, info, &
                         work, iwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,ldaf,cmode,ipiv(*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(sp), intent(out) :: work(*)
               end function sla_syrcond
#else
               module procedure stdlib_sla_syrcond
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function dla_syrcond( uplo, n, a, lda, af, ldaf,ipiv, cmode, c, info, &
                         work,iwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,lda,ldaf,cmode,ipiv(*)
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(dp), intent(out) :: work(*)
               end function dla_syrcond
#else
               module procedure stdlib_I64_dla_syrcond
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp) function sla_syrcond( uplo, n, a, lda, af, ldaf, ipiv, cmode,c, info, &
                         work, iwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,lda,ldaf,cmode,ipiv(*)
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(sp), intent(out) :: work(*)
               end function sla_syrcond
#else
               module procedure stdlib_I64_sla_syrcond
#endif
          end interface la_syrcond

          interface la_syrcond_c
          !! LA_SYRCOND_C Computes the infinity norm condition number of
          !! op(A) * inv(diag(C)) where C is a REAL vector.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function cla_syrcond_c( uplo, n, a, lda, af, ldaf, ipiv, c,capply, info, &
                         work, rwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(sp), intent(out) :: work(*)
                    real(sp), intent(in) :: c(*)
                    real(sp), intent(out) :: rwork(*)
               end function cla_syrcond_c
#else
               module procedure stdlib_cla_syrcond_c
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zla_syrcond_c( uplo, n, a, lda, af,ldaf, ipiv, c, capply,info, &
                         work, rwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(dp), intent(out) :: work(*)
                    real(dp), intent(in) :: c(*)
                    real(dp), intent(out) :: rwork(*)
               end function zla_syrcond_c
#else
               module procedure stdlib_zla_syrcond_c
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp) function cla_syrcond_c( uplo, n, a, lda, af, ldaf, ipiv, c,capply, info, &
                         work, rwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp64), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(sp), intent(out) :: work(*)
                    real(sp), intent(in) :: c(*)
                    real(sp), intent(out) :: rwork(*)
               end function cla_syrcond_c
#else
               module procedure stdlib_I64_cla_syrcond_c
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zla_syrcond_c( uplo, n, a, lda, af,ldaf, ipiv, c, capply,info, &
                         work, rwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp64), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(dp), intent(out) :: work(*)
                    real(dp), intent(in) :: c(*)
                    real(dp), intent(out) :: rwork(*)
               end function zla_syrcond_c
#else
               module procedure stdlib_I64_zla_syrcond_c
#endif
          end interface la_syrcond_c

          interface la_syrpvgrw
          !! LA_SYRPVGRW computes the reciprocal pivot growth factor
          !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
          !! much less than 1, the stability of the LU factorization of the
          !! (equilibrated) matrix A could be poor. This also means that the
          !! solution X, estimated condition numbers, and error bounds could be
          !! unreliable.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function cla_syrpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,work )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp), intent(out) :: work(*)
               end function cla_syrpvgrw
#else
               module procedure stdlib_cla_syrpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dla_syrpvgrw( uplo, n, info, a, lda, af,ldaf, ipiv, work )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp), intent(out) :: work(*)
               end function dla_syrpvgrw
#else
               module procedure stdlib_dla_syrpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function sla_syrpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,work )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp), intent(out) :: work(*)
               end function sla_syrpvgrw
#else
               module procedure stdlib_sla_syrpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zla_syrpvgrw( uplo, n, info, a, lda, af,ldaf, ipiv, work )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp), intent(out) :: work(*)
               end function zla_syrpvgrw
#else
               module procedure stdlib_zla_syrpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp) function cla_syrpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,work )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp), intent(out) :: work(*)
               end function cla_syrpvgrw
#else
               module procedure stdlib_I64_cla_syrpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function dla_syrpvgrw( uplo, n, info, a, lda, af,ldaf, ipiv, work )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp), intent(out) :: work(*)
               end function dla_syrpvgrw
#else
               module procedure stdlib_I64_dla_syrpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp) function sla_syrpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,work )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp), intent(out) :: work(*)
               end function sla_syrpvgrw
#else
               module procedure stdlib_I64_sla_syrpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zla_syrpvgrw( uplo, n, info, a, lda, af,ldaf, ipiv, work )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp), intent(out) :: work(*)
               end function zla_syrpvgrw
#else
               module procedure stdlib_I64_zla_syrpvgrw
#endif
          end interface la_syrpvgrw

          interface la_wwaddw
          !! LA_WWADDW adds a vector W into a doubled-single vector (X, Y).
          !! This works for all extant IBM's hex and binary floating point
          !! arithmetic, but not for decimal.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cla_wwaddw( n, x, y, w )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: x(*),y(*)
                    complex(sp), intent(in) :: w(*)
               end subroutine cla_wwaddw
#else
               module procedure stdlib_cla_wwaddw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dla_wwaddw( n, x, y, w )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: x(*),y(*)
                    real(dp), intent(in) :: w(*)
               end subroutine dla_wwaddw
#else
               module procedure stdlib_dla_wwaddw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sla_wwaddw( n, x, y, w )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: x(*),y(*)
                    real(sp), intent(in) :: w(*)
               end subroutine sla_wwaddw
#else
               module procedure stdlib_sla_wwaddw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zla_wwaddw( n, x, y, w )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: x(*),y(*)
                    complex(dp), intent(in) :: w(*)
               end subroutine zla_wwaddw
#else
               module procedure stdlib_zla_wwaddw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cla_wwaddw( n, x, y, w )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n
                    complex(sp), intent(inout) :: x(*),y(*)
                    complex(sp), intent(in) :: w(*)
               end subroutine cla_wwaddw
#else
               module procedure stdlib_I64_cla_wwaddw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dla_wwaddw( n, x, y, w )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(inout) :: x(*),y(*)
                    real(dp), intent(in) :: w(*)
               end subroutine dla_wwaddw
#else
               module procedure stdlib_I64_dla_wwaddw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sla_wwaddw( n, x, y, w )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(inout) :: x(*),y(*)
                    real(sp), intent(in) :: w(*)
               end subroutine sla_wwaddw
#else
               module procedure stdlib_I64_sla_wwaddw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zla_wwaddw( n, x, y, w )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n
                    complex(dp), intent(inout) :: x(*),y(*)
                    complex(dp), intent(in) :: w(*)
               end subroutine zla_wwaddw
#else
               module procedure stdlib_I64_zla_wwaddw
#endif
          end interface la_wwaddw

          interface labad
          !! LABAD takes as input the values computed by DLAMCH for underflow and
          !! overflow, and returns the square root of each of these values if the
          !! log of LARGE is sufficiently large.  This subroutine is intended to
          !! identify machines with a large exponent range, such as the Crays, and
          !! redefine the underflow and overflow limits to be the square roots of
          !! the values computed by DLAMCH.  This subroutine is needed because
          !! DLAMCH does not compensate for poor arithmetic in the upper half of
          !! the exponent range, as is found on a Cray.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlabad( small, large )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(inout) :: large,small
               end subroutine dlabad
#else
               module procedure stdlib_dlabad
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slabad( small, large )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(inout) :: large,small
               end subroutine slabad
#else
               module procedure stdlib_slabad
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlabad( small, large )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(inout) :: large,small
               end subroutine dlabad
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slabad( small, large )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(inout) :: large,small
               end subroutine slabad
#endif
          end interface labad

          interface labrd
          !! LABRD reduces the first NB rows and columns of a complex general
          !! m by n matrix A to upper or lower real bidiagonal form by a unitary
          !! transformation Q**H * A * P, and returns the matrices X and Y which
          !! are needed to apply the transformation to the unreduced part of A.
          !! If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
          !! bidiagonal form.
          !! This is an auxiliary routine called by CGEBRD
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: lda,ldx,ldy,m,n,nb
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: taup(*),tauq(*),x(ldx,*),y(ldy,*)
               end subroutine clabrd
#else
               module procedure stdlib_clabrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: lda,ldx,ldy,m,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*),e(*),taup(*),tauq(*),x(ldx,*),y(ldy,*)
               end subroutine dlabrd
#else
               module procedure stdlib_dlabrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: lda,ldx,ldy,m,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*),e(*),taup(*),tauq(*),x(ldx,*),y(ldy,*)
               end subroutine slabrd
#else
               module procedure stdlib_slabrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: lda,ldx,ldy,m,n,nb
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: taup(*),tauq(*),x(ldx,*),y(ldy,*)
               end subroutine zlabrd
#else
               module procedure stdlib_zlabrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: lda,ldx,ldy,m,n,nb
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: taup(*),tauq(*),x(ldx,*),y(ldy,*)
               end subroutine clabrd
#else
               module procedure stdlib_I64_clabrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: lda,ldx,ldy,m,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*),e(*),taup(*),tauq(*),x(ldx,*),y(ldy,*)
               end subroutine dlabrd
#else
               module procedure stdlib_I64_dlabrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: lda,ldx,ldy,m,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*),e(*),taup(*),tauq(*),x(ldx,*),y(ldy,*)
               end subroutine slabrd
#else
               module procedure stdlib_I64_slabrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: lda,ldx,ldy,m,n,nb
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: taup(*),tauq(*),x(ldx,*),y(ldy,*)
               end subroutine zlabrd
#else
               module procedure stdlib_I64_zlabrd
#endif
          end interface labrd

          interface lacgv
          !! LACGV conjugates a complex vector of length N.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clacgv( n, x, incx )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,n
                    complex(sp), intent(inout) :: x(*)
               end subroutine clacgv
#else
               module procedure stdlib_clacgv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlacgv( n, x, incx )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,n
                    complex(dp), intent(inout) :: x(*)
               end subroutine zlacgv
#else
               module procedure stdlib_zlacgv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clacgv( n, x, incx )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,n
                    complex(sp), intent(inout) :: x(*)
               end subroutine clacgv
#else
               module procedure stdlib_I64_clacgv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlacgv( n, x, incx )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,n
                    complex(dp), intent(inout) :: x(*)
               end subroutine zlacgv
#else
               module procedure stdlib_I64_zlacgv
#endif
          end interface lacgv

          interface lacon
          !! LACON estimates the 1-norm of a square, complex matrix A.
          !! Reverse communication is used for evaluating matrix-vector products.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine clacon( n, v, x, est, kase )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(inout) :: kase
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: est
                    complex(sp), intent(out) :: v(n)
                    complex(sp), intent(inout) :: x(n)
               end subroutine clacon
#else
               module procedure stdlib_clacon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dlacon( n, v, x, isgn, est, kase )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(inout) :: kase
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: est,x(*)
                    integer(ilp), intent(out) :: isgn(*)
                    real(dp), intent(out) :: v(*)
               end subroutine dlacon
#else
               module procedure stdlib_dlacon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine slacon( n, v, x, isgn, est, kase )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(inout) :: kase
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: est,x(*)
                    integer(ilp), intent(out) :: isgn(*)
                    real(sp), intent(out) :: v(*)
               end subroutine slacon
#else
               module procedure stdlib_slacon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zlacon( n, v, x, est, kase )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(inout) :: kase
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: est
                    complex(dp), intent(out) :: v(n)
                    complex(dp), intent(inout) :: x(n)
               end subroutine zlacon
#else
               module procedure stdlib_zlacon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine clacon( n, v, x, est, kase )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(inout) :: kase
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(inout) :: est
                    complex(sp), intent(out) :: v(n)
                    complex(sp), intent(inout) :: x(n)
               end subroutine clacon
#else
               module procedure stdlib_I64_clacon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dlacon( n, v, x, isgn, est, kase )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(inout) :: kase
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(inout) :: est,x(*)
                    integer(ilp64), intent(out) :: isgn(*)
                    real(dp), intent(out) :: v(*)
               end subroutine dlacon
#else
               module procedure stdlib_I64_dlacon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine slacon( n, v, x, isgn, est, kase )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(inout) :: kase
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(inout) :: est,x(*)
                    integer(ilp64), intent(out) :: isgn(*)
                    real(sp), intent(out) :: v(*)
               end subroutine slacon
#else
               module procedure stdlib_I64_slacon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zlacon( n, v, x, est, kase )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(inout) :: kase
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(inout) :: est
                    complex(dp), intent(out) :: v(n)
                    complex(dp), intent(inout) :: x(n)
               end subroutine zlacon
#else
               module procedure stdlib_I64_zlacon
#endif
          end interface lacon

          interface lacpy
          !! LACPY copies all or part of a two-dimensional matrix A to another
          !! matrix B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clacpy( uplo, m, n, a, lda, b, ldb )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,ldb,m,n
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: b(ldb,*)
               end subroutine clacpy
#else
               module procedure stdlib_clacpy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlacpy( uplo, m, n, a, lda, b, ldb )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,ldb,m,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: b(ldb,*)
               end subroutine dlacpy
#else
               module procedure stdlib_dlacpy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slacpy( uplo, m, n, a, lda, b, ldb )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,ldb,m,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: b(ldb,*)
               end subroutine slacpy
#else
               module procedure stdlib_slacpy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlacpy( uplo, m, n, a, lda, b, ldb )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,ldb,m,n
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: b(ldb,*)
               end subroutine zlacpy
#else
               module procedure stdlib_zlacpy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clacpy( uplo, m, n, a, lda, b, ldb )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,ldb,m,n
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: b(ldb,*)
               end subroutine clacpy
#else
               module procedure stdlib_I64_clacpy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlacpy( uplo, m, n, a, lda, b, ldb )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,ldb,m,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: b(ldb,*)
               end subroutine dlacpy
#else
               module procedure stdlib_I64_dlacpy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slacpy( uplo, m, n, a, lda, b, ldb )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,ldb,m,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: b(ldb,*)
               end subroutine slacpy
#else
               module procedure stdlib_I64_slacpy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlacpy( uplo, m, n, a, lda, b, ldb )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,ldb,m,n
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: b(ldb,*)
               end subroutine zlacpy
#else
               module procedure stdlib_I64_zlacpy
#endif
          end interface lacpy

          interface lacrm
          !! LACRM performs a very simple matrix-matrix multiplication:
          !! C := A * B,
          !! where A is M by N and complex; B is N by N and real;
          !! C is M by N and complex.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clacrm( m, n, a, lda, b, ldb, c, ldc, rwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: lda,ldb,ldc,m,n
                    real(sp), intent(in) :: b(ldb,*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: c(ldc,*)
               end subroutine clacrm
#else
               module procedure stdlib_clacrm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlacrm( m, n, a, lda, b, ldb, c, ldc, rwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: lda,ldb,ldc,m,n
                    real(dp), intent(in) :: b(ldb,*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: c(ldc,*)
               end subroutine zlacrm
#else
               module procedure stdlib_zlacrm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clacrm( m, n, a, lda, b, ldb, c, ldc, rwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: lda,ldb,ldc,m,n
                    real(sp), intent(in) :: b(ldb,*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: c(ldc,*)
               end subroutine clacrm
#else
               module procedure stdlib_I64_clacrm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlacrm( m, n, a, lda, b, ldb, c, ldc, rwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: lda,ldb,ldc,m,n
                    real(dp), intent(in) :: b(ldb,*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: c(ldc,*)
               end subroutine zlacrm
#else
               module procedure stdlib_I64_zlacrm
#endif
          end interface lacrm

          interface lacrt
          !! LACRT performs the operation
          !! (  c  s )( x )  ==> ( x )
          !! ( -s  c )( y )      ( y )
          !! where c and s are complex and the vectors x and y are complex.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clacrt( n, cx, incx, cy, incy, c, s )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,incy,n
                    complex(sp), intent(in) :: c,s
                    complex(sp), intent(inout) :: cx(*),cy(*)
               end subroutine clacrt
#else
               module procedure stdlib_clacrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlacrt( n, cx, incx, cy, incy, c, s )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,incy,n
                    complex(dp), intent(in) :: c,s
                    complex(dp), intent(inout) :: cx(*),cy(*)
               end subroutine zlacrt
#else
               module procedure stdlib_zlacrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clacrt( n, cx, incx, cy, incy, c, s )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,incy,n
                    complex(sp), intent(in) :: c,s
                    complex(sp), intent(inout) :: cx(*),cy(*)
               end subroutine clacrt
#else
               module procedure stdlib_I64_clacrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlacrt( n, cx, incx, cy, incy, c, s )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,incy,n
                    complex(dp), intent(in) :: c,s
                    complex(dp), intent(inout) :: cx(*),cy(*)
               end subroutine zlacrt
#else
               module procedure stdlib_I64_zlacrt
#endif
          end interface lacrt

          interface ladiv_f
          !! LADIV_F := X / Y, where X and Y are complex.  The computation of X / Y
          !! will not overflow on an intermediary step unless the results
          !! overflows.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure complex(sp) function cladiv( x, y )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    complex(sp), intent(in) :: x,y
               end function cladiv
#else
               module procedure stdlib_cladiv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure complex(dp)     function zladiv( x, y )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    complex(dp), intent(in) :: x,y
               end function zladiv
#else
               module procedure stdlib_zladiv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure complex(sp) function cladiv( x, y )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    complex(sp), intent(in) :: x,y
               end function cladiv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure complex(dp)     function zladiv( x, y )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    complex(dp), intent(in) :: x,y
               end function zladiv
#endif
          end interface ladiv_f

          interface ladiv_s
          !! LADIV_S performs complex division in  real arithmetic
          !! a + i*b
          !! p + i*q = ---------
          !! c + i*d
          !! The algorithm is due to Michael Baudin and Robert L. Smith
          !! and can be found in the paper
          !! "A Robust Complex Division in Scilab"
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dladiv( a, b, c, d, p, q )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: a,b,c,d
                    real(dp), intent(out) :: p,q
               end subroutine dladiv
#else
               module procedure stdlib_dladiv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sladiv( a, b, c, d, p, q )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: a,b,c,d
                    real(sp), intent(out) :: p,q
               end subroutine sladiv
#else
               module procedure stdlib_sladiv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dladiv( a, b, c, d, p, q )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: a,b,c,d
                    real(dp), intent(out) :: p,q
               end subroutine dladiv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sladiv( a, b, c, d, p, q )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: a,b,c,d
                    real(sp), intent(out) :: p,q
               end subroutine sladiv
#endif
          end interface ladiv_s

          interface ladiv1
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dladiv1( a, b, c, d, p, q )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(inout) :: a
                    real(dp), intent(in) :: b,c,d
                    real(dp), intent(out) :: p,q
               end subroutine dladiv1
#else
               module procedure stdlib_dladiv1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sladiv1( a, b, c, d, p, q )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(inout) :: a
                    real(sp), intent(in) :: b,c,d
                    real(sp), intent(out) :: p,q
               end subroutine sladiv1
#else
               module procedure stdlib_sladiv1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dladiv1( a, b, c, d, p, q )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(inout) :: a
                    real(dp), intent(in) :: b,c,d
                    real(dp), intent(out) :: p,q
               end subroutine dladiv1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sladiv1( a, b, c, d, p, q )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(inout) :: a
                    real(sp), intent(in) :: b,c,d
                    real(sp), intent(out) :: p,q
               end subroutine sladiv1
#endif
          end interface ladiv1

          interface ladiv2
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function dladiv2( a, b, c, d, r, t )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: a,b,c,d,r,t
               end function dladiv2
#else
               module procedure stdlib_dladiv2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp) function sladiv2( a, b, c, d, r, t )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: a,b,c,d,r,t
               end function sladiv2
#else
               module procedure stdlib_sladiv2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(dp) function dladiv2( a, b, c, d, r, t )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: a,b,c,d,r,t
               end function dladiv2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(sp) function sladiv2( a, b, c, d, r, t )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: a,b,c,d,r,t
               end function sladiv2
#endif
          end interface ladiv2

          interface laebz
          !! LAEBZ contains the iteration loops which compute and use the
          !! function N(w), which is the count of eigenvalues of a symmetric
          !! tridiagonal matrix T less than or equal to its argument  w.  It
          !! performs a choice of two types of loops:
          !! IJOB=1, followed by
          !! IJOB=2: It takes as input a list of intervals and returns a list of
          !! sufficiently small intervals whose union contains the same
          !! eigenvalues as the union of the original intervals.
          !! The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.
          !! The output interval (AB(j,1),AB(j,2)] will contain
          !! eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 <= j <= MOUT.
          !! IJOB=3: It performs a binary search in each input interval
          !! (AB(j,1),AB(j,2)] for a point  w(j)  such that
          !! N(w(j))=NVAL(j), and uses  C(j)  as the starting point of
          !! the search.  If such a w(j) is found, then on output
          !! AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output
          !! (AB(j,1),AB(j,2)] will be a small interval containing the
          !! point where N(w) jumps through NVAL(j), unless that point
          !! lies outside the initial interval.
          !! Note that the intervals are in all cases half-open intervals,
          !! i.e., of the form  (a,b] , which includes  b  but not  a .
          !! To avoid underflow, the matrix should be scaled so that its largest
          !! element is no greater than  overflow**(1/2) * underflow**(1/4)
          !! in absolute value.  To assure the most accurate computation
          !! of small eigenvalues, the matrix should be scaled to be
          !! not much smaller than that, either.
          !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
          !! Matrix", Report CS41, Computer Science Dept., Stanford
          !! University, July 21, 1966
          !! Note: the arguments are, in general, *not* checked for unreasonable
          !! values.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaebz( ijob, nitmax, n, mmax, minp, nbmin, abstol,reltol, pivmin, &
                         d, e, e2, nval, ab, c, mout,nab, work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ijob,minp,mmax,n,nbmin,nitmax
                    integer(ilp), intent(out) :: info,mout,iwork(*)
                    real(dp), intent(in) :: abstol,pivmin,reltol,d(*),e(*),e2(*)
                    integer(ilp), intent(inout) :: nab(mmax,*),nval(*)
                    real(dp), intent(inout) :: ab(mmax,*),c(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlaebz
#else
               module procedure stdlib_dlaebz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaebz( ijob, nitmax, n, mmax, minp, nbmin, abstol,reltol, pivmin, &
                         d, e, e2, nval, ab, c, mout,nab, work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ijob,minp,mmax,n,nbmin,nitmax
                    integer(ilp), intent(out) :: info,mout,iwork(*)
                    real(sp), intent(in) :: abstol,pivmin,reltol,d(*),e(*),e2(*)
                    integer(ilp), intent(inout) :: nab(mmax,*),nval(*)
                    real(sp), intent(inout) :: ab(mmax,*),c(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slaebz
#else
               module procedure stdlib_slaebz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaebz( ijob, nitmax, n, mmax, minp, nbmin, abstol,reltol, pivmin, &
                         d, e, e2, nval, ab, c, mout,nab, work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ijob,minp,mmax,n,nbmin,nitmax
                    integer(ilp64), intent(out) :: info,mout,iwork(*)
                    real(dp), intent(in) :: abstol,pivmin,reltol,d(*),e(*),e2(*)
                    integer(ilp64), intent(inout) :: nab(mmax,*),nval(*)
                    real(dp), intent(inout) :: ab(mmax,*),c(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlaebz
#else
               module procedure stdlib_I64_dlaebz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaebz( ijob, nitmax, n, mmax, minp, nbmin, abstol,reltol, pivmin, &
                         d, e, e2, nval, ab, c, mout,nab, work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ijob,minp,mmax,n,nbmin,nitmax
                    integer(ilp64), intent(out) :: info,mout,iwork(*)
                    real(sp), intent(in) :: abstol,pivmin,reltol,d(*),e(*),e2(*)
                    integer(ilp64), intent(inout) :: nab(mmax,*),nval(*)
                    real(sp), intent(inout) :: ab(mmax,*),c(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slaebz
#else
               module procedure stdlib_I64_slaebz
#endif
          end interface laebz

          interface laed0
          !! Using the divide and conquer method, LAED0: computes all eigenvalues
          !! of a symmetric tridiagonal matrix which is one diagonal block of
          !! those from reducing a dense or band Hermitian matrix and
          !! corresponding eigenvectors of the dense or band matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claed0( qsiz, n, d, e, q, ldq, qstore, ldqs, rwork,iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldq,ldqs,n,qsiz
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: q(ldq,*)
                    complex(sp), intent(out) :: qstore(ldqs,*)
               end subroutine claed0
#else
               module procedure stdlib_claed0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaed0( icompq, qsiz, n, d, e, q, ldq, qstore, ldqs,work, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: icompq,ldq,ldqs,n,qsiz
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(inout) :: d(*),e(*),q(ldq,*)
                    real(dp), intent(out) :: qstore(ldqs,*),work(*)
               end subroutine dlaed0
#else
               module procedure stdlib_dlaed0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaed0( icompq, qsiz, n, d, e, q, ldq, qstore, ldqs,work, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: icompq,ldq,ldqs,n,qsiz
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(inout) :: d(*),e(*),q(ldq,*)
                    real(sp), intent(out) :: qstore(ldqs,*),work(*)
               end subroutine slaed0
#else
               module procedure stdlib_slaed0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaed0( qsiz, n, d, e, q, ldq, qstore, ldqs, rwork,iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldq,ldqs,n,qsiz
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: q(ldq,*)
                    complex(dp), intent(out) :: qstore(ldqs,*)
               end subroutine zlaed0
#else
               module procedure stdlib_zlaed0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claed0( qsiz, n, d, e, q, ldq, qstore, ldqs, rwork,iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldq,ldqs,n,qsiz
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: q(ldq,*)
                    complex(sp), intent(out) :: qstore(ldqs,*)
               end subroutine claed0
#else
               module procedure stdlib_I64_claed0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaed0( icompq, qsiz, n, d, e, q, ldq, qstore, ldqs,work, iwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: icompq,ldq,ldqs,n,qsiz
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(dp), intent(inout) :: d(*),e(*),q(ldq,*)
                    real(dp), intent(out) :: qstore(ldqs,*),work(*)
               end subroutine dlaed0
#else
               module procedure stdlib_I64_dlaed0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaed0( icompq, qsiz, n, d, e, q, ldq, qstore, ldqs,work, iwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: icompq,ldq,ldqs,n,qsiz
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(sp), intent(inout) :: d(*),e(*),q(ldq,*)
                    real(sp), intent(out) :: qstore(ldqs,*),work(*)
               end subroutine slaed0
#else
               module procedure stdlib_I64_slaed0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaed0( qsiz, n, d, e, q, ldq, qstore, ldqs, rwork,iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldq,ldqs,n,qsiz
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: q(ldq,*)
                    complex(dp), intent(out) :: qstore(ldqs,*)
               end subroutine zlaed0
#else
               module procedure stdlib_I64_zlaed0
#endif
          end interface laed0

          interface laed1
          !! LAED1 computes the updated eigensystem of a diagonal
          !! matrix after modification by a rank-one symmetric matrix.  This
          !! routine is used only for the eigenproblem which requires all
          !! eigenvalues and eigenvectors of a tridiagonal matrix.  DLAED7 handles
          !! the case in which eigenvalues only or eigenvalues and eigenvectors
          !! of a full symmetric matrix (which was reduced to tridiagonal form)
          !! are desired.
          !! T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
          !! where Z = Q**T*u, u is a vector of length N with ones in the
          !! CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
          !! The eigenvectors of the original matrix are stored in Q, and the
          !! eigenvalues are in D.  The algorithm consists of three stages:
          !! The first stage consists of deflating the size of the problem
          !! when there are multiple eigenvalues or if there is a zero in
          !! the Z vector.  For each such occurrence the dimension of the
          !! secular equation problem is reduced by one.  This stage is
          !! performed by the routine DLAED2.
          !! The second stage consists of calculating the updated
          !! eigenvalues. This is done by finding the roots of the secular
          !! equation via the routine DLAED4 (as called by DLAED3).
          !! This routine also calculates the eigenvectors of the current
          !! problem.
          !! The final stage consists of computing the updated eigenvectors
          !! directly using the updated eigenvalues.  The eigenvectors for
          !! the current problem are multiplied with the eigenvectors from
          !! the overall problem.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaed1( n, d, q, ldq, indxq, rho, cutpnt, work, iwork,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: cutpnt,ldq,n
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(inout) :: rho,d(*),q(ldq,*)
                    integer(ilp), intent(inout) :: indxq(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlaed1
#else
               module procedure stdlib_dlaed1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaed1( n, d, q, ldq, indxq, rho, cutpnt, work, iwork,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: cutpnt,ldq,n
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(inout) :: rho,d(*),q(ldq,*)
                    integer(ilp), intent(inout) :: indxq(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slaed1
#else
               module procedure stdlib_slaed1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaed1( n, d, q, ldq, indxq, rho, cutpnt, work, iwork,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: cutpnt,ldq,n
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(dp), intent(inout) :: rho,d(*),q(ldq,*)
                    integer(ilp64), intent(inout) :: indxq(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlaed1
#else
               module procedure stdlib_I64_dlaed1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaed1( n, d, q, ldq, indxq, rho, cutpnt, work, iwork,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: cutpnt,ldq,n
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(sp), intent(inout) :: rho,d(*),q(ldq,*)
                    integer(ilp64), intent(inout) :: indxq(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slaed1
#else
               module procedure stdlib_I64_slaed1
#endif
          end interface laed1

          interface laed4
          !! This subroutine computes the I-th updated eigenvalue of a symmetric
          !! rank-one modification to a diagonal matrix whose elements are
          !! given in the array d, and that
          !! D(i) < D(j)  for  i < j
          !! and that RHO > 0.  This is arranged by the calling routine, and is
          !! no loss in generality.  The rank-one modified system is thus
          !! diag( D )  +  RHO * Z * Z_transpose.
          !! where we assume the Euclidean norm of Z is 1.
          !! The method consists of approximating the rational functions in the
          !! secular equation by simpler interpolating rational functions.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaed4( n, i, d, z, delta, rho, dlam, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: i,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(out) :: dlam,delta(*)
                    real(dp), intent(in) :: rho,d(*),z(*)
               end subroutine dlaed4
#else
               module procedure stdlib_dlaed4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaed4( n, i, d, z, delta, rho, dlam, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: i,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(out) :: dlam,delta(*)
                    real(sp), intent(in) :: rho,d(*),z(*)
               end subroutine slaed4
#else
               module procedure stdlib_slaed4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaed4( n, i, d, z, delta, rho, dlam, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: i,n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(out) :: dlam,delta(*)
                    real(dp), intent(in) :: rho,d(*),z(*)
               end subroutine dlaed4
#else
               module procedure stdlib_I64_dlaed4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaed4( n, i, d, z, delta, rho, dlam, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: i,n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(out) :: dlam,delta(*)
                    real(sp), intent(in) :: rho,d(*),z(*)
               end subroutine slaed4
#else
               module procedure stdlib_I64_slaed4
#endif
          end interface laed4

          interface laed5
          !! This subroutine computes the I-th eigenvalue of a symmetric rank-one
          !! modification of a 2-by-2 diagonal matrix
          !! diag( D )  +  RHO * Z * transpose(Z) .
          !! The diagonal elements in the array D are assumed to satisfy
          !! D(i) < D(j)  for  i < j .
          !! We also assume RHO > 0 and that the Euclidean norm of the vector
          !! Z is one.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaed5( i, d, z, delta, rho, dlam )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: i
                    real(dp), intent(out) :: dlam,delta(2)
                    real(dp), intent(in) :: rho,d(2),z(2)
               end subroutine dlaed5
#else
               module procedure stdlib_dlaed5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaed5( i, d, z, delta, rho, dlam )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: i
                    real(sp), intent(out) :: dlam,delta(2)
                    real(sp), intent(in) :: rho,d(2),z(2)
               end subroutine slaed5
#else
               module procedure stdlib_slaed5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaed5( i, d, z, delta, rho, dlam )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: i
                    real(dp), intent(out) :: dlam,delta(2)
                    real(dp), intent(in) :: rho,d(2),z(2)
               end subroutine dlaed5
#else
               module procedure stdlib_I64_dlaed5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaed5( i, d, z, delta, rho, dlam )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: i
                    real(sp), intent(out) :: dlam,delta(2)
                    real(sp), intent(in) :: rho,d(2),z(2)
               end subroutine slaed5
#else
               module procedure stdlib_I64_slaed5
#endif
          end interface laed5

          interface laed6
          !! LAED6 computes the positive or negative root (closest to the origin)
          !! of
          !! z(1)        z(2)        z(3)
          !! f(x) =   rho + --------- + ---------- + ---------
          !! d(1)-x      d(2)-x      d(3)-x
          !! It is assumed that
          !! if ORGATI = .true. the root is between d(2) and d(3);
          !! otherwise it is between d(1) and d(2)
          !! This routine will be called by DLAED4 when necessary. In most cases,
          !! the root sought is the smallest in magnitude, though it might not be
          !! in some extremely rare situations.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaed6( kniter, orgati, rho, d, z, finit, tau, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: orgati
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kniter
                    real(dp), intent(in) :: finit,rho,d(3),z(3)
                    real(dp), intent(out) :: tau
               end subroutine dlaed6
#else
               module procedure stdlib_dlaed6
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaed6( kniter, orgati, rho, d, z, finit, tau, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: orgati
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kniter
                    real(sp), intent(in) :: finit,rho,d(3),z(3)
                    real(sp), intent(out) :: tau
               end subroutine slaed6
#else
               module procedure stdlib_slaed6
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaed6( kniter, orgati, rho, d, z, finit, tau, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: orgati
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kniter
                    real(dp), intent(in) :: finit,rho,d(3),z(3)
                    real(dp), intent(out) :: tau
               end subroutine dlaed6
#else
               module procedure stdlib_I64_dlaed6
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaed6( kniter, orgati, rho, d, z, finit, tau, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: orgati
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kniter
                    real(sp), intent(in) :: finit,rho,d(3),z(3)
                    real(sp), intent(out) :: tau
               end subroutine slaed6
#else
               module procedure stdlib_I64_slaed6
#endif
          end interface laed6

          interface laed7
          !! LAED7 computes the updated eigensystem of a diagonal
          !! matrix after modification by a rank-one symmetric matrix. This
          !! routine is used only for the eigenproblem which requires all
          !! eigenvalues and optionally eigenvectors of a dense or banded
          !! Hermitian matrix that has been reduced to tridiagonal form.
          !! T = Q(in) ( D(in) + RHO * Z*Z**H ) Q**H(in) = Q(out) * D(out) * Q**H(out)
          !! where Z = Q**Hu, u is a vector of length N with ones in the
          !! CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
          !! The eigenvectors of the original matrix are stored in Q, and the
          !! eigenvalues are in D.  The algorithm consists of three stages:
          !! The first stage consists of deflating the size of the problem
          !! when there are multiple eigenvalues or if there is a zero in
          !! the Z vector.  For each such occurrence the dimension of the
          !! secular equation problem is reduced by one.  This stage is
          !! performed by the routine SLAED2.
          !! The second stage consists of calculating the updated
          !! eigenvalues. This is done by finding the roots of the secular
          !! equation via the routine SLAED4 (as called by SLAED3).
          !! This routine also calculates the eigenvectors of the current
          !! problem.
          !! The final stage consists of computing the updated eigenvectors
          !! directly using the updated eigenvalues.  The eigenvectors for
          !! the current problem are multiplied with the eigenvectors from
          !! the overall problem.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claed7( n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q,ldq, rho, &
               indxq, qstore, qptr, prmptr, perm,givptr, givcol, givnum, work, rwork, iwork,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: curlvl,curpbm,cutpnt,ldq,n,qsiz,tlvls
                    integer(ilp), intent(out) :: info,indxq(*),iwork(*)
                    real(sp), intent(inout) :: rho,d(*),givnum(2,*),qstore(*)
                    integer(ilp), intent(inout) :: givcol(2,*),givptr(*),perm(*),prmptr(*),qptr(*)

                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: q(ldq,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine claed7
#else
               module procedure stdlib_claed7
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaed7( icompq, n, qsiz, tlvls, curlvl, curpbm, d, q,ldq, indxq, &
               rho, cutpnt, qstore, qptr, prmptr,perm, givptr, givcol, givnum, work, iwork,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: curlvl,curpbm,cutpnt,icompq,ldq,n,qsiz,&
                              tlvls
                    integer(ilp), intent(out) :: info,indxq(*),iwork(*)
                    real(dp), intent(inout) :: rho,d(*),givnum(2,*),q(ldq,*),qstore(*)
                    integer(ilp), intent(inout) :: givcol(2,*),givptr(*),perm(*),prmptr(*),qptr(*)

                    real(dp), intent(out) :: work(*)
               end subroutine dlaed7
#else
               module procedure stdlib_dlaed7
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaed7( icompq, n, qsiz, tlvls, curlvl, curpbm, d, q,ldq, indxq, &
               rho, cutpnt, qstore, qptr, prmptr,perm, givptr, givcol, givnum, work, iwork,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: curlvl,curpbm,cutpnt,icompq,ldq,n,qsiz,&
                              tlvls
                    integer(ilp), intent(out) :: info,indxq(*),iwork(*)
                    real(sp), intent(inout) :: rho,d(*),givnum(2,*),q(ldq,*),qstore(*)
                    integer(ilp), intent(inout) :: givcol(2,*),givptr(*),perm(*),prmptr(*),qptr(*)

                    real(sp), intent(out) :: work(*)
               end subroutine slaed7
#else
               module procedure stdlib_slaed7
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaed7( n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q,ldq, rho, &
               indxq, qstore, qptr, prmptr, perm,givptr, givcol, givnum, work, rwork, iwork,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: curlvl,curpbm,cutpnt,ldq,n,qsiz,tlvls
                    integer(ilp), intent(out) :: info,indxq(*),iwork(*)
                    real(dp), intent(inout) :: rho,d(*),givnum(2,*),qstore(*)
                    integer(ilp), intent(inout) :: givcol(2,*),givptr(*),perm(*),prmptr(*),qptr(*)

                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: q(ldq,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlaed7
#else
               module procedure stdlib_zlaed7
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claed7( n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q,ldq, rho, &
               indxq, qstore, qptr, prmptr, perm,givptr, givcol, givnum, work, rwork, iwork,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: curlvl,curpbm,cutpnt,ldq,n,qsiz,tlvls
                    integer(ilp64), intent(out) :: info,indxq(*),iwork(*)
                    real(sp), intent(inout) :: rho,d(*),givnum(2,*),qstore(*)
                    integer(ilp64), intent(inout) :: givcol(2,*),givptr(*),perm(*),prmptr(*),qptr(*)

                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: q(ldq,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine claed7
#else
               module procedure stdlib_I64_claed7
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaed7( icompq, n, qsiz, tlvls, curlvl, curpbm, d, q,ldq, indxq, &
               rho, cutpnt, qstore, qptr, prmptr,perm, givptr, givcol, givnum, work, iwork,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: curlvl,curpbm,cutpnt,icompq,ldq,n,qsiz,&
                              tlvls
                    integer(ilp64), intent(out) :: info,indxq(*),iwork(*)
                    real(dp), intent(inout) :: rho,d(*),givnum(2,*),q(ldq,*),qstore(*)
                    integer(ilp64), intent(inout) :: givcol(2,*),givptr(*),perm(*),prmptr(*),qptr(*)

                    real(dp), intent(out) :: work(*)
               end subroutine dlaed7
#else
               module procedure stdlib_I64_dlaed7
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaed7( icompq, n, qsiz, tlvls, curlvl, curpbm, d, q,ldq, indxq, &
               rho, cutpnt, qstore, qptr, prmptr,perm, givptr, givcol, givnum, work, iwork,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: curlvl,curpbm,cutpnt,icompq,ldq,n,qsiz,&
                              tlvls
                    integer(ilp64), intent(out) :: info,indxq(*),iwork(*)
                    real(sp), intent(inout) :: rho,d(*),givnum(2,*),q(ldq,*),qstore(*)
                    integer(ilp64), intent(inout) :: givcol(2,*),givptr(*),perm(*),prmptr(*),qptr(*)

                    real(sp), intent(out) :: work(*)
               end subroutine slaed7
#else
               module procedure stdlib_I64_slaed7
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaed7( n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q,ldq, rho, &
               indxq, qstore, qptr, prmptr, perm,givptr, givcol, givnum, work, rwork, iwork,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: curlvl,curpbm,cutpnt,ldq,n,qsiz,tlvls
                    integer(ilp64), intent(out) :: info,indxq(*),iwork(*)
                    real(dp), intent(inout) :: rho,d(*),givnum(2,*),qstore(*)
                    integer(ilp64), intent(inout) :: givcol(2,*),givptr(*),perm(*),prmptr(*),qptr(*)

                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: q(ldq,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlaed7
#else
               module procedure stdlib_I64_zlaed7
#endif
          end interface laed7

          interface laed8
          !! LAED8 merges the two sets of eigenvalues together into a single
          !! sorted set.  Then it tries to deflate the size of the problem.
          !! There are two ways in which deflation can occur:  when two or more
          !! eigenvalues are close together or if there is a tiny element in the
          !! Z vector.  For each such occurrence the order of the related secular
          !! equation problem is reduced by one.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claed8( k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda,q2, ldq2, w, &
                         indxp, indx, indxq, perm, givptr,givcol, givnum, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: cutpnt,ldq,ldq2,n,qsiz
                    integer(ilp), intent(out) :: givptr,info,k,givcol(2,*),indx(*),indxp(*),perm(&
                              *)
                    real(sp), intent(inout) :: rho,d(*),z(*)
                    integer(ilp), intent(inout) :: indxq(*)
                    real(sp), intent(out) :: dlamda(*),givnum(2,*),w(*)
                    complex(sp), intent(inout) :: q(ldq,*)
                    complex(sp), intent(out) :: q2(ldq2,*)
               end subroutine claed8
#else
               module procedure stdlib_claed8
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho,cutpnt, z, &
                         dlamda, q2, ldq2, w, perm, givptr,givcol, givnum, indxp, indx, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: cutpnt,icompq,ldq,ldq2,n,qsiz
                    integer(ilp), intent(out) :: givptr,info,k,givcol(2,*),indx(*),indxp(*),perm(&
                              *)
                    real(dp), intent(inout) :: rho,d(*),q(ldq,*),z(*)
                    integer(ilp), intent(inout) :: indxq(*)
                    real(dp), intent(out) :: dlamda(*),givnum(2,*),q2(ldq2,*),w(*)
               end subroutine dlaed8
#else
               module procedure stdlib_dlaed8
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho,cutpnt, z, &
                         dlamda, q2, ldq2, w, perm, givptr,givcol, givnum, indxp, indx, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: cutpnt,icompq,ldq,ldq2,n,qsiz
                    integer(ilp), intent(out) :: givptr,info,k,givcol(2,*),indx(*),indxp(*),perm(&
                              *)
                    real(sp), intent(inout) :: rho,d(*),q(ldq,*),z(*)
                    integer(ilp), intent(inout) :: indxq(*)
                    real(sp), intent(out) :: dlamda(*),givnum(2,*),q2(ldq2,*),w(*)
               end subroutine slaed8
#else
               module procedure stdlib_slaed8
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaed8( k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda,q2, ldq2, w, &
                         indxp, indx, indxq, perm, givptr,givcol, givnum, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: cutpnt,ldq,ldq2,n,qsiz
                    integer(ilp), intent(out) :: givptr,info,k,givcol(2,*),indx(*),indxp(*),perm(&
                              *)
                    real(dp), intent(inout) :: rho,d(*),z(*)
                    integer(ilp), intent(inout) :: indxq(*)
                    real(dp), intent(out) :: dlamda(*),givnum(2,*),w(*)
                    complex(dp), intent(inout) :: q(ldq,*)
                    complex(dp), intent(out) :: q2(ldq2,*)
               end subroutine zlaed8
#else
               module procedure stdlib_zlaed8
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claed8( k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda,q2, ldq2, w, &
                         indxp, indx, indxq, perm, givptr,givcol, givnum, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: cutpnt,ldq,ldq2,n,qsiz
                    integer(ilp64), intent(out) :: givptr,info,k,givcol(2,*),indx(*),indxp(*),perm(&
                              *)
                    real(sp), intent(inout) :: rho,d(*),z(*)
                    integer(ilp64), intent(inout) :: indxq(*)
                    real(sp), intent(out) :: dlamda(*),givnum(2,*),w(*)
                    complex(sp), intent(inout) :: q(ldq,*)
                    complex(sp), intent(out) :: q2(ldq2,*)
               end subroutine claed8
#else
               module procedure stdlib_I64_claed8
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho,cutpnt, z, &
                         dlamda, q2, ldq2, w, perm, givptr,givcol, givnum, indxp, indx, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: cutpnt,icompq,ldq,ldq2,n,qsiz
                    integer(ilp64), intent(out) :: givptr,info,k,givcol(2,*),indx(*),indxp(*),perm(&
                              *)
                    real(dp), intent(inout) :: rho,d(*),q(ldq,*),z(*)
                    integer(ilp64), intent(inout) :: indxq(*)
                    real(dp), intent(out) :: dlamda(*),givnum(2,*),q2(ldq2,*),w(*)
               end subroutine dlaed8
#else
               module procedure stdlib_I64_dlaed8
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho,cutpnt, z, &
                         dlamda, q2, ldq2, w, perm, givptr,givcol, givnum, indxp, indx, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: cutpnt,icompq,ldq,ldq2,n,qsiz
                    integer(ilp64), intent(out) :: givptr,info,k,givcol(2,*),indx(*),indxp(*),perm(&
                              *)
                    real(sp), intent(inout) :: rho,d(*),q(ldq,*),z(*)
                    integer(ilp64), intent(inout) :: indxq(*)
                    real(sp), intent(out) :: dlamda(*),givnum(2,*),q2(ldq2,*),w(*)
               end subroutine slaed8
#else
               module procedure stdlib_I64_slaed8
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaed8( k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda,q2, ldq2, w, &
                         indxp, indx, indxq, perm, givptr,givcol, givnum, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: cutpnt,ldq,ldq2,n,qsiz
                    integer(ilp64), intent(out) :: givptr,info,k,givcol(2,*),indx(*),indxp(*),perm(&
                              *)
                    real(dp), intent(inout) :: rho,d(*),z(*)
                    integer(ilp64), intent(inout) :: indxq(*)
                    real(dp), intent(out) :: dlamda(*),givnum(2,*),w(*)
                    complex(dp), intent(inout) :: q(ldq,*)
                    complex(dp), intent(out) :: q2(ldq2,*)
               end subroutine zlaed8
#else
               module procedure stdlib_I64_zlaed8
#endif
          end interface laed8

          interface laed9
          !! LAED9 finds the roots of the secular equation, as defined by the
          !! values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
          !! appropriate calls to DLAED4 and then stores the new matrix of
          !! eigenvectors for use in calculating the next level of Z vectors.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaed9( k, kstart, kstop, n, d, q, ldq, rho, dlamda, w,s, lds, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,kstart,kstop,ldq,lds,n
                    real(dp), intent(in) :: rho
                    real(dp), intent(out) :: d(*),q(ldq,*),s(lds,*)
                    real(dp), intent(inout) :: dlamda(*),w(*)
               end subroutine dlaed9
#else
               module procedure stdlib_dlaed9
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaed9( k, kstart, kstop, n, d, q, ldq, rho, dlamda, w,s, lds, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,kstart,kstop,ldq,lds,n
                    real(sp), intent(in) :: rho
                    real(sp), intent(out) :: d(*),q(ldq,*),s(lds,*)
                    real(sp), intent(inout) :: dlamda(*),w(*)
               end subroutine slaed9
#else
               module procedure stdlib_slaed9
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaed9( k, kstart, kstop, n, d, q, ldq, rho, dlamda, w,s, lds, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,kstart,kstop,ldq,lds,n
                    real(dp), intent(in) :: rho
                    real(dp), intent(out) :: d(*),q(ldq,*),s(lds,*)
                    real(dp), intent(inout) :: dlamda(*),w(*)
               end subroutine dlaed9
#else
               module procedure stdlib_I64_dlaed9
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaed9( k, kstart, kstop, n, d, q, ldq, rho, dlamda, w,s, lds, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,kstart,kstop,ldq,lds,n
                    real(sp), intent(in) :: rho
                    real(sp), intent(out) :: d(*),q(ldq,*),s(lds,*)
                    real(sp), intent(inout) :: dlamda(*),w(*)
               end subroutine slaed9
#else
               module procedure stdlib_I64_slaed9
#endif
          end interface laed9

          interface laeda
          !! LAEDA computes the Z vector corresponding to the merge step in the
          !! CURLVLth step of the merge process with TLVLS steps for the CURPBMth
          !! problem.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, &
                         givnum, q, qptr, z, ztemp, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: curlvl,curpbm,n,tlvls,givcol(2,*),givptr(*),perm(&
                              *),prmptr(*),qptr(*)
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: givnum(2,*),q(*)
                    real(dp), intent(out) :: z(*),ztemp(*)
               end subroutine dlaeda
#else
               module procedure stdlib_dlaeda
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, &
                         givnum, q, qptr, z, ztemp, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: curlvl,curpbm,n,tlvls,givcol(2,*),givptr(*),perm(&
                              *),prmptr(*),qptr(*)
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: givnum(2,*),q(*)
                    real(sp), intent(out) :: z(*),ztemp(*)
               end subroutine slaeda
#else
               module procedure stdlib_slaeda
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, &
                         givnum, q, qptr, z, ztemp, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: curlvl,curpbm,n,tlvls,givcol(2,*),givptr(*),perm(&
                              *),prmptr(*),qptr(*)
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(in) :: givnum(2,*),q(*)
                    real(dp), intent(out) :: z(*),ztemp(*)
               end subroutine dlaeda
#else
               module procedure stdlib_I64_dlaeda
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, &
                         givnum, q, qptr, z, ztemp, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: curlvl,curpbm,n,tlvls,givcol(2,*),givptr(*),perm(&
                              *),prmptr(*),qptr(*)
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(in) :: givnum(2,*),q(*)
                    real(sp), intent(out) :: z(*),ztemp(*)
               end subroutine slaeda
#else
               module procedure stdlib_I64_slaeda
#endif
          end interface laeda

          interface laein
          !! LAEIN uses inverse iteration to find a right or left eigenvector
          !! corresponding to the eigenvalue W of a complex upper Hessenberg
          !! matrix H.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,eps3, &
                         smlnum, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: noinit,rightv
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldh,n
                    real(sp), intent(in) :: eps3,smlnum
                    complex(sp), intent(in) :: w,h(ldh,*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(out) :: b(ldb,*)
                    complex(sp), intent(inout) :: v(*)
               end subroutine claein
#else
               module procedure stdlib_claein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,ldb, work, &
                         eps3, smlnum, bignum, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: noinit,rightv
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldh,n
                    real(dp), intent(in) :: bignum,eps3,smlnum,wi,wr,h(ldh,*)
                    real(dp), intent(out) :: b(ldb,*),work(*)
                    real(dp), intent(inout) :: vi(*),vr(*)
               end subroutine dlaein
#else
               module procedure stdlib_dlaein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,ldb, work, &
                         eps3, smlnum, bignum, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: noinit,rightv
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldh,n
                    real(sp), intent(in) :: bignum,eps3,smlnum,wi,wr,h(ldh,*)
                    real(sp), intent(out) :: b(ldb,*),work(*)
                    real(sp), intent(inout) :: vi(*),vr(*)
               end subroutine slaein
#else
               module procedure stdlib_slaein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,eps3, &
                         smlnum, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: noinit,rightv
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldh,n
                    real(dp), intent(in) :: eps3,smlnum
                    complex(dp), intent(in) :: w,h(ldh,*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(out) :: b(ldb,*)
                    complex(dp), intent(inout) :: v(*)
               end subroutine zlaein
#else
               module procedure stdlib_zlaein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,eps3, &
                         smlnum, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: noinit,rightv
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldh,n
                    real(sp), intent(in) :: eps3,smlnum
                    complex(sp), intent(in) :: w,h(ldh,*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(out) :: b(ldb,*)
                    complex(sp), intent(inout) :: v(*)
               end subroutine claein
#else
               module procedure stdlib_I64_claein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,ldb, work, &
                         eps3, smlnum, bignum, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: noinit,rightv
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldh,n
                    real(dp), intent(in) :: bignum,eps3,smlnum,wi,wr,h(ldh,*)
                    real(dp), intent(out) :: b(ldb,*),work(*)
                    real(dp), intent(inout) :: vi(*),vr(*)
               end subroutine dlaein
#else
               module procedure stdlib_I64_dlaein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,ldb, work, &
                         eps3, smlnum, bignum, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: noinit,rightv
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldh,n
                    real(sp), intent(in) :: bignum,eps3,smlnum,wi,wr,h(ldh,*)
                    real(sp), intent(out) :: b(ldb,*),work(*)
                    real(sp), intent(inout) :: vi(*),vr(*)
               end subroutine slaein
#else
               module procedure stdlib_I64_slaein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,eps3, &
                         smlnum, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: noinit,rightv
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldh,n
                    real(dp), intent(in) :: eps3,smlnum
                    complex(dp), intent(in) :: w,h(ldh,*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(out) :: b(ldb,*)
                    complex(dp), intent(inout) :: v(*)
               end subroutine zlaein
#else
               module procedure stdlib_I64_zlaein
#endif
          end interface laein

          interface laesy
          !! LAESY computes the eigendecomposition of a 2-by-2 symmetric matrix
          !! ( ( A, B );( B, C ) )
          !! provided the norm of the matrix of eigenvectors is larger than
          !! some threshold value.
          !! RT1 is the eigenvalue of larger absolute value, and RT2 of
          !! smaller absolute value.  If the eigenvectors are computed, then
          !! on return ( CS1, SN1 ) is the unit eigenvector for RT1, hence
          !! [  CS1     SN1   ] . [ A  B ] . [ CS1    -SN1   ] = [ RT1  0  ]
          !! [ -SN1     CS1   ]   [ B  C ]   [ SN1     CS1   ]   [  0  RT2 ]
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claesy( a, b, c, rt1, rt2, evscal, cs1, sn1 )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    complex(sp), intent(in) :: a,b,c
                    complex(sp), intent(out) :: cs1,evscal,rt1,rt2,sn1
               end subroutine claesy
#else
               module procedure stdlib_claesy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaesy( a, b, c, rt1, rt2, evscal, cs1, sn1 )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    complex(dp), intent(in) :: a,b,c
                    complex(dp), intent(out) :: cs1,evscal,rt1,rt2,sn1
               end subroutine zlaesy
#else
               module procedure stdlib_zlaesy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claesy( a, b, c, rt1, rt2, evscal, cs1, sn1 )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    complex(sp), intent(in) :: a,b,c
                    complex(sp), intent(out) :: cs1,evscal,rt1,rt2,sn1
               end subroutine claesy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaesy( a, b, c, rt1, rt2, evscal, cs1, sn1 )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    complex(dp), intent(in) :: a,b,c
                    complex(dp), intent(out) :: cs1,evscal,rt1,rt2,sn1
               end subroutine zlaesy
#endif
          end interface laesy

          interface laexc
          !! LAEXC swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
          !! an upper quasi-triangular matrix T by an orthogonal similarity
          !! transformation.
          !! T must be in Schur canonical form, that is, block upper triangular
          !! with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
          !! has its diagonal elements equal and its off-diagonal elements of
          !! opposite sign.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dlaexc( wantq, n, t, ldt, q, ldq, j1, n1, n2, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: wantq
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: j1,ldq,ldt,n,n1,n2
                    real(dp), intent(inout) :: q(ldq,*),t(ldt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlaexc
#else
               module procedure stdlib_dlaexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine slaexc( wantq, n, t, ldt, q, ldq, j1, n1, n2, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: wantq
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: j1,ldq,ldt,n,n1,n2
                    real(sp), intent(inout) :: q(ldq,*),t(ldt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slaexc
#else
               module procedure stdlib_slaexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dlaexc( wantq, n, t, ldt, q, ldq, j1, n1, n2, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: wantq
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: j1,ldq,ldt,n,n1,n2
                    real(dp), intent(inout) :: q(ldq,*),t(ldt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlaexc
#else
               module procedure stdlib_I64_dlaexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine slaexc( wantq, n, t, ldt, q, ldq, j1, n1, n2, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: wantq
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: j1,ldq,ldt,n,n1,n2
                    real(sp), intent(inout) :: q(ldq,*),t(ldt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slaexc
#else
               module procedure stdlib_I64_slaexc
#endif
          end interface laexc

          interface lagtf
          !! LAGTF factorizes the matrix (T - lambda*I), where T is an n by n
          !! tridiagonal matrix and lambda is a scalar, as
          !! T - lambda*I = PLU,
          !! where P is a permutation matrix, L is a unit lower tridiagonal matrix
          !! with at most one non-zero sub-diagonal elements per column and U is
          !! an upper triangular matrix with at most two non-zero super-diagonal
          !! elements per column.
          !! The factorization is obtained by Gaussian elimination with partial
          !! pivoting and implicit row scaling.
          !! The parameter LAMBDA is included in the routine so that LAGTF may
          !! be used, in conjunction with DLAGTS, to obtain eigenvectors of T by
          !! inverse iteration.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlagtf( n, a, lambda, b, c, tol, d, in, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,in(*)
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: lambda,tol
                    real(dp), intent(inout) :: a(*),b(*),c(*)
                    real(dp), intent(out) :: d(*)
               end subroutine dlagtf
#else
               module procedure stdlib_dlagtf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slagtf( n, a, lambda, b, c, tol, d, in, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,in(*)
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: lambda,tol
                    real(sp), intent(inout) :: a(*),b(*),c(*)
                    real(sp), intent(out) :: d(*)
               end subroutine slagtf
#else
               module procedure stdlib_slagtf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlagtf( n, a, lambda, b, c, tol, d, in, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,in(*)
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: lambda,tol
                    real(dp), intent(inout) :: a(*),b(*),c(*)
                    real(dp), intent(out) :: d(*)
               end subroutine dlagtf
#else
               module procedure stdlib_I64_dlagtf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slagtf( n, a, lambda, b, c, tol, d, in, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,in(*)
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: lambda,tol
                    real(sp), intent(inout) :: a(*),b(*),c(*)
                    real(sp), intent(out) :: d(*)
               end subroutine slagtf
#else
               module procedure stdlib_I64_slagtf
#endif
          end interface lagtf

          interface lagtm
          !! LAGTM performs a matrix-vector product of the form
          !! B := alpha * A * X + beta * B
          !! where A is a tridiagonal matrix of order N, B and X are N by NRHS
          !! matrices, and alpha and beta are real scalars, each of which may be
          !! 0., 1., or -1.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,b, ldb )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(in) :: alpha,beta
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(in) :: d(*),dl(*),du(*),x(ldx,*)
               end subroutine clagtm
#else
               module procedure stdlib_clagtm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,b, ldb )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(in) :: alpha,beta,d(*),dl(*),du(*),x(ldx,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dlagtm
#else
               module procedure stdlib_dlagtm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,b, ldb )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(in) :: alpha,beta,d(*),dl(*),du(*),x(ldx,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine slagtm
#else
               module procedure stdlib_slagtm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,b, ldb )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(in) :: alpha,beta
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(in) :: d(*),dl(*),du(*),x(ldx,*)
               end subroutine zlagtm
#else
               module procedure stdlib_zlagtm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,b, ldb )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(in) :: alpha,beta
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(in) :: d(*),dl(*),du(*),x(ldx,*)
               end subroutine clagtm
#else
               module procedure stdlib_I64_clagtm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,b, ldb )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(in) :: alpha,beta,d(*),dl(*),du(*),x(ldx,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dlagtm
#else
               module procedure stdlib_I64_dlagtm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,b, ldb )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(in) :: alpha,beta,d(*),dl(*),du(*),x(ldx,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine slagtm
#else
               module procedure stdlib_I64_slagtm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,b, ldb )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(in) :: alpha,beta
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(in) :: d(*),dl(*),du(*),x(ldx,*)
               end subroutine zlagtm
#else
               module procedure stdlib_I64_zlagtm
#endif
          end interface lagtm

          interface lagts
          !! LAGTS may be used to solve one of the systems of equations
          !! (T - lambda*I)*x = y   or   (T - lambda*I)**T*x = y,
          !! where T is an n by n tridiagonal matrix, for x, following the
          !! factorization of (T - lambda*I) as
          !! (T - lambda*I) = P*L*U ,
          !! by routine DLAGTF. The choice of equation to be solved is
          !! controlled by the argument JOB, and in each case there is an option
          !! to perturb zero or very small diagonal elements of U, this option
          !! being intended for use in applications such as inverse iteration.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlagts( job, n, a, b, c, d, in, y, tol, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: job,n,in(*)
                    real(dp), intent(inout) :: tol,y(*)
                    real(dp), intent(in) :: a(*),b(*),c(*),d(*)
               end subroutine dlagts
#else
               module procedure stdlib_dlagts
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slagts( job, n, a, b, c, d, in, y, tol, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: job,n,in(*)
                    real(sp), intent(inout) :: tol,y(*)
                    real(sp), intent(in) :: a(*),b(*),c(*),d(*)
               end subroutine slagts
#else
               module procedure stdlib_slagts
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlagts( job, n, a, b, c, d, in, y, tol, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: job,n,in(*)
                    real(dp), intent(inout) :: tol,y(*)
                    real(dp), intent(in) :: a(*),b(*),c(*),d(*)
               end subroutine dlagts
#else
               module procedure stdlib_I64_dlagts
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slagts( job, n, a, b, c, d, in, y, tol, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: job,n,in(*)
                    real(sp), intent(inout) :: tol,y(*)
                    real(sp), intent(in) :: a(*),b(*),c(*),d(*)
               end subroutine slagts
#else
               module procedure stdlib_I64_slagts
#endif
          end interface lagts

          interface lahef
          !! LAHEF computes a partial factorization of a complex Hermitian
          !! matrix A using the Bunch-Kaufman diagonal pivoting method. The
          !! partial factorization has the form:
          !! A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:
          !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
          !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'
          !! ( L21  I ) (  0  A22 ) (  0      I     )
          !! where the order of D is at most NB. The actual order is returned in
          !! the argument KB, and is either NB or NB-1, or N if N <= NB.
          !! Note that U**H denotes the conjugate transpose of U.
          !! LAHEF is an auxiliary routine called by CHETRF. It uses blocked code
          !! (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
          !! A22 (if UPLO = 'L').
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clahef( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: w(ldw,*)
               end subroutine clahef
#else
               module procedure stdlib_clahef
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlahef( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: w(ldw,*)
               end subroutine zlahef
#else
               module procedure stdlib_zlahef
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clahef( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: w(ldw,*)
               end subroutine clahef
#else
               module procedure stdlib_I64_clahef
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlahef( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: w(ldw,*)
               end subroutine zlahef
#else
               module procedure stdlib_I64_zlahef
#endif
          end interface lahef

          interface lahef_aa
          !! LAHEF_AA factorizes a panel of a complex hermitian matrix A using
          !! the Aasen's algorithm. The panel consists of a set of NB rows of A
          !! when UPLO is U, or a set of NB columns when UPLO is L.
          !! In order to factorize the panel, the Aasen's algorithm requires the
          !! last row, or column, of the previous panel. The first row, or column,
          !! of A is set to be the first row, or column, of an identity matrix,
          !! which is used to factorize the first panel.
          !! The resulting J-th row of U, or J-th column of L, is stored in the
          !! (J-1)-th row, or column, of A (without the unit diagonals), while
          !! the diagonal and subdiagonal of A are overwritten by those of T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clahef_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp), intent(out) :: ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),h(ldh,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clahef_aa
#else
               module procedure stdlib_clahef_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlahef_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp), intent(out) :: ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),h(ldh,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlahef_aa
#else
               module procedure stdlib_zlahef_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clahef_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp64), intent(out) :: ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),h(ldh,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clahef_aa
#else
               module procedure stdlib_I64_clahef_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlahef_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp64), intent(out) :: ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),h(ldh,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlahef_aa
#else
               module procedure stdlib_I64_zlahef_aa
#endif
          end interface lahef_aa

          interface lahef_rk
          !! LAHEF_RK computes a partial factorization of a complex Hermitian
          !! matrix A using the bounded Bunch-Kaufman (rook) diagonal
          !! pivoting method. The partial factorization has the form:
          !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
          !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
          !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L',
          !! ( L21  I ) (  0  A22 ) (  0       I    )
          !! where the order of D is at most NB. The actual order is returned in
          !! the argument KB, and is either NB or NB-1, or N if N <= NB.
          !! LAHEF_RK is an auxiliary routine called by CHETRF_RK. It uses
          !! blocked code (calling Level 3 BLAS) to update the submatrix
          !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clahef_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: w(ldw,*),e(*)
               end subroutine clahef_rk
#else
               module procedure stdlib_clahef_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlahef_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: w(ldw,*),e(*)
               end subroutine zlahef_rk
#else
               module procedure stdlib_zlahef_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clahef_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: w(ldw,*),e(*)
               end subroutine clahef_rk
#else
               module procedure stdlib_I64_clahef_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlahef_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: w(ldw,*),e(*)
               end subroutine zlahef_rk
#else
               module procedure stdlib_I64_zlahef_rk
#endif
          end interface lahef_rk

          interface lahef_rook
          !! LAHEF_ROOK computes a partial factorization of a complex Hermitian
          !! matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting
          !! method. The partial factorization has the form:
          !! A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:
          !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
          !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'
          !! ( L21  I ) (  0  A22 ) (  0      I     )
          !! where the order of D is at most NB. The actual order is returned in
          !! the argument KB, and is either NB or NB-1, or N if N <= NB.
          !! Note that U**H denotes the conjugate transpose of U.
          !! LAHEF_ROOK is an auxiliary routine called by CHETRF_ROOK. It uses
          !! blocked code (calling Level 3 BLAS) to update the submatrix
          !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clahef_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: w(ldw,*)
               end subroutine clahef_rook
#else
               module procedure stdlib_clahef_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlahef_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: w(ldw,*)
               end subroutine zlahef_rook
#else
               module procedure stdlib_zlahef_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clahef_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: w(ldw,*)
               end subroutine clahef_rook
#else
               module procedure stdlib_I64_clahef_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlahef_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: w(ldw,*)
               end subroutine zlahef_rook
#else
               module procedure stdlib_I64_zlahef_rook
#endif
          end interface lahef_rook

          interface lahqr
          !! LAHQR is an auxiliary routine called by CHSEQR to update the
          !! eigenvalues and Schur decomposition already computed by CHSEQR, by
          !! dealing with the Hessenberg submatrix in rows and columns ILO to
          !! IHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(sp), intent(out) :: w(*)
               end subroutine clahqr
#else
               module procedure stdlib_clahqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, &
                         ldz, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(dp), intent(out) :: wi(*),wr(*)
               end subroutine dlahqr
#else
               module procedure stdlib_dlahqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, &
                         ldz, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(sp), intent(out) :: wi(*),wr(*)
               end subroutine slahqr
#else
               module procedure stdlib_slahqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(dp), intent(out) :: w(*)
               end subroutine zlahqr
#else
               module procedure stdlib_zlahqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,n
                    integer(ilp64), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(sp), intent(out) :: w(*)
               end subroutine clahqr
#else
               module procedure stdlib_I64_clahqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, &
                         ldz, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,n
                    integer(ilp64), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(dp), intent(out) :: wi(*),wr(*)
               end subroutine dlahqr
#else
               module procedure stdlib_I64_dlahqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, &
                         ldz, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,n
                    integer(ilp64), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(sp), intent(out) :: wi(*),wr(*)
               end subroutine slahqr
#else
               module procedure stdlib_I64_slahqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,n
                    integer(ilp64), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(dp), intent(out) :: w(*)
               end subroutine zlahqr
#else
               module procedure stdlib_I64_zlahqr
#endif
          end interface lahqr

          interface laic1
          !! LAIC1 applies one step of incremental condition estimation in
          !! its simplest version:
          !! Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j
          !! lower triangular matrix L, such that
          !! twonorm(L*x) = sest
          !! Then LAIC1 computes sestpr, s, c such that
          !! the vector
          !! [ s*x ]
          !! xhat = [  c  ]
          !! is an approximate singular vector of
          !! [ L      0  ]
          !! Lhat = [ w**H gamma ]
          !! in the sense that
          !! twonorm(Lhat*xhat) = sestpr.
          !! Depending on JOB, an estimate for the largest or smallest singular
          !! value is computed.
          !! Note that [s c]**H and sestpr**2 is an eigenpair of the system
          !! diag(sest*sest, 0) + [alpha  gamma] * [ conjg(alpha) ]
          !! [ conjg(gamma) ]
          !! where  alpha =  x**H*w.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claic1( job, j, x, sest, w, gamma, sestpr, s, c )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: j,job
                    real(sp), intent(in) :: sest
                    real(sp), intent(out) :: sestpr
                    complex(sp), intent(out) :: c,s
                    complex(sp), intent(in) :: gamma,w(j),x(j)
               end subroutine claic1
#else
               module procedure stdlib_claic1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaic1( job, j, x, sest, w, gamma, sestpr, s, c )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: j,job
                    real(dp), intent(out) :: c,s,sestpr
                    real(dp), intent(in) :: gamma,sest,w(j),x(j)
               end subroutine dlaic1
#else
               module procedure stdlib_dlaic1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaic1( job, j, x, sest, w, gamma, sestpr, s, c )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: j,job
                    real(sp), intent(out) :: c,s,sestpr
                    real(sp), intent(in) :: gamma,sest,w(j),x(j)
               end subroutine slaic1
#else
               module procedure stdlib_slaic1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaic1( job, j, x, sest, w, gamma, sestpr, s, c )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: j,job
                    real(dp), intent(in) :: sest
                    real(dp), intent(out) :: sestpr
                    complex(dp), intent(out) :: c,s
                    complex(dp), intent(in) :: gamma,w(j),x(j)
               end subroutine zlaic1
#else
               module procedure stdlib_zlaic1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claic1( job, j, x, sest, w, gamma, sestpr, s, c )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: j,job
                    real(sp), intent(in) :: sest
                    real(sp), intent(out) :: sestpr
                    complex(sp), intent(out) :: c,s
                    complex(sp), intent(in) :: gamma,w(j),x(j)
               end subroutine claic1
#else
               module procedure stdlib_I64_claic1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaic1( job, j, x, sest, w, gamma, sestpr, s, c )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: j,job
                    real(dp), intent(out) :: c,s,sestpr
                    real(dp), intent(in) :: gamma,sest,w(j),x(j)
               end subroutine dlaic1
#else
               module procedure stdlib_I64_dlaic1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaic1( job, j, x, sest, w, gamma, sestpr, s, c )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: j,job
                    real(sp), intent(out) :: c,s,sestpr
                    real(sp), intent(in) :: gamma,sest,w(j),x(j)
               end subroutine slaic1
#else
               module procedure stdlib_I64_slaic1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaic1( job, j, x, sest, w, gamma, sestpr, s, c )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: j,job
                    real(dp), intent(in) :: sest
                    real(dp), intent(out) :: sestpr
                    complex(dp), intent(out) :: c,s
                    complex(dp), intent(in) :: gamma,w(j),x(j)
               end subroutine zlaic1
#else
               module procedure stdlib_I64_zlaic1
#endif
          end interface laic1

          interface laisnan
          !! This routine is not for general use.  It exists solely to avoid
          !! over-optimization in DISNAN.
          !! LAISNAN checks for NaNs by comparing its two arguments for
          !! inequality.  NaN is the only floating-point value where NaN != NaN
          !! returns .TRUE.  To check for NaNs, pass the same variable as both
          !! arguments.
          !! A compiler must assume that the two arguments are
          !! not the same variable, and the test will not be optimized away.
          !! Interprocedural or whole-program optimization may delete this
          !! test.  The ISNAN functions will be replaced by the correct
          !! Fortran 03 intrinsic once the intrinsic is widely available.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure logical(lk) function dlaisnan( din1, din2 )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: din1,din2
               end function dlaisnan
#else
               module procedure stdlib_dlaisnan
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure logical(lk) function slaisnan( sin1, sin2 )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: sin1,sin2
               end function slaisnan
#else
               module procedure stdlib_slaisnan
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure logical(lk) function dlaisnan( din1, din2 )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: din1,din2
               end function dlaisnan
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure logical(lk) function slaisnan( sin1, sin2 )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: sin1,sin2
               end function slaisnan
#endif
          end interface laisnan

          interface lals0
          !! LALS0 applies back the multiplying factors of either the left or the
          !! right singular vector matrix of a diagonal matrix appended by a row
          !! to the right hand side matrix B in solving the least squares problem
          !! using the divide-and-conquer SVD approach.
          !! For the left singular vector matrix, three types of orthogonal
          !! matrices are involved:
          !! (1L) Givens rotations: the number of such rotations is GIVPTR; the
          !! pairs of columns/rows they were applied to are stored in GIVCOL;
          !! and the C- and S-values of these rotations are stored in GIVNUM.
          !! (2L) Permutation. The (NL+1)-st row of B is to be moved to the first
          !! row, and for J=2:N, PERM(J)-th row of B is to be moved to the
          !! J-th row.
          !! (3L) The left singular vector matrix of the remaining matrix.
          !! For the right singular vector matrix, four types of orthogonal
          !! matrices are involved:
          !! (1R) The right singular vector matrix of the remaining matrix.
          !! (2R) If SQRE = 1, one extra Givens rotation to generate the right
          !! null space.
          !! (3R) The inverse transformation of (2L).
          !! (4R) The inverse transformation of (1L).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
                         givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: givptr,icompq,k,ldb,ldbx,ldgcol,ldgnum,nl,nr,nrhs,&
                              sqre,givcol(ldgcol,*),perm(*)
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: c,s,difl(*),difr(ldgnum,*),givnum(ldgnum,*),poles(&
                              ldgnum,*),z(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(out) :: bx(ldbx,*)
               end subroutine clals0
#else
               module procedure stdlib_clals0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
                         givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: givptr,icompq,k,ldb,ldbx,ldgcol,ldgnum,nl,nr,nrhs,&
                              sqre,givcol(ldgcol,*),perm(*)
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: c,s,difl(*),difr(ldgnum,*),givnum(ldgnum,*),poles(&
                              ldgnum,*),z(*)
                    real(dp), intent(inout) :: b(ldb,*)
                    real(dp), intent(out) :: bx(ldbx,*),work(*)
               end subroutine dlals0
#else
               module procedure stdlib_dlals0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
                         givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: givptr,icompq,k,ldb,ldbx,ldgcol,ldgnum,nl,nr,nrhs,&
                              sqre,givcol(ldgcol,*),perm(*)
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: c,s,difl(*),difr(ldgnum,*),givnum(ldgnum,*),poles(&
                              ldgnum,*),z(*)
                    real(sp), intent(inout) :: b(ldb,*)
                    real(sp), intent(out) :: bx(ldbx,*),work(*)
               end subroutine slals0
#else
               module procedure stdlib_slals0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
                         givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: givptr,icompq,k,ldb,ldbx,ldgcol,ldgnum,nl,nr,nrhs,&
                              sqre,givcol(ldgcol,*),perm(*)
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: c,s,difl(*),difr(ldgnum,*),givnum(ldgnum,*),poles(&
                              ldgnum,*),z(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(out) :: bx(ldbx,*)
               end subroutine zlals0
#else
               module procedure stdlib_zlals0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
                         givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: givptr,icompq,k,ldb,ldbx,ldgcol,ldgnum,nl,nr,nrhs,&
                              sqre,givcol(ldgcol,*),perm(*)
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(in) :: c,s,difl(*),difr(ldgnum,*),givnum(ldgnum,*),poles(&
                              ldgnum,*),z(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(out) :: bx(ldbx,*)
               end subroutine clals0
#else
               module procedure stdlib_I64_clals0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
                         givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: givptr,icompq,k,ldb,ldbx,ldgcol,ldgnum,nl,nr,nrhs,&
                              sqre,givcol(ldgcol,*),perm(*)
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(in) :: c,s,difl(*),difr(ldgnum,*),givnum(ldgnum,*),poles(&
                              ldgnum,*),z(*)
                    real(dp), intent(inout) :: b(ldb,*)
                    real(dp), intent(out) :: bx(ldbx,*),work(*)
               end subroutine dlals0
#else
               module procedure stdlib_I64_dlals0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
                         givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: givptr,icompq,k,ldb,ldbx,ldgcol,ldgnum,nl,nr,nrhs,&
                              sqre,givcol(ldgcol,*),perm(*)
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(in) :: c,s,difl(*),difr(ldgnum,*),givnum(ldgnum,*),poles(&
                              ldgnum,*),z(*)
                    real(sp), intent(inout) :: b(ldb,*)
                    real(sp), intent(out) :: bx(ldbx,*),work(*)
               end subroutine slals0
#else
               module procedure stdlib_I64_slals0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
                         givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: givptr,icompq,k,ldb,ldbx,ldgcol,ldgnum,nl,nr,nrhs,&
                              sqre,givcol(ldgcol,*),perm(*)
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(in) :: c,s,difl(*),difr(ldgnum,*),givnum(ldgnum,*),poles(&
                              ldgnum,*),z(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(out) :: bx(ldbx,*)
               end subroutine zlals0
#else
               module procedure stdlib_I64_zlals0
#endif
          end interface lals0

          interface lalsa
          !! LALSA is an itermediate step in solving the least squares problem
          !! by computing the SVD of the coefficient matrix in compact form (The
          !! singular vectors are computed as products of simple orthorgonal
          !! matrices.).
          !! If ICOMPQ = 0, LALSA applies the inverse of the left singular vector
          !! matrix of an upper bidiagonal matrix to the right hand side; and if
          !! ICOMPQ = 1, LALSA applies the right singular vector matrix to the
          !! right hand side. The singular vector matrices were generated in
          !! compact form by LALSA.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, &
               difl, difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, rwork,iwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: icompq,ldb,ldbx,ldgcol,ldu,n,nrhs,smlsiz,givcol(&
                              ldgcol,*),givptr(*),k(*),perm(ldgcol,*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),z(ldu,*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(out) :: bx(ldbx,*)
               end subroutine clalsa
#else
               module procedure stdlib_clalsa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, &
               difl, difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, work,iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: icompq,ldb,ldbx,ldgcol,ldu,n,nrhs,smlsiz,givcol(&
                              ldgcol,*),givptr(*),k(*),perm(ldgcol,*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(inout) :: b(ldb,*)
                    real(dp), intent(out) :: bx(ldbx,*),work(*)
                    real(dp), intent(in) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),z(ldu,*)
               end subroutine dlalsa
#else
               module procedure stdlib_dlalsa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, &
               difl, difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, work,iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: icompq,ldb,ldbx,ldgcol,ldu,n,nrhs,smlsiz,givcol(&
                              ldgcol,*),givptr(*),k(*),perm(ldgcol,*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(inout) :: b(ldb,*)
                    real(sp), intent(out) :: bx(ldbx,*),work(*)
                    real(sp), intent(in) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),z(ldu,*)
               end subroutine slalsa
#else
               module procedure stdlib_slalsa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, &
               difl, difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, rwork,iwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: icompq,ldb,ldbx,ldgcol,ldu,n,nrhs,smlsiz,givcol(&
                              ldgcol,*),givptr(*),k(*),perm(ldgcol,*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),z(ldu,*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(out) :: bx(ldbx,*)
               end subroutine zlalsa
#else
               module procedure stdlib_zlalsa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, &
               difl, difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, rwork,iwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: icompq,ldb,ldbx,ldgcol,ldu,n,nrhs,smlsiz,givcol(&
                              ldgcol,*),givptr(*),k(*),perm(ldgcol,*)
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),z(ldu,*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(out) :: bx(ldbx,*)
               end subroutine clalsa
#else
               module procedure stdlib_I64_clalsa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, &
               difl, difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, work,iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: icompq,ldb,ldbx,ldgcol,ldu,n,nrhs,smlsiz,givcol(&
                              ldgcol,*),givptr(*),k(*),perm(ldgcol,*)
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(dp), intent(inout) :: b(ldb,*)
                    real(dp), intent(out) :: bx(ldbx,*),work(*)
                    real(dp), intent(in) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),z(ldu,*)
               end subroutine dlalsa
#else
               module procedure stdlib_I64_dlalsa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, &
               difl, difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, work,iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: icompq,ldb,ldbx,ldgcol,ldu,n,nrhs,smlsiz,givcol(&
                              ldgcol,*),givptr(*),k(*),perm(ldgcol,*)
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(sp), intent(inout) :: b(ldb,*)
                    real(sp), intent(out) :: bx(ldbx,*),work(*)
                    real(sp), intent(in) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),z(ldu,*)
               end subroutine slalsa
#else
               module procedure stdlib_I64_slalsa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, &
               difl, difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, rwork,iwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: icompq,ldb,ldbx,ldgcol,ldu,n,nrhs,smlsiz,givcol(&
                              ldgcol,*),givptr(*),k(*),perm(ldgcol,*)
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),z(ldu,*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(out) :: bx(ldbx,*)
               end subroutine zlalsa
#else
               module procedure stdlib_I64_zlalsa
#endif
          end interface lalsa

          interface lalsd
          !! LALSD uses the singular value decomposition of A to solve the least
          !! squares problem of finding X to minimize the Euclidean norm of each
          !! column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
          !! are N-by-NRHS. The solution X overwrites B.
          !! The singular values of A smaller than RCOND times the largest
          !! singular value are treated as zero in solving the least squares
          !! problem; in this case a minimum norm solution is returned.
          !! The actual singular values are returned in D in ascending order.
          !! This code makes very mild assumptions about floating point
          !! arithmetic. It will work on machines with a guard digit in
          !! add/subtract, or on those binary machines without guard digits
          !! which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
          !! It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, &
                         rwork, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,rank,iwork(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs,smlsiz
                    real(sp), intent(in) :: rcond
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clalsd
#else
               module procedure stdlib_clalsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, &
                         iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,rank,iwork(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs,smlsiz
                    real(dp), intent(in) :: rcond
                    real(dp), intent(inout) :: b(ldb,*),d(*),e(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlalsd
#else
               module procedure stdlib_dlalsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, &
                         iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,rank,iwork(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs,smlsiz
                    real(sp), intent(in) :: rcond
                    real(sp), intent(inout) :: b(ldb,*),d(*),e(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slalsd
#else
               module procedure stdlib_slalsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, &
                         rwork, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,rank,iwork(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs,smlsiz
                    real(dp), intent(in) :: rcond
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlalsd
#else
               module procedure stdlib_zlalsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, &
                         rwork, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,rank,iwork(*)
                    integer(ilp64), intent(in) :: ldb,n,nrhs,smlsiz
                    real(sp), intent(in) :: rcond
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clalsd
#else
               module procedure stdlib_I64_clalsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, &
                         iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,rank,iwork(*)
                    integer(ilp64), intent(in) :: ldb,n,nrhs,smlsiz
                    real(dp), intent(in) :: rcond
                    real(dp), intent(inout) :: b(ldb,*),d(*),e(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlalsd
#else
               module procedure stdlib_I64_dlalsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, &
                         iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,rank,iwork(*)
                    integer(ilp64), intent(in) :: ldb,n,nrhs,smlsiz
                    real(sp), intent(in) :: rcond
                    real(sp), intent(inout) :: b(ldb,*),d(*),e(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slalsd
#else
               module procedure stdlib_I64_slalsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, &
                         rwork, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,rank,iwork(*)
                    integer(ilp64), intent(in) :: ldb,n,nrhs,smlsiz
                    real(dp), intent(in) :: rcond
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlalsd
#else
               module procedure stdlib_I64_zlalsd
#endif
          end interface lalsd

          interface lamrg
          !! LAMRG will create a permutation list which will merge the elements
          !! of A (which is composed of two independently sorted sets) into a
          !! single set which is sorted in ascending order.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlamrg( n1, n2, a, dtrd1, dtrd2, index )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: dtrd1,dtrd2,n1,n2
                    integer(ilp), intent(out) :: index(*)
                    real(dp), intent(in) :: a(*)
               end subroutine dlamrg
#else
               module procedure stdlib_dlamrg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slamrg( n1, n2, a, strd1, strd2, index )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n1,n2,strd1,strd2
                    integer(ilp), intent(out) :: index(*)
                    real(sp), intent(in) :: a(*)
               end subroutine slamrg
#else
               module procedure stdlib_slamrg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlamrg( n1, n2, a, dtrd1, dtrd2, index )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: dtrd1,dtrd2,n1,n2
                    integer(ilp64), intent(out) :: index(*)
                    real(dp), intent(in) :: a(*)
               end subroutine dlamrg
#else
               module procedure stdlib_I64_dlamrg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slamrg( n1, n2, a, strd1, strd2, index )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n1,n2,strd1,strd2
                    integer(ilp64), intent(out) :: index(*)
                    real(sp), intent(in) :: a(*)
               end subroutine slamrg
#else
               module procedure stdlib_I64_slamrg
#endif
          end interface lamrg

          interface lamswlq
          !! LAMSWLQ overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product of blocked
          !! elementary reflectors computed by short wide LQ
          !! factorization (CLASWLQ)
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clamswlq( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    complex(sp), intent(in) :: a(lda,*),t(ldt,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: c(ldc,*)
               end subroutine clamswlq
#else
               module procedure stdlib_clamswlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlamswlq( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    real(dp), intent(in) :: a(lda,*),t(ldt,*)
                    real(dp), intent(out) :: work(*)
                    real(dp), intent(inout) :: c(ldc,*)
               end subroutine dlamswlq
#else
               module procedure stdlib_dlamswlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slamswlq( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    real(sp), intent(in) :: a(lda,*),t(ldt,*)
                    real(sp), intent(out) :: work(*)
                    real(sp), intent(inout) :: c(ldc,*)
               end subroutine slamswlq
#else
               module procedure stdlib_slamswlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlamswlq( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    complex(dp), intent(in) :: a(lda,*),t(ldt,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: c(ldc,*)
               end subroutine zlamswlq
#else
               module procedure stdlib_zlamswlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clamswlq( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    complex(sp), intent(in) :: a(lda,*),t(ldt,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: c(ldc,*)
               end subroutine clamswlq
#else
               module procedure stdlib_I64_clamswlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlamswlq( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    real(dp), intent(in) :: a(lda,*),t(ldt,*)
                    real(dp), intent(out) :: work(*)
                    real(dp), intent(inout) :: c(ldc,*)
               end subroutine dlamswlq
#else
               module procedure stdlib_I64_dlamswlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slamswlq( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    real(sp), intent(in) :: a(lda,*),t(ldt,*)
                    real(sp), intent(out) :: work(*)
                    real(sp), intent(inout) :: c(ldc,*)
               end subroutine slamswlq
#else
               module procedure stdlib_I64_slamswlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlamswlq( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    complex(dp), intent(in) :: a(lda,*),t(ldt,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: c(ldc,*)
               end subroutine zlamswlq
#else
               module procedure stdlib_I64_zlamswlq
#endif
          end interface lamswlq

          interface lamtsqr
          !! LAMTSQR overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product
          !! of blocked elementary reflectors computed by tall skinny
          !! QR factorization (CLATSQR)
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clamtsqr( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    complex(sp), intent(in) :: a(lda,*),t(ldt,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: c(ldc,*)
               end subroutine clamtsqr
#else
               module procedure stdlib_clamtsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlamtsqr( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    real(dp), intent(in) :: a(lda,*),t(ldt,*)
                    real(dp), intent(out) :: work(*)
                    real(dp), intent(inout) :: c(ldc,*)
               end subroutine dlamtsqr
#else
               module procedure stdlib_dlamtsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slamtsqr( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    real(sp), intent(in) :: a(lda,*),t(ldt,*)
                    real(sp), intent(out) :: work(*)
                    real(sp), intent(inout) :: c(ldc,*)
               end subroutine slamtsqr
#else
               module procedure stdlib_slamtsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlamtsqr( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    complex(dp), intent(in) :: a(lda,*),t(ldt,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: c(ldc,*)
               end subroutine zlamtsqr
#else
               module procedure stdlib_zlamtsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clamtsqr( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    complex(sp), intent(in) :: a(lda,*),t(ldt,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: c(ldc,*)
               end subroutine clamtsqr
#else
               module procedure stdlib_I64_clamtsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlamtsqr( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    real(dp), intent(in) :: a(lda,*),t(ldt,*)
                    real(dp), intent(out) :: work(*)
                    real(dp), intent(inout) :: c(ldc,*)
               end subroutine dlamtsqr
#else
               module procedure stdlib_I64_dlamtsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slamtsqr( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    real(sp), intent(in) :: a(lda,*),t(ldt,*)
                    real(sp), intent(out) :: work(*)
                    real(sp), intent(inout) :: c(ldc,*)
               end subroutine slamtsqr
#else
               module procedure stdlib_I64_slamtsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlamtsqr( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    complex(dp), intent(in) :: a(lda,*),t(ldt,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: c(ldc,*)
               end subroutine zlamtsqr
#else
               module procedure stdlib_I64_zlamtsqr
#endif
          end interface lamtsqr

          interface laneg
          !! LANEG computes the Sturm count, the number of negative pivots
          !! encountered while factoring tridiagonal T - sigma I = L D L^T.
          !! This implementation works directly on the factors without forming
          !! the tridiagonal matrix T.  The Sturm count is also the number of
          !! eigenvalues of T less than sigma.
          !! This routine is called from DLARRB.
          !! The current routine does not use the PIVMIN parameter but rather
          !! requires IEEE-754 propagation of Infinities and NaNs.  This
          !! routine also has no input range restrictions but does require
          !! default exception handling such that x/0 produces Inf when x is
          !! non-zero, and Inf/Inf produces NaN.  For more information, see:
          !! Marques, Riedy, and Voemel, "Benefits of IEEE-754 Features in
          !! Modern Symmetric Tridiagonal Eigensolvers," SIAM Journal on
          !! Scientific Computing, v28, n5, 2006.  DOI 10.1137/050641624
          !! (Tech report version in LAWN 172 with the same title.)
#ifdef STDLIB_EXTERNAL_LAPACK
               pure integer(ilp) function dlaneg( n, d, lld, sigma, pivmin, r )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n,r
                    real(dp), intent(in) :: pivmin,sigma,d(*),lld(*)
               end function dlaneg
#else
               module procedure stdlib_dlaneg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure integer(ilp) function slaneg( n, d, lld, sigma, pivmin, r )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n,r
                    real(sp), intent(in) :: pivmin,sigma,d(*),lld(*)
               end function slaneg
#else
               module procedure stdlib_slaneg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure integer(ilp64) function dlaneg( n, d, lld, sigma, pivmin, r )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n,r
                    real(dp), intent(in) :: pivmin,sigma,d(*),lld(*)
               end function dlaneg
#else
               module procedure stdlib_I64_dlaneg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure integer(ilp64) function slaneg( n, d, lld, sigma, pivmin, r )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n,r
                    real(sp), intent(in) :: pivmin,sigma,d(*),lld(*)
               end function slaneg
#else
               module procedure stdlib_I64_slaneg
#endif
          end interface laneg

          interface langb
          !! LANGB returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the element of  largest absolute value  of an
          !! n by n band matrix  A,  with kl sub-diagonals and ku super-diagonals.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clangb( norm, n, kl, ku, ab, ldab,work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: kl,ku,ldab,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end function clangb
#else
               module procedure stdlib_clangb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlangb( norm, n, kl, ku, ab, ldab,work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: kl,ku,ldab,n
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(out) :: work(*)
               end function dlangb
#else
               module procedure stdlib_dlangb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slangb( norm, n, kl, ku, ab, ldab,work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: kl,ku,ldab,n
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(out) :: work(*)
               end function slangb
#else
               module procedure stdlib_slangb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlangb( norm, n, kl, ku, ab, ldab,work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: kl,ku,ldab,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end function zlangb
#else
               module procedure stdlib_zlangb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function clangb( norm, n, kl, ku, ab, ldab,work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: kl,ku,ldab,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end function clangb
#else
               module procedure stdlib_I64_clangb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function dlangb( norm, n, kl, ku, ab, ldab,work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: kl,ku,ldab,n
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(out) :: work(*)
               end function dlangb
#else
               module procedure stdlib_I64_dlangb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function slangb( norm, n, kl, ku, ab, ldab,work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: kl,ku,ldab,n
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(out) :: work(*)
               end function slangb
#else
               module procedure stdlib_I64_slangb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zlangb( norm, n, kl, ku, ab, ldab,work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: kl,ku,ldab,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end function zlangb
#else
               module procedure stdlib_I64_zlangb
#endif
          end interface langb

          interface lange
          !! LANGE returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! complex matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clange( norm, m, n, a, lda, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: a(lda,*)
               end function clange
#else
               module procedure stdlib_clange
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlange( norm, m, n, a, lda, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end function dlange
#else
               module procedure stdlib_dlange
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slange( norm, m, n, a, lda, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end function slange
#else
               module procedure stdlib_slange
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlange( norm, m, n, a, lda, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: a(lda,*)
               end function zlange
#else
               module procedure stdlib_zlange
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function clange( norm, m, n, a, lda, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: a(lda,*)
               end function clange
#else
               module procedure stdlib_I64_clange
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function dlange( norm, m, n, a, lda, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end function dlange
#else
               module procedure stdlib_I64_dlange
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function slange( norm, m, n, a, lda, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end function slange
#else
               module procedure stdlib_I64_slange
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zlange( norm, m, n, a, lda, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: a(lda,*)
               end function zlange
#else
               module procedure stdlib_I64_zlange
#endif
          end interface lange

          interface langt
          !! LANGT returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! complex tridiagonal matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp)             function clangt( norm, n, dl, d, du )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(in) :: d(*),dl(*),du(*)
               end function clangt
#else
               module procedure stdlib_clangt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function dlangt( norm, n, dl, d, du )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: d(*),dl(*),du(*)
               end function dlangt
#else
               module procedure stdlib_dlangt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp)             function slangt( norm, n, dl, d, du )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: d(*),dl(*),du(*)
               end function slangt
#else
               module procedure stdlib_slangt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function zlangt( norm, n, dl, d, du )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(in) :: d(*),dl(*),du(*)
               end function zlangt
#else
               module procedure stdlib_zlangt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(sp)             function clangt( norm, n, dl, d, du )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: n
                    complex(sp), intent(in) :: d(*),dl(*),du(*)
               end function clangt
#else
               module procedure stdlib_I64_clangt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(dp) function dlangt( norm, n, dl, d, du )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: d(*),dl(*),du(*)
               end function dlangt
#else
               module procedure stdlib_I64_dlangt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(sp)             function slangt( norm, n, dl, d, du )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: d(*),dl(*),du(*)
               end function slangt
#else
               module procedure stdlib_I64_slangt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(dp) function zlangt( norm, n, dl, d, du )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: n
                    complex(dp), intent(in) :: d(*),dl(*),du(*)
               end function zlangt
#else
               module procedure stdlib_I64_zlangt
#endif
          end interface langt

          interface lanhb
          !! LANHB returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the element of  largest absolute value  of an
          !! n by n hermitian band matrix A,  with k super-diagonals.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clanhb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end function clanhb
#else
               module procedure stdlib_clanhb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlanhb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end function zlanhb
#else
               module procedure stdlib_zlanhb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function clanhb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: k,ldab,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end function clanhb
#else
               module procedure stdlib_I64_clanhb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zlanhb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: k,ldab,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end function zlanhb
#else
               module procedure stdlib_I64_zlanhb
#endif
          end interface lanhb

          interface lanhe
          !! LANHE returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! complex hermitian matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clanhe( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: a(lda,*)
               end function clanhe
#else
               module procedure stdlib_clanhe
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlanhe( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: a(lda,*)
               end function zlanhe
#else
               module procedure stdlib_zlanhe
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function clanhe( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: a(lda,*)
               end function clanhe
#else
               module procedure stdlib_I64_clanhe
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zlanhe( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: a(lda,*)
               end function zlanhe
#else
               module procedure stdlib_I64_zlanhe
#endif
          end interface lanhe

          interface lanhf
          !! LANHF returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! complex Hermitian matrix A in RFP format.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function clanhf( norm, transr, uplo, n, a, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,transr,uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: work(0:*)
                    complex(sp), intent(in) :: a(0:*)
               end function clanhf
#else
               module procedure stdlib_clanhf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlanhf( norm, transr, uplo, n, a, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,transr,uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: work(0:*)
                    complex(dp), intent(in) :: a(0:*)
               end function zlanhf
#else
               module procedure stdlib_zlanhf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp) function clanhf( norm, transr, uplo, n, a, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,transr,uplo
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(out) :: work(0:*)
                    complex(sp), intent(in) :: a(0:*)
               end function clanhf
#else
               module procedure stdlib_I64_clanhf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zlanhf( norm, transr, uplo, n, a, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,transr,uplo
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(out) :: work(0:*)
                    complex(dp), intent(in) :: a(0:*)
               end function zlanhf
#else
               module procedure stdlib_I64_zlanhf
#endif
          end interface lanhf

          interface lanhp
          !! LANHP returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! complex hermitian matrix A,  supplied in packed form.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clanhp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ap(*)
               end function clanhp
#else
               module procedure stdlib_clanhp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlanhp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ap(*)
               end function zlanhp
#else
               module procedure stdlib_zlanhp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function clanhp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ap(*)
               end function clanhp
#else
               module procedure stdlib_I64_clanhp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zlanhp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ap(*)
               end function zlanhp
#else
               module procedure stdlib_I64_zlanhp
#endif
          end interface lanhp

          interface lanhs
          !! LANHS returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! Hessenberg matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clanhs( norm, n, a, lda, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: a(lda,*)
               end function clanhs
#else
               module procedure stdlib_clanhs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlanhs( norm, n, a, lda, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end function dlanhs
#else
               module procedure stdlib_dlanhs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slanhs( norm, n, a, lda, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end function slanhs
#else
               module procedure stdlib_slanhs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlanhs( norm, n, a, lda, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: a(lda,*)
               end function zlanhs
#else
               module procedure stdlib_zlanhs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function clanhs( norm, n, a, lda, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: a(lda,*)
               end function clanhs
#else
               module procedure stdlib_I64_clanhs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function dlanhs( norm, n, a, lda, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end function dlanhs
#else
               module procedure stdlib_I64_dlanhs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function slanhs( norm, n, a, lda, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end function slanhs
#else
               module procedure stdlib_I64_slanhs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zlanhs( norm, n, a, lda, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: a(lda,*)
               end function zlanhs
#else
               module procedure stdlib_I64_zlanhs
#endif
          end interface lanhs

          interface lanht
          !! LANHT returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! complex Hermitian tridiagonal matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp)             function clanht( norm, n, d, e )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: d(*)
                    complex(sp), intent(in) :: e(*)
               end function clanht
#else
               module procedure stdlib_clanht
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function zlanht( norm, n, d, e )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: d(*)
                    complex(dp), intent(in) :: e(*)
               end function zlanht
#else
               module procedure stdlib_zlanht
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(sp)             function clanht( norm, n, d, e )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: d(*)
                    complex(sp), intent(in) :: e(*)
               end function clanht
#else
               module procedure stdlib_I64_clanht
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(dp) function zlanht( norm, n, d, e )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: d(*)
                    complex(dp), intent(in) :: e(*)
               end function zlanht
#else
               module procedure stdlib_I64_zlanht
#endif
          end interface lanht

          interface lansb
          !! LANSB returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the element of  largest absolute value  of an
          !! n by n symmetric band matrix A,  with k super-diagonals.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clansb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end function clansb
#else
               module procedure stdlib_clansb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlansb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(out) :: work(*)
               end function dlansb
#else
               module procedure stdlib_dlansb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slansb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(out) :: work(*)
               end function slansb
#else
               module procedure stdlib_slansb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlansb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end function zlansb
#else
               module procedure stdlib_zlansb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function clansb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: k,ldab,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end function clansb
#else
               module procedure stdlib_I64_clansb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function dlansb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: k,ldab,n
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(out) :: work(*)
               end function dlansb
#else
               module procedure stdlib_I64_dlansb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function slansb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: k,ldab,n
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(out) :: work(*)
               end function slansb
#else
               module procedure stdlib_I64_slansb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zlansb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: k,ldab,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end function zlansb
#else
               module procedure stdlib_I64_zlansb
#endif
          end interface lansb

          interface lansf
          !! LANSF returns the value of the one norm, or the Frobenius norm, or
          !! the infinity norm, or the element of largest absolute value of a
          !! real symmetric matrix A in RFP format.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlansf( norm, transr, uplo, n, a, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,transr,uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: a(0:*)
                    real(dp), intent(out) :: work(0:*)
               end function dlansf
#else
               module procedure stdlib_dlansf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function slansf( norm, transr, uplo, n, a, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,transr,uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: a(0:*)
                    real(sp), intent(out) :: work(0:*)
               end function slansf
#else
               module procedure stdlib_slansf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function dlansf( norm, transr, uplo, n, a, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,transr,uplo
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: a(0:*)
                    real(dp), intent(out) :: work(0:*)
               end function dlansf
#else
               module procedure stdlib_I64_dlansf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp) function slansf( norm, transr, uplo, n, a, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,transr,uplo
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: a(0:*)
                    real(sp), intent(out) :: work(0:*)
               end function slansf
#else
               module procedure stdlib_I64_slansf
#endif
          end interface lansf

          interface lansp
          !! LANSP returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! complex symmetric matrix A,  supplied in packed form.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clansp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ap(*)
               end function clansp
#else
               module procedure stdlib_clansp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlansp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(out) :: work(*)
               end function dlansp
#else
               module procedure stdlib_dlansp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slansp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(out) :: work(*)
               end function slansp
#else
               module procedure stdlib_slansp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlansp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ap(*)
               end function zlansp
#else
               module procedure stdlib_zlansp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function clansp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ap(*)
               end function clansp
#else
               module procedure stdlib_I64_clansp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function dlansp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(out) :: work(*)
               end function dlansp
#else
               module procedure stdlib_I64_dlansp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function slansp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(out) :: work(*)
               end function slansp
#else
               module procedure stdlib_I64_slansp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zlansp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ap(*)
               end function zlansp
#else
               module procedure stdlib_I64_zlansp
#endif
          end interface lansp

          interface lanst
          !! LANST returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! real symmetric tridiagonal matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function dlanst( norm, n, d, e )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: d(*),e(*)
               end function dlanst
#else
               module procedure stdlib_dlanst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp)             function slanst( norm, n, d, e )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: d(*),e(*)
               end function slanst
#else
               module procedure stdlib_slanst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(dp) function dlanst( norm, n, d, e )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: d(*),e(*)
               end function dlanst
#else
               module procedure stdlib_I64_dlanst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure real(sp)             function slanst( norm, n, d, e )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: d(*),e(*)
               end function slanst
#else
               module procedure stdlib_I64_slanst
#endif
          end interface lanst

          interface lansy
          !! LANSY returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! complex symmetric matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clansy( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: a(lda,*)
               end function clansy
#else
               module procedure stdlib_clansy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlansy( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end function dlansy
#else
               module procedure stdlib_dlansy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slansy( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end function slansy
#else
               module procedure stdlib_slansy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlansy( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: a(lda,*)
               end function zlansy
#else
               module procedure stdlib_zlansy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function clansy( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: a(lda,*)
               end function clansy
#else
               module procedure stdlib_I64_clansy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function dlansy( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end function dlansy
#else
               module procedure stdlib_I64_dlansy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function slansy( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end function slansy
#else
               module procedure stdlib_I64_slansy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zlansy( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: norm,uplo
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: a(lda,*)
               end function zlansy
#else
               module procedure stdlib_I64_zlansy
#endif
          end interface lansy

          interface lantb
          !! LANTB returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the element of  largest absolute value  of an
          !! n by n triangular band matrix A,  with ( k + 1 ) diagonals.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clantb( norm, uplo, diag, n, k, ab,ldab, work )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end function clantb
#else
               module procedure stdlib_clantb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlantb( norm, uplo, diag, n, k, ab,ldab, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(out) :: work(*)
               end function dlantb
#else
               module procedure stdlib_dlantb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slantb( norm, uplo, diag, n, k, ab,ldab, work )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(out) :: work(*)
               end function slantb
#else
               module procedure stdlib_slantb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlantb( norm, uplo, diag, n, k, ab,ldab, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end function zlantb
#else
               module procedure stdlib_zlantb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function clantb( norm, uplo, diag, n, k, ab,ldab, work )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(in) :: k,ldab,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end function clantb
#else
               module procedure stdlib_I64_clantb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function dlantb( norm, uplo, diag, n, k, ab,ldab, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(in) :: k,ldab,n
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(out) :: work(*)
               end function dlantb
#else
               module procedure stdlib_I64_dlantb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function slantb( norm, uplo, diag, n, k, ab,ldab, work )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(in) :: k,ldab,n
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(out) :: work(*)
               end function slantb
#else
               module procedure stdlib_I64_slantb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zlantb( norm, uplo, diag, n, k, ab,ldab, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(in) :: k,ldab,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end function zlantb
#else
               module procedure stdlib_I64_zlantb
#endif
          end interface lantb

          interface lantp
          !! LANTP returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! triangular matrix A, supplied in packed form.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clantp( norm, uplo, diag, n, ap, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ap(*)
               end function clantp
#else
               module procedure stdlib_clantp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlantp( norm, uplo, diag, n, ap, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(out) :: work(*)
               end function dlantp
#else
               module procedure stdlib_dlantp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slantp( norm, uplo, diag, n, ap, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(out) :: work(*)
               end function slantp
#else
               module procedure stdlib_slantp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlantp( norm, uplo, diag, n, ap, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ap(*)
               end function zlantp
#else
               module procedure stdlib_zlantp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function clantp( norm, uplo, diag, n, ap, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ap(*)
               end function clantp
#else
               module procedure stdlib_I64_clantp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function dlantp( norm, uplo, diag, n, ap, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(out) :: work(*)
               end function dlantp
#else
               module procedure stdlib_I64_dlantp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function slantp( norm, uplo, diag, n, ap, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(out) :: work(*)
               end function slantp
#else
               module procedure stdlib_I64_slantp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zlantp( norm, uplo, diag, n, ap, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ap(*)
               end function zlantp
#else
               module procedure stdlib_I64_zlantp
#endif
          end interface lantp

          interface lantr
          !! LANTR returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! trapezoidal or triangular matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clantr( norm, uplo, diag, m, n, a, lda,work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: a(lda,*)
               end function clantr
#else
               module procedure stdlib_clantr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlantr( norm, uplo, diag, m, n, a, lda,work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end function dlantr
#else
               module procedure stdlib_dlantr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slantr( norm, uplo, diag, m, n, a, lda,work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end function slantr
#else
               module procedure stdlib_slantr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlantr( norm, uplo, diag, m, n, a, lda,work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: a(lda,*)
               end function zlantr
#else
               module procedure stdlib_zlantr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function clantr( norm, uplo, diag, m, n, a, lda,work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: a(lda,*)
               end function clantr
#else
               module procedure stdlib_I64_clantr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function dlantr( norm, uplo, diag, m, n, a, lda,work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end function dlantr
#else
               module procedure stdlib_I64_dlantr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(sp)             function slantr( norm, uplo, diag, m, n, a, lda,work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end function slantr
#else
               module procedure stdlib_I64_slantr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               real(dp) function zlantr( norm, uplo, diag, m, n, a, lda,work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: a(lda,*)
               end function zlantr
#else
               module procedure stdlib_I64_zlantr
#endif
          end interface lantr

          interface laorhr_col_getrfnp
          !! LAORHR_COL_GETRFNP computes the modified LU factorization without
          !! pivoting of a real general M-by-N matrix A. The factorization has
          !! the form:
          !! A - S = L * U,
          !! where:
          !! S is a m-by-n diagonal sign matrix with the diagonal D, so that
          !! D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
          !! as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
          !! i-1 steps of Gaussian elimination. This means that the diagonal
          !! element at each step of "modified" Gaussian elimination is
          !! at least one in absolute value (so that division-by-zero not
          !! not possible during the division by the diagonal element);
          !! L is a M-by-N lower triangular matrix with unit diagonal elements
          !! (lower trapezoidal if M > N);
          !! and U is a M-by-N upper triangular matrix
          !! (upper trapezoidal if M < N).
          !! This routine is an auxiliary routine used in the Householder
          !! reconstruction routine DORHR_COL. In DORHR_COL, this routine is
          !! applied to an M-by-N matrix A with orthonormal columns, where each
          !! element is bounded by one in absolute value. With the choice of
          !! the matrix S above, one can show that the diagonal element at each
          !! step of Gaussian elimination is the largest (in absolute value) in
          !! the column on or below the diagonal, so that no pivoting is required
          !! for numerical stability [1].
          !! For more details on the Householder reconstruction algorithm,
          !! including the modified LU factorization, see [1].
          !! This is the blocked right-looking version of the algorithm,
          !! calling Level 3 BLAS to update the submatrix. To factorize a block,
          !! this routine calls the recursive routine LAORHR_COL_GETRFNP2.
          !! [1] "Reconstructing Householder vectors from tall-skinny QR",
          !! G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
          !! E. Solomonik, J. Parallel Distrib. Comput.,
          !! vol. 85, pp. 3-31, 2015.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaorhr_col_getrfnp( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*)
               end subroutine dlaorhr_col_getrfnp
#else
               module procedure stdlib_dlaorhr_col_getrfnp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaorhr_col_getrfnp( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*)
               end subroutine slaorhr_col_getrfnp
#else
               module procedure stdlib_slaorhr_col_getrfnp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaorhr_col_getrfnp( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*)
               end subroutine dlaorhr_col_getrfnp
#else
               module procedure stdlib_I64_dlaorhr_col_getrfnp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaorhr_col_getrfnp( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*)
               end subroutine slaorhr_col_getrfnp
#else
               module procedure stdlib_I64_slaorhr_col_getrfnp
#endif
          end interface laorhr_col_getrfnp

          interface laorhr_col_getrfnp2
          !! LAORHR_COL_GETRFNP2 computes the modified LU factorization without
          !! pivoting of a real general M-by-N matrix A. The factorization has
          !! the form:
          !! A - S = L * U,
          !! where:
          !! S is a m-by-n diagonal sign matrix with the diagonal D, so that
          !! D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
          !! as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
          !! i-1 steps of Gaussian elimination. This means that the diagonal
          !! element at each step of "modified" Gaussian elimination is at
          !! least one in absolute value (so that division-by-zero not
          !! possible during the division by the diagonal element);
          !! L is a M-by-N lower triangular matrix with unit diagonal elements
          !! (lower trapezoidal if M > N);
          !! and U is a M-by-N upper triangular matrix
          !! (upper trapezoidal if M < N).
          !! This routine is an auxiliary routine used in the Householder
          !! reconstruction routine DORHR_COL. In DORHR_COL, this routine is
          !! applied to an M-by-N matrix A with orthonormal columns, where each
          !! element is bounded by one in absolute value. With the choice of
          !! the matrix S above, one can show that the diagonal element at each
          !! step of Gaussian elimination is the largest (in absolute value) in
          !! the column on or below the diagonal, so that no pivoting is required
          !! for numerical stability [1].
          !! For more details on the Householder reconstruction algorithm,
          !! including the modified LU factorization, see [1].
          !! This is the recursive version of the LU factorization algorithm.
          !! Denote A - S by B. The algorithm divides the matrix B into four
          !! submatrices:
          !! [  B11 | B12  ]  where B11 is n1 by n1,
          !! B = [ -----|----- ]        B21 is (m-n1) by n1,
          !! [  B21 | B22  ]        B12 is n1 by n2,
          !! B22 is (m-n1) by n2,
          !! with n1 = min(m,n)/2, n2 = n-n1.
          !! The subroutine calls itself to factor B11, solves for B21,
          !! solves for B12, updates B22, then calls itself to factor B22.
          !! For more details on the recursive LU algorithm, see [2].
          !! LAORHR_COL_GETRFNP2 is called to factorize a block by the blocked
          !! routine DLAORHR_COL_GETRFNP, which uses blocked code calling
          !! Level 3 BLAS to update the submatrix. However, LAORHR_COL_GETRFNP2
          !! is self-sufficient and can be used without DLAORHR_COL_GETRFNP.
          !! [1] "Reconstructing Householder vectors from tall-skinny QR",
          !! G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
          !! E. Solomonik, J. Parallel Distrib. Comput.,
          !! vol. 85, pp. 3-31, 2015.
          !! [2] "Recursion leads to automatic variable blocking for dense linear
          !! algebra algorithms", F. Gustavson, IBM J. of Res. and Dev.,
          !! vol. 41, no. 6, pp. 737-755, 1997.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine dlaorhr_col_getrfnp2( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*)
               end subroutine dlaorhr_col_getrfnp2
#else
               module procedure stdlib_dlaorhr_col_getrfnp2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine slaorhr_col_getrfnp2( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*)
               end subroutine slaorhr_col_getrfnp2
#else
               module procedure stdlib_slaorhr_col_getrfnp2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine dlaorhr_col_getrfnp2( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*)
               end subroutine dlaorhr_col_getrfnp2
#else
               module procedure stdlib_I64_dlaorhr_col_getrfnp2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine slaorhr_col_getrfnp2( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*)
               end subroutine slaorhr_col_getrfnp2
#else
               module procedure stdlib_I64_slaorhr_col_getrfnp2
#endif
          end interface laorhr_col_getrfnp2

          interface lapll
          !! Given two column vectors X and Y, let
          !! A = ( X Y ).
          !! The subroutine first computes the QR factorization of A = Q*R,
          !! and then computes the SVD of the 2-by-2 upper triangular matrix R.
          !! The smaller singular value of R is returned in SSMIN, which is used
          !! as the measurement of the linear dependency of the vectors X and Y.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clapll( n, x, incx, y, incy, ssmin )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,incy,n
                    real(sp), intent(out) :: ssmin
                    complex(sp), intent(inout) :: x(*),y(*)
               end subroutine clapll
#else
               module procedure stdlib_clapll
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlapll( n, x, incx, y, incy, ssmin )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,incy,n
                    real(dp), intent(out) :: ssmin
                    real(dp), intent(inout) :: x(*),y(*)
               end subroutine dlapll
#else
               module procedure stdlib_dlapll
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slapll( n, x, incx, y, incy, ssmin )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,incy,n
                    real(sp), intent(out) :: ssmin
                    real(sp), intent(inout) :: x(*),y(*)
               end subroutine slapll
#else
               module procedure stdlib_slapll
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlapll( n, x, incx, y, incy, ssmin )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,incy,n
                    real(dp), intent(out) :: ssmin
                    complex(dp), intent(inout) :: x(*),y(*)
               end subroutine zlapll
#else
               module procedure stdlib_zlapll
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clapll( n, x, incx, y, incy, ssmin )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,incy,n
                    real(sp), intent(out) :: ssmin
                    complex(sp), intent(inout) :: x(*),y(*)
               end subroutine clapll
#else
               module procedure stdlib_I64_clapll
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlapll( n, x, incx, y, incy, ssmin )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,incy,n
                    real(dp), intent(out) :: ssmin
                    real(dp), intent(inout) :: x(*),y(*)
               end subroutine dlapll
#else
               module procedure stdlib_I64_dlapll
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slapll( n, x, incx, y, incy, ssmin )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,incy,n
                    real(sp), intent(out) :: ssmin
                    real(sp), intent(inout) :: x(*),y(*)
               end subroutine slapll
#else
               module procedure stdlib_I64_slapll
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlapll( n, x, incx, y, incy, ssmin )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,incy,n
                    real(dp), intent(out) :: ssmin
                    complex(dp), intent(inout) :: x(*),y(*)
               end subroutine zlapll
#else
               module procedure stdlib_I64_zlapll
#endif
          end interface lapll

          interface lapmr
          !! LAPMR rearranges the rows of the M by N matrix X as specified
          !! by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
          !! If FORWRD = .TRUE.,  forward permutation:
          !! X(K(I),*) is moved X(I,*) for I = 1,2,...,M.
          !! If FORWRD = .FALSE., backward permutation:
          !! X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clapmr( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: forwrd
                    integer(ilp), intent(in) :: ldx,m,n
                    integer(ilp), intent(inout) :: k(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine clapmr
#else
               module procedure stdlib_clapmr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlapmr( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: forwrd
                    integer(ilp), intent(in) :: ldx,m,n
                    integer(ilp), intent(inout) :: k(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dlapmr
#else
               module procedure stdlib_dlapmr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slapmr( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: forwrd
                    integer(ilp), intent(in) :: ldx,m,n
                    integer(ilp), intent(inout) :: k(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine slapmr
#else
               module procedure stdlib_slapmr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlapmr( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: forwrd
                    integer(ilp), intent(in) :: ldx,m,n
                    integer(ilp), intent(inout) :: k(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zlapmr
#else
               module procedure stdlib_zlapmr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clapmr( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: forwrd
                    integer(ilp64), intent(in) :: ldx,m,n
                    integer(ilp64), intent(inout) :: k(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine clapmr
#else
               module procedure stdlib_I64_clapmr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlapmr( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: forwrd
                    integer(ilp64), intent(in) :: ldx,m,n
                    integer(ilp64), intent(inout) :: k(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dlapmr
#else
               module procedure stdlib_I64_dlapmr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slapmr( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: forwrd
                    integer(ilp64), intent(in) :: ldx,m,n
                    integer(ilp64), intent(inout) :: k(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine slapmr
#else
               module procedure stdlib_I64_slapmr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlapmr( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: forwrd
                    integer(ilp64), intent(in) :: ldx,m,n
                    integer(ilp64), intent(inout) :: k(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zlapmr
#else
               module procedure stdlib_I64_zlapmr
#endif
          end interface lapmr

          interface lapmt
          !! LAPMT rearranges the columns of the M by N matrix X as specified
          !! by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
          !! If FORWRD = .TRUE.,  forward permutation:
          !! X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
          !! If FORWRD = .FALSE., backward permutation:
          !! X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clapmt( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: forwrd
                    integer(ilp), intent(in) :: ldx,m,n
                    integer(ilp), intent(inout) :: k(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine clapmt
#else
               module procedure stdlib_clapmt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlapmt( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: forwrd
                    integer(ilp), intent(in) :: ldx,m,n
                    integer(ilp), intent(inout) :: k(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dlapmt
#else
               module procedure stdlib_dlapmt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slapmt( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: forwrd
                    integer(ilp), intent(in) :: ldx,m,n
                    integer(ilp), intent(inout) :: k(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine slapmt
#else
               module procedure stdlib_slapmt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlapmt( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: forwrd
                    integer(ilp), intent(in) :: ldx,m,n
                    integer(ilp), intent(inout) :: k(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zlapmt
#else
               module procedure stdlib_zlapmt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clapmt( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: forwrd
                    integer(ilp64), intent(in) :: ldx,m,n
                    integer(ilp64), intent(inout) :: k(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine clapmt
#else
               module procedure stdlib_I64_clapmt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlapmt( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: forwrd
                    integer(ilp64), intent(in) :: ldx,m,n
                    integer(ilp64), intent(inout) :: k(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dlapmt
#else
               module procedure stdlib_I64_dlapmt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slapmt( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: forwrd
                    integer(ilp64), intent(in) :: ldx,m,n
                    integer(ilp64), intent(inout) :: k(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine slapmt
#else
               module procedure stdlib_I64_slapmt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlapmt( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: forwrd
                    integer(ilp64), intent(in) :: ldx,m,n
                    integer(ilp64), intent(inout) :: k(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zlapmt
#else
               module procedure stdlib_I64_zlapmt
#endif
          end interface lapmt

          interface laqgb
          !! LAQGB equilibrates a general M by N band matrix A with KL
          !! subdiagonals and KU superdiagonals using the row and scaling factors
          !! in the vectors R and C.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, equed )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine claqgb
#else
               module procedure stdlib_claqgb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, equed )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dlaqgb
#else
               module procedure stdlib_dlaqgb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, equed )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine slaqgb
#else
               module procedure stdlib_slaqgb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, equed )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zlaqgb
#else
               module procedure stdlib_zlaqgb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, equed )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    integer(ilp64), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine claqgb
#else
               module procedure stdlib_I64_claqgb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, equed )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    integer(ilp64), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dlaqgb
#else
               module procedure stdlib_I64_dlaqgb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, equed )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    integer(ilp64), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine slaqgb
#else
               module procedure stdlib_I64_slaqgb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, equed )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    integer(ilp64), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zlaqgb
#else
               module procedure stdlib_I64_zlaqgb
#endif
          end interface laqgb

          interface laqge
          !! LAQGE equilibrates a general M by N matrix A using the row and
          !! column scaling factors in the vectors R and C.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine claqge
#else
               module procedure stdlib_claqge
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dlaqge
#else
               module procedure stdlib_dlaqge
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine slaqge
#else
               module procedure stdlib_slaqge
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlaqge
#else
               module procedure stdlib_zlaqge
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine claqge
#else
               module procedure stdlib_I64_claqge
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dlaqge
#else
               module procedure stdlib_I64_dlaqge
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine slaqge
#else
               module procedure stdlib_I64_slaqge
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlaqge
#else
               module procedure stdlib_I64_zlaqge
#endif
          end interface laqge

          interface laqhb
          !! LAQHB equilibrates an Hermitian band matrix A using the scaling
          !! factors in the vector S.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqhb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(in) :: amax,scond
                    real(sp), intent(out) :: s(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine claqhb
#else
               module procedure stdlib_claqhb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqhb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(in) :: amax,scond
                    real(dp), intent(out) :: s(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zlaqhb
#else
               module procedure stdlib_zlaqhb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claqhb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(sp), intent(in) :: amax,scond
                    real(sp), intent(out) :: s(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine claqhb
#else
               module procedure stdlib_I64_claqhb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaqhb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(dp), intent(in) :: amax,scond
                    real(dp), intent(out) :: s(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zlaqhb
#else
               module procedure stdlib_I64_zlaqhb
#endif
          end interface laqhb

          interface laqhe
          !! LAQHE equilibrates a Hermitian matrix A using the scaling factors
          !! in the vector S.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqhe( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: amax,scond,s(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine claqhe
#else
               module procedure stdlib_claqhe
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqhe( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: amax,scond,s(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlaqhe
#else
               module procedure stdlib_zlaqhe
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claqhe( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(in) :: amax,scond,s(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine claqhe
#else
               module procedure stdlib_I64_claqhe
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaqhe( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(in) :: amax,scond,s(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlaqhe
#else
               module procedure stdlib_I64_zlaqhe
#endif
          end interface laqhe

          interface laqhp
          !! LAQHP equilibrates a Hermitian matrix A using the scaling factors
          !! in the vector S.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqhp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: amax,scond,s(*)
                    complex(sp), intent(inout) :: ap(*)
               end subroutine claqhp
#else
               module procedure stdlib_claqhp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqhp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: amax,scond,s(*)
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zlaqhp
#else
               module procedure stdlib_zlaqhp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claqhp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: amax,scond,s(*)
                    complex(sp), intent(inout) :: ap(*)
               end subroutine claqhp
#else
               module procedure stdlib_I64_claqhp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaqhp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: amax,scond,s(*)
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zlaqhp
#else
               module procedure stdlib_I64_zlaqhp
#endif
          end interface laqhp

          interface laqps
          !! LAQPS computes a step of QR factorization with column pivoting
          !! of a complex M-by-N matrix A by using Blas-3.  It tries to factorize
          !! NB columns from A starting from the row OFFSET+1, and updates all
          !! of the matrix with Blas-3 xGEMM.
          !! In some cases, due to catastrophic cancellations, it cannot
          !! factorize NB columns.  Hence, the actual number of factorized
          !! columns is returned in KB.
          !! Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,vn2, auxv, f, &
                         ldf )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: kb
                    integer(ilp), intent(in) :: lda,ldf,m,n,nb,offset
                    integer(ilp), intent(inout) :: jpvt(*)
                    real(sp), intent(inout) :: vn1(*),vn2(*)
                    complex(sp), intent(inout) :: a(lda,*),auxv(*),f(ldf,*)
                    complex(sp), intent(out) :: tau(*)
               end subroutine claqps
#else
               module procedure stdlib_claqps
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,vn2, auxv, f, &
                         ldf )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: kb
                    integer(ilp), intent(in) :: lda,ldf,m,n,nb,offset
                    integer(ilp), intent(inout) :: jpvt(*)
                    real(dp), intent(inout) :: a(lda,*),auxv(*),f(ldf,*),vn1(*),vn2(*)
                    real(dp), intent(out) :: tau(*)
               end subroutine dlaqps
#else
               module procedure stdlib_dlaqps
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,vn2, auxv, f, &
                         ldf )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: kb
                    integer(ilp), intent(in) :: lda,ldf,m,n,nb,offset
                    integer(ilp), intent(inout) :: jpvt(*)
                    real(sp), intent(inout) :: a(lda,*),auxv(*),f(ldf,*),vn1(*),vn2(*)
                    real(sp), intent(out) :: tau(*)
               end subroutine slaqps
#else
               module procedure stdlib_slaqps
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,vn2, auxv, f, &
                         ldf )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: kb
                    integer(ilp), intent(in) :: lda,ldf,m,n,nb,offset
                    integer(ilp), intent(inout) :: jpvt(*)
                    real(dp), intent(inout) :: vn1(*),vn2(*)
                    complex(dp), intent(inout) :: a(lda,*),auxv(*),f(ldf,*)
                    complex(dp), intent(out) :: tau(*)
               end subroutine zlaqps
#else
               module procedure stdlib_zlaqps
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,vn2, auxv, f, &
                         ldf )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: kb
                    integer(ilp64), intent(in) :: lda,ldf,m,n,nb,offset
                    integer(ilp64), intent(inout) :: jpvt(*)
                    real(sp), intent(inout) :: vn1(*),vn2(*)
                    complex(sp), intent(inout) :: a(lda,*),auxv(*),f(ldf,*)
                    complex(sp), intent(out) :: tau(*)
               end subroutine claqps
#else
               module procedure stdlib_I64_claqps
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,vn2, auxv, f, &
                         ldf )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: kb
                    integer(ilp64), intent(in) :: lda,ldf,m,n,nb,offset
                    integer(ilp64), intent(inout) :: jpvt(*)
                    real(dp), intent(inout) :: a(lda,*),auxv(*),f(ldf,*),vn1(*),vn2(*)
                    real(dp), intent(out) :: tau(*)
               end subroutine dlaqps
#else
               module procedure stdlib_I64_dlaqps
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,vn2, auxv, f, &
                         ldf )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: kb
                    integer(ilp64), intent(in) :: lda,ldf,m,n,nb,offset
                    integer(ilp64), intent(inout) :: jpvt(*)
                    real(sp), intent(inout) :: a(lda,*),auxv(*),f(ldf,*),vn1(*),vn2(*)
                    real(sp), intent(out) :: tau(*)
               end subroutine slaqps
#else
               module procedure stdlib_I64_slaqps
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,vn2, auxv, f, &
                         ldf )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: kb
                    integer(ilp64), intent(in) :: lda,ldf,m,n,nb,offset
                    integer(ilp64), intent(inout) :: jpvt(*)
                    real(dp), intent(inout) :: vn1(*),vn2(*)
                    complex(dp), intent(inout) :: a(lda,*),auxv(*),f(ldf,*)
                    complex(dp), intent(out) :: tau(*)
               end subroutine zlaqps
#else
               module procedure stdlib_I64_zlaqps
#endif
          end interface laqps

          interface laqr0
          !! LAQR0 computes the eigenvalues of a Hessenberg matrix H
          !! and, optionally, the matrices T and Z from the Schur decomposition
          !! H = Z T Z**H, where T is an upper triangular matrix (the
          !! Schur form), and Z is the unitary matrix of Schur vectors.
          !! Optionally Z may be postmultiplied into an input unitary
          !! matrix Q so that this routine can give the Schur factorization
          !! of a matrix A which has been reduced to the Hessenberg form H
          !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(sp), intent(out) :: w(*),work(*)
               end subroutine claqr0
#else
               module procedure stdlib_claqr0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(dp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine dlaqr0
#else
               module procedure stdlib_dlaqr0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine slaqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(sp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine slaqr0
#else
               module procedure stdlib_slaqr0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(dp), intent(out) :: w(*),work(*)
               end subroutine zlaqr0
#else
               module procedure stdlib_zlaqr0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp64), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(sp), intent(out) :: w(*),work(*)
               end subroutine claqr0
#else
               module procedure stdlib_I64_claqr0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp64), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(dp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine dlaqr0
#else
               module procedure stdlib_I64_dlaqr0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine slaqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp64), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(sp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine slaqr0
#else
               module procedure stdlib_I64_slaqr0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp64), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(dp), intent(out) :: w(*),work(*)
               end subroutine zlaqr0
#else
               module procedure stdlib_I64_zlaqr0
#endif
          end interface laqr0

          interface laqr1
          !! Given a 2-by-2 or 3-by-3 matrix H, LAQR1: sets v to a
          !! scalar multiple of the first column of the product
          !! (*)  K = (H - s1*I)*(H - s2*I)
          !! scaling to avoid overflows and most underflows.
          !! This is useful for starting double implicit shift bulges
          !! in the QR algorithm.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqr1( n, h, ldh, s1, s2, v )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    complex(sp), intent(in) :: s1,s2,h(ldh,*)
                    integer(ilp), intent(in) :: ldh,n
                    complex(sp), intent(out) :: v(*)
               end subroutine claqr1
#else
               module procedure stdlib_claqr1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqr1( n, h, ldh, sr1, si1, sr2, si2, v )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: si1,si2,sr1,sr2,h(ldh,*)
                    integer(ilp), intent(in) :: ldh,n
                    real(dp), intent(out) :: v(*)
               end subroutine dlaqr1
#else
               module procedure stdlib_dlaqr1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqr1( n, h, ldh, sr1, si1, sr2, si2, v )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: si1,si2,sr1,sr2,h(ldh,*)
                    integer(ilp), intent(in) :: ldh,n
                    real(sp), intent(out) :: v(*)
               end subroutine slaqr1
#else
               module procedure stdlib_slaqr1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqr1( n, h, ldh, s1, s2, v )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    complex(dp), intent(in) :: s1,s2,h(ldh,*)
                    integer(ilp), intent(in) :: ldh,n
                    complex(dp), intent(out) :: v(*)
               end subroutine zlaqr1
#else
               module procedure stdlib_zlaqr1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claqr1( n, h, ldh, s1, s2, v )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    complex(sp), intent(in) :: s1,s2,h(ldh,*)
                    integer(ilp64), intent(in) :: ldh,n
                    complex(sp), intent(out) :: v(*)
               end subroutine claqr1
#else
               module procedure stdlib_I64_claqr1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaqr1( n, h, ldh, sr1, si1, sr2, si2, v )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: si1,si2,sr1,sr2,h(ldh,*)
                    integer(ilp64), intent(in) :: ldh,n
                    real(dp), intent(out) :: v(*)
               end subroutine dlaqr1
#else
               module procedure stdlib_I64_dlaqr1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaqr1( n, h, ldh, sr1, si1, sr2, si2, v )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: si1,si2,sr1,sr2,h(ldh,*)
                    integer(ilp64), intent(in) :: ldh,n
                    real(sp), intent(out) :: v(*)
               end subroutine slaqr1
#else
               module procedure stdlib_I64_slaqr1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaqr1( n, h, ldh, s1, s2, v )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    complex(dp), intent(in) :: s1,s2,h(ldh,*)
                    integer(ilp64), intent(in) :: ldh,n
                    complex(dp), intent(out) :: v(*)
               end subroutine zlaqr1
#else
               module procedure stdlib_I64_zlaqr1
#endif
          end interface laqr1

          interface laqr4
          !! LAQR4 implements one level of recursion for CLAQR0.
          !! It is a complete implementation of the small bulge multi-shift
          !! QR algorithm.  It may be called by CLAQR0 and, for large enough
          !! deflation window size, it may be called by CLAQR3.  This
          !! subroutine is identical to CLAQR0 except that it calls CLAQR2
          !! instead of CLAQR3.
          !! LAQR4 computes the eigenvalues of a Hessenberg matrix H
          !! and, optionally, the matrices T and Z from the Schur decomposition
          !! H = Z T Z**H, where T is an upper triangular matrix (the
          !! Schur form), and Z is the unitary matrix of Schur vectors.
          !! Optionally Z may be postmultiplied into an input unitary
          !! matrix Q so that this routine can give the Schur factorization
          !! of a matrix A which has been reduced to the Hessenberg form H
          !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(sp), intent(out) :: w(*),work(*)
               end subroutine claqr4
#else
               module procedure stdlib_claqr4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dlaqr4( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(dp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine dlaqr4
#else
               module procedure stdlib_dlaqr4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine slaqr4( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(sp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine slaqr4
#else
               module procedure stdlib_slaqr4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(dp), intent(out) :: w(*),work(*)
               end subroutine zlaqr4
#else
               module procedure stdlib_zlaqr4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp64), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(sp), intent(out) :: w(*),work(*)
               end subroutine claqr4
#else
               module procedure stdlib_I64_claqr4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dlaqr4( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp64), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(dp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine dlaqr4
#else
               module procedure stdlib_I64_dlaqr4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine slaqr4( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp64), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(sp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine slaqr4
#else
               module procedure stdlib_I64_slaqr4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp64), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(dp), intent(out) :: w(*),work(*)
               end subroutine zlaqr4
#else
               module procedure stdlib_I64_zlaqr4
#endif
          end interface laqr4

          interface laqr5
          !! LAQR5 called by CLAQR0 performs a
          !! single small-bulge multi-shift QR sweep.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,h, ldh, &
                         iloz, ihiz, z, ldz, v, ldv, u, ldu, nv,wv, ldwv, nh, wh, ldwh )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihiz,iloz,kacc22,kbot,ktop,ldh,ldu,ldv,ldwh,ldwv,&
                              ldz,n,nh,nshfts,nv
                    logical(lk), intent(in) :: wantt,wantz
                    complex(sp), intent(inout) :: h(ldh,*),s(*),z(ldz,*)
                    complex(sp), intent(out) :: u(ldu,*),v(ldv,*),wh(ldwh,*),wv(ldwv,*)
               end subroutine claqr5
#else
               module procedure stdlib_claqr5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,sr, si, h, ldh,&
                          iloz, ihiz, z, ldz, v, ldv, u,ldu, nv, wv, ldwv, nh, wh, ldwh )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihiz,iloz,kacc22,kbot,ktop,ldh,ldu,ldv,ldwh,ldwv,&
                              ldz,n,nh,nshfts,nv
                    logical(lk), intent(in) :: wantt,wantz
                    real(dp), intent(inout) :: h(ldh,*),si(*),sr(*),z(ldz,*)
                    real(dp), intent(out) :: u(ldu,*),v(ldv,*),wh(ldwh,*),wv(ldwv,*)
               end subroutine dlaqr5
#else
               module procedure stdlib_dlaqr5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,sr, si, h, ldh,&
                          iloz, ihiz, z, ldz, v, ldv, u,ldu, nv, wv, ldwv, nh, wh, ldwh )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihiz,iloz,kacc22,kbot,ktop,ldh,ldu,ldv,ldwh,ldwv,&
                              ldz,n,nh,nshfts,nv
                    logical(lk), intent(in) :: wantt,wantz
                    real(sp), intent(inout) :: h(ldh,*),si(*),sr(*),z(ldz,*)
                    real(sp), intent(out) :: u(ldu,*),v(ldv,*),wh(ldwh,*),wv(ldwv,*)
               end subroutine slaqr5
#else
               module procedure stdlib_slaqr5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,h, ldh, &
                         iloz, ihiz, z, ldz, v, ldv, u, ldu, nv,wv, ldwv, nh, wh, ldwh )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihiz,iloz,kacc22,kbot,ktop,ldh,ldu,ldv,ldwh,ldwv,&
                              ldz,n,nh,nshfts,nv
                    logical(lk), intent(in) :: wantt,wantz
                    complex(dp), intent(inout) :: h(ldh,*),s(*),z(ldz,*)
                    complex(dp), intent(out) :: u(ldu,*),v(ldv,*),wh(ldwh,*),wv(ldwv,*)
               end subroutine zlaqr5
#else
               module procedure stdlib_zlaqr5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,h, ldh, &
                         iloz, ihiz, z, ldz, v, ldv, u, ldu, nv,wv, ldwv, nh, wh, ldwh )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihiz,iloz,kacc22,kbot,ktop,ldh,ldu,ldv,ldwh,ldwv,&
                              ldz,n,nh,nshfts,nv
                    logical(lk), intent(in) :: wantt,wantz
                    complex(sp), intent(inout) :: h(ldh,*),s(*),z(ldz,*)
                    complex(sp), intent(out) :: u(ldu,*),v(ldv,*),wh(ldwh,*),wv(ldwv,*)
               end subroutine claqr5
#else
               module procedure stdlib_I64_claqr5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,sr, si, h, ldh,&
                          iloz, ihiz, z, ldz, v, ldv, u,ldu, nv, wv, ldwv, nh, wh, ldwh )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihiz,iloz,kacc22,kbot,ktop,ldh,ldu,ldv,ldwh,ldwv,&
                              ldz,n,nh,nshfts,nv
                    logical(lk), intent(in) :: wantt,wantz
                    real(dp), intent(inout) :: h(ldh,*),si(*),sr(*),z(ldz,*)
                    real(dp), intent(out) :: u(ldu,*),v(ldv,*),wh(ldwh,*),wv(ldwv,*)
               end subroutine dlaqr5
#else
               module procedure stdlib_I64_dlaqr5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,sr, si, h, ldh,&
                          iloz, ihiz, z, ldz, v, ldv, u,ldu, nv, wv, ldwv, nh, wh, ldwh )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihiz,iloz,kacc22,kbot,ktop,ldh,ldu,ldv,ldwh,ldwv,&
                              ldz,n,nh,nshfts,nv
                    logical(lk), intent(in) :: wantt,wantz
                    real(sp), intent(inout) :: h(ldh,*),si(*),sr(*),z(ldz,*)
                    real(sp), intent(out) :: u(ldu,*),v(ldv,*),wh(ldwh,*),wv(ldwv,*)
               end subroutine slaqr5
#else
               module procedure stdlib_I64_slaqr5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,h, ldh, &
                         iloz, ihiz, z, ldz, v, ldv, u, ldu, nv,wv, ldwv, nh, wh, ldwh )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihiz,iloz,kacc22,kbot,ktop,ldh,ldu,ldv,ldwh,ldwv,&
                              ldz,n,nh,nshfts,nv
                    logical(lk), intent(in) :: wantt,wantz
                    complex(dp), intent(inout) :: h(ldh,*),s(*),z(ldz,*)
                    complex(dp), intent(out) :: u(ldu,*),v(ldv,*),wh(ldwh,*),wv(ldwv,*)
               end subroutine zlaqr5
#else
               module procedure stdlib_I64_zlaqr5
#endif
          end interface laqr5

          interface laqsb
          !! LAQSB equilibrates a symmetric band matrix A using the scaling
          !! factors in the vector S.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(in) :: amax,scond,s(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine claqsb
#else
               module procedure stdlib_claqsb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(in) :: amax,scond,s(*)
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dlaqsb
#else
               module procedure stdlib_dlaqsb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(in) :: amax,scond,s(*)
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine slaqsb
#else
               module procedure stdlib_slaqsb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(in) :: amax,scond,s(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zlaqsb
#else
               module procedure stdlib_zlaqsb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(sp), intent(in) :: amax,scond,s(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine claqsb
#else
               module procedure stdlib_I64_claqsb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(dp), intent(in) :: amax,scond,s(*)
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dlaqsb
#else
               module procedure stdlib_I64_dlaqsb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(sp), intent(in) :: amax,scond,s(*)
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine slaqsb
#else
               module procedure stdlib_I64_slaqsb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(dp), intent(in) :: amax,scond,s(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zlaqsb
#else
               module procedure stdlib_I64_zlaqsb
#endif
          end interface laqsb

          interface laqsp
          !! LAQSP equilibrates a symmetric matrix A using the scaling factors
          !! in the vector S.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqsp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: amax,scond,s(*)
                    complex(sp), intent(inout) :: ap(*)
               end subroutine claqsp
#else
               module procedure stdlib_claqsp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqsp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: amax,scond,s(*)
                    real(dp), intent(inout) :: ap(*)
               end subroutine dlaqsp
#else
               module procedure stdlib_dlaqsp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqsp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: amax,scond,s(*)
                    real(sp), intent(inout) :: ap(*)
               end subroutine slaqsp
#else
               module procedure stdlib_slaqsp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqsp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: amax,scond,s(*)
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zlaqsp
#else
               module procedure stdlib_zlaqsp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claqsp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: amax,scond,s(*)
                    complex(sp), intent(inout) :: ap(*)
               end subroutine claqsp
#else
               module procedure stdlib_I64_claqsp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaqsp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: amax,scond,s(*)
                    real(dp), intent(inout) :: ap(*)
               end subroutine dlaqsp
#else
               module procedure stdlib_I64_dlaqsp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaqsp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: amax,scond,s(*)
                    real(sp), intent(inout) :: ap(*)
               end subroutine slaqsp
#else
               module procedure stdlib_I64_slaqsp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaqsp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: amax,scond,s(*)
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zlaqsp
#else
               module procedure stdlib_I64_zlaqsp
#endif
          end interface laqsp

          interface laqsy
          !! LAQSY equilibrates a symmetric matrix A using the scaling factors
          !! in the vector S.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqsy( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: amax,scond,s(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine claqsy
#else
               module procedure stdlib_claqsy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqsy( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: amax,scond,s(*)
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dlaqsy
#else
               module procedure stdlib_dlaqsy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqsy( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: amax,scond,s(*)
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine slaqsy
#else
               module procedure stdlib_slaqsy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqsy( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: amax,scond,s(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlaqsy
#else
               module procedure stdlib_zlaqsy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claqsy( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(in) :: amax,scond,s(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine claqsy
#else
               module procedure stdlib_I64_claqsy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaqsy( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(in) :: amax,scond,s(*)
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dlaqsy
#else
               module procedure stdlib_I64_dlaqsy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaqsy( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(in) :: amax,scond,s(*)
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine slaqsy
#else
               module procedure stdlib_I64_slaqsy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaqsy( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(in) :: amax,scond,s(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlaqsy
#else
               module procedure stdlib_I64_zlaqsy
#endif
          end interface laqsy

          interface laqtr
          !! LAQTR solves the real quasi-triangular system
          !! op(T)*p = scale*c,               if LREAL = .TRUE.
          !! or the complex quasi-triangular systems
          !! op(T + iB)*(p+iq) = scale*(c+id),  if LREAL = .FALSE.
          !! in real arithmetic, where T is upper quasi-triangular.
          !! If LREAL = .FALSE., then the first diagonal block of T must be
          !! 1 by 1, B is the specially structured matrix
          !! B = [ b(1) b(2) ... b(n) ]
          !! [       w            ]
          !! [           w        ]
          !! [              .     ]
          !! [                 w  ]
          !! op(A) = A or A**T, A**T denotes the transpose of
          !! matrix A.
          !! On input, X = [ c ].  On output, X = [ p ].
          !! [ d ]                  [ q ]
          !! This subroutine is designed for the condition number estimation
          !! in routine DTRSNA.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dlaqtr( ltran, lreal, n, t, ldt, b, w, scale, x, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: lreal,ltran
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldt,n
                    real(dp), intent(out) :: scale,work(*)
                    real(dp), intent(in) :: w,b(*),t(ldt,*)
                    real(dp), intent(inout) :: x(*)
               end subroutine dlaqtr
#else
               module procedure stdlib_dlaqtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine slaqtr( ltran, lreal, n, t, ldt, b, w, scale, x, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: lreal,ltran
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldt,n
                    real(sp), intent(out) :: scale,work(*)
                    real(sp), intent(in) :: w,b(*),t(ldt,*)
                    real(sp), intent(inout) :: x(*)
               end subroutine slaqtr
#else
               module procedure stdlib_slaqtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dlaqtr( ltran, lreal, n, t, ldt, b, w, scale, x, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: lreal,ltran
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldt,n
                    real(dp), intent(out) :: scale,work(*)
                    real(dp), intent(in) :: w,b(*),t(ldt,*)
                    real(dp), intent(inout) :: x(*)
               end subroutine dlaqtr
#else
               module procedure stdlib_I64_dlaqtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine slaqtr( ltran, lreal, n, t, ldt, b, w, scale, x, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: lreal,ltran
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldt,n
                    real(sp), intent(out) :: scale,work(*)
                    real(sp), intent(in) :: w,b(*),t(ldt,*)
                    real(sp), intent(inout) :: x(*)
               end subroutine slaqtr
#else
               module procedure stdlib_I64_slaqtr
#endif
          end interface laqtr

          interface laqz0
          !! LAQZ0 computes the eigenvalues of a matrix pair (H,T),
          !! where H is an upper Hessenberg matrix and T is upper triangular,
          !! using the double-shift QZ method.
          !! Matrix pairs of this type are produced by the reduction to
          !! generalized upper Hessenberg form of a matrix pair (A,B):
          !! A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
          !! as computed by CGGHRD.
          !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
          !! also reduced to generalized Schur form,
          !! H = Q*S*Z**H,  T = Q*P*Z**H,
          !! where Q and Z are unitary matrices, P and S are an upper triangular
          !! matrices.
          !! Optionally, the unitary matrix Q from the generalized Schur
          !! factorization may be postmultiplied into an input matrix Q1, and the
          !! unitary matrix Z may be postmultiplied into an input matrix Z1.
          !! If Q1 and Z1 are the unitary matrices from CGGHRD that reduced
          !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
          !! output matrices Q1*Q and Z1*Z are the unitary factors from the
          !! generalized Schur factorization of (A,B):
          !! A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
          !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
          !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
          !! complex and beta real.
          !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
          !! generalized nonsymmetric eigenvalue problem (GNEP)
          !! A*x = lambda*B*x
          !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
          !! alternate form of the GNEP
          !! mu*A*y = B*y.
          !! Eigenvalues can be read directly from the generalized Schur
          !! form:
          !! alpha = S(i,i), beta = P(i,i).
          !! Ref: C.B. Moler
          !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
          !! pp. 241--256.
          !! Ref: B. Kagstrom, D. Kressner, "Multishift Variants of the QZ
          !! Algorithm with Aggressive Early Deflation", SIAM J. Numer.
          !! Anal., 29(2006), pp. 199--227.
          !! Ref: T. Steel, D. Camps, K. Meerbergen, R. Vandebril "A multishift,
          !! multipole rational QZ method with agressive early deflation"
#ifdef STDLIB_EXTERNAL_LAPACK
               recursive subroutine claqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, &
                         alpha, beta, q, ldq, z,ldz, work, lwork, rwork, rec,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: wants,wantq,wantz
                    integer(ilp), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,rec
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    complex(sp), intent(inout) :: alpha(*),beta(*),work(*)
                    real(sp), intent(out) :: rwork(*)
               end subroutine claqz0
#else
               module procedure stdlib_claqz0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               recursive subroutine dlaqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, &
                         alphar, alphai, beta,q, ldq, z, ldz, work, lwork, rec,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: wants,wantq,wantz
                    integer(ilp), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,rec
                    integer(ilp), intent(out) :: info
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    real(dp), intent(inout) :: alphar(*),alphai(*),beta(*),work(*)
               end subroutine dlaqz0
#else
               module procedure stdlib_dlaqz0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               recursive subroutine slaqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, &
                         alphar, alphai, beta,q, ldq, z, ldz, work, lwork, rec,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: wants,wantq,wantz
                    integer(ilp), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,rec
                    integer(ilp), intent(out) :: info
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    real(sp), intent(inout) :: alphar(*),alphai(*),beta(*),work(*)
               end subroutine slaqz0
#else
               module procedure stdlib_slaqz0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               recursive subroutine zlaqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, &
                         alpha, beta, q, ldq, z,ldz, work, lwork, rwork, rec,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: wants,wantq,wantz
                    integer(ilp), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,rec
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    complex(dp), intent(inout) :: alpha(*),beta(*),work(*)
                    real(dp), intent(out) :: rwork(*)
               end subroutine zlaqz0
#else
               module procedure stdlib_zlaqz0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               recursive subroutine claqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, &
                         alpha, beta, q, ldq, z,ldz, work, lwork, rwork, rec,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: wants,wantq,wantz
                    integer(ilp64), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,rec
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    complex(sp), intent(inout) :: alpha(*),beta(*),work(*)
                    real(sp), intent(out) :: rwork(*)
               end subroutine claqz0
#else
               module procedure stdlib_I64_claqz0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               recursive subroutine dlaqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, &
                         alphar, alphai, beta,q, ldq, z, ldz, work, lwork, rec,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: wants,wantq,wantz
                    integer(ilp64), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,rec
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    real(dp), intent(inout) :: alphar(*),alphai(*),beta(*),work(*)
               end subroutine dlaqz0
#else
               module procedure stdlib_I64_dlaqz0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               recursive subroutine slaqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, &
                         alphar, alphai, beta,q, ldq, z, ldz, work, lwork, rec,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: wants,wantq,wantz
                    integer(ilp64), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,rec
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    real(sp), intent(inout) :: alphar(*),alphai(*),beta(*),work(*)
               end subroutine slaqz0
#else
               module procedure stdlib_I64_slaqz0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               recursive subroutine zlaqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, &
                         alpha, beta, q, ldq, z,ldz, work, lwork, rwork, rec,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: wants,wantq,wantz
                    integer(ilp64), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,rec
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    complex(dp), intent(inout) :: alpha(*),beta(*),work(*)
                    real(dp), intent(out) :: rwork(*)
               end subroutine zlaqz0
#else
               module procedure stdlib_I64_zlaqz0
#endif
          end interface laqz0

          interface laqz1
          !! LAQZ1 chases a 1x1 shift bulge in a matrix pencil down a single position
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqz1( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, &
                         qstart, q, ldq, nz, zstart, z, ldz )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: ilq,ilz
                    integer(ilp), intent(in) :: k,lda,ldb,ldq,ldz,istartm,istopm,nq,nz,qstart,&
                              zstart,ihi
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine claqz1
#else
               module procedure stdlib_claqz1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqz1( a, lda, b, ldb, sr1, sr2, si, beta1, beta2,v )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: lda,ldb
                    real(dp), intent(in) :: a(lda,*),b(ldb,*),sr1,sr2,si,beta1,beta2
                    real(dp), intent(out) :: v(*)
               end subroutine dlaqz1
#else
               module procedure stdlib_dlaqz1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqz1( a, lda, b, ldb, sr1, sr2, si, beta1, beta2,v )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: lda,ldb
                    real(sp), intent(in) :: a(lda,*),b(ldb,*),sr1,sr2,si,beta1,beta2
                    real(sp), intent(out) :: v(*)
               end subroutine slaqz1
#else
               module procedure stdlib_slaqz1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqz1( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, &
                         qstart, q, ldq, nz, zstart, z, ldz )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: ilq,ilz
                    integer(ilp), intent(in) :: k,lda,ldb,ldq,ldz,istartm,istopm,nq,nz,qstart,&
                              zstart,ihi
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine zlaqz1
#else
               module procedure stdlib_zlaqz1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claqz1( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, &
                         qstart, q, ldq, nz, zstart, z, ldz )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: ilq,ilz
                    integer(ilp64), intent(in) :: k,lda,ldb,ldq,ldz,istartm,istopm,nq,nz,qstart,&
                              zstart,ihi
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine claqz1
#else
               module procedure stdlib_I64_claqz1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaqz1( a, lda, b, ldb, sr1, sr2, si, beta1, beta2,v )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: lda,ldb
                    real(dp), intent(in) :: a(lda,*),b(ldb,*),sr1,sr2,si,beta1,beta2
                    real(dp), intent(out) :: v(*)
               end subroutine dlaqz1
#else
               module procedure stdlib_I64_dlaqz1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaqz1( a, lda, b, ldb, sr1, sr2, si, beta1, beta2,v )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: lda,ldb
                    real(sp), intent(in) :: a(lda,*),b(ldb,*),sr1,sr2,si,beta1,beta2
                    real(sp), intent(out) :: v(*)
               end subroutine slaqz1
#else
               module procedure stdlib_I64_slaqz1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaqz1( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, &
                         qstart, q, ldq, nz, zstart, z, ldz )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: ilq,ilz
                    integer(ilp64), intent(in) :: k,lda,ldb,ldq,ldz,istartm,istopm,nq,nz,qstart,&
                              zstart,ihi
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine zlaqz1
#else
               module procedure stdlib_I64_zlaqz1
#endif
          end interface laqz1

          interface laqz4
          !! LAQZ4 Executes a single multishift QZ sweep
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqz4( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, sr,&
                si, ss, a, lda, b, ldb, q,ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: ilschur,ilq,ilz
                    integer(ilp), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,nshifts,&
                              nblock_desired,ldqc,ldzc
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*),qc(ldqc,*),zc(&
                              ldzc,*)
                    real(dp), intent(inout) :: work(*)
                    real(dp), intent(inout) :: sr(*),si(*),ss(*)
                    integer(ilp), intent(out) :: info
               end subroutine dlaqz4
#else
               module procedure stdlib_dlaqz4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqz4( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, sr,&
                si, ss, a, lda, b, ldb, q,ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: ilschur,ilq,ilz
                    integer(ilp), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,nshifts,&
                              nblock_desired,ldqc,ldzc
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*),qc(ldqc,*),zc(&
                              ldzc,*)
                    real(sp), intent(inout) :: work(*)
                    real(sp), intent(inout) :: sr(*),si(*),ss(*)
                    integer(ilp), intent(out) :: info
               end subroutine slaqz4
#else
               module procedure stdlib_slaqz4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaqz4( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, sr,&
                si, ss, a, lda, b, ldb, q,ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: ilschur,ilq,ilz
                    integer(ilp64), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,nshifts,&
                              nblock_desired,ldqc,ldzc
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*),qc(ldqc,*),zc(&
                              ldzc,*)
                    real(dp), intent(inout) :: work(*)
                    real(dp), intent(inout) :: sr(*),si(*),ss(*)
                    integer(ilp64), intent(out) :: info
               end subroutine dlaqz4
#else
               module procedure stdlib_I64_dlaqz4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaqz4( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, sr,&
                si, ss, a, lda, b, ldb, q,ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: ilschur,ilq,ilz
                    integer(ilp64), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,nshifts,&
                              nblock_desired,ldqc,ldzc
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*),qc(ldqc,*),zc(&
                              ldzc,*)
                    real(sp), intent(inout) :: work(*)
                    real(sp), intent(inout) :: sr(*),si(*),ss(*)
                    integer(ilp64), intent(out) :: info
               end subroutine slaqz4
#else
               module procedure stdlib_I64_slaqz4
#endif
          end interface laqz4

          interface lar1v
          !! LAR1V computes the (scaled) r-th column of the inverse of
          !! the sumbmatrix in rows B1 through BN of the tridiagonal matrix
          !! L D L**T - sigma I. When sigma is close to an eigenvalue, the
          !! computed vector is an accurate eigenvector. Usually, r corresponds
          !! to the index where the eigenvector is largest in magnitude.
          !! The following steps accomplish this computation :
          !! (a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,
          !! (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
          !! (c) Computation of the diagonal elements of the inverse of
          !! L D L**T - sigma I by combining the above transforms, and choosing
          !! r as the index where the diagonal of the inverse is (one of the)
          !! largest in magnitude.
          !! (d) Computation of the (scaled) r-th column of the inverse using the
          !! twisted factorization obtained by combining the top part of the
          !! the stationary and the bottom part of the progressive transform.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc,&
                          negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: wantnc
                    integer(ilp), intent(in) :: b1,bn,n
                    integer(ilp), intent(out) :: negcnt,isuppz(*)
                    integer(ilp), intent(inout) :: r
                    real(sp), intent(in) :: gaptol,lambda,pivmin,d(*),l(*),ld(*),lld(*)
                    real(sp), intent(out) :: mingma,nrminv,resid,rqcorr,ztz,work(*)
                    complex(sp), intent(inout) :: z(*)
               end subroutine clar1v
#else
               module procedure stdlib_clar1v
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc,&
                          negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: wantnc
                    integer(ilp), intent(in) :: b1,bn,n
                    integer(ilp), intent(out) :: negcnt,isuppz(*)
                    integer(ilp), intent(inout) :: r
                    real(dp), intent(in) :: gaptol,lambda,pivmin,d(*),l(*),ld(*),lld(*)
                    real(dp), intent(out) :: mingma,nrminv,resid,rqcorr,ztz,work(*)
                    real(dp), intent(inout) :: z(*)
               end subroutine dlar1v
#else
               module procedure stdlib_dlar1v
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc,&
                          negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: wantnc
                    integer(ilp), intent(in) :: b1,bn,n
                    integer(ilp), intent(out) :: negcnt,isuppz(*)
                    integer(ilp), intent(inout) :: r
                    real(sp), intent(in) :: gaptol,lambda,pivmin,d(*),l(*),ld(*),lld(*)
                    real(sp), intent(out) :: mingma,nrminv,resid,rqcorr,ztz,work(*)
                    real(sp), intent(inout) :: z(*)
               end subroutine slar1v
#else
               module procedure stdlib_slar1v
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc,&
                          negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: wantnc
                    integer(ilp), intent(in) :: b1,bn,n
                    integer(ilp), intent(out) :: negcnt,isuppz(*)
                    integer(ilp), intent(inout) :: r
                    real(dp), intent(in) :: gaptol,lambda,pivmin,d(*),l(*),ld(*),lld(*)
                    real(dp), intent(out) :: mingma,nrminv,resid,rqcorr,ztz,work(*)
                    complex(dp), intent(inout) :: z(*)
               end subroutine zlar1v
#else
               module procedure stdlib_zlar1v
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc,&
                          negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: wantnc
                    integer(ilp64), intent(in) :: b1,bn,n
                    integer(ilp64), intent(out) :: negcnt,isuppz(*)
                    integer(ilp64), intent(inout) :: r
                    real(sp), intent(in) :: gaptol,lambda,pivmin,d(*),l(*),ld(*),lld(*)
                    real(sp), intent(out) :: mingma,nrminv,resid,rqcorr,ztz,work(*)
                    complex(sp), intent(inout) :: z(*)
               end subroutine clar1v
#else
               module procedure stdlib_I64_clar1v
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc,&
                          negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: wantnc
                    integer(ilp64), intent(in) :: b1,bn,n
                    integer(ilp64), intent(out) :: negcnt,isuppz(*)
                    integer(ilp64), intent(inout) :: r
                    real(dp), intent(in) :: gaptol,lambda,pivmin,d(*),l(*),ld(*),lld(*)
                    real(dp), intent(out) :: mingma,nrminv,resid,rqcorr,ztz,work(*)
                    real(dp), intent(inout) :: z(*)
               end subroutine dlar1v
#else
               module procedure stdlib_I64_dlar1v
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc,&
                          negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: wantnc
                    integer(ilp64), intent(in) :: b1,bn,n
                    integer(ilp64), intent(out) :: negcnt,isuppz(*)
                    integer(ilp64), intent(inout) :: r
                    real(sp), intent(in) :: gaptol,lambda,pivmin,d(*),l(*),ld(*),lld(*)
                    real(sp), intent(out) :: mingma,nrminv,resid,rqcorr,ztz,work(*)
                    real(sp), intent(inout) :: z(*)
               end subroutine slar1v
#else
               module procedure stdlib_I64_slar1v
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc,&
                          negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: wantnc
                    integer(ilp64), intent(in) :: b1,bn,n
                    integer(ilp64), intent(out) :: negcnt,isuppz(*)
                    integer(ilp64), intent(inout) :: r
                    real(dp), intent(in) :: gaptol,lambda,pivmin,d(*),l(*),ld(*),lld(*)
                    real(dp), intent(out) :: mingma,nrminv,resid,rqcorr,ztz,work(*)
                    complex(dp), intent(inout) :: z(*)
               end subroutine zlar1v
#else
               module procedure stdlib_I64_zlar1v
#endif
          end interface lar1v

          interface lar2v
          !! LAR2V applies a vector of complex plane rotations with real cosines
          !! from both sides to a sequence of 2-by-2 complex Hermitian matrices,
          !! defined by the elements of the vectors x, y and z. For i = 1,2,...,n
          !! (       x(i)  z(i) ) :=
          !! ( conjg(z(i)) y(i) )
          !! (  c(i) conjg(s(i)) ) (       x(i)  z(i) ) ( c(i) -conjg(s(i)) )
          !! ( -s(i)       c(i)  ) ( conjg(z(i)) y(i) ) ( s(i)        c(i)  )
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clar2v( n, x, y, z, incx, c, s, incc )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incc,incx,n
                    real(sp), intent(in) :: c(*)
                    complex(sp), intent(in) :: s(*)
                    complex(sp), intent(inout) :: x(*),y(*),z(*)
               end subroutine clar2v
#else
               module procedure stdlib_clar2v
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlar2v( n, x, y, z, incx, c, s, incc )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incc,incx,n
                    real(dp), intent(in) :: c(*),s(*)
                    real(dp), intent(inout) :: x(*),y(*),z(*)
               end subroutine dlar2v
#else
               module procedure stdlib_dlar2v
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slar2v( n, x, y, z, incx, c, s, incc )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incc,incx,n
                    real(sp), intent(in) :: c(*),s(*)
                    real(sp), intent(inout) :: x(*),y(*),z(*)
               end subroutine slar2v
#else
               module procedure stdlib_slar2v
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlar2v( n, x, y, z, incx, c, s, incc )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incc,incx,n
                    real(dp), intent(in) :: c(*)
                    complex(dp), intent(in) :: s(*)
                    complex(dp), intent(inout) :: x(*),y(*),z(*)
               end subroutine zlar2v
#else
               module procedure stdlib_zlar2v
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clar2v( n, x, y, z, incx, c, s, incc )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incc,incx,n
                    real(sp), intent(in) :: c(*)
                    complex(sp), intent(in) :: s(*)
                    complex(sp), intent(inout) :: x(*),y(*),z(*)
               end subroutine clar2v
#else
               module procedure stdlib_I64_clar2v
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlar2v( n, x, y, z, incx, c, s, incc )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incc,incx,n
                    real(dp), intent(in) :: c(*),s(*)
                    real(dp), intent(inout) :: x(*),y(*),z(*)
               end subroutine dlar2v
#else
               module procedure stdlib_I64_dlar2v
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slar2v( n, x, y, z, incx, c, s, incc )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incc,incx,n
                    real(sp), intent(in) :: c(*),s(*)
                    real(sp), intent(inout) :: x(*),y(*),z(*)
               end subroutine slar2v
#else
               module procedure stdlib_I64_slar2v
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlar2v( n, x, y, z, incx, c, s, incc )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incc,incx,n
                    real(dp), intent(in) :: c(*)
                    complex(dp), intent(in) :: s(*)
                    complex(dp), intent(inout) :: x(*),y(*),z(*)
               end subroutine zlar2v
#else
               module procedure stdlib_I64_zlar2v
#endif
          end interface lar2v

          interface larcm
          !! LARCM performs a very simple matrix-matrix multiplication:
          !! C := A * B,
          !! where A is M by M and real; B is M by N and complex;
          !! C is M by N and complex.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarcm( m, n, a, lda, b, ldb, c, ldc, rwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: lda,ldb,ldc,m,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(in) :: b(ldb,*)
                    complex(sp), intent(out) :: c(ldc,*)
               end subroutine clarcm
#else
               module procedure stdlib_clarcm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarcm( m, n, a, lda, b, ldb, c, ldc, rwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: lda,ldb,ldc,m,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(in) :: b(ldb,*)
                    complex(dp), intent(out) :: c(ldc,*)
               end subroutine zlarcm
#else
               module procedure stdlib_zlarcm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clarcm( m, n, a, lda, b, ldb, c, ldc, rwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: lda,ldb,ldc,m,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(in) :: b(ldb,*)
                    complex(sp), intent(out) :: c(ldc,*)
               end subroutine clarcm
#else
               module procedure stdlib_I64_clarcm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlarcm( m, n, a, lda, b, ldb, c, ldc, rwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: lda,ldb,ldc,m,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(in) :: b(ldb,*)
                    complex(dp), intent(out) :: c(ldc,*)
               end subroutine zlarcm
#else
               module procedure stdlib_I64_zlarcm
#endif
          end interface larcm

          interface larf
          !! LARF applies a complex elementary reflector H to a complex M-by-N
          !! matrix C, from either the left or the right. H is represented in the
          !! form
          !! H = I - tau * v * v**H
          !! where tau is a complex scalar and v is a complex vector.
          !! If tau = 0, then H is taken to be the unit matrix.
          !! To apply H**H (the conjugate transpose of H), supply conjg(tau) instead
          !! tau.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarf( side, m, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side
                    integer(ilp), intent(in) :: incv,ldc,m,n
                    complex(sp), intent(in) :: tau,v(*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clarf
#else
               module procedure stdlib_clarf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarf( side, m, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side
                    integer(ilp), intent(in) :: incv,ldc,m,n
                    real(dp), intent(in) :: tau,v(*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlarf
#else
               module procedure stdlib_dlarf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarf( side, m, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side
                    integer(ilp), intent(in) :: incv,ldc,m,n
                    real(sp), intent(in) :: tau,v(*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slarf
#else
               module procedure stdlib_slarf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarf( side, m, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side
                    integer(ilp), intent(in) :: incv,ldc,m,n
                    complex(dp), intent(in) :: tau,v(*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlarf
#else
               module procedure stdlib_zlarf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clarf( side, m, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side
                    integer(ilp64), intent(in) :: incv,ldc,m,n
                    complex(sp), intent(in) :: tau,v(*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clarf
#else
               module procedure stdlib_I64_clarf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarf( side, m, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side
                    integer(ilp64), intent(in) :: incv,ldc,m,n
                    real(dp), intent(in) :: tau,v(*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlarf
#else
               module procedure stdlib_I64_dlarf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarf( side, m, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side
                    integer(ilp64), intent(in) :: incv,ldc,m,n
                    real(sp), intent(in) :: tau,v(*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slarf
#else
               module procedure stdlib_I64_slarf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlarf( side, m, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side
                    integer(ilp64), intent(in) :: incv,ldc,m,n
                    complex(dp), intent(in) :: tau,v(*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlarf
#else
               module procedure stdlib_I64_zlarf
#endif
          end interface larf

          interface larfb
          !! LARFB applies a complex block reflector H or its transpose H**H to a
          !! complex M-by-N matrix C, from either the left or the right.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarfb( side, trans, direct, storev, m, n, k, v, ldv,t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,ldc,ldt,ldv,ldwork,m,n
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(in) :: t(ldt,*),v(ldv,*)
                    complex(sp), intent(out) :: work(ldwork,*)
               end subroutine clarfb
#else
               module procedure stdlib_clarfb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarfb( side, trans, direct, storev, m, n, k, v, ldv,t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,ldc,ldt,ldv,ldwork,m,n
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(in) :: t(ldt,*),v(ldv,*)
                    real(dp), intent(out) :: work(ldwork,*)
               end subroutine dlarfb
#else
               module procedure stdlib_dlarfb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarfb( side, trans, direct, storev, m, n, k, v, ldv,t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,ldc,ldt,ldv,ldwork,m,n
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(in) :: t(ldt,*),v(ldv,*)
                    real(sp), intent(out) :: work(ldwork,*)
               end subroutine slarfb
#else
               module procedure stdlib_slarfb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarfb( side, trans, direct, storev, m, n, k, v, ldv,t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,ldc,ldt,ldv,ldwork,m,n
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(in) :: t(ldt,*),v(ldv,*)
                    complex(dp), intent(out) :: work(ldwork,*)
               end subroutine zlarfb
#else
               module procedure stdlib_zlarfb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clarfb( side, trans, direct, storev, m, n, k, v, ldv,t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp64), intent(in) :: k,ldc,ldt,ldv,ldwork,m,n
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(in) :: t(ldt,*),v(ldv,*)
                    complex(sp), intent(out) :: work(ldwork,*)
               end subroutine clarfb
#else
               module procedure stdlib_I64_clarfb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarfb( side, trans, direct, storev, m, n, k, v, ldv,t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp64), intent(in) :: k,ldc,ldt,ldv,ldwork,m,n
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(in) :: t(ldt,*),v(ldv,*)
                    real(dp), intent(out) :: work(ldwork,*)
               end subroutine dlarfb
#else
               module procedure stdlib_I64_dlarfb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarfb( side, trans, direct, storev, m, n, k, v, ldv,t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp64), intent(in) :: k,ldc,ldt,ldv,ldwork,m,n
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(in) :: t(ldt,*),v(ldv,*)
                    real(sp), intent(out) :: work(ldwork,*)
               end subroutine slarfb
#else
               module procedure stdlib_I64_slarfb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlarfb( side, trans, direct, storev, m, n, k, v, ldv,t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp64), intent(in) :: k,ldc,ldt,ldv,ldwork,m,n
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(in) :: t(ldt,*),v(ldv,*)
                    complex(dp), intent(out) :: work(ldwork,*)
               end subroutine zlarfb
#else
               module procedure stdlib_I64_zlarfb
#endif
          end interface larfb

          interface larfb_gett
          !! LARFB_GETT applies a complex Householder block reflector H from the
          !! left to a complex (K+M)-by-N  "triangular-pentagonal" matrix
          !! composed of two block matrices: an upper trapezoidal K-by-N matrix A
          !! stored in the array A, and a rectangular M-by-(N-K) matrix B, stored
          !! in the array B. The block reflector H is stored in a compact
          !! WY-representation, where the elementary reflectors are in the
          !! arrays A, B and T. See Further Details section.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarfb_gett( ident, m, n, k, t, ldt, a, lda, b, ldb,work, ldwork )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: ident
                    integer(ilp), intent(in) :: k,lda,ldb,ldt,ldwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(in) :: t(ldt,*)
                    complex(sp), intent(out) :: work(ldwork,*)
               end subroutine clarfb_gett
#else
               module procedure stdlib_clarfb_gett
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarfb_gett( ident, m, n, k, t, ldt, a, lda, b, ldb,work, ldwork )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: ident
                    integer(ilp), intent(in) :: k,lda,ldb,ldt,ldwork,m,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(in) :: t(ldt,*)
                    real(dp), intent(out) :: work(ldwork,*)
               end subroutine dlarfb_gett
#else
               module procedure stdlib_dlarfb_gett
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarfb_gett( ident, m, n, k, t, ldt, a, lda, b, ldb,work, ldwork )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: ident
                    integer(ilp), intent(in) :: k,lda,ldb,ldt,ldwork,m,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(in) :: t(ldt,*)
                    real(sp), intent(out) :: work(ldwork,*)
               end subroutine slarfb_gett
#else
               module procedure stdlib_slarfb_gett
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarfb_gett( ident, m, n, k, t, ldt, a, lda, b, ldb,work, ldwork )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: ident
                    integer(ilp), intent(in) :: k,lda,ldb,ldt,ldwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(in) :: t(ldt,*)
                    complex(dp), intent(out) :: work(ldwork,*)
               end subroutine zlarfb_gett
#else
               module procedure stdlib_zlarfb_gett
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clarfb_gett( ident, m, n, k, t, ldt, a, lda, b, ldb,work, ldwork )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: ident
                    integer(ilp64), intent(in) :: k,lda,ldb,ldt,ldwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(in) :: t(ldt,*)
                    complex(sp), intent(out) :: work(ldwork,*)
               end subroutine clarfb_gett
#else
               module procedure stdlib_I64_clarfb_gett
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarfb_gett( ident, m, n, k, t, ldt, a, lda, b, ldb,work, ldwork )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: ident
                    integer(ilp64), intent(in) :: k,lda,ldb,ldt,ldwork,m,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(in) :: t(ldt,*)
                    real(dp), intent(out) :: work(ldwork,*)
               end subroutine dlarfb_gett
#else
               module procedure stdlib_I64_dlarfb_gett
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarfb_gett( ident, m, n, k, t, ldt, a, lda, b, ldb,work, ldwork )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: ident
                    integer(ilp64), intent(in) :: k,lda,ldb,ldt,ldwork,m,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(in) :: t(ldt,*)
                    real(sp), intent(out) :: work(ldwork,*)
               end subroutine slarfb_gett
#else
               module procedure stdlib_I64_slarfb_gett
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlarfb_gett( ident, m, n, k, t, ldt, a, lda, b, ldb,work, ldwork )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: ident
                    integer(ilp64), intent(in) :: k,lda,ldb,ldt,ldwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(in) :: t(ldt,*)
                    complex(dp), intent(out) :: work(ldwork,*)
               end subroutine zlarfb_gett
#else
               module procedure stdlib_I64_zlarfb_gett
#endif
          end interface larfb_gett

          interface larfg
          !! LARFG generates a complex elementary reflector H of order n, such
          !! that
          !! H**H * ( alpha ) = ( beta ),   H**H * H = I.
          !! (   x   )   (   0  )
          !! where alpha and beta are scalars, with beta real, and x is an
          !! (n-1)-element complex vector. H is represented in the form
          !! H = I - tau * ( 1 ) * ( 1 v**H ) ,
          !! ( v )
          !! where tau is a complex scalar and v is a complex (n-1)-element
          !! vector. Note that H is not hermitian.
          !! If the elements of x are all zero and alpha is real, then tau = 0
          !! and H is taken to be the unit matrix.
          !! Otherwise  1 <= real(tau) <= 2  and  abs(tau-1) <= 1 .
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarfg( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,n
                    complex(sp), intent(inout) :: alpha,x(*)
                    complex(sp), intent(out) :: tau
               end subroutine clarfg
#else
               module procedure stdlib_clarfg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarfg( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,n
                    real(dp), intent(inout) :: alpha,x(*)
                    real(dp), intent(out) :: tau
               end subroutine dlarfg
#else
               module procedure stdlib_dlarfg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarfg( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,n
                    real(sp), intent(inout) :: alpha,x(*)
                    real(sp), intent(out) :: tau
               end subroutine slarfg
#else
               module procedure stdlib_slarfg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarfg( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,n
                    complex(dp), intent(inout) :: alpha,x(*)
                    complex(dp), intent(out) :: tau
               end subroutine zlarfg
#else
               module procedure stdlib_zlarfg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clarfg( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,n
                    complex(sp), intent(inout) :: alpha,x(*)
                    complex(sp), intent(out) :: tau
               end subroutine clarfg
#else
               module procedure stdlib_I64_clarfg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarfg( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,n
                    real(dp), intent(inout) :: alpha,x(*)
                    real(dp), intent(out) :: tau
               end subroutine dlarfg
#else
               module procedure stdlib_I64_dlarfg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarfg( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,n
                    real(sp), intent(inout) :: alpha,x(*)
                    real(sp), intent(out) :: tau
               end subroutine slarfg
#else
               module procedure stdlib_I64_slarfg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlarfg( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,n
                    complex(dp), intent(inout) :: alpha,x(*)
                    complex(dp), intent(out) :: tau
               end subroutine zlarfg
#else
               module procedure stdlib_I64_zlarfg
#endif
          end interface larfg

          interface larfgp
          !! LARFGP generates a complex elementary reflector H of order n, such
          !! that
          !! H**H * ( alpha ) = ( beta ),   H**H * H = I.
          !! (   x   )   (   0  )
          !! where alpha and beta are scalars, beta is real and non-negative, and
          !! x is an (n-1)-element complex vector.  H is represented in the form
          !! H = I - tau * ( 1 ) * ( 1 v**H ) ,
          !! ( v )
          !! where tau is a complex scalar and v is a complex (n-1)-element
          !! vector. Note that H is not hermitian.
          !! If the elements of x are all zero and alpha is real, then tau = 0
          !! and H is taken to be the unit matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine clarfgp( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,n
                    complex(sp), intent(inout) :: alpha,x(*)
                    complex(sp), intent(out) :: tau
               end subroutine clarfgp
#else
               module procedure stdlib_clarfgp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dlarfgp( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,n
                    real(dp), intent(inout) :: alpha,x(*)
                    real(dp), intent(out) :: tau
               end subroutine dlarfgp
#else
               module procedure stdlib_dlarfgp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine slarfgp( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,n
                    real(sp), intent(inout) :: alpha,x(*)
                    real(sp), intent(out) :: tau
               end subroutine slarfgp
#else
               module procedure stdlib_slarfgp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zlarfgp( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,n
                    complex(dp), intent(inout) :: alpha,x(*)
                    complex(dp), intent(out) :: tau
               end subroutine zlarfgp
#else
               module procedure stdlib_zlarfgp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine clarfgp( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,n
                    complex(sp), intent(inout) :: alpha,x(*)
                    complex(sp), intent(out) :: tau
               end subroutine clarfgp
#else
               module procedure stdlib_I64_clarfgp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dlarfgp( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,n
                    real(dp), intent(inout) :: alpha,x(*)
                    real(dp), intent(out) :: tau
               end subroutine dlarfgp
#else
               module procedure stdlib_I64_dlarfgp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine slarfgp( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,n
                    real(sp), intent(inout) :: alpha,x(*)
                    real(sp), intent(out) :: tau
               end subroutine slarfgp
#else
               module procedure stdlib_I64_slarfgp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zlarfgp( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,n
                    complex(dp), intent(inout) :: alpha,x(*)
                    complex(dp), intent(out) :: tau
               end subroutine zlarfgp
#else
               module procedure stdlib_I64_zlarfgp
#endif
          end interface larfgp

          interface larft
          !! LARFT forms the triangular factor T of a complex block reflector H
          !! of order n, which is defined as a product of k elementary reflectors.
          !! If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
          !! If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
          !! If STOREV = 'C', the vector which defines the elementary reflector
          !! H(i) is stored in the i-th column of the array V, and
          !! H  =  I - V * T * V**H
          !! If STOREV = 'R', the vector which defines the elementary reflector
          !! H(i) is stored in the i-th row of the array V, and
          !! H  =  I - V**H * T * V
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarft( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,storev
                    integer(ilp), intent(in) :: k,ldt,ldv,n
                    complex(sp), intent(out) :: t(ldt,*)
                    complex(sp), intent(in) :: tau(*),v(ldv,*)
               end subroutine clarft
#else
               module procedure stdlib_clarft
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarft( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,storev
                    integer(ilp), intent(in) :: k,ldt,ldv,n
                    real(dp), intent(out) :: t(ldt,*)
                    real(dp), intent(in) :: tau(*),v(ldv,*)
               end subroutine dlarft
#else
               module procedure stdlib_dlarft
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarft( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,storev
                    integer(ilp), intent(in) :: k,ldt,ldv,n
                    real(sp), intent(out) :: t(ldt,*)
                    real(sp), intent(in) :: tau(*),v(ldv,*)
               end subroutine slarft
#else
               module procedure stdlib_slarft
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarft( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,storev
                    integer(ilp), intent(in) :: k,ldt,ldv,n
                    complex(dp), intent(out) :: t(ldt,*)
                    complex(dp), intent(in) :: tau(*),v(ldv,*)
               end subroutine zlarft
#else
               module procedure stdlib_zlarft
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clarft( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,storev
                    integer(ilp64), intent(in) :: k,ldt,ldv,n
                    complex(sp), intent(out) :: t(ldt,*)
                    complex(sp), intent(in) :: tau(*),v(ldv,*)
               end subroutine clarft
#else
               module procedure stdlib_I64_clarft
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarft( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,storev
                    integer(ilp64), intent(in) :: k,ldt,ldv,n
                    real(dp), intent(out) :: t(ldt,*)
                    real(dp), intent(in) :: tau(*),v(ldv,*)
               end subroutine dlarft
#else
               module procedure stdlib_I64_dlarft
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarft( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,storev
                    integer(ilp64), intent(in) :: k,ldt,ldv,n
                    real(sp), intent(out) :: t(ldt,*)
                    real(sp), intent(in) :: tau(*),v(ldv,*)
               end subroutine slarft
#else
               module procedure stdlib_I64_slarft
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlarft( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,storev
                    integer(ilp64), intent(in) :: k,ldt,ldv,n
                    complex(dp), intent(out) :: t(ldt,*)
                    complex(dp), intent(in) :: tau(*),v(ldv,*)
               end subroutine zlarft
#else
               module procedure stdlib_I64_zlarft
#endif
          end interface larft

          interface larfy
          !! LARFY applies an elementary reflector, or Householder matrix, H,
          !! to an n x n Hermitian matrix C, from both the left and the right.
          !! H is represented in the form
          !! H = I - tau * v * v'
          !! where  tau  is a scalar and  v  is a vector.
          !! If  tau  is  zero, then  H  is taken to be the unit matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarfy( uplo, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incv,ldc,n
                    complex(sp), intent(in) :: tau,v(*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clarfy
#else
               module procedure stdlib_clarfy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarfy( uplo, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incv,ldc,n
                    real(dp), intent(in) :: tau,v(*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlarfy
#else
               module procedure stdlib_dlarfy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarfy( uplo, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incv,ldc,n
                    real(sp), intent(in) :: tau,v(*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slarfy
#else
               module procedure stdlib_slarfy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarfy( uplo, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incv,ldc,n
                    complex(dp), intent(in) :: tau,v(*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlarfy
#else
               module procedure stdlib_zlarfy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clarfy( uplo, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: incv,ldc,n
                    complex(sp), intent(in) :: tau,v(*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clarfy
#else
               module procedure stdlib_I64_clarfy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarfy( uplo, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: incv,ldc,n
                    real(dp), intent(in) :: tau,v(*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlarfy
#else
               module procedure stdlib_I64_dlarfy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarfy( uplo, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: incv,ldc,n
                    real(sp), intent(in) :: tau,v(*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slarfy
#else
               module procedure stdlib_I64_slarfy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlarfy( uplo, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: incv,ldc,n
                    complex(dp), intent(in) :: tau,v(*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlarfy
#else
               module procedure stdlib_I64_zlarfy
#endif
          end interface larfy

          interface largv
          !! LARGV generates a vector of complex plane rotations with real
          !! cosines, determined by elements of the complex vectors x and y.
          !! For i = 1,2,...,n
          !! (        c(i)   s(i) ) ( x(i) ) = ( r(i) )
          !! ( -conjg(s(i))  c(i) ) ( y(i) ) = (   0  )
          !! where c(i)**2 + ABS(s(i))**2 = 1
          !! The following conventions are used (these are the same as in CLARTG,
          !! but differ from the BLAS1 routine CROTG):
          !! If y(i)=0, then c(i)=1 and s(i)=0.
          !! If x(i)=0, then c(i)=0 and s(i) is chosen so that r(i) is real.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clargv( n, x, incx, y, incy, c, incc )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incc,incx,incy,n
                    real(sp), intent(out) :: c(*)
                    complex(sp), intent(inout) :: x(*),y(*)
               end subroutine clargv
#else
               module procedure stdlib_clargv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlargv( n, x, incx, y, incy, c, incc )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incc,incx,incy,n
                    real(dp), intent(out) :: c(*)
                    real(dp), intent(inout) :: x(*),y(*)
               end subroutine dlargv
#else
               module procedure stdlib_dlargv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slargv( n, x, incx, y, incy, c, incc )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incc,incx,incy,n
                    real(sp), intent(out) :: c(*)
                    real(sp), intent(inout) :: x(*),y(*)
               end subroutine slargv
#else
               module procedure stdlib_slargv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlargv( n, x, incx, y, incy, c, incc )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incc,incx,incy,n
                    real(dp), intent(out) :: c(*)
                    complex(dp), intent(inout) :: x(*),y(*)
               end subroutine zlargv
#else
               module procedure stdlib_zlargv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clargv( n, x, incx, y, incy, c, incc )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incc,incx,incy,n
                    real(sp), intent(out) :: c(*)
                    complex(sp), intent(inout) :: x(*),y(*)
               end subroutine clargv
#else
               module procedure stdlib_I64_clargv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlargv( n, x, incx, y, incy, c, incc )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incc,incx,incy,n
                    real(dp), intent(out) :: c(*)
                    real(dp), intent(inout) :: x(*),y(*)
               end subroutine dlargv
#else
               module procedure stdlib_I64_dlargv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slargv( n, x, incx, y, incy, c, incc )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incc,incx,incy,n
                    real(sp), intent(out) :: c(*)
                    real(sp), intent(inout) :: x(*),y(*)
               end subroutine slargv
#else
               module procedure stdlib_I64_slargv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlargv( n, x, incx, y, incy, c, incc )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incc,incx,incy,n
                    real(dp), intent(out) :: c(*)
                    complex(dp), intent(inout) :: x(*),y(*)
               end subroutine zlargv
#else
               module procedure stdlib_I64_zlargv
#endif
          end interface largv

          interface larnv
          !! LARNV returns a vector of n random complex numbers from a uniform or
          !! normal distribution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarnv( idist, iseed, n, x )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: idist,n
                    integer(ilp), intent(inout) :: iseed(4)
                    complex(sp), intent(out) :: x(*)
               end subroutine clarnv
#else
               module procedure stdlib_clarnv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarnv( idist, iseed, n, x )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: idist,n
                    integer(ilp), intent(inout) :: iseed(4)
                    real(dp), intent(out) :: x(*)
               end subroutine dlarnv
#else
               module procedure stdlib_dlarnv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarnv( idist, iseed, n, x )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: idist,n
                    integer(ilp), intent(inout) :: iseed(4)
                    real(sp), intent(out) :: x(*)
               end subroutine slarnv
#else
               module procedure stdlib_slarnv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarnv( idist, iseed, n, x )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: idist,n
                    integer(ilp), intent(inout) :: iseed(4)
                    complex(dp), intent(out) :: x(*)
               end subroutine zlarnv
#else
               module procedure stdlib_zlarnv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clarnv( idist, iseed, n, x )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: idist,n
                    integer(ilp64), intent(inout) :: iseed(4)
                    complex(sp), intent(out) :: x(*)
               end subroutine clarnv
#else
               module procedure stdlib_I64_clarnv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarnv( idist, iseed, n, x )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: idist,n
                    integer(ilp64), intent(inout) :: iseed(4)
                    real(dp), intent(out) :: x(*)
               end subroutine dlarnv
#else
               module procedure stdlib_I64_dlarnv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarnv( idist, iseed, n, x )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: idist,n
                    integer(ilp64), intent(inout) :: iseed(4)
                    real(sp), intent(out) :: x(*)
               end subroutine slarnv
#else
               module procedure stdlib_I64_slarnv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlarnv( idist, iseed, n, x )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: idist,n
                    integer(ilp64), intent(inout) :: iseed(4)
                    complex(dp), intent(out) :: x(*)
               end subroutine zlarnv
#else
               module procedure stdlib_I64_zlarnv
#endif
          end interface larnv

          interface larra
          !! Compute the splitting points with threshold SPLTOL.
          !! LARRA sets any "small" off-diagonal elements to zero.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarra( n, d, e, e2, spltol, tnrm,nsplit, isplit, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,nsplit,isplit(*)
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: spltol,tnrm,d(*)
                    real(dp), intent(inout) :: e(*),e2(*)
               end subroutine dlarra
#else
               module procedure stdlib_dlarra
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarra( n, d, e, e2, spltol, tnrm,nsplit, isplit, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,nsplit,isplit(*)
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: spltol,tnrm,d(*)
                    real(sp), intent(inout) :: e(*),e2(*)
               end subroutine slarra
#else
               module procedure stdlib_slarra
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarra( n, d, e, e2, spltol, tnrm,nsplit, isplit, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,nsplit,isplit(*)
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: spltol,tnrm,d(*)
                    real(dp), intent(inout) :: e(*),e2(*)
               end subroutine dlarra
#else
               module procedure stdlib_I64_dlarra
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarra( n, d, e, e2, spltol, tnrm,nsplit, isplit, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,nsplit,isplit(*)
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: spltol,tnrm,d(*)
                    real(sp), intent(inout) :: e(*),e2(*)
               end subroutine slarra
#else
               module procedure stdlib_I64_slarra
#endif
          end interface larra

          interface larrb
          !! Given the relatively robust representation(RRR) L D L^T, LARRB:
          !! does "limited" bisection to refine the eigenvalues of L D L^T,
          !! W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
          !! guesses for these eigenvalues are input in W, the corresponding estimate
          !! of the error in these guesses and their gaps are input in WERR
          !! and WGAP, respectively. During bisection, intervals
          !! [left, right] are maintained by storing their mid-points and
          !! semi-widths in the arrays W and WERR respectively.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarrb( n, d, lld, ifirst, ilast, rtol1,rtol2, offset, w, wgap, &
                         werr, work, iwork,pivmin, spdiam, twist, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ifirst,ilast,n,offset,twist
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: pivmin,rtol1,rtol2,spdiam,d(*),lld(*)
                    real(dp), intent(inout) :: w(*),werr(*),wgap(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlarrb
#else
               module procedure stdlib_dlarrb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarrb( n, d, lld, ifirst, ilast, rtol1,rtol2, offset, w, wgap, &
                         werr, work, iwork,pivmin, spdiam, twist, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ifirst,ilast,n,offset,twist
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: pivmin,rtol1,rtol2,spdiam,d(*),lld(*)
                    real(sp), intent(inout) :: w(*),werr(*),wgap(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slarrb
#else
               module procedure stdlib_slarrb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarrb( n, d, lld, ifirst, ilast, rtol1,rtol2, offset, w, wgap, &
                         werr, work, iwork,pivmin, spdiam, twist, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ifirst,ilast,n,offset,twist
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: pivmin,rtol1,rtol2,spdiam,d(*),lld(*)
                    real(dp), intent(inout) :: w(*),werr(*),wgap(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlarrb
#else
               module procedure stdlib_I64_dlarrb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarrb( n, d, lld, ifirst, ilast, rtol1,rtol2, offset, w, wgap, &
                         werr, work, iwork,pivmin, spdiam, twist, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ifirst,ilast,n,offset,twist
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: pivmin,rtol1,rtol2,spdiam,d(*),lld(*)
                    real(sp), intent(inout) :: w(*),werr(*),wgap(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slarrb
#else
               module procedure stdlib_I64_slarrb
#endif
          end interface larrb

          interface larrc
          !! Find the number of eigenvalues of the symmetric tridiagonal matrix T
          !! that are in the interval (VL,VU] if JOBT = 'T', and of L D L^T
          !! if JOBT = 'L'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarrc( jobt, n, vl, vu, d, e, pivmin,eigcnt, lcnt, rcnt, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobt
                    integer(ilp), intent(out) :: eigcnt,info,lcnt,rcnt
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: pivmin,vl,vu,d(*),e(*)
               end subroutine dlarrc
#else
               module procedure stdlib_dlarrc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarrc( jobt, n, vl, vu, d, e, pivmin,eigcnt, lcnt, rcnt, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobt
                    integer(ilp), intent(out) :: eigcnt,info,lcnt,rcnt
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: pivmin,vl,vu,d(*),e(*)
               end subroutine slarrc
#else
               module procedure stdlib_slarrc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarrc( jobt, n, vl, vu, d, e, pivmin,eigcnt, lcnt, rcnt, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobt
                    integer(ilp64), intent(out) :: eigcnt,info,lcnt,rcnt
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: pivmin,vl,vu,d(*),e(*)
               end subroutine dlarrc
#else
               module procedure stdlib_I64_dlarrc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarrc( jobt, n, vl, vu, d, e, pivmin,eigcnt, lcnt, rcnt, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobt
                    integer(ilp64), intent(out) :: eigcnt,info,lcnt,rcnt
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: pivmin,vl,vu,d(*),e(*)
               end subroutine slarrc
#else
               module procedure stdlib_I64_slarrc
#endif
          end interface larrc

          interface larrd
          !! LARRD computes the eigenvalues of a symmetric tridiagonal
          !! matrix T to suitable accuracy. This is an auxiliary code to be
          !! called from DSTEMR.
          !! The user may ask for all eigenvalues, all eigenvalues
          !! in the half-open interval (VL, VU], or the IL-th through IU-th
          !! eigenvalues.
          !! To avoid overflow, the matrix must be scaled so that its
          !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
          !! accuracy, it should not be much smaller than that.
          !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
          !! Matrix", Report CS41, Computer Science Dept., Stanford
          !! University, July 21, 1966.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarrd( range, order, n, vl, vu, il, iu, gers,reltol, d, e, e2, &
               pivmin, nsplit, isplit,m, w, werr, wl, wu, iblock, indexw,work, iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: order,range
                    integer(ilp), intent(in) :: il,iu,n,nsplit,isplit(*)
                    integer(ilp), intent(out) :: info,m,iblock(*),indexw(*),iwork(*)
                    real(dp), intent(in) :: pivmin,reltol,vl,vu,d(*),e(*),e2(*),gers(*)
                    real(dp), intent(out) :: wl,wu,w(*),werr(*),work(*)
               end subroutine dlarrd
#else
               module procedure stdlib_dlarrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarrd( range, order, n, vl, vu, il, iu, gers,reltol, d, e, e2, &
               pivmin, nsplit, isplit,m, w, werr, wl, wu, iblock, indexw,work, iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: order,range
                    integer(ilp), intent(in) :: il,iu,n,nsplit,isplit(*)
                    integer(ilp), intent(out) :: info,m,iblock(*),indexw(*),iwork(*)
                    real(sp), intent(in) :: pivmin,reltol,vl,vu,d(*),e(*),e2(*),gers(*)
                    real(sp), intent(out) :: wl,wu,w(*),werr(*),work(*)
               end subroutine slarrd
#else
               module procedure stdlib_slarrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarrd( range, order, n, vl, vu, il, iu, gers,reltol, d, e, e2, &
               pivmin, nsplit, isplit,m, w, werr, wl, wu, iblock, indexw,work, iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: order,range
                    integer(ilp64), intent(in) :: il,iu,n,nsplit,isplit(*)
                    integer(ilp64), intent(out) :: info,m,iblock(*),indexw(*),iwork(*)
                    real(dp), intent(in) :: pivmin,reltol,vl,vu,d(*),e(*),e2(*),gers(*)
                    real(dp), intent(out) :: wl,wu,w(*),werr(*),work(*)
               end subroutine dlarrd
#else
               module procedure stdlib_I64_dlarrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarrd( range, order, n, vl, vu, il, iu, gers,reltol, d, e, e2, &
               pivmin, nsplit, isplit,m, w, werr, wl, wu, iblock, indexw,work, iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: order,range
                    integer(ilp64), intent(in) :: il,iu,n,nsplit,isplit(*)
                    integer(ilp64), intent(out) :: info,m,iblock(*),indexw(*),iwork(*)
                    real(sp), intent(in) :: pivmin,reltol,vl,vu,d(*),e(*),e2(*),gers(*)
                    real(sp), intent(out) :: wl,wu,w(*),werr(*),work(*)
               end subroutine slarrd
#else
               module procedure stdlib_I64_slarrd
#endif
          end interface larrd

          interface larre
          !! To find the desired eigenvalues of a given real symmetric
          !! tridiagonal matrix T, LARRE: sets any "small" off-diagonal
          !! elements to zero, and for each unreduced block T_i, it finds
          !! (a) a suitable shift at one end of the block's spectrum,
          !! (b) the base representation, T_i - sigma_i I = L_i D_i L_i^T, and
          !! (c) eigenvalues of each L_i D_i L_i^T.
          !! The representations and eigenvalues found are then used by
          !! DSTEMR to compute the eigenvectors of T.
          !! The accuracy varies depending on whether bisection is used to
          !! find a few eigenvalues or the dqds algorithm (subroutine DLASQ2) to
          !! conpute all and then discard any unwanted one.
          !! As an added benefit, LARRE also outputs the n
          !! Gerschgorin intervals for the matrices L_i D_i L_i^T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarre( range, n, vl, vu, il, iu, d, e, e2,rtol1, rtol2, spltol, &
               nsplit, isplit, m,w, werr, wgap, iblock, indexw, gers, pivmin,work, iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: range
                    integer(ilp), intent(in) :: il,iu,n
                    integer(ilp), intent(out) :: info,m,nsplit,iblock(*),isplit(*),iwork(*),&
                              indexw(*)
                    real(dp), intent(out) :: pivmin,gers(*),w(*),werr(*),wgap(*),work(*)
                    real(dp), intent(in) :: rtol1,rtol2,spltol
                    real(dp), intent(inout) :: vl,vu,d(*),e(*),e2(*)
               end subroutine dlarre
#else
               module procedure stdlib_dlarre
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarre( range, n, vl, vu, il, iu, d, e, e2,rtol1, rtol2, spltol, &
               nsplit, isplit, m,w, werr, wgap, iblock, indexw, gers, pivmin,work, iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: range
                    integer(ilp), intent(in) :: il,iu,n
                    integer(ilp), intent(out) :: info,m,nsplit,iblock(*),isplit(*),iwork(*),&
                              indexw(*)
                    real(sp), intent(out) :: pivmin,gers(*),w(*),werr(*),wgap(*),work(*)
                    real(sp), intent(in) :: rtol1,rtol2,spltol
                    real(sp), intent(inout) :: vl,vu,d(*),e(*),e2(*)
               end subroutine slarre
#else
               module procedure stdlib_slarre
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarre( range, n, vl, vu, il, iu, d, e, e2,rtol1, rtol2, spltol, &
               nsplit, isplit, m,w, werr, wgap, iblock, indexw, gers, pivmin,work, iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: range
                    integer(ilp64), intent(in) :: il,iu,n
                    integer(ilp64), intent(out) :: info,m,nsplit,iblock(*),isplit(*),iwork(*),&
                              indexw(*)
                    real(dp), intent(out) :: pivmin,gers(*),w(*),werr(*),wgap(*),work(*)
                    real(dp), intent(in) :: rtol1,rtol2,spltol
                    real(dp), intent(inout) :: vl,vu,d(*),e(*),e2(*)
               end subroutine dlarre
#else
               module procedure stdlib_I64_dlarre
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarre( range, n, vl, vu, il, iu, d, e, e2,rtol1, rtol2, spltol, &
               nsplit, isplit, m,w, werr, wgap, iblock, indexw, gers, pivmin,work, iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: range
                    integer(ilp64), intent(in) :: il,iu,n
                    integer(ilp64), intent(out) :: info,m,nsplit,iblock(*),isplit(*),iwork(*),&
                              indexw(*)
                    real(sp), intent(out) :: pivmin,gers(*),w(*),werr(*),wgap(*),work(*)
                    real(sp), intent(in) :: rtol1,rtol2,spltol
                    real(sp), intent(inout) :: vl,vu,d(*),e(*),e2(*)
               end subroutine slarre
#else
               module procedure stdlib_I64_slarre
#endif
          end interface larre

          interface larrf
          !! Given the initial representation L D L^T and its cluster of close
          !! eigenvalues (in a relative measure), W( CLSTRT ), W( CLSTRT+1 ), ...
          !! W( CLEND ), LARRF: finds a new relatively robust representation
          !! L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the
          !! eigenvalues of L(+) D(+) L(+)^T is relatively isolated.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarrf( n, d, l, ld, clstrt, clend,w, wgap, werr,spdiam, clgapl, &
                         clgapr, pivmin, sigma,dplus, lplus, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: clstrt,clend,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: clgapl,clgapr,pivmin,spdiam,d(*),l(*),ld(*),w(*),werr(&
                              *)
                    real(dp), intent(out) :: sigma,dplus(*),lplus(*),work(*)
                    real(dp), intent(inout) :: wgap(*)
               end subroutine dlarrf
#else
               module procedure stdlib_dlarrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarrf( n, d, l, ld, clstrt, clend,w, wgap, werr,spdiam, clgapl, &
                         clgapr, pivmin, sigma,dplus, lplus, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: clstrt,clend,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: clgapl,clgapr,pivmin,spdiam,d(*),l(*),ld(*),w(*),werr(&
                              *)
                    real(sp), intent(out) :: sigma,dplus(*),lplus(*),work(*)
                    real(sp), intent(inout) :: wgap(*)
               end subroutine slarrf
#else
               module procedure stdlib_slarrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarrf( n, d, l, ld, clstrt, clend,w, wgap, werr,spdiam, clgapl, &
                         clgapr, pivmin, sigma,dplus, lplus, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: clstrt,clend,n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(in) :: clgapl,clgapr,pivmin,spdiam,d(*),l(*),ld(*),w(*),werr(&
                              *)
                    real(dp), intent(out) :: sigma,dplus(*),lplus(*),work(*)
                    real(dp), intent(inout) :: wgap(*)
               end subroutine dlarrf
#else
               module procedure stdlib_I64_dlarrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarrf( n, d, l, ld, clstrt, clend,w, wgap, werr,spdiam, clgapl, &
                         clgapr, pivmin, sigma,dplus, lplus, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: clstrt,clend,n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(in) :: clgapl,clgapr,pivmin,spdiam,d(*),l(*),ld(*),w(*),werr(&
                              *)
                    real(sp), intent(out) :: sigma,dplus(*),lplus(*),work(*)
                    real(sp), intent(inout) :: wgap(*)
               end subroutine slarrf
#else
               module procedure stdlib_I64_slarrf
#endif
          end interface larrf

          interface larrj
          !! Given the initial eigenvalue approximations of T, LARRJ:
          !! does  bisection to refine the eigenvalues of T,
          !! W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
          !! guesses for these eigenvalues are input in W, the corresponding estimate
          !! of the error in these guesses in WERR. During bisection, intervals
          !! [left, right] are maintained by storing their mid-points and
          !! semi-widths in the arrays W and WERR respectively.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarrj( n, d, e2, ifirst, ilast,rtol, offset, w, werr, work, iwork,&
                         pivmin, spdiam, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ifirst,ilast,n,offset
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: pivmin,rtol,spdiam,d(*),e2(*)
                    real(dp), intent(inout) :: w(*),werr(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlarrj
#else
               module procedure stdlib_dlarrj
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarrj( n, d, e2, ifirst, ilast,rtol, offset, w, werr, work, iwork,&
                         pivmin, spdiam, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ifirst,ilast,n,offset
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: pivmin,rtol,spdiam,d(*),e2(*)
                    real(sp), intent(inout) :: w(*),werr(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slarrj
#else
               module procedure stdlib_slarrj
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarrj( n, d, e2, ifirst, ilast,rtol, offset, w, werr, work, iwork,&
                         pivmin, spdiam, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ifirst,ilast,n,offset
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: pivmin,rtol,spdiam,d(*),e2(*)
                    real(dp), intent(inout) :: w(*),werr(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlarrj
#else
               module procedure stdlib_I64_dlarrj
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarrj( n, d, e2, ifirst, ilast,rtol, offset, w, werr, work, iwork,&
                         pivmin, spdiam, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ifirst,ilast,n,offset
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: pivmin,rtol,spdiam,d(*),e2(*)
                    real(sp), intent(inout) :: w(*),werr(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slarrj
#else
               module procedure stdlib_I64_slarrj
#endif
          end interface larrj

          interface larrk
          !! LARRK computes one eigenvalue of a symmetric tridiagonal
          !! matrix T to suitable accuracy. This is an auxiliary code to be
          !! called from DSTEMR.
          !! To avoid overflow, the matrix must be scaled so that its
          !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
          !! accuracy, it should not be much smaller than that.
          !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
          !! Matrix", Report CS41, Computer Science Dept., Stanford
          !! University, July 21, 1966.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarrk( n, iw, gl, gu,d, e2, pivmin, reltol, w, werr, info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: iw,n
                    real(dp), intent(in) :: pivmin,reltol,gl,gu,d(*),e2(*)
                    real(dp), intent(out) :: w,werr
               end subroutine dlarrk
#else
               module procedure stdlib_dlarrk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarrk( n, iw, gl, gu,d, e2, pivmin, reltol, w, werr, info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: iw,n
                    real(sp), intent(in) :: pivmin,reltol,gl,gu,d(*),e2(*)
                    real(sp), intent(out) :: w,werr
               end subroutine slarrk
#else
               module procedure stdlib_slarrk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarrk( n, iw, gl, gu,d, e2, pivmin, reltol, w, werr, info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: iw,n
                    real(dp), intent(in) :: pivmin,reltol,gl,gu,d(*),e2(*)
                    real(dp), intent(out) :: w,werr
               end subroutine dlarrk
#else
               module procedure stdlib_I64_dlarrk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarrk( n, iw, gl, gu,d, e2, pivmin, reltol, w, werr, info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: iw,n
                    real(sp), intent(in) :: pivmin,reltol,gl,gu,d(*),e2(*)
                    real(sp), intent(out) :: w,werr
               end subroutine slarrk
#else
               module procedure stdlib_I64_slarrk
#endif
          end interface larrk

          interface larrr
          !! Perform tests to decide whether the symmetric tridiagonal matrix T
          !! warrants expensive computations which guarantee high relative accuracy
          !! in the eigenvalues.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarrr( n, d, e, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: d(*)
                    real(dp), intent(inout) :: e(*)
               end subroutine dlarrr
#else
               module procedure stdlib_dlarrr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarrr( n, d, e, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: d(*)
                    real(sp), intent(inout) :: e(*)
               end subroutine slarrr
#else
               module procedure stdlib_slarrr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarrr( n, d, e, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(in) :: d(*)
                    real(dp), intent(inout) :: e(*)
               end subroutine dlarrr
#else
               module procedure stdlib_I64_dlarrr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarrr( n, d, e, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(in) :: d(*)
                    real(sp), intent(inout) :: e(*)
               end subroutine slarrr
#else
               module procedure stdlib_I64_slarrr
#endif
          end interface larrr

          interface larrv
          !! LARRV computes the eigenvectors of the tridiagonal matrix
          !! T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.
          !! The input eigenvalues should have been computed by SLARRE.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: dol,dou,ldz,m,n,iblock(*),indexw(*),isplit(*)

                    integer(ilp), intent(out) :: info,isuppz(*),iwork(*)
                    real(sp), intent(in) :: minrgp,pivmin,vl,vu,gers(*)
                    real(sp), intent(inout) :: rtol1,rtol2,d(*),l(*),w(*),werr(*),wgap(*)
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(out) :: z(ldz,*)
               end subroutine clarrv
#else
               module procedure stdlib_clarrv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: dol,dou,ldz,m,n,iblock(*),indexw(*),isplit(*)

                    integer(ilp), intent(out) :: info,isuppz(*),iwork(*)
                    real(dp), intent(in) :: minrgp,pivmin,vl,vu,gers(*)
                    real(dp), intent(inout) :: rtol1,rtol2,d(*),l(*),w(*),werr(*),wgap(*)
                    real(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine dlarrv
#else
               module procedure stdlib_dlarrv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: dol,dou,ldz,m,n,iblock(*),indexw(*),isplit(*)

                    integer(ilp), intent(out) :: info,isuppz(*),iwork(*)
                    real(sp), intent(in) :: minrgp,pivmin,vl,vu,gers(*)
                    real(sp), intent(inout) :: rtol1,rtol2,d(*),l(*),w(*),werr(*),wgap(*)
                    real(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine slarrv
#else
               module procedure stdlib_slarrv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: dol,dou,ldz,m,n,iblock(*),indexw(*),isplit(*)

                    integer(ilp), intent(out) :: info,isuppz(*),iwork(*)
                    real(dp), intent(in) :: minrgp,pivmin,vl,vu,gers(*)
                    real(dp), intent(inout) :: rtol1,rtol2,d(*),l(*),w(*),werr(*),wgap(*)
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(out) :: z(ldz,*)
               end subroutine zlarrv
#else
               module procedure stdlib_zlarrv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: dol,dou,ldz,m,n,iblock(*),indexw(*),isplit(*)

                    integer(ilp64), intent(out) :: info,isuppz(*),iwork(*)
                    real(sp), intent(in) :: minrgp,pivmin,vl,vu,gers(*)
                    real(sp), intent(inout) :: rtol1,rtol2,d(*),l(*),w(*),werr(*),wgap(*)
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(out) :: z(ldz,*)
               end subroutine clarrv
#else
               module procedure stdlib_I64_clarrv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: dol,dou,ldz,m,n,iblock(*),indexw(*),isplit(*)

                    integer(ilp64), intent(out) :: info,isuppz(*),iwork(*)
                    real(dp), intent(in) :: minrgp,pivmin,vl,vu,gers(*)
                    real(dp), intent(inout) :: rtol1,rtol2,d(*),l(*),w(*),werr(*),wgap(*)
                    real(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine dlarrv
#else
               module procedure stdlib_I64_dlarrv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: dol,dou,ldz,m,n,iblock(*),indexw(*),isplit(*)

                    integer(ilp64), intent(out) :: info,isuppz(*),iwork(*)
                    real(sp), intent(in) :: minrgp,pivmin,vl,vu,gers(*)
                    real(sp), intent(inout) :: rtol1,rtol2,d(*),l(*),w(*),werr(*),wgap(*)
                    real(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine slarrv
#else
               module procedure stdlib_I64_slarrv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: dol,dou,ldz,m,n,iblock(*),indexw(*),isplit(*)

                    integer(ilp64), intent(out) :: info,isuppz(*),iwork(*)
                    real(dp), intent(in) :: minrgp,pivmin,vl,vu,gers(*)
                    real(dp), intent(inout) :: rtol1,rtol2,d(*),l(*),w(*),werr(*),wgap(*)
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(out) :: z(ldz,*)
               end subroutine zlarrv
#else
               module procedure stdlib_I64_zlarrv
#endif
          end interface larrv

          interface lartg
          !! LARTG generates a plane rotation so that
          !! [  C         S  ] . [ F ]  =  [ R ]
          !! [ -conjg(S)  C  ]   [ G ]     [ 0 ]
          !! where C is real and C**2 + |S|**2 = 1.
          !! The mathematical formulas used for C and S are
          !! sgn(x) = {  x / |x|,   x != 0
          !! {  1,         x = 0
          !! R = sgn(F) * sqrt(|F|**2 + |G|**2)
          !! C = |F| / sqrt(|F|**2 + |G|**2)
          !! S = sgn(F) * conjg(G) / sqrt(|F|**2 + |G|**2)
          !! When F and G are real, the formulas simplify to C = F/R and
          !! S = G/R, and the returned values of C, S, and R should be
          !! identical to those returned by LARTG.
          !! The algorithm used to compute these quantities incorporates scaling
          !! to avoid overflow or underflow in computing the square root of the
          !! sum of squares.
          !! This is a faster version of the BLAS1 routine CROTG, except for
          !! the following differences:
          !! F and G are unchanged on return.
          !! If G=0, then C=1 and S=0.
          !! If F=0, then C=0 and S is chosen so that R is real.
          !! Below, wp=>sp stands for single precision from LA_CONSTANTS module.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slartg( f, g, c, s, r )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(out) :: c
                    real(sp), intent(in) :: f,g
                    real(sp), intent(out) :: r,s
               end subroutine slartg
#else
               module procedure stdlib_slartg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlartg( f, g, c, s, r )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(out) :: c
                    real(dp), intent(in) :: f,g
                    real(dp), intent(out) :: r,s
               end subroutine dlartg
#else
               module procedure stdlib_dlartg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clartg( f, g, c, s, r )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(out) :: c
                    complex(sp), intent(in) :: f,g
                    complex(sp), intent(out) :: r,s
               end subroutine clartg
#else
               module procedure stdlib_clartg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlartg( f, g, c, s, r )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(out) :: c
                    complex(dp), intent(in) :: f,g
                    complex(dp), intent(out) :: r,s
               end subroutine zlartg
#else
               module procedure stdlib_zlartg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slartg( f, g, c, s, r )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(out) :: c
                    real(sp), intent(in) :: f,g
                    real(sp), intent(out) :: r,s
               end subroutine slartg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlartg( f, g, c, s, r )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(out) :: c
                    real(dp), intent(in) :: f,g
                    real(dp), intent(out) :: r,s
               end subroutine dlartg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clartg( f, g, c, s, r )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(out) :: c
                    complex(sp), intent(in) :: f,g
                    complex(sp), intent(out) :: r,s
               end subroutine clartg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlartg( f, g, c, s, r )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(out) :: c
                    complex(dp), intent(in) :: f,g
                    complex(dp), intent(out) :: r,s
               end subroutine zlartg
#endif
          end interface lartg

          interface lartgp
          !! LARTGP generates a plane rotation so that
          !! [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
          !! [ -SN  CS  ]     [ G ]     [ 0 ]
          !! This is a slower, more accurate version of the Level 1 BLAS routine DROTG,
          !! with the following other differences:
          !! F and G are unchanged on return.
          !! If G=0, then CS=(+/-)1 and SN=0.
          !! If F=0 and (G .ne. 0), then CS=0 and SN=(+/-)1.
          !! The sign is chosen so that R >= 0.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slartgp( f, g, cs, sn, r )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(out) :: cs,r,sn
                    real(sp), intent(in) :: f,g
               end subroutine slartgp
#else
               module procedure stdlib_slartgp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlartgp( f, g, cs, sn, r )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(out) :: cs,r,sn
                    real(dp), intent(in) :: f,g
               end subroutine dlartgp
#else
               module procedure stdlib_dlartgp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slartgp( f, g, cs, sn, r )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(out) :: cs,r,sn
                    real(sp), intent(in) :: f,g
               end subroutine slartgp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlartgp( f, g, cs, sn, r )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(out) :: cs,r,sn
                    real(dp), intent(in) :: f,g
               end subroutine dlartgp
#endif
          end interface lartgp

          interface lartgs
          !! LARTGS generates a plane rotation designed to introduce a bulge in
          !! Golub-Reinsch-style implicit QR iteration for the bidiagonal SVD
          !! problem. X and Y are the top-row entries, and SIGMA is the shift.
          !! The computed CS and SN define a plane rotation satisfying
          !! [  CS  SN  ]  .  [ X^2 - SIGMA ]  =  [ R ],
          !! [ -SN  CS  ]     [    X * Y    ]     [ 0 ]
          !! with R nonnegative.  If X^2 - SIGMA and X * Y are 0, then the
          !! rotation is by PI/2.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slartgs( x, y, sigma, cs, sn )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(out) :: cs,sn
                    real(sp), intent(in) :: sigma,x,y
               end subroutine slartgs
#else
               module procedure stdlib_slartgs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlartgs( x, y, sigma, cs, sn )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(out) :: cs,sn
                    real(dp), intent(in) :: sigma,x,y
               end subroutine dlartgs
#else
               module procedure stdlib_dlartgs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slartgs( x, y, sigma, cs, sn )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(out) :: cs,sn
                    real(sp), intent(in) :: sigma,x,y
               end subroutine slartgs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlartgs( x, y, sigma, cs, sn )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(out) :: cs,sn
                    real(dp), intent(in) :: sigma,x,y
               end subroutine dlartgs
#endif
          end interface lartgs

          interface lartv
          !! LARTV applies a vector of complex plane rotations with real cosines
          !! to elements of the complex vectors x and y. For i = 1,2,...,n
          !! ( x(i) ) := (        c(i)   s(i) ) ( x(i) )
          !! ( y(i) )    ( -conjg(s(i))  c(i) ) ( y(i) )
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clartv( n, x, incx, y, incy, c, s, incc )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incc,incx,incy,n
                    real(sp), intent(in) :: c(*)
                    complex(sp), intent(in) :: s(*)
                    complex(sp), intent(inout) :: x(*),y(*)
               end subroutine clartv
#else
               module procedure stdlib_clartv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlartv( n, x, incx, y, incy, c, s, incc )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incc,incx,incy,n
                    real(dp), intent(in) :: c(*),s(*)
                    real(dp), intent(inout) :: x(*),y(*)
               end subroutine dlartv
#else
               module procedure stdlib_dlartv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slartv( n, x, incx, y, incy, c, s, incc )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incc,incx,incy,n
                    real(sp), intent(in) :: c(*),s(*)
                    real(sp), intent(inout) :: x(*),y(*)
               end subroutine slartv
#else
               module procedure stdlib_slartv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlartv( n, x, incx, y, incy, c, s, incc )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incc,incx,incy,n
                    real(dp), intent(in) :: c(*)
                    complex(dp), intent(in) :: s(*)
                    complex(dp), intent(inout) :: x(*),y(*)
               end subroutine zlartv
#else
               module procedure stdlib_zlartv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clartv( n, x, incx, y, incy, c, s, incc )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incc,incx,incy,n
                    real(sp), intent(in) :: c(*)
                    complex(sp), intent(in) :: s(*)
                    complex(sp), intent(inout) :: x(*),y(*)
               end subroutine clartv
#else
               module procedure stdlib_I64_clartv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlartv( n, x, incx, y, incy, c, s, incc )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incc,incx,incy,n
                    real(dp), intent(in) :: c(*),s(*)
                    real(dp), intent(inout) :: x(*),y(*)
               end subroutine dlartv
#else
               module procedure stdlib_I64_dlartv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slartv( n, x, incx, y, incy, c, s, incc )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incc,incx,incy,n
                    real(sp), intent(in) :: c(*),s(*)
                    real(sp), intent(inout) :: x(*),y(*)
               end subroutine slartv
#else
               module procedure stdlib_I64_slartv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlartv( n, x, incx, y, incy, c, s, incc )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incc,incx,incy,n
                    real(dp), intent(in) :: c(*)
                    complex(dp), intent(in) :: s(*)
                    complex(dp), intent(inout) :: x(*),y(*)
               end subroutine zlartv
#else
               module procedure stdlib_I64_zlartv
#endif
          end interface lartv

          interface laruv
          !! LARUV returns a vector of n random real numbers from a uniform (0,1)
          !! distribution (n <= 128).
          !! This is an auxiliary routine called by DLARNV and ZLARNV.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaruv( iseed, n, x )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n
                    integer(ilp), intent(inout) :: iseed(4)
                    real(dp), intent(out) :: x(n)
               end subroutine dlaruv
#else
               module procedure stdlib_dlaruv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaruv( iseed, n, x )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: n
                    integer(ilp), intent(inout) :: iseed(4)
                    real(sp), intent(out) :: x(n)
               end subroutine slaruv
#else
               module procedure stdlib_slaruv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaruv( iseed, n, x )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n
                    integer(ilp64), intent(inout) :: iseed(4)
                    real(dp), intent(out) :: x(n)
               end subroutine dlaruv
#else
               module procedure stdlib_I64_dlaruv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaruv( iseed, n, x )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: n
                    integer(ilp64), intent(inout) :: iseed(4)
                    real(sp), intent(out) :: x(n)
               end subroutine slaruv
#else
               module procedure stdlib_I64_slaruv
#endif
          end interface laruv

          interface larz
          !! LARZ applies a complex elementary reflector H to a complex
          !! M-by-N matrix C, from either the left or the right. H is represented
          !! in the form
          !! H = I - tau * v * v**H
          !! where tau is a complex scalar and v is a complex vector.
          !! If tau = 0, then H is taken to be the unit matrix.
          !! To apply H**H (the conjugate transpose of H), supply conjg(tau) instead
          !! tau.
          !! H is a product of k elementary reflectors as returned by CTZRZF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarz( side, m, n, l, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side
                    integer(ilp), intent(in) :: incv,l,ldc,m,n
                    complex(sp), intent(in) :: tau,v(*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clarz
#else
               module procedure stdlib_clarz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarz( side, m, n, l, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side
                    integer(ilp), intent(in) :: incv,l,ldc,m,n
                    real(dp), intent(in) :: tau,v(*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlarz
#else
               module procedure stdlib_dlarz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarz( side, m, n, l, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side
                    integer(ilp), intent(in) :: incv,l,ldc,m,n
                    real(sp), intent(in) :: tau,v(*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slarz
#else
               module procedure stdlib_slarz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarz( side, m, n, l, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side
                    integer(ilp), intent(in) :: incv,l,ldc,m,n
                    complex(dp), intent(in) :: tau,v(*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlarz
#else
               module procedure stdlib_zlarz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clarz( side, m, n, l, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side
                    integer(ilp64), intent(in) :: incv,l,ldc,m,n
                    complex(sp), intent(in) :: tau,v(*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clarz
#else
               module procedure stdlib_I64_clarz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarz( side, m, n, l, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side
                    integer(ilp64), intent(in) :: incv,l,ldc,m,n
                    real(dp), intent(in) :: tau,v(*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlarz
#else
               module procedure stdlib_I64_dlarz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarz( side, m, n, l, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side
                    integer(ilp64), intent(in) :: incv,l,ldc,m,n
                    real(sp), intent(in) :: tau,v(*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slarz
#else
               module procedure stdlib_I64_slarz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlarz( side, m, n, l, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side
                    integer(ilp64), intent(in) :: incv,l,ldc,m,n
                    complex(dp), intent(in) :: tau,v(*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlarz
#else
               module procedure stdlib_I64_zlarz
#endif
          end interface larz

          interface larzb
          !! LARZB applies a complex block reflector H or its transpose H**H
          !! to a complex distributed M-by-N  C from the left or the right.
          !! Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarzb( side, trans, direct, storev, m, n, k, l, v,ldv, t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,l,ldc,ldt,ldv,ldwork,m,n
                    complex(sp), intent(inout) :: c(ldc,*),t(ldt,*),v(ldv,*)
                    complex(sp), intent(out) :: work(ldwork,*)
               end subroutine clarzb
#else
               module procedure stdlib_clarzb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarzb( side, trans, direct, storev, m, n, k, l, v,ldv, t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,l,ldc,ldt,ldv,ldwork,m,n
                    real(dp), intent(inout) :: c(ldc,*),t(ldt,*),v(ldv,*)
                    real(dp), intent(out) :: work(ldwork,*)
               end subroutine dlarzb
#else
               module procedure stdlib_dlarzb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarzb( side, trans, direct, storev, m, n, k, l, v,ldv, t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,l,ldc,ldt,ldv,ldwork,m,n
                    real(sp), intent(inout) :: c(ldc,*),t(ldt,*),v(ldv,*)
                    real(sp), intent(out) :: work(ldwork,*)
               end subroutine slarzb
#else
               module procedure stdlib_slarzb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarzb( side, trans, direct, storev, m, n, k, l, v,ldv, t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,l,ldc,ldt,ldv,ldwork,m,n
                    complex(dp), intent(inout) :: c(ldc,*),t(ldt,*),v(ldv,*)
                    complex(dp), intent(out) :: work(ldwork,*)
               end subroutine zlarzb
#else
               module procedure stdlib_zlarzb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clarzb( side, trans, direct, storev, m, n, k, l, v,ldv, t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp64), intent(in) :: k,l,ldc,ldt,ldv,ldwork,m,n
                    complex(sp), intent(inout) :: c(ldc,*),t(ldt,*),v(ldv,*)
                    complex(sp), intent(out) :: work(ldwork,*)
               end subroutine clarzb
#else
               module procedure stdlib_I64_clarzb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarzb( side, trans, direct, storev, m, n, k, l, v,ldv, t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp64), intent(in) :: k,l,ldc,ldt,ldv,ldwork,m,n
                    real(dp), intent(inout) :: c(ldc,*),t(ldt,*),v(ldv,*)
                    real(dp), intent(out) :: work(ldwork,*)
               end subroutine dlarzb
#else
               module procedure stdlib_I64_dlarzb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarzb( side, trans, direct, storev, m, n, k, l, v,ldv, t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp64), intent(in) :: k,l,ldc,ldt,ldv,ldwork,m,n
                    real(sp), intent(inout) :: c(ldc,*),t(ldt,*),v(ldv,*)
                    real(sp), intent(out) :: work(ldwork,*)
               end subroutine slarzb
#else
               module procedure stdlib_I64_slarzb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlarzb( side, trans, direct, storev, m, n, k, l, v,ldv, t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp64), intent(in) :: k,l,ldc,ldt,ldv,ldwork,m,n
                    complex(dp), intent(inout) :: c(ldc,*),t(ldt,*),v(ldv,*)
                    complex(dp), intent(out) :: work(ldwork,*)
               end subroutine zlarzb
#else
               module procedure stdlib_I64_zlarzb
#endif
          end interface larzb

          interface larzt
          !! LARZT forms the triangular factor T of a complex block reflector
          !! H of order > n, which is defined as a product of k elementary
          !! reflectors.
          !! If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
          !! If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
          !! If STOREV = 'C', the vector which defines the elementary reflector
          !! H(i) is stored in the i-th column of the array V, and
          !! H  =  I - V * T * V**H
          !! If STOREV = 'R', the vector which defines the elementary reflector
          !! H(i) is stored in the i-th row of the array V, and
          !! H  =  I - V**H * T * V
          !! Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,storev
                    integer(ilp), intent(in) :: k,ldt,ldv,n
                    complex(sp), intent(out) :: t(ldt,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(inout) :: v(ldv,*)
               end subroutine clarzt
#else
               module procedure stdlib_clarzt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,storev
                    integer(ilp), intent(in) :: k,ldt,ldv,n
                    real(dp), intent(out) :: t(ldt,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(inout) :: v(ldv,*)
               end subroutine dlarzt
#else
               module procedure stdlib_dlarzt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,storev
                    integer(ilp), intent(in) :: k,ldt,ldv,n
                    real(sp), intent(out) :: t(ldt,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(inout) :: v(ldv,*)
               end subroutine slarzt
#else
               module procedure stdlib_slarzt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,storev
                    integer(ilp), intent(in) :: k,ldt,ldv,n
                    complex(dp), intent(out) :: t(ldt,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(inout) :: v(ldv,*)
               end subroutine zlarzt
#else
               module procedure stdlib_zlarzt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,storev
                    integer(ilp64), intent(in) :: k,ldt,ldv,n
                    complex(sp), intent(out) :: t(ldt,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(inout) :: v(ldv,*)
               end subroutine clarzt
#else
               module procedure stdlib_I64_clarzt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,storev
                    integer(ilp64), intent(in) :: k,ldt,ldv,n
                    real(dp), intent(out) :: t(ldt,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(inout) :: v(ldv,*)
               end subroutine dlarzt
#else
               module procedure stdlib_I64_dlarzt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,storev
                    integer(ilp64), intent(in) :: k,ldt,ldv,n
                    real(sp), intent(out) :: t(ldt,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(inout) :: v(ldv,*)
               end subroutine slarzt
#else
               module procedure stdlib_I64_slarzt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,storev
                    integer(ilp64), intent(in) :: k,ldt,ldv,n
                    complex(dp), intent(out) :: t(ldt,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(inout) :: v(ldv,*)
               end subroutine zlarzt
#else
               module procedure stdlib_I64_zlarzt
#endif
          end interface larzt

          interface lascl
          !! LASCL multiplies the M by N complex matrix A by the real scalar
          !! CTO/CFROM.  This is done without over/underflow as long as the final
          !! result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
          !! A may be full, upper triangular, lower triangular, upper Hessenberg,
          !! or banded.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: type
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,lda,m,n
                    real(sp), intent(in) :: cfrom,cto
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine clascl
#else
               module procedure stdlib_clascl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: type
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,lda,m,n
                    real(dp), intent(in) :: cfrom,cto
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dlascl
#else
               module procedure stdlib_dlascl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: type
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,lda,m,n
                    real(sp), intent(in) :: cfrom,cto
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine slascl
#else
               module procedure stdlib_slascl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: type
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,lda,m,n
                    real(dp), intent(in) :: cfrom,cto
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlascl
#else
               module procedure stdlib_zlascl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: type
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,lda,m,n
                    real(sp), intent(in) :: cfrom,cto
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine clascl
#else
               module procedure stdlib_I64_clascl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: type
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,lda,m,n
                    real(dp), intent(in) :: cfrom,cto
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dlascl
#else
               module procedure stdlib_I64_dlascl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: type
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,lda,m,n
                    real(sp), intent(in) :: cfrom,cto
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine slascl
#else
               module procedure stdlib_I64_slascl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: type
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kl,ku,lda,m,n
                    real(dp), intent(in) :: cfrom,cto
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlascl
#else
               module procedure stdlib_I64_zlascl
#endif
          end interface lascl

          interface lasd0
          !! Using a divide and conquer approach, LASD0: computes the singular
          !! value decomposition (SVD) of a real upper bidiagonal N-by-M
          !! matrix B with diagonal D and offdiagonal E, where M = N + SQRE.
          !! The algorithm computes orthogonal matrices U and VT such that
          !! B = U * S * VT. The singular values S are overwritten on D.
          !! A related subroutine, DLASDA, computes only the singular values,
          !! and optionally, the singular vectors in compact form.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasd0( n, sqre, d, e, u, ldu, vt, ldvt, smlsiz, iwork,work, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu,ldvt,n,smlsiz,sqre
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine dlasd0
#else
               module procedure stdlib_dlasd0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasd0( n, sqre, d, e, u, ldu, vt, ldvt, smlsiz, iwork,work, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu,ldvt,n,smlsiz,sqre
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine slasd0
#else
               module procedure stdlib_slasd0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasd0( n, sqre, d, e, u, ldu, vt, ldvt, smlsiz, iwork,work, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldu,ldvt,n,smlsiz,sqre
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine dlasd0
#else
               module procedure stdlib_I64_dlasd0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasd0( n, sqre, d, e, u, ldu, vt, ldvt, smlsiz, iwork,work, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldu,ldvt,n,smlsiz,sqre
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine slasd0
#else
               module procedure stdlib_I64_slasd0
#endif
          end interface lasd0

          interface lasd1
          !! LASD1 computes the SVD of an upper bidiagonal N-by-M matrix B,
          !! where N = NL + NR + 1 and M = N + SQRE. LASD1 is called from DLASD0.
          !! A related subroutine DLASD7 handles the case in which the singular
          !! values (and the singular vectors in factored form) are desired.
          !! LASD1 computes the SVD as follows:
          !! ( D1(in)    0    0       0 )
          !! B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
          !! (   0       0   D2(in)   0 )
          !! = U(out) * ( D(out) 0) * VT(out)
          !! where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
          !! with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
          !! elsewhere; and the entry b is empty if SQRE = 0.
          !! The left singular vectors of the original matrix are stored in U, and
          !! the transpose of the right singular vectors are stored in VT, and the
          !! singular values are in D.  The algorithm consists of three stages:
          !! The first stage consists of deflating the size of the problem
          !! when there are multiple singular values or when there are zeros in
          !! the Z vector.  For each such occurrence the dimension of the
          !! secular equation problem is reduced by one.  This stage is
          !! performed by the routine DLASD2.
          !! The second stage consists of calculating the updated
          !! singular values. This is done by finding the square roots of the
          !! roots of the secular equation via the routine DLASD4 (as called
          !! by DLASD3). This routine also calculates the singular vectors of
          !! the current problem.
          !! The final stage consists of computing the updated singular vectors
          !! directly using the updated singular values.  The singular vectors
          !! for the current problem are multiplied with the singular vectors
          !! from the overall problem.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasd1( nl, nr, sqre, d, alpha, beta, u, ldu, vt, ldvt,idxq, iwork,&
                          work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu,ldvt,nl,nr,sqre
                    real(dp), intent(inout) :: alpha,beta,d(*),u(ldu,*),vt(ldvt,*)
                    integer(ilp), intent(inout) :: idxq(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlasd1
#else
               module procedure stdlib_dlasd1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasd1( nl, nr, sqre, d, alpha, beta, u, ldu, vt, ldvt,idxq, iwork,&
                          work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu,ldvt,nl,nr,sqre
                    real(sp), intent(inout) :: alpha,beta,d(*),u(ldu,*),vt(ldvt,*)
                    integer(ilp), intent(inout) :: idxq(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slasd1
#else
               module procedure stdlib_slasd1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasd1( nl, nr, sqre, d, alpha, beta, u, ldu, vt, ldvt,idxq, iwork,&
                          work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldu,ldvt,nl,nr,sqre
                    real(dp), intent(inout) :: alpha,beta,d(*),u(ldu,*),vt(ldvt,*)
                    integer(ilp64), intent(inout) :: idxq(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlasd1
#else
               module procedure stdlib_I64_dlasd1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasd1( nl, nr, sqre, d, alpha, beta, u, ldu, vt, ldvt,idxq, iwork,&
                          work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldu,ldvt,nl,nr,sqre
                    real(sp), intent(inout) :: alpha,beta,d(*),u(ldu,*),vt(ldvt,*)
                    integer(ilp64), intent(inout) :: idxq(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slasd1
#else
               module procedure stdlib_I64_slasd1
#endif
          end interface lasd1

          interface lasd4
          !! This subroutine computes the square root of the I-th updated
          !! eigenvalue of a positive symmetric rank-one modification to
          !! a positive diagonal matrix whose entries are given as the squares
          !! of the corresponding entries in the array d, and that
          !! 0 <= D(i) < D(j)  for  i < j
          !! and that RHO > 0. This is arranged by the calling routine, and is
          !! no loss in generality.  The rank-one modified system is thus
          !! diag( D ) * diag( D ) +  RHO * Z * Z_transpose.
          !! where we assume the Euclidean norm of Z is 1.
          !! The method consists of approximating the rational functions in the
          !! secular equation by simpler interpolating rational functions.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasd4( n, i, d, z, delta, rho, sigma, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: i,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: rho,d(*),z(*)
                    real(dp), intent(out) :: sigma,delta(*),work(*)
               end subroutine dlasd4
#else
               module procedure stdlib_dlasd4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasd4( n, i, d, z, delta, rho, sigma, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: i,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: rho,d(*),z(*)
                    real(sp), intent(out) :: sigma,delta(*),work(*)
               end subroutine slasd4
#else
               module procedure stdlib_slasd4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasd4( n, i, d, z, delta, rho, sigma, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: i,n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(in) :: rho,d(*),z(*)
                    real(dp), intent(out) :: sigma,delta(*),work(*)
               end subroutine dlasd4
#else
               module procedure stdlib_I64_dlasd4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasd4( n, i, d, z, delta, rho, sigma, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: i,n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(in) :: rho,d(*),z(*)
                    real(sp), intent(out) :: sigma,delta(*),work(*)
               end subroutine slasd4
#else
               module procedure stdlib_I64_slasd4
#endif
          end interface lasd4

          interface lasd5
          !! This subroutine computes the square root of the I-th eigenvalue
          !! of a positive symmetric rank-one modification of a 2-by-2 diagonal
          !! matrix
          !! diag( D ) * diag( D ) +  RHO * Z * transpose(Z) .
          !! The diagonal entries in the array D are assumed to satisfy
          !! 0 <= D(i) < D(j)  for  i < j .
          !! We also assume RHO > 0 and that the Euclidean norm of the vector
          !! Z is one.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasd5( i, d, z, delta, rho, dsigma, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: i
                    real(dp), intent(out) :: dsigma,delta(2),work(2)
                    real(dp), intent(in) :: rho,d(2),z(2)
               end subroutine dlasd5
#else
               module procedure stdlib_dlasd5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasd5( i, d, z, delta, rho, dsigma, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: i
                    real(sp), intent(out) :: dsigma,delta(2),work(2)
                    real(sp), intent(in) :: rho,d(2),z(2)
               end subroutine slasd5
#else
               module procedure stdlib_slasd5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasd5( i, d, z, delta, rho, dsigma, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: i
                    real(dp), intent(out) :: dsigma,delta(2),work(2)
                    real(dp), intent(in) :: rho,d(2),z(2)
               end subroutine dlasd5
#else
               module procedure stdlib_I64_dlasd5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasd5( i, d, z, delta, rho, dsigma, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: i
                    real(sp), intent(out) :: dsigma,delta(2),work(2)
                    real(sp), intent(in) :: rho,d(2),z(2)
               end subroutine slasd5
#else
               module procedure stdlib_I64_slasd5
#endif
          end interface lasd5

          interface lasd6
          !! LASD6 computes the SVD of an updated upper bidiagonal matrix B
          !! obtained by merging two smaller ones by appending a row. This
          !! routine is used only for the problem which requires all singular
          !! values and optionally singular vector matrices in factored form.
          !! B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
          !! A related subroutine, DLASD1, handles the case in which all singular
          !! values and singular vectors of the bidiagonal matrix are desired.
          !! LASD6 computes the SVD as follows:
          !! ( D1(in)    0    0       0 )
          !! B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
          !! (   0       0   D2(in)   0 )
          !! = U(out) * ( D(out) 0) * VT(out)
          !! where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
          !! with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
          !! elsewhere; and the entry b is empty if SQRE = 0.
          !! The singular values of B can be computed using D1, D2, the first
          !! components of all the right singular vectors of the lower block, and
          !! the last components of all the right singular vectors of the upper
          !! block. These components are stored and updated in VF and VL,
          !! respectively, in LASD6. Hence U and VT are not explicitly
          !! referenced.
          !! The singular values are stored in D. The algorithm consists of two
          !! stages:
          !! The first stage consists of deflating the size of the problem
          !! when there are multiple singular values or if there is a zero
          !! in the Z vector. For each such occurrence the dimension of the
          !! secular equation problem is reduced by one. This stage is
          !! performed by the routine DLASD7.
          !! The second stage consists of calculating the updated
          !! singular values. This is done by finding the roots of the
          !! secular equation via the routine DLASD4 (as called by DLASD8).
          !! This routine also updates VF and VL and computes the distances
          !! between the updated singular values and the old singular
          !! values.
          !! LASD6 is called from DLASDA.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasd6( icompq, nl, nr, sqre, d, vf, vl, alpha, beta,idxq, perm, &
               givptr, givcol, ldgcol, givnum,ldgnum, poles, difl, difr, z, k, c, s, work,iwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: givptr,info,k,givcol(ldgcol,*),iwork(*),perm(*)

                    integer(ilp), intent(in) :: icompq,ldgcol,ldgnum,nl,nr,sqre
                    real(dp), intent(inout) :: alpha,beta,d(*),vf(*),vl(*)
                    real(dp), intent(out) :: c,s,difl(*),difr(*),givnum(ldgnum,*),poles(ldgnum,*),&
                              work(*),z(*)
                    integer(ilp), intent(inout) :: idxq(*)
               end subroutine dlasd6
#else
               module procedure stdlib_dlasd6
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasd6( icompq, nl, nr, sqre, d, vf, vl, alpha, beta,idxq, perm, &
               givptr, givcol, ldgcol, givnum,ldgnum, poles, difl, difr, z, k, c, s, work,iwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: givptr,info,k,givcol(ldgcol,*),iwork(*),perm(*)

                    integer(ilp), intent(in) :: icompq,ldgcol,ldgnum,nl,nr,sqre
                    real(sp), intent(inout) :: alpha,beta,d(*),vf(*),vl(*)
                    real(sp), intent(out) :: c,s,difl(*),difr(*),givnum(ldgnum,*),poles(ldgnum,*),&
                              work(*),z(*)
                    integer(ilp), intent(inout) :: idxq(*)
               end subroutine slasd6
#else
               module procedure stdlib_slasd6
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasd6( icompq, nl, nr, sqre, d, vf, vl, alpha, beta,idxq, perm, &
               givptr, givcol, ldgcol, givnum,ldgnum, poles, difl, difr, z, k, c, s, work,iwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: givptr,info,k,givcol(ldgcol,*),iwork(*),perm(*)

                    integer(ilp64), intent(in) :: icompq,ldgcol,ldgnum,nl,nr,sqre
                    real(dp), intent(inout) :: alpha,beta,d(*),vf(*),vl(*)
                    real(dp), intent(out) :: c,s,difl(*),difr(*),givnum(ldgnum,*),poles(ldgnum,*),&
                              work(*),z(*)
                    integer(ilp64), intent(inout) :: idxq(*)
               end subroutine dlasd6
#else
               module procedure stdlib_I64_dlasd6
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasd6( icompq, nl, nr, sqre, d, vf, vl, alpha, beta,idxq, perm, &
               givptr, givcol, ldgcol, givnum,ldgnum, poles, difl, difr, z, k, c, s, work,iwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: givptr,info,k,givcol(ldgcol,*),iwork(*),perm(*)

                    integer(ilp64), intent(in) :: icompq,ldgcol,ldgnum,nl,nr,sqre
                    real(sp), intent(inout) :: alpha,beta,d(*),vf(*),vl(*)
                    real(sp), intent(out) :: c,s,difl(*),difr(*),givnum(ldgnum,*),poles(ldgnum,*),&
                              work(*),z(*)
                    integer(ilp64), intent(inout) :: idxq(*)
               end subroutine slasd6
#else
               module procedure stdlib_I64_slasd6
#endif
          end interface lasd6

          interface lasd7
          !! LASD7 merges the two sets of singular values together into a single
          !! sorted set. Then it tries to deflate the size of the problem. There
          !! are two ways in which deflation can occur:  when two or more singular
          !! values are close together or if there is a tiny entry in the Z
          !! vector. For each such occurrence the order of the related
          !! secular equation problem is reduced by one.
          !! LASD7 is called from DLASD6.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasd7( icompq, nl, nr, sqre, k, d, z, zw, vf, vfw, vl,vlw, alpha, &
               beta, dsigma, idx, idxp, idxq,perm, givptr, givcol, ldgcol, givnum, ldgnum,c, s, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: givptr,info,k,givcol(ldgcol,*),idx(*),idxp(*),&
                              perm(*)
                    integer(ilp), intent(in) :: icompq,ldgcol,ldgnum,nl,nr,sqre
                    real(dp), intent(in) :: alpha,beta
                    real(dp), intent(out) :: c,s,dsigma(*),givnum(ldgnum,*),vfw(*),vlw(*),z(*),zw(&
                              *)
                    integer(ilp), intent(inout) :: idxq(*)
                    real(dp), intent(inout) :: d(*),vf(*),vl(*)
               end subroutine dlasd7
#else
               module procedure stdlib_dlasd7
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasd7( icompq, nl, nr, sqre, k, d, z, zw, vf, vfw, vl,vlw, alpha, &
               beta, dsigma, idx, idxp, idxq,perm, givptr, givcol, ldgcol, givnum, ldgnum,c, s, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: givptr,info,k,givcol(ldgcol,*),idx(*),idxp(*),&
                              perm(*)
                    integer(ilp), intent(in) :: icompq,ldgcol,ldgnum,nl,nr,sqre
                    real(sp), intent(in) :: alpha,beta
                    real(sp), intent(out) :: c,s,dsigma(*),givnum(ldgnum,*),vfw(*),vlw(*),z(*),zw(&
                              *)
                    integer(ilp), intent(inout) :: idxq(*)
                    real(sp), intent(inout) :: d(*),vf(*),vl(*)
               end subroutine slasd7
#else
               module procedure stdlib_slasd7
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasd7( icompq, nl, nr, sqre, k, d, z, zw, vf, vfw, vl,vlw, alpha, &
               beta, dsigma, idx, idxp, idxq,perm, givptr, givcol, ldgcol, givnum, ldgnum,c, s, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: givptr,info,k,givcol(ldgcol,*),idx(*),idxp(*),&
                              perm(*)
                    integer(ilp64), intent(in) :: icompq,ldgcol,ldgnum,nl,nr,sqre
                    real(dp), intent(in) :: alpha,beta
                    real(dp), intent(out) :: c,s,dsigma(*),givnum(ldgnum,*),vfw(*),vlw(*),z(*),zw(&
                              *)
                    integer(ilp64), intent(inout) :: idxq(*)
                    real(dp), intent(inout) :: d(*),vf(*),vl(*)
               end subroutine dlasd7
#else
               module procedure stdlib_I64_dlasd7
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasd7( icompq, nl, nr, sqre, k, d, z, zw, vf, vfw, vl,vlw, alpha, &
               beta, dsigma, idx, idxp, idxq,perm, givptr, givcol, ldgcol, givnum, ldgnum,c, s, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: givptr,info,k,givcol(ldgcol,*),idx(*),idxp(*),&
                              perm(*)
                    integer(ilp64), intent(in) :: icompq,ldgcol,ldgnum,nl,nr,sqre
                    real(sp), intent(in) :: alpha,beta
                    real(sp), intent(out) :: c,s,dsigma(*),givnum(ldgnum,*),vfw(*),vlw(*),z(*),zw(&
                              *)
                    integer(ilp64), intent(inout) :: idxq(*)
                    real(sp), intent(inout) :: d(*),vf(*),vl(*)
               end subroutine slasd7
#else
               module procedure stdlib_I64_slasd7
#endif
          end interface lasd7

          interface lasd8
          !! LASD8 finds the square roots of the roots of the secular equation,
          !! as defined by the values in DSIGMA and Z. It makes the appropriate
          !! calls to DLASD4, and stores, for each  element in D, the distance
          !! to its two nearest poles (elements in DSIGMA). It also updates
          !! the arrays VF and VL, the first and last components of all the
          !! right singular vectors of the original bidiagonal matrix.
          !! LASD8 is called from DLASD6.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasd8( icompq, k, d, z, vf, vl, difl, difr, lddifr,dsigma, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: icompq,k,lddifr
                    integer(ilp), intent(out) :: info
                    real(dp), intent(out) :: d(*),difl(*),difr(lddifr,*),work(*)
                    real(dp), intent(inout) :: dsigma(*),vf(*),vl(*),z(*)
               end subroutine dlasd8
#else
               module procedure stdlib_dlasd8
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasd8( icompq, k, d, z, vf, vl, difl, difr, lddifr,dsigma, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: icompq,k,lddifr
                    integer(ilp), intent(out) :: info
                    real(sp), intent(out) :: d(*),difl(*),difr(lddifr,*),work(*)
                    real(sp), intent(inout) :: dsigma(*),vf(*),vl(*),z(*)
               end subroutine slasd8
#else
               module procedure stdlib_slasd8
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasd8( icompq, k, d, z, vf, vl, difl, difr, lddifr,dsigma, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: icompq,k,lddifr
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(out) :: d(*),difl(*),difr(lddifr,*),work(*)
                    real(dp), intent(inout) :: dsigma(*),vf(*),vl(*),z(*)
               end subroutine dlasd8
#else
               module procedure stdlib_I64_dlasd8
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasd8( icompq, k, d, z, vf, vl, difl, difr, lddifr,dsigma, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: icompq,k,lddifr
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(out) :: d(*),difl(*),difr(lddifr,*),work(*)
                    real(sp), intent(inout) :: dsigma(*),vf(*),vl(*),z(*)
               end subroutine slasd8
#else
               module procedure stdlib_I64_slasd8
#endif
          end interface lasd8

          interface lasda
          !! Using a divide and conquer approach, LASDA: computes the singular
          !! value decomposition (SVD) of a real upper bidiagonal N-by-M matrix
          !! B with diagonal D and offdiagonal E, where M = N + SQRE. The
          !! algorithm computes the singular values in the SVD B = U * S * VT.
          !! The orthogonal matrices U and VT are optionally computed in
          !! compact form.
          !! A related subroutine, DLASD0, computes the singular values and
          !! the singular vectors in explicit form.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasda( icompq, smlsiz, n, sqre, d, e, u, ldu, vt, k,difl, difr, z,&
                          poles, givptr, givcol, ldgcol,perm, givnum, c, s, work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: icompq,ldgcol,ldu,n,smlsiz,sqre
                    integer(ilp), intent(out) :: info,givcol(ldgcol,*),givptr(*),iwork(*),k(*),&
                              perm(ldgcol,*)
                    real(dp), intent(out) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),work(*),z(ldu,*)
                    real(dp), intent(inout) :: d(*),e(*)
               end subroutine dlasda
#else
               module procedure stdlib_dlasda
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasda( icompq, smlsiz, n, sqre, d, e, u, ldu, vt, k,difl, difr, z,&
                          poles, givptr, givcol, ldgcol,perm, givnum, c, s, work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: icompq,ldgcol,ldu,n,smlsiz,sqre
                    integer(ilp), intent(out) :: info,givcol(ldgcol,*),givptr(*),iwork(*),k(*),&
                              perm(ldgcol,*)
                    real(sp), intent(out) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),work(*),z(ldu,*)
                    real(sp), intent(inout) :: d(*),e(*)
               end subroutine slasda
#else
               module procedure stdlib_slasda
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasda( icompq, smlsiz, n, sqre, d, e, u, ldu, vt, k,difl, difr, z,&
                          poles, givptr, givcol, ldgcol,perm, givnum, c, s, work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: icompq,ldgcol,ldu,n,smlsiz,sqre
                    integer(ilp64), intent(out) :: info,givcol(ldgcol,*),givptr(*),iwork(*),k(*),&
                              perm(ldgcol,*)
                    real(dp), intent(out) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),work(*),z(ldu,*)
                    real(dp), intent(inout) :: d(*),e(*)
               end subroutine dlasda
#else
               module procedure stdlib_I64_dlasda
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasda( icompq, smlsiz, n, sqre, d, e, u, ldu, vt, k,difl, difr, z,&
                          poles, givptr, givcol, ldgcol,perm, givnum, c, s, work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: icompq,ldgcol,ldu,n,smlsiz,sqre
                    integer(ilp64), intent(out) :: info,givcol(ldgcol,*),givptr(*),iwork(*),k(*),&
                              perm(ldgcol,*)
                    real(sp), intent(out) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),work(*),z(ldu,*)
                    real(sp), intent(inout) :: d(*),e(*)
               end subroutine slasda
#else
               module procedure stdlib_I64_slasda
#endif
          end interface lasda

          interface lasdq
          !! LASDQ computes the singular value decomposition (SVD) of a real
          !! (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
          !! E, accumulating the transformations if desired. Letting B denote
          !! the input bidiagonal matrix, the algorithm computes orthogonal
          !! matrices Q and P such that B = Q * S * P**T (P**T denotes the transpose
          !! of P). The singular values S are overwritten on D.
          !! The input matrix U  is changed to U  * Q  if desired.
          !! The input matrix VT is changed to P**T * VT if desired.
          !! The input matrix C  is changed to Q**T * C  if desired.
          !! See "Computing  Small Singular Values of Bidiagonal Matrices With
          !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
          !! LAPACK Working Note #3, for a detailed description of the algorithm.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasdq( uplo, sqre, n, ncvt, nru, ncc, d, e, vt, ldvt,u, ldu, c, &
                         ldc, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru,sqre
                    real(dp), intent(inout) :: c(ldc,*),d(*),e(*),u(ldu,*),vt(ldvt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlasdq
#else
               module procedure stdlib_dlasdq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasdq( uplo, sqre, n, ncvt, nru, ncc, d, e, vt, ldvt,u, ldu, c, &
                         ldc, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru,sqre
                    real(sp), intent(inout) :: c(ldc,*),d(*),e(*),u(ldu,*),vt(ldvt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slasdq
#else
               module procedure stdlib_slasdq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasdq( uplo, sqre, n, ncvt, nru, ncc, d, e, vt, ldvt,u, ldu, c, &
                         ldc, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru,sqre
                    real(dp), intent(inout) :: c(ldc,*),d(*),e(*),u(ldu,*),vt(ldvt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlasdq
#else
               module procedure stdlib_I64_dlasdq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasdq( uplo, sqre, n, ncvt, nru, ncc, d, e, vt, ldvt,u, ldu, c, &
                         ldc, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru,sqre
                    real(sp), intent(inout) :: c(ldc,*),d(*),e(*),u(ldu,*),vt(ldvt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slasdq
#else
               module procedure stdlib_I64_slasdq
#endif
          end interface lasdq

          interface laset
          !! LASET initializes a 2-D array A to BETA on the diagonal and
          !! ALPHA on the offdiagonals.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claset( uplo, m, n, alpha, beta, a, lda )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,m,n
                    complex(sp), intent(in) :: alpha,beta
                    complex(sp), intent(out) :: a(lda,*)
               end subroutine claset
#else
               module procedure stdlib_claset
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaset( uplo, m, n, alpha, beta, a, lda )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(in) :: alpha,beta
                    real(dp), intent(out) :: a(lda,*)
               end subroutine dlaset
#else
               module procedure stdlib_dlaset
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaset( uplo, m, n, alpha, beta, a, lda )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(in) :: alpha,beta
                    real(sp), intent(out) :: a(lda,*)
               end subroutine slaset
#else
               module procedure stdlib_slaset
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaset( uplo, m, n, alpha, beta, a, lda )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,m,n
                    complex(dp), intent(in) :: alpha,beta
                    complex(dp), intent(out) :: a(lda,*)
               end subroutine zlaset
#else
               module procedure stdlib_zlaset
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claset( uplo, m, n, alpha, beta, a, lda )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,m,n
                    complex(sp), intent(in) :: alpha,beta
                    complex(sp), intent(out) :: a(lda,*)
               end subroutine claset
#else
               module procedure stdlib_I64_claset
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaset( uplo, m, n, alpha, beta, a, lda )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(in) :: alpha,beta
                    real(dp), intent(out) :: a(lda,*)
               end subroutine dlaset
#else
               module procedure stdlib_I64_dlaset
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaset( uplo, m, n, alpha, beta, a, lda )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(in) :: alpha,beta
                    real(sp), intent(out) :: a(lda,*)
               end subroutine slaset
#else
               module procedure stdlib_I64_slaset
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaset( uplo, m, n, alpha, beta, a, lda )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,m,n
                    complex(dp), intent(in) :: alpha,beta
                    complex(dp), intent(out) :: a(lda,*)
               end subroutine zlaset
#else
               module procedure stdlib_I64_zlaset
#endif
          end interface laset

          interface lasq1
          !! LASQ1 computes the singular values of a real N-by-N bidiagonal
          !! matrix with diagonal D and off-diagonal E. The singular values
          !! are computed to high relative accuracy, in the absence of
          !! denormalization, underflow and overflow. The algorithm was first
          !! presented in
          !! "Accurate singular values and differential qd algorithms" by K. V.
          !! Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
          !! 1994,
          !! and the present implementation is described in "An implementation of
          !! the dqds Algorithm (Positive Case)", LAPACK Working Note.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasq1( n, d, e, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlasq1
#else
               module procedure stdlib_dlasq1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasq1( n, d, e, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slasq1
#else
               module procedure stdlib_slasq1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasq1( n, d, e, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlasq1
#else
               module procedure stdlib_I64_dlasq1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasq1( n, d, e, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slasq1
#else
               module procedure stdlib_I64_slasq1
#endif
          end interface lasq1

          interface lasq4
          !! LASQ4 computes an approximation TAU to the smallest eigenvalue
          !! using values of d from the previous transform.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasq4( i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn,dn1, dn2, tau, &
                         ttype, g )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: i0,n0,n0in,pp
                    integer(ilp), intent(out) :: ttype
                    real(dp), intent(in) :: dmin,dmin1,dmin2,dn,dn1,dn2,z(*)
                    real(dp), intent(inout) :: g
                    real(dp), intent(out) :: tau
               end subroutine dlasq4
#else
               module procedure stdlib_dlasq4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasq4( i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn,dn1, dn2, tau, &
                         ttype, g )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: i0,n0,n0in,pp
                    integer(ilp), intent(out) :: ttype
                    real(sp), intent(in) :: dmin,dmin1,dmin2,dn,dn1,dn2,z(*)
                    real(sp), intent(inout) :: g
                    real(sp), intent(out) :: tau
               end subroutine slasq4
#else
               module procedure stdlib_slasq4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasq4( i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn,dn1, dn2, tau, &
                         ttype, g )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: i0,n0,n0in,pp
                    integer(ilp64), intent(out) :: ttype
                    real(dp), intent(in) :: dmin,dmin1,dmin2,dn,dn1,dn2,z(*)
                    real(dp), intent(inout) :: g
                    real(dp), intent(out) :: tau
               end subroutine dlasq4
#else
               module procedure stdlib_I64_dlasq4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasq4( i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn,dn1, dn2, tau, &
                         ttype, g )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: i0,n0,n0in,pp
                    integer(ilp64), intent(out) :: ttype
                    real(sp), intent(in) :: dmin,dmin1,dmin2,dn,dn1,dn2,z(*)
                    real(sp), intent(inout) :: g
                    real(sp), intent(out) :: tau
               end subroutine slasq4
#else
               module procedure stdlib_I64_slasq4
#endif
          end interface lasq4

          interface lasq5
          !! LASQ5 computes one dqds transform in ping-pong form, one
          !! version for IEEE machines another for non IEEE machines.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasq5( i0, n0, z, pp, tau, sigma, dmin, dmin1, dmin2,dn, dnm1, &
                         dnm2, ieee, eps )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: ieee
                    integer(ilp), intent(in) :: i0,n0,pp
                    real(dp), intent(out) :: dmin,dmin1,dmin2,dn,dnm1,dnm2
                    real(dp), intent(inout) :: tau,z(*)
                    real(dp), intent(in) :: sigma,eps
               end subroutine dlasq5
#else
               module procedure stdlib_dlasq5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasq5( i0, n0, z, pp, tau, sigma, dmin, dmin1, dmin2,dn, dnm1, &
                         dnm2, ieee, eps )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: ieee
                    integer(ilp), intent(in) :: i0,n0,pp
                    real(sp), intent(out) :: dmin,dmin1,dmin2,dn,dnm1,dnm2
                    real(sp), intent(inout) :: tau,z(*)
                    real(sp), intent(in) :: sigma,eps
               end subroutine slasq5
#else
               module procedure stdlib_slasq5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasq5( i0, n0, z, pp, tau, sigma, dmin, dmin1, dmin2,dn, dnm1, &
                         dnm2, ieee, eps )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: ieee
                    integer(ilp64), intent(in) :: i0,n0,pp
                    real(dp), intent(out) :: dmin,dmin1,dmin2,dn,dnm1,dnm2
                    real(dp), intent(inout) :: tau,z(*)
                    real(dp), intent(in) :: sigma,eps
               end subroutine dlasq5
#else
               module procedure stdlib_I64_dlasq5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasq5( i0, n0, z, pp, tau, sigma, dmin, dmin1, dmin2,dn, dnm1, &
                         dnm2, ieee, eps )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: ieee
                    integer(ilp64), intent(in) :: i0,n0,pp
                    real(sp), intent(out) :: dmin,dmin1,dmin2,dn,dnm1,dnm2
                    real(sp), intent(inout) :: tau,z(*)
                    real(sp), intent(in) :: sigma,eps
               end subroutine slasq5
#else
               module procedure stdlib_I64_slasq5
#endif
          end interface lasq5

          interface lasq6
          !! LASQ6 computes one dqd (shift equal to zero) transform in
          !! ping-pong form, with protection against underflow and overflow.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasq6( i0, n0, z, pp, dmin, dmin1, dmin2, dn,dnm1, dnm2 )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: i0,n0,pp
                    real(dp), intent(out) :: dmin,dmin1,dmin2,dn,dnm1,dnm2
                    real(dp), intent(inout) :: z(*)
               end subroutine dlasq6
#else
               module procedure stdlib_dlasq6
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasq6( i0, n0, z, pp, dmin, dmin1, dmin2, dn,dnm1, dnm2 )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: i0,n0,pp
                    real(sp), intent(out) :: dmin,dmin1,dmin2,dn,dnm1,dnm2
                    real(sp), intent(inout) :: z(*)
               end subroutine slasq6
#else
               module procedure stdlib_slasq6
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasq6( i0, n0, z, pp, dmin, dmin1, dmin2, dn,dnm1, dnm2 )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: i0,n0,pp
                    real(dp), intent(out) :: dmin,dmin1,dmin2,dn,dnm1,dnm2
                    real(dp), intent(inout) :: z(*)
               end subroutine dlasq6
#else
               module procedure stdlib_I64_dlasq6
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasq6( i0, n0, z, pp, dmin, dmin1, dmin2, dn,dnm1, dnm2 )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: i0,n0,pp
                    real(sp), intent(out) :: dmin,dmin1,dmin2,dn,dnm1,dnm2
                    real(sp), intent(inout) :: z(*)
               end subroutine slasq6
#else
               module procedure stdlib_I64_slasq6
#endif
          end interface lasq6

          interface lasr
          !! LASR applies a sequence of real plane rotations to a complex matrix
          !! A, from either the left or the right.
          !! When SIDE = 'L', the transformation takes the form
          !! A := P*A
          !! and when SIDE = 'R', the transformation takes the form
          !! A := A*P**T
          !! where P is an orthogonal matrix consisting of a sequence of z plane
          !! rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
          !! and P**T is the transpose of P.
          !! When DIRECT = 'F' (Forward sequence), then
          !! P = P(z-1) * ... * P(2) * P(1)
          !! and when DIRECT = 'B' (Backward sequence), then
          !! P = P(1) * P(2) * ... * P(z-1)
          !! where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
          !! R(k) = (  c(k)  s(k) )
          !! = ( -s(k)  c(k) ).
          !! When PIVOT = 'V' (Variable pivot), the rotation is performed
          !! for the plane (k,k+1), i.e., P(k) has the form
          !! P(k) = (  1                                            )
          !! (       ...                                     )
          !! (              1                                )
          !! (                   c(k)  s(k)                  )
          !! (                  -s(k)  c(k)                  )
          !! (                                1              )
          !! (                                     ...       )
          !! (                                            1  )
          !! where R(k) appears as a rank-2 modification to the identity matrix in
          !! rows and columns k and k+1.
          !! When PIVOT = 'T' (Top pivot), the rotation is performed for the
          !! plane (1,k+1), so P(k) has the form
          !! P(k) = (  c(k)                    s(k)                 )
          !! (         1                                     )
          !! (              ...                              )
          !! (                     1                         )
          !! ( -s(k)                    c(k)                 )
          !! (                                 1             )
          !! (                                      ...      )
          !! (                                             1 )
          !! where R(k) appears in rows and columns 1 and k+1.
          !! Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
          !! performed for the plane (k,z), giving P(k) the form
          !! P(k) = ( 1                                             )
          !! (      ...                                      )
          !! (             1                                 )
          !! (                  c(k)                    s(k) )
          !! (                         1                     )
          !! (                              ...              )
          !! (                                     1         )
          !! (                 -s(k)                    c(k) )
          !! where R(k) appears in rows and columns k and z.  The rotations are
          !! performed without ever forming P(k) explicitly.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clasr( side, pivot, direct, m, n, c, s, a, lda )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,pivot,side
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(in) :: c(*),s(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine clasr
#else
               module procedure stdlib_clasr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasr( side, pivot, direct, m, n, c, s, a, lda )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,pivot,side
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: c(*),s(*)
               end subroutine dlasr
#else
               module procedure stdlib_dlasr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasr( side, pivot, direct, m, n, c, s, a, lda )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,pivot,side
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: c(*),s(*)
               end subroutine slasr
#else
               module procedure stdlib_slasr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlasr( side, pivot, direct, m, n, c, s, a, lda )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,pivot,side
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(in) :: c(*),s(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlasr
#else
               module procedure stdlib_zlasr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clasr( side, pivot, direct, m, n, c, s, a, lda )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,pivot,side
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(in) :: c(*),s(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine clasr
#else
               module procedure stdlib_I64_clasr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasr( side, pivot, direct, m, n, c, s, a, lda )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,pivot,side
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: c(*),s(*)
               end subroutine dlasr
#else
               module procedure stdlib_I64_dlasr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasr( side, pivot, direct, m, n, c, s, a, lda )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,pivot,side
                    integer(ilp64), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: c(*),s(*)
               end subroutine slasr
#else
               module procedure stdlib_I64_slasr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlasr( side, pivot, direct, m, n, c, s, a, lda )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,pivot,side
                    integer(ilp64), intent(in) :: lda,m,n
                    real(dp), intent(in) :: c(*),s(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlasr
#else
               module procedure stdlib_I64_zlasr
#endif
          end interface lasr

          interface lasrt
          !! Sort the numbers in D in increasing order (if ID = 'I') or
          !! in decreasing order (if ID = 'D' ).
          !! Use Quick Sort, reverting to Insertion sort on arrays of
          !! size <= 20. Dimension of STACK limits N to about 2**32.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasrt( id, n, d, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: id
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: d(*)
               end subroutine dlasrt
#else
               module procedure stdlib_dlasrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasrt( id, n, d, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: id
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: d(*)
               end subroutine slasrt
#else
               module procedure stdlib_slasrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasrt( id, n, d, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: id
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(inout) :: d(*)
               end subroutine dlasrt
#else
               module procedure stdlib_I64_dlasrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasrt( id, n, d, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: id
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(inout) :: d(*)
               end subroutine slasrt
#else
               module procedure stdlib_I64_slasrt
#endif
          end interface lasrt

          interface lassq
          !! LASSQ returns the values  scl  and  smsq  such that
          !! ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
          !! where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
          !! assumed to be non-negative.
          !! scale and sumsq must be supplied in SCALE and SUMSQ and
          !! scl and smsq are overwritten on SCALE and SUMSQ respectively.
          !! If scale * sqrt( sumsq ) > tbig then
          !! we require:   scale >= sqrt( TINY*EPS ) / sbig   on entry,
          !! and if 0 < scale * sqrt( sumsq ) < tsml then
          !! we require:   scale <= sqrt( HUGE ) / ssml       on entry,
          !! where
          !! tbig -- upper threshold for values whose square is representable;
          !! sbig -- scaling constant for big numbers; \see la_constants.f90
          !! tsml -- lower threshold for values whose square is representable;
          !! ssml -- scaling constant for small numbers; \see la_constants.f90
          !! and
          !! TINY*EPS -- tiniest representable number;
          !! HUGE     -- biggest representable number.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine classq( n, x, incx, scl, sumsq )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,n
                    real(sp), intent(inout) :: scl,sumsq
                    complex(sp), intent(in) :: x(*)
               end subroutine classq
#else
               module procedure stdlib_classq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlassq( n, x, incx, scl, sumsq )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,n
                    real(dp), intent(inout) :: scl,sumsq
                    real(dp), intent(in) :: x(*)
               end subroutine dlassq
#else
               module procedure stdlib_dlassq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slassq( n, x, incx, scl, sumsq )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,n
                    real(sp), intent(inout) :: scl,sumsq
                    real(sp), intent(in) :: x(*)
               end subroutine slassq
#else
               module procedure stdlib_slassq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlassq( n, x, incx, scl, sumsq )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,n
                    real(dp), intent(inout) :: scl,sumsq
                    complex(dp), intent(in) :: x(*)
               end subroutine zlassq
#else
               module procedure stdlib_zlassq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine classq( n, x, incx, scl, sumsq )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,n
                    real(sp), intent(inout) :: scl,sumsq
                    complex(sp), intent(in) :: x(*)
               end subroutine classq
#else
               module procedure stdlib_I64_classq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlassq( n, x, incx, scl, sumsq )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,n
                    real(dp), intent(inout) :: scl,sumsq
                    real(dp), intent(in) :: x(*)
               end subroutine dlassq
#else
               module procedure stdlib_I64_dlassq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slassq( n, x, incx, scl, sumsq )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,n
                    real(sp), intent(inout) :: scl,sumsq
                    real(sp), intent(in) :: x(*)
               end subroutine slassq
#else
               module procedure stdlib_I64_slassq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlassq( n, x, incx, scl, sumsq )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,n
                    real(dp), intent(inout) :: scl,sumsq
                    complex(dp), intent(in) :: x(*)
               end subroutine zlassq
#else
               module procedure stdlib_I64_zlassq
#endif
          end interface lassq

          interface laswlq
          !! LASWLQ computes a blocked Tall-Skinny LQ factorization of
          !! a complex M-by-N matrix A for M <= N:
          !! A = ( L 0 ) *  Q,
          !! where:
          !! Q is a n-by-N orthogonal matrix, stored on exit in an implicit
          !! form in the elements above the diagonal of the array A and in
          !! the elements of the array T;
          !! L is a lower-triangular M-by-M matrix stored on exit in
          !! the elements on and below the diagonal of the array A.
          !! 0 is a M-by-(N-M) zero matrix, if M < N, and is not stored.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claswlq( m, n, mb, nb, a, lda, t, ldt, work, lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,mb,nb,lwork,ldt
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*),t(ldt,*)
               end subroutine claswlq
#else
               module procedure stdlib_claswlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaswlq( m, n, mb, nb, a, lda, t, ldt, work, lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,mb,nb,lwork,ldt
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*),t(ldt,*)
               end subroutine dlaswlq
#else
               module procedure stdlib_dlaswlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaswlq( m, n, mb, nb, a, lda, t, ldt, work, lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,mb,nb,lwork,ldt
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*),t(ldt,*)
               end subroutine slaswlq
#else
               module procedure stdlib_slaswlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaswlq( m, n, mb, nb, a, lda, t, ldt, work, lwork,info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,mb,nb,lwork,ldt
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*),t(ldt,*)
               end subroutine zlaswlq
#else
               module procedure stdlib_zlaswlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claswlq( m, n, mb, nb, a, lda, t, ldt, work, lwork,info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,mb,nb,lwork,ldt
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*),t(ldt,*)
               end subroutine claswlq
#else
               module procedure stdlib_I64_claswlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaswlq( m, n, mb, nb, a, lda, t, ldt, work, lwork,info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,mb,nb,lwork,ldt
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*),t(ldt,*)
               end subroutine dlaswlq
#else
               module procedure stdlib_I64_dlaswlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaswlq( m, n, mb, nb, a, lda, t, ldt, work, lwork,info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,mb,nb,lwork,ldt
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*),t(ldt,*)
               end subroutine slaswlq
#else
               module procedure stdlib_I64_slaswlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaswlq( m, n, mb, nb, a, lda, t, ldt, work, lwork,info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,mb,nb,lwork,ldt
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*),t(ldt,*)
               end subroutine zlaswlq
#else
               module procedure stdlib_I64_zlaswlq
#endif
          end interface laswlq

          interface laswp
          !! LASWP performs a series of row interchanges on the matrix A.
          !! One row interchange is initiated for each of rows K1 through K2 of A.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claswp( n, a, lda, k1, k2, ipiv, incx )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,k1,k2,lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine claswp
#else
               module procedure stdlib_claswp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaswp( n, a, lda, k1, k2, ipiv, incx )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,k1,k2,lda,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dlaswp
#else
               module procedure stdlib_dlaswp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaswp( n, a, lda, k1, k2, ipiv, incx )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,k1,k2,lda,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine slaswp
#else
               module procedure stdlib_slaswp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaswp( n, a, lda, k1, k2, ipiv, incx )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,k1,k2,lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlaswp
#else
               module procedure stdlib_zlaswp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claswp( n, a, lda, k1, k2, ipiv, incx )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,k1,k2,lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine claswp
#else
               module procedure stdlib_I64_claswp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlaswp( n, a, lda, k1, k2, ipiv, incx )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,k1,k2,lda,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dlaswp
#else
               module procedure stdlib_I64_dlaswp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slaswp( n, a, lda, k1, k2, ipiv, incx )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,k1,k2,lda,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine slaswp
#else
               module procedure stdlib_I64_slaswp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaswp( n, a, lda, k1, k2, ipiv, incx )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,k1,k2,lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlaswp
#else
               module procedure stdlib_I64_zlaswp
#endif
          end interface laswp

          interface lasyf
          !! LASYF computes a partial factorization of a complex symmetric matrix
          !! A using the Bunch-Kaufman diagonal pivoting method. The partial
          !! factorization has the form:
          !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
          !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
          !! A  =  ( L11  0 ) ( D    0  ) ( L11**T L21**T )  if UPLO = 'L'
          !! ( L21  I ) ( 0   A22 ) (  0       I    )
          !! where the order of D is at most NB. The actual order is returned in
          !! the argument KB, and is either NB or NB-1, or N if N <= NB.
          !! Note that U**T denotes the transpose of U.
          !! LASYF is an auxiliary routine called by CSYTRF. It uses blocked code
          !! (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
          !! A22 (if UPLO = 'L').
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: w(ldw,*)
               end subroutine clasyf
#else
               module procedure stdlib_clasyf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: w(ldw,*)
               end subroutine dlasyf
#else
               module procedure stdlib_dlasyf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: w(ldw,*)
               end subroutine slasyf
#else
               module procedure stdlib_slasyf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: w(ldw,*)
               end subroutine zlasyf
#else
               module procedure stdlib_zlasyf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: w(ldw,*)
               end subroutine clasyf
#else
               module procedure stdlib_I64_clasyf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: w(ldw,*)
               end subroutine dlasyf
#else
               module procedure stdlib_I64_dlasyf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: w(ldw,*)
               end subroutine slasyf
#else
               module procedure stdlib_I64_slasyf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: w(ldw,*)
               end subroutine zlasyf
#else
               module procedure stdlib_I64_zlasyf
#endif
          end interface lasyf

          interface lasyf_aa
          !! DLATRF_AA factorizes a panel of a complex symmetric matrix A using
          !! the Aasen's algorithm. The panel consists of a set of NB rows of A
          !! when UPLO is U, or a set of NB columns when UPLO is L.
          !! In order to factorize the panel, the Aasen's algorithm requires the
          !! last row, or column, of the previous panel. The first row, or column,
          !! of A is set to be the first row, or column, of an identity matrix,
          !! which is used to factorize the first panel.
          !! The resulting J-th row of U, or J-th column of L, is stored in the
          !! (J-1)-th row, or column, of A (without the unit diagonals), while
          !! the diagonal and subdiagonal of A are overwritten by those of T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp), intent(out) :: ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),h(ldh,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clasyf_aa
#else
               module procedure stdlib_clasyf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp), intent(out) :: ipiv(*)
                    real(dp), intent(inout) :: a(lda,*),h(ldh,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlasyf_aa
#else
               module procedure stdlib_dlasyf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp), intent(out) :: ipiv(*)
                    real(sp), intent(inout) :: a(lda,*),h(ldh,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slasyf_aa
#else
               module procedure stdlib_slasyf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp), intent(out) :: ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),h(ldh,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlasyf_aa
#else
               module procedure stdlib_zlasyf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp64), intent(out) :: ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),h(ldh,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clasyf_aa
#else
               module procedure stdlib_I64_clasyf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp64), intent(out) :: ipiv(*)
                    real(dp), intent(inout) :: a(lda,*),h(ldh,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlasyf_aa
#else
               module procedure stdlib_I64_dlasyf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp64), intent(out) :: ipiv(*)
                    real(sp), intent(inout) :: a(lda,*),h(ldh,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slasyf_aa
#else
               module procedure stdlib_I64_slasyf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp64), intent(out) :: ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),h(ldh,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlasyf_aa
#else
               module procedure stdlib_I64_zlasyf_aa
#endif
          end interface lasyf_aa

          interface lasyf_rk
          !! LASYF_RK computes a partial factorization of a complex symmetric
          !! matrix A using the bounded Bunch-Kaufman (rook) diagonal
          !! pivoting method. The partial factorization has the form:
          !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
          !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
          !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L',
          !! ( L21  I ) (  0  A22 ) (  0       I    )
          !! where the order of D is at most NB. The actual order is returned in
          !! the argument KB, and is either NB or NB-1, or N if N <= NB.
          !! LASYF_RK is an auxiliary routine called by CSYTRF_RK. It uses
          !! blocked code (calling Level 3 BLAS) to update the submatrix
          !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*),w(ldw,*)
               end subroutine clasyf_rk
#else
               module procedure stdlib_clasyf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: e(*),w(ldw,*)
               end subroutine dlasyf_rk
#else
               module procedure stdlib_dlasyf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: e(*),w(ldw,*)
               end subroutine slasyf_rk
#else
               module procedure stdlib_slasyf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*),w(ldw,*)
               end subroutine zlasyf_rk
#else
               module procedure stdlib_zlasyf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*),w(ldw,*)
               end subroutine clasyf_rk
#else
               module procedure stdlib_I64_clasyf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: e(*),w(ldw,*)
               end subroutine dlasyf_rk
#else
               module procedure stdlib_I64_dlasyf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: e(*),w(ldw,*)
               end subroutine slasyf_rk
#else
               module procedure stdlib_I64_slasyf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*),w(ldw,*)
               end subroutine zlasyf_rk
#else
               module procedure stdlib_I64_zlasyf_rk
#endif
          end interface lasyf_rk

          interface lasyf_rook
          !! LASYF_ROOK computes a partial factorization of a complex symmetric
          !! matrix A using the bounded Bunch-Kaufman ("rook") diagonal
          !! pivoting method. The partial factorization has the form:
          !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
          !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
          !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
          !! ( L21  I ) (  0  A22 ) (  0       I    )
          !! where the order of D is at most NB. The actual order is returned in
          !! the argument KB, and is either NB or NB-1, or N if N <= NB.
          !! LASYF_ROOK is an auxiliary routine called by CSYTRF_ROOK. It uses
          !! blocked code (calling Level 3 BLAS) to update the submatrix
          !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: w(ldw,*)
               end subroutine clasyf_rook
#else
               module procedure stdlib_clasyf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: w(ldw,*)
               end subroutine dlasyf_rook
#else
               module procedure stdlib_dlasyf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: w(ldw,*)
               end subroutine slasyf_rook
#else
               module procedure stdlib_slasyf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: w(ldw,*)
               end subroutine zlasyf_rook
#else
               module procedure stdlib_zlasyf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: w(ldw,*)
               end subroutine clasyf_rook
#else
               module procedure stdlib_I64_clasyf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: w(ldw,*)
               end subroutine dlasyf_rook
#else
               module procedure stdlib_I64_dlasyf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: w(ldw,*)
               end subroutine slasyf_rook
#else
               module procedure stdlib_I64_slasyf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,kb,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: w(ldw,*)
               end subroutine zlasyf_rook
#else
               module procedure stdlib_I64_zlasyf_rook
#endif
          end interface lasyf_rook

          interface latbs
          !! LATBS solves one of the triangular systems
          !! A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
          !! with scaling to prevent overflow, where A is an upper or lower
          !! triangular band matrix.  Here A**T denotes the transpose of A, x and b
          !! are n-element vectors, and s is a scaling factor, usually less than
          !! or equal to 1, chosen so that the components of x will be less than
          !! the overflow threshold.  If the unscaled problem will not cause
          !! overflow, the Level 2 BLAS routine CTBSV is called.  If the matrix A
          !! is singular (A(j,j) = 0 for some j), then s is set to 0 and a
          !! non-trivial solution to A*x = 0 is returned.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,scale, cnorm,&
                          info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: scale
                    real(sp), intent(inout) :: cnorm(*)
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(inout) :: x(*)
               end subroutine clatbs
#else
               module procedure stdlib_clatbs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,scale, cnorm,&
                          info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: scale
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(inout) :: cnorm(*),x(*)
               end subroutine dlatbs
#else
               module procedure stdlib_dlatbs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,scale, cnorm,&
                          info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: scale
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(inout) :: cnorm(*),x(*)
               end subroutine slatbs
#else
               module procedure stdlib_slatbs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,scale, cnorm,&
                          info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: scale
                    real(dp), intent(inout) :: cnorm(*)
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(inout) :: x(*)
               end subroutine zlatbs
#else
               module procedure stdlib_zlatbs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,scale, cnorm,&
                          info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: scale
                    real(sp), intent(inout) :: cnorm(*)
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(inout) :: x(*)
               end subroutine clatbs
#else
               module procedure stdlib_I64_clatbs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,scale, cnorm,&
                          info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: scale
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(inout) :: cnorm(*),x(*)
               end subroutine dlatbs
#else
               module procedure stdlib_I64_dlatbs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,scale, cnorm,&
                          info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: scale
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(inout) :: cnorm(*),x(*)
               end subroutine slatbs
#else
               module procedure stdlib_I64_slatbs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,scale, cnorm,&
                          info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: scale
                    real(dp), intent(inout) :: cnorm(*)
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(inout) :: x(*)
               end subroutine zlatbs
#else
               module procedure stdlib_I64_zlatbs
#endif
          end interface latbs

          interface latdf
          !! LATDF computes the contribution to the reciprocal Dif-estimate
          !! by solving for x in Z * x = b, where b is chosen such that the norm
          !! of x is as large as possible. It is assumed that LU decomposition
          !! of Z has been computed by CGETC2. On entry RHS = f holds the
          !! contribution from earlier solved sub-systems, and on return RHS = x.
          !! The factorization of Z returned by CGETC2 has the form
          !! Z = P * L * U * Q, where P and Q are permutation matrices. L is lower
          !! triangular with unit diagonal elements and U is upper triangular.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,jpiv )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ijob,ldz,n,ipiv(*),jpiv(*)
                    real(sp), intent(inout) :: rdscal,rdsum
                    complex(sp), intent(inout) :: rhs(*),z(ldz,*)
               end subroutine clatdf
#else
               module procedure stdlib_clatdf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,jpiv )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ijob,ldz,n,ipiv(*),jpiv(*)
                    real(dp), intent(inout) :: rdscal,rdsum,rhs(*),z(ldz,*)
               end subroutine dlatdf
#else
               module procedure stdlib_dlatdf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,jpiv )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ijob,ldz,n,ipiv(*),jpiv(*)
                    real(sp), intent(inout) :: rdscal,rdsum,rhs(*),z(ldz,*)
               end subroutine slatdf
#else
               module procedure stdlib_slatdf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,jpiv )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ijob,ldz,n,ipiv(*),jpiv(*)
                    real(dp), intent(inout) :: rdscal,rdsum
                    complex(dp), intent(inout) :: rhs(*),z(ldz,*)
               end subroutine zlatdf
#else
               module procedure stdlib_zlatdf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,jpiv )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ijob,ldz,n,ipiv(*),jpiv(*)
                    real(sp), intent(inout) :: rdscal,rdsum
                    complex(sp), intent(inout) :: rhs(*),z(ldz,*)
               end subroutine clatdf
#else
               module procedure stdlib_I64_clatdf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,jpiv )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ijob,ldz,n,ipiv(*),jpiv(*)
                    real(dp), intent(inout) :: rdscal,rdsum,rhs(*),z(ldz,*)
               end subroutine dlatdf
#else
               module procedure stdlib_I64_dlatdf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,jpiv )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ijob,ldz,n,ipiv(*),jpiv(*)
                    real(sp), intent(inout) :: rdscal,rdsum,rhs(*),z(ldz,*)
               end subroutine slatdf
#else
               module procedure stdlib_I64_slatdf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,jpiv )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ijob,ldz,n,ipiv(*),jpiv(*)
                    real(dp), intent(inout) :: rdscal,rdsum
                    complex(dp), intent(inout) :: rhs(*),z(ldz,*)
               end subroutine zlatdf
#else
               module procedure stdlib_I64_zlatdf
#endif
          end interface latdf

          interface latps
          !! LATPS solves one of the triangular systems
          !! A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
          !! with scaling to prevent overflow, where A is an upper or lower
          !! triangular matrix stored in packed form.  Here A**T denotes the
          !! transpose of A, A**H denotes the conjugate transpose of A, x and b
          !! are n-element vectors, and s is a scaling factor, usually less than
          !! or equal to 1, chosen so that the components of x will be less than
          !! the overflow threshold.  If the unscaled problem will not cause
          !! overflow, the Level 2 BLAS routine CTPSV is called. If the matrix A
          !! is singular (A(j,j) = 0 for some j), then s is set to 0 and a
          !! non-trivial solution to A*x = 0 is returned.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clatps( uplo, trans, diag, normin, n, ap, x, scale,cnorm, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: scale
                    real(sp), intent(inout) :: cnorm(*)
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(inout) :: x(*)
               end subroutine clatps
#else
               module procedure stdlib_clatps
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlatps( uplo, trans, diag, normin, n, ap, x, scale,cnorm, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: scale
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(inout) :: cnorm(*),x(*)
               end subroutine dlatps
#else
               module procedure stdlib_dlatps
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slatps( uplo, trans, diag, normin, n, ap, x, scale,cnorm, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: scale
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(inout) :: cnorm(*),x(*)
               end subroutine slatps
#else
               module procedure stdlib_slatps
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlatps( uplo, trans, diag, normin, n, ap, x, scale,cnorm, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: scale
                    real(dp), intent(inout) :: cnorm(*)
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(inout) :: x(*)
               end subroutine zlatps
#else
               module procedure stdlib_zlatps
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clatps( uplo, trans, diag, normin, n, ap, x, scale,cnorm, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(out) :: scale
                    real(sp), intent(inout) :: cnorm(*)
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(inout) :: x(*)
               end subroutine clatps
#else
               module procedure stdlib_I64_clatps
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlatps( uplo, trans, diag, normin, n, ap, x, scale,cnorm, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(out) :: scale
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(inout) :: cnorm(*),x(*)
               end subroutine dlatps
#else
               module procedure stdlib_I64_dlatps
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slatps( uplo, trans, diag, normin, n, ap, x, scale,cnorm, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(out) :: scale
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(inout) :: cnorm(*),x(*)
               end subroutine slatps
#else
               module procedure stdlib_I64_slatps
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlatps( uplo, trans, diag, normin, n, ap, x, scale,cnorm, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(out) :: scale
                    real(dp), intent(inout) :: cnorm(*)
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(inout) :: x(*)
               end subroutine zlatps
#else
               module procedure stdlib_I64_zlatps
#endif
          end interface latps

          interface latrd
          !! LATRD reduces NB rows and columns of a complex Hermitian matrix A to
          !! Hermitian tridiagonal form by a unitary similarity
          !! transformation Q**H * A * Q, and returns the matrices V and W which are
          !! needed to apply the transformation to the unreduced part of A.
          !! If UPLO = 'U', LATRD reduces the last NB rows and columns of a
          !! matrix, of which the upper triangle is supplied;
          !! if UPLO = 'L', LATRD reduces the first NB rows and columns of a
          !! matrix, of which the lower triangle is supplied.
          !! This is an auxiliary routine called by CHETRD.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(sp), intent(out) :: e(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),w(ldw,*)
               end subroutine clatrd
#else
               module procedure stdlib_clatrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: e(*),tau(*),w(ldw,*)
               end subroutine dlatrd
#else
               module procedure stdlib_dlatrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: e(*),tau(*),w(ldw,*)
               end subroutine slatrd
#else
               module procedure stdlib_slatrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(dp), intent(out) :: e(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),w(ldw,*)
               end subroutine zlatrd
#else
               module procedure stdlib_zlatrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    real(sp), intent(out) :: e(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),w(ldw,*)
               end subroutine clatrd
#else
               module procedure stdlib_I64_clatrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: e(*),tau(*),w(ldw,*)
               end subroutine dlatrd
#else
               module procedure stdlib_I64_dlatrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: e(*),tau(*),w(ldw,*)
               end subroutine slatrd
#else
               module procedure stdlib_I64_slatrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: lda,ldw,n,nb
                    real(dp), intent(out) :: e(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),w(ldw,*)
               end subroutine zlatrd
#else
               module procedure stdlib_I64_zlatrd
#endif
          end interface latrd

          interface latrs
          !! LATRS solves one of the triangular systems
          !! A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
          !! with scaling to prevent overflow.  Here A is an upper or lower
          !! triangular matrix, A**T denotes the transpose of A, A**H denotes the
          !! conjugate transpose of A, x and b are n-element vectors, and s is a
          !! scaling factor, usually less than or equal to 1, chosen so that the
          !! components of x will be less than the overflow threshold.  If the
          !! unscaled problem will not cause overflow, the Level 2 BLAS routine
          !! CTRSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
          !! then s is set to 0 and a non-trivial solution to A*x = 0 is returned.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clatrs( uplo, trans, diag, normin, n, a, lda, x, scale,cnorm, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: scale
                    real(sp), intent(inout) :: cnorm(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: x(*)
               end subroutine clatrs
#else
               module procedure stdlib_clatrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlatrs( uplo, trans, diag, normin, n, a, lda, x, scale,cnorm, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: scale
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: cnorm(*),x(*)
               end subroutine dlatrs
#else
               module procedure stdlib_dlatrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slatrs( uplo, trans, diag, normin, n, a, lda, x, scale,cnorm, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: scale
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: cnorm(*),x(*)
               end subroutine slatrs
#else
               module procedure stdlib_slatrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlatrs( uplo, trans, diag, normin, n, a, lda, x, scale,cnorm, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: scale
                    real(dp), intent(inout) :: cnorm(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: x(*)
               end subroutine zlatrs
#else
               module procedure stdlib_zlatrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clatrs( uplo, trans, diag, normin, n, a, lda, x, scale,cnorm, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(out) :: scale
                    real(sp), intent(inout) :: cnorm(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: x(*)
               end subroutine clatrs
#else
               module procedure stdlib_I64_clatrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlatrs( uplo, trans, diag, normin, n, a, lda, x, scale,cnorm, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(out) :: scale
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: cnorm(*),x(*)
               end subroutine dlatrs
#else
               module procedure stdlib_I64_dlatrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slatrs( uplo, trans, diag, normin, n, a, lda, x, scale,cnorm, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(out) :: scale
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: cnorm(*),x(*)
               end subroutine slatrs
#else
               module procedure stdlib_I64_slatrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlatrs( uplo, trans, diag, normin, n, a, lda, x, scale,cnorm, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(out) :: scale
                    real(dp), intent(inout) :: cnorm(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: x(*)
               end subroutine zlatrs
#else
               module procedure stdlib_I64_zlatrs
#endif
          end interface latrs

          interface latrz
          !! LATRZ factors the M-by-(M+L) complex upper trapezoidal matrix
          !! [ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R  0 ) * Z by means
          !! of unitary transformations, where  Z is an (M+L)-by-(M+L) unitary
          !! matrix and, R and A1 are M-by-M upper triangular matrices.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clatrz( m, n, l, a, lda, tau, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: l,lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine clatrz
#else
               module procedure stdlib_clatrz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlatrz( m, n, l, a, lda, tau, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: l,lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dlatrz
#else
               module procedure stdlib_dlatrz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slatrz( m, n, l, a, lda, tau, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: l,lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine slatrz
#else
               module procedure stdlib_slatrz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlatrz( m, n, l, a, lda, tau, work )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: l,lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zlatrz
#else
               module procedure stdlib_zlatrz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clatrz( m, n, l, a, lda, tau, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: l,lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine clatrz
#else
               module procedure stdlib_I64_clatrz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlatrz( m, n, l, a, lda, tau, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: l,lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dlatrz
#else
               module procedure stdlib_I64_dlatrz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slatrz( m, n, l, a, lda, tau, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: l,lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine slatrz
#else
               module procedure stdlib_I64_slatrz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlatrz( m, n, l, a, lda, tau, work )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: l,lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zlatrz
#else
               module procedure stdlib_I64_zlatrz
#endif
          end interface latrz

          interface latsqr
          !! LATSQR computes a blocked Tall-Skinny QR factorization of
          !! a complex M-by-N matrix A for M >= N:
          !! A = Q * ( R ),
          !! ( 0 )
          !! where:
          !! Q is a M-by-M orthogonal matrix, stored on exit in an implicit
          !! form in the elements below the diagonal of the array A and in
          !! the elements of the array T;
          !! R is an upper-triangular N-by-N matrix, stored on exit in
          !! the elements on and above the diagonal of the array A.
          !! 0 is a (M-N)-by-N zero matrix, and is not stored.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clatsqr( m, n, mb, nb, a, lda, t, ldt, work,lwork, info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,mb,nb,ldt,lwork
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*),t(ldt,*)
               end subroutine clatsqr
#else
               module procedure stdlib_clatsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlatsqr( m, n, mb, nb, a, lda, t, ldt, work,lwork, info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,mb,nb,ldt,lwork
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*),t(ldt,*)
               end subroutine dlatsqr
#else
               module procedure stdlib_dlatsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slatsqr( m, n, mb, nb, a, lda, t, ldt, work,lwork, info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,mb,nb,ldt,lwork
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*),t(ldt,*)
               end subroutine slatsqr
#else
               module procedure stdlib_slatsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlatsqr( m, n, mb, nb, a, lda, t, ldt, work,lwork, info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,mb,nb,ldt,lwork
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*),t(ldt,*)
               end subroutine zlatsqr
#else
               module procedure stdlib_zlatsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clatsqr( m, n, mb, nb, a, lda, t, ldt, work,lwork, info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,mb,nb,ldt,lwork
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*),t(ldt,*)
               end subroutine clatsqr
#else
               module procedure stdlib_I64_clatsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlatsqr( m, n, mb, nb, a, lda, t, ldt, work,lwork, info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,mb,nb,ldt,lwork
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*),t(ldt,*)
               end subroutine dlatsqr
#else
               module procedure stdlib_I64_dlatsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slatsqr( m, n, mb, nb, a, lda, t, ldt, work,lwork, info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,mb,nb,ldt,lwork
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*),t(ldt,*)
               end subroutine slatsqr
#else
               module procedure stdlib_I64_slatsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlatsqr( m, n, mb, nb, a, lda, t, ldt, work,lwork, info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n,mb,nb,ldt,lwork
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*),t(ldt,*)
               end subroutine zlatsqr
#else
               module procedure stdlib_I64_zlatsqr
#endif
          end interface latsqr

          interface launhr_col_getrfnp
          !! LAUNHR_COL_GETRFNP computes the modified LU factorization without
          !! pivoting of a complex general M-by-N matrix A. The factorization has
          !! the form:
          !! A - S = L * U,
          !! where:
          !! S is a m-by-n diagonal sign matrix with the diagonal D, so that
          !! D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
          !! as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
          !! i-1 steps of Gaussian elimination. This means that the diagonal
          !! element at each step of "modified" Gaussian elimination is
          !! at least one in absolute value (so that division-by-zero not
          !! not possible during the division by the diagonal element);
          !! L is a M-by-N lower triangular matrix with unit diagonal elements
          !! (lower trapezoidal if M > N);
          !! and U is a M-by-N upper triangular matrix
          !! (upper trapezoidal if M < N).
          !! This routine is an auxiliary routine used in the Householder
          !! reconstruction routine CUNHR_COL. In CUNHR_COL, this routine is
          !! applied to an M-by-N matrix A with orthonormal columns, where each
          !! element is bounded by one in absolute value. With the choice of
          !! the matrix S above, one can show that the diagonal element at each
          !! step of Gaussian elimination is the largest (in absolute value) in
          !! the column on or below the diagonal, so that no pivoting is required
          !! for numerical stability [1].
          !! For more details on the Householder reconstruction algorithm,
          !! including the modified LU factorization, see [1].
          !! This is the blocked right-looking version of the algorithm,
          !! calling Level 3 BLAS to update the submatrix. To factorize a block,
          !! this routine calls the recursive routine LAUNHR_COL_GETRFNP2.
          !! [1] "Reconstructing Householder vectors from tall-skinny QR",
          !! G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
          !! E. Solomonik, J. Parallel Distrib. Comput.,
          !! vol. 85, pp. 3-31, 2015.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claunhr_col_getrfnp( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: d(*)
               end subroutine claunhr_col_getrfnp
#else
               module procedure stdlib_claunhr_col_getrfnp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaunhr_col_getrfnp( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: d(*)
               end subroutine zlaunhr_col_getrfnp
#else
               module procedure stdlib_zlaunhr_col_getrfnp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine claunhr_col_getrfnp( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: d(*)
               end subroutine claunhr_col_getrfnp
#else
               module procedure stdlib_I64_claunhr_col_getrfnp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlaunhr_col_getrfnp( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: d(*)
               end subroutine zlaunhr_col_getrfnp
#else
               module procedure stdlib_I64_zlaunhr_col_getrfnp
#endif
          end interface launhr_col_getrfnp

          interface launhr_col_getrfnp2
          !! LAUNHR_COL_GETRFNP2 computes the modified LU factorization without
          !! pivoting of a complex general M-by-N matrix A. The factorization has
          !! the form:
          !! A - S = L * U,
          !! where:
          !! S is a m-by-n diagonal sign matrix with the diagonal D, so that
          !! D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
          !! as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
          !! i-1 steps of Gaussian elimination. This means that the diagonal
          !! element at each step of "modified" Gaussian elimination is at
          !! least one in absolute value (so that division-by-zero not
          !! possible during the division by the diagonal element);
          !! L is a M-by-N lower triangular matrix with unit diagonal elements
          !! (lower trapezoidal if M > N);
          !! and U is a M-by-N upper triangular matrix
          !! (upper trapezoidal if M < N).
          !! This routine is an auxiliary routine used in the Householder
          !! reconstruction routine CUNHR_COL. In CUNHR_COL, this routine is
          !! applied to an M-by-N matrix A with orthonormal columns, where each
          !! element is bounded by one in absolute value. With the choice of
          !! the matrix S above, one can show that the diagonal element at each
          !! step of Gaussian elimination is the largest (in absolute value) in
          !! the column on or below the diagonal, so that no pivoting is required
          !! for numerical stability [1].
          !! For more details on the Householder reconstruction algorithm,
          !! including the modified LU factorization, see [1].
          !! This is the recursive version of the LU factorization algorithm.
          !! Denote A - S by B. The algorithm divides the matrix B into four
          !! submatrices:
          !! [  B11 | B12  ]  where B11 is n1 by n1,
          !! B = [ -----|----- ]        B21 is (m-n1) by n1,
          !! [  B21 | B22  ]        B12 is n1 by n2,
          !! B22 is (m-n1) by n2,
          !! with n1 = min(m,n)/2, n2 = n-n1.
          !! The subroutine calls itself to factor B11, solves for B21,
          !! solves for B12, updates B22, then calls itself to factor B22.
          !! For more details on the recursive LU algorithm, see [2].
          !! LAUNHR_COL_GETRFNP2 is called to factorize a block by the blocked
          !! routine CLAUNHR_COL_GETRFNP, which uses blocked code calling
          !! Level 3 BLAS to update the submatrix. However, LAUNHR_COL_GETRFNP2
          !! is self-sufficient and can be used without CLAUNHR_COL_GETRFNP.
          !! [1] "Reconstructing Householder vectors from tall-skinny QR",
          !! G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
          !! E. Solomonik, J. Parallel Distrib. Comput.,
          !! vol. 85, pp. 3-31, 2015.
          !! [2] "Recursion leads to automatic variable blocking for dense linear
          !! algebra algorithms", F. Gustavson, IBM J. of Res. and Dev.,
          !! vol. 41, no. 6, pp. 737-755, 1997.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine claunhr_col_getrfnp2( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: d(*)
               end subroutine claunhr_col_getrfnp2
#else
               module procedure stdlib_claunhr_col_getrfnp2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine zlaunhr_col_getrfnp2( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: d(*)
               end subroutine zlaunhr_col_getrfnp2
#else
               module procedure stdlib_zlaunhr_col_getrfnp2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine claunhr_col_getrfnp2( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: d(*)
               end subroutine claunhr_col_getrfnp2
#else
               module procedure stdlib_I64_claunhr_col_getrfnp2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine zlaunhr_col_getrfnp2( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: d(*)
               end subroutine zlaunhr_col_getrfnp2
#else
               module procedure stdlib_I64_zlaunhr_col_getrfnp2
#endif
          end interface launhr_col_getrfnp2

          interface lauum
          !! LAUUM computes the product U * U**H or L**H * L, where the triangular
          !! factor U or L is stored in the upper or lower triangular part of
          !! the array A.
          !! If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
          !! overwriting the factor U in A.
          !! If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
          !! overwriting the factor L in A.
          !! This is the blocked form of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clauum( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine clauum
#else
               module procedure stdlib_clauum
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlauum( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dlauum
#else
               module procedure stdlib_dlauum
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slauum( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine slauum
#else
               module procedure stdlib_slauum
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlauum( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlauum
#else
               module procedure stdlib_zlauum
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine clauum( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine clauum
#else
               module procedure stdlib_I64_clauum
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dlauum( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dlauum
#else
               module procedure stdlib_I64_dlauum
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine slauum( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine slauum
#else
               module procedure stdlib_I64_slauum
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zlauum( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlauum
#else
               module procedure stdlib_I64_zlauum
#endif
          end interface lauum

          interface opgtr
          !! OPGTR generates a real orthogonal matrix Q which is defined as the
          !! product of n-1 elementary reflectors H(i) of order n, as returned by
          !! DSPTRD using packed storage:
          !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
          !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dopgtr( uplo, n, ap, tau, q, ldq, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldq,n
                    real(dp), intent(in) :: ap(*),tau(*)
                    real(dp), intent(out) :: q(ldq,*),work(*)
               end subroutine dopgtr
#else
               module procedure stdlib_dopgtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sopgtr( uplo, n, ap, tau, q, ldq, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldq,n
                    real(sp), intent(in) :: ap(*),tau(*)
                    real(sp), intent(out) :: q(ldq,*),work(*)
               end subroutine sopgtr
#else
               module procedure stdlib_sopgtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dopgtr( uplo, n, ap, tau, q, ldq, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldq,n
                    real(dp), intent(in) :: ap(*),tau(*)
                    real(dp), intent(out) :: q(ldq,*),work(*)
               end subroutine dopgtr
#else
               module procedure stdlib_I64_dopgtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sopgtr( uplo, n, ap, tau, q, ldq, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldq,n
                    real(sp), intent(in) :: ap(*),tau(*)
                    real(sp), intent(out) :: q(ldq,*),work(*)
               end subroutine sopgtr
#else
               module procedure stdlib_I64_sopgtr
#endif
          end interface opgtr

          interface opmtr
          !! OPMTR overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! where Q is a real orthogonal matrix of order nq, with nq = m if
          !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !! nq-1 elementary reflectors, as returned by DSPTRD using packed
          !! storage:
          !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
          !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dopmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,m,n
                    real(dp), intent(inout) :: ap(*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dopmtr
#else
               module procedure stdlib_dopmtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sopmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,m,n
                    real(sp), intent(inout) :: ap(*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sopmtr
#else
               module procedure stdlib_sopmtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dopmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldc,m,n
                    real(dp), intent(inout) :: ap(*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dopmtr
#else
               module procedure stdlib_I64_dopmtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sopmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldc,m,n
                    real(sp), intent(inout) :: ap(*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sopmtr
#else
               module procedure stdlib_I64_sopmtr
#endif
          end interface opmtr

          interface orbdb
          !! ORBDB simultaneously bidiagonalizes the blocks of an M-by-M
          !! partitioned orthogonal matrix X:
          !! [ B11 | B12 0  0 ]
          !! [ X11 | X12 ]   [ P1 |    ] [  0  |  0 -I  0 ] [ Q1 |    ]**T
          !! X = [-----------] = [---------] [----------------] [---------]   .
          !! [ X21 | X22 ]   [    | P2 ] [ B21 | B22 0  0 ] [    | Q2 ]
          !! [  0  |  0  0  I ]
          !! X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
          !! not the case, then X must be transposed and/or permuted. This can be
          !! done in constant time using the TRANS and SIGNS options. See DORCSD
          !! for details.)
          !! The orthogonal matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
          !! (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
          !! represented implicitly by Householder vectors.
          !! B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
          !! implicitly by angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dorbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
                         ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: signs,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldx11,ldx12,ldx21,ldx22,lwork,m,p,q
                    real(dp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),tauq2(*),&
                              work(*)
                    real(dp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(ldx22,*)

               end subroutine dorbdb
#else
               module procedure stdlib_dorbdb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sorbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
                         ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: signs,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldx11,ldx12,ldx21,ldx22,lwork,m,p,q
                    real(sp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),tauq2(*),&
                              work(*)
                    real(sp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(ldx22,*)

               end subroutine sorbdb
#else
               module procedure stdlib_sorbdb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dorbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
                         ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: signs,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldx11,ldx12,ldx21,ldx22,lwork,m,p,q
                    real(dp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),tauq2(*),&
                              work(*)
                    real(dp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(ldx22,*)

               end subroutine dorbdb
#else
               module procedure stdlib_I64_dorbdb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sorbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
                         ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: signs,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldx11,ldx12,ldx21,ldx22,lwork,m,p,q
                    real(sp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),tauq2(*),&
                              work(*)
                    real(sp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(ldx22,*)

               end subroutine sorbdb
#else
               module procedure stdlib_I64_sorbdb
#endif
          end interface orbdb

          interface orbdb1
          !! ORBDB1 simultaneously bidiagonalizes the blocks of a tall and skinny
          !! matrix X with orthonomal columns:
          !! [ B11 ]
          !! [ X11 ]   [ P1 |    ] [  0  ]
          !! [-----] = [---------] [-----] Q1**T .
          !! [ X21 ]   [    | P2 ] [ B21 ]
          !! [  0  ]
          !! X11 is P-by-Q, and X21 is (M-P)-by-Q. Q must be no larger than P,
          !! M-P, or M-Q. Routines DORBDB2, DORBDB3, and DORBDB4 handle cases in
          !! which Q is not the minimum dimension.
          !! The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !! Householder vectors.
          !! B11 and B12 are Q-by-Q bidiagonal matrices represented implicitly by
          !! angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dorbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)

                    real(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorbdb1
#else
               module procedure stdlib_dorbdb1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sorbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)

                    real(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorbdb1
#else
               module procedure stdlib_sorbdb1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dorbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)

                    real(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorbdb1
#else
               module procedure stdlib_I64_dorbdb1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sorbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)

                    real(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorbdb1
#else
               module procedure stdlib_I64_sorbdb1
#endif
          end interface orbdb1

          interface orbdb2
          !! ORBDB2 simultaneously bidiagonalizes the blocks of a tall and skinny
          !! matrix X with orthonomal columns:
          !! [ B11 ]
          !! [ X11 ]   [ P1 |    ] [  0  ]
          !! [-----] = [---------] [-----] Q1**T .
          !! [ X21 ]   [    | P2 ] [ B21 ]
          !! [  0  ]
          !! X11 is P-by-Q, and X21 is (M-P)-by-Q. P must be no larger than M-P,
          !! Q, or M-Q. Routines DORBDB1, DORBDB3, and DORBDB4 handle cases in
          !! which P is not the minimum dimension.
          !! The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !! Householder vectors.
          !! B11 and B12 are P-by-P bidiagonal matrices represented implicitly by
          !! angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dorbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)

                    real(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorbdb2
#else
               module procedure stdlib_dorbdb2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sorbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)

                    real(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorbdb2
#else
               module procedure stdlib_sorbdb2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dorbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)

                    real(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorbdb2
#else
               module procedure stdlib_I64_dorbdb2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sorbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)

                    real(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorbdb2
#else
               module procedure stdlib_I64_sorbdb2
#endif
          end interface orbdb2

          interface orbdb3
          !! ORBDB3 simultaneously bidiagonalizes the blocks of a tall and skinny
          !! matrix X with orthonomal columns:
          !! [ B11 ]
          !! [ X11 ]   [ P1 |    ] [  0  ]
          !! [-----] = [---------] [-----] Q1**T .
          !! [ X21 ]   [    | P2 ] [ B21 ]
          !! [  0  ]
          !! X11 is P-by-Q, and X21 is (M-P)-by-Q. M-P must be no larger than P,
          !! Q, or M-Q. Routines DORBDB1, DORBDB2, and DORBDB4 handle cases in
          !! which M-P is not the minimum dimension.
          !! The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !! Householder vectors.
          !! B11 and B12 are (M-P)-by-(M-P) bidiagonal matrices represented
          !! implicitly by angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dorbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)

                    real(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorbdb3
#else
               module procedure stdlib_dorbdb3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sorbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)

                    real(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorbdb3
#else
               module procedure stdlib_sorbdb3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dorbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)

                    real(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorbdb3
#else
               module procedure stdlib_I64_dorbdb3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sorbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)

                    real(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorbdb3
#else
               module procedure stdlib_I64_sorbdb3
#endif
          end interface orbdb3

          interface orbdb4
          !! ORBDB4 simultaneously bidiagonalizes the blocks of a tall and skinny
          !! matrix X with orthonomal columns:
          !! [ B11 ]
          !! [ X11 ]   [ P1 |    ] [  0  ]
          !! [-----] = [---------] [-----] Q1**T .
          !! [ X21 ]   [    | P2 ] [ B21 ]
          !! [  0  ]
          !! X11 is P-by-Q, and X21 is (M-P)-by-Q. M-Q must be no larger than P,
          !! M-P, or Q. Routines DORBDB1, DORBDB2, and DORBDB3 handle cases in
          !! which M-Q is not the minimum dimension.
          !! The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !! Householder vectors.
          !! B11 and B12 are (M-Q)-by-(M-Q) bidiagonal matrices represented
          !! implicitly by angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dorbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, phantom, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*),phantom(*),taup1(*),taup2(*),tauq1(*)&
                              ,work(*)
                    real(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorbdb4
#else
               module procedure stdlib_dorbdb4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sorbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, phantom, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*),phantom(*),taup1(*),taup2(*),tauq1(*)&
                              ,work(*)
                    real(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorbdb4
#else
               module procedure stdlib_sorbdb4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dorbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, phantom, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*),phantom(*),taup1(*),taup2(*),tauq1(*)&
                              ,work(*)
                    real(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorbdb4
#else
               module procedure stdlib_I64_dorbdb4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sorbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, phantom, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*),phantom(*),taup1(*),taup2(*),tauq1(*)&
                              ,work(*)
                    real(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorbdb4
#else
               module procedure stdlib_I64_sorbdb4
#endif
          end interface orbdb4

          interface orbdb5
          !! ORBDB5 orthogonalizes the column vector
          !! X = [ X1 ]
          !! [ X2 ]
          !! with respect to the columns of
          !! Q = [ Q1 ] .
          !! [ Q2 ]
          !! The columns of Q must be orthonormal.
          !! If the projection is zero according to Kahan's "twice is enough"
          !! criterion, then some other vector from the orthogonal complement
          !! is returned. This vector is chosen in an arbitrary but deterministic
          !! way.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    real(dp), intent(out) :: work(*)
                    real(dp), intent(inout) :: x1(*),x2(*)
               end subroutine dorbdb5
#else
               module procedure stdlib_dorbdb5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    real(sp), intent(out) :: work(*)
                    real(sp), intent(inout) :: x1(*),x2(*)
               end subroutine sorbdb5
#else
               module procedure stdlib_sorbdb5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dorbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    real(dp), intent(out) :: work(*)
                    real(dp), intent(inout) :: x1(*),x2(*)
               end subroutine dorbdb5
#else
               module procedure stdlib_I64_dorbdb5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sorbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    real(sp), intent(out) :: work(*)
                    real(sp), intent(inout) :: x1(*),x2(*)
               end subroutine sorbdb5
#else
               module procedure stdlib_I64_sorbdb5
#endif
          end interface orbdb5

          interface orbdb6
          !! ORBDB6 orthogonalizes the column vector
          !! X = [ X1 ]
          !! [ X2 ]
          !! with respect to the columns of
          !! Q = [ Q1 ] .
          !! [ Q2 ]
          !! The columns of Q must be orthonormal.
          !! If the projection is zero according to Kahan's "twice is enough"
          !! criterion, then the zero vector is returned.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    real(dp), intent(out) :: work(*)
                    real(dp), intent(inout) :: x1(*),x2(*)
               end subroutine dorbdb6
#else
               module procedure stdlib_dorbdb6
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    real(sp), intent(out) :: work(*)
                    real(sp), intent(inout) :: x1(*),x2(*)
               end subroutine sorbdb6
#else
               module procedure stdlib_sorbdb6
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    real(dp), intent(out) :: work(*)
                    real(dp), intent(inout) :: x1(*),x2(*)
               end subroutine dorbdb6
#else
               module procedure stdlib_I64_dorbdb6
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    real(sp), intent(out) :: work(*)
                    real(sp), intent(inout) :: x1(*),x2(*)
               end subroutine sorbdb6
#else
               module procedure stdlib_I64_sorbdb6
#endif
          end interface orbdb6

          interface orcsd
          !! ORCSD computes the CS decomposition of an M-by-M partitioned
          !! orthogonal matrix X:
          !! [  I  0  0 |  0  0  0 ]
          !! [  0  C  0 |  0 -S  0 ]
          !! [ X11 | X12 ]   [ U1 |    ] [  0  0  0 |  0  0 -I ] [ V1 |    ]**T
          !! X = [-----------] = [---------] [---------------------] [---------]   .
          !! [ X21 | X22 ]   [    | U2 ] [  0  0  0 |  I  0  0 ] [    | V2 ]
          !! [  0  S  0 |  0  C  0 ]
          !! [  0  0  I |  0  0  0 ]
          !! X11 is P-by-Q. The orthogonal matrices U1, U2, V1, and V2 are P-by-P,
          !! (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
          !! R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
          !! which R = MIN(P,M-P,Q,M-Q).
#ifdef STDLIB_EXTERNAL_LAPACK
               recursive subroutine dorcsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, &
               x11, ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, &
                         ldv1t, v2t,ldv2t, work, lwork, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,signs,trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,ldx11,ldx12,ldx21,ldx22,&
                              lwork,m,p,q
                    real(dp), intent(out) :: theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(&
                              ldv2t,*),work(*)
                    real(dp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(ldx22,*)

               end subroutine dorcsd
#else
               module procedure stdlib_dorcsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               recursive subroutine sorcsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, &
               x11, ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, &
                         ldv1t, v2t,ldv2t, work, lwork, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,signs,trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,ldx11,ldx12,ldx21,ldx22,&
                              lwork,m,p,q
                    real(sp), intent(out) :: theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(&
                              ldv2t,*),work(*)
                    real(sp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(ldx22,*)

               end subroutine sorcsd
#else
               module procedure stdlib_sorcsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               recursive subroutine dorcsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, &
               x11, ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, &
                         ldv1t, v2t,ldv2t, work, lwork, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,signs,trans
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,ldx11,ldx12,ldx21,ldx22,&
                              lwork,m,p,q
                    real(dp), intent(out) :: theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(&
                              ldv2t,*),work(*)
                    real(dp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(ldx22,*)

               end subroutine dorcsd
#else
               module procedure stdlib_I64_dorcsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               recursive subroutine sorcsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, &
               x11, ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, &
                         ldv1t, v2t,ldv2t, work, lwork, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,signs,trans
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,ldx11,ldx12,ldx21,ldx22,&
                              lwork,m,p,q
                    real(sp), intent(out) :: theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(&
                              ldv2t,*),work(*)
                    real(sp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(ldx22,*)

               end subroutine sorcsd
#else
               module procedure stdlib_I64_sorcsd
#endif
          end interface orcsd

          interface orcsd2by1
          !! ORCSD2BY1 computes the CS decomposition of an M-by-Q matrix X with
          !! orthonormal columns that has been partitioned into a 2-by-1 block
          !! structure:
          !! [  I1 0  0 ]
          !! [  0  C  0 ]
          !! [ X11 ]   [ U1 |    ] [  0  0  0 ]
          !! X = [-----] = [---------] [----------] V1**T .
          !! [ X21 ]   [    | U2 ] [  0  0  0 ]
          !! [  0  S  0 ]
          !! [  0  0  I2]
          !! X11 is P-by-Q. The orthogonal matrices U1, U2, and V1 are P-by-P,
          !! (M-P)-by-(M-P), and Q-by-Q, respectively. C and S are R-by-R
          !! nonnegative diagonal matrices satisfying C^2 + S^2 = I, in which
          !! R = MIN(P,M-P,Q,M-Q). I1 is a K1-by-K1 identity matrix and I2 is a
          !! K2-by-K2 identity matrix, where K1 = MAX(Q+P-M,0), K2 = MAX(Q-P,0).
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dorcsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta,&
                          u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,lwork,ldx11,ldx21,m,p,q
                    real(dp), intent(out) :: theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),work(*)

                    real(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorcsd2by1
#else
               module procedure stdlib_dorcsd2by1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sorcsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta,&
                          u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,lwork,ldx11,ldx21,m,p,q
                    real(sp), intent(out) :: theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),work(*)

                    real(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorcsd2by1
#else
               module procedure stdlib_sorcsd2by1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dorcsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta,&
                          u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldu1,ldu2,ldv1t,lwork,ldx11,ldx21,m,p,q
                    real(dp), intent(out) :: theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),work(*)

                    real(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorcsd2by1
#else
               module procedure stdlib_I64_dorcsd2by1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sorcsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta,&
                          u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldu1,ldu2,ldv1t,lwork,ldx11,ldx21,m,p,q
                    real(sp), intent(out) :: theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),work(*)

                    real(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorcsd2by1
#else
               module procedure stdlib_I64_sorcsd2by1
#endif
          end interface orcsd2by1

          interface org2l
          !! ORG2L generates an m by n real matrix Q with orthonormal columns,
          !! which is defined as the last n columns of a product of k elementary
          !! reflectors of order m
          !! Q  =  H(k) . . . H(2) H(1)
          !! as returned by DGEQLF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorg2l( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorg2l
#else
               module procedure stdlib_dorg2l
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorg2l( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorg2l
#else
               module procedure stdlib_sorg2l
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dorg2l( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorg2l
#else
               module procedure stdlib_I64_dorg2l
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sorg2l( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorg2l
#else
               module procedure stdlib_I64_sorg2l
#endif
          end interface org2l

          interface org2r
          !! ORG2R generates an m by n real matrix Q with orthonormal columns,
          !! which is defined as the first n columns of a product of k elementary
          !! reflectors of order m
          !! Q  =  H(1) H(2) . . . H(k)
          !! as returned by DGEQRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorg2r( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorg2r
#else
               module procedure stdlib_dorg2r
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorg2r( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorg2r
#else
               module procedure stdlib_sorg2r
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dorg2r( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorg2r
#else
               module procedure stdlib_I64_dorg2r
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sorg2r( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorg2r
#else
               module procedure stdlib_I64_sorg2r
#endif
          end interface org2r

          interface orgbr
          !! ORGBR generates one of the real orthogonal matrices Q or P**T
          !! determined by DGEBRD when reducing a real matrix A to bidiagonal
          !! form: A = Q * B * P**T.  Q and P**T are defined as products of
          !! elementary reflectors H(i) or G(i) respectively.
          !! If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
          !! is of order M:
          !! if m >= k, Q = H(1) H(2) . . . H(k) and ORGBR returns the first n
          !! columns of Q, where m >= n >= k;
          !! if m < k, Q = H(1) H(2) . . . H(m-1) and ORGBR returns Q as an
          !! M-by-M matrix.
          !! If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
          !! is of order N:
          !! if k < n, P**T = G(k) . . . G(2) G(1) and ORGBR returns the first m
          !! rows of P**T, where n >= m >= k;
          !! if k >= n, P**T = G(n-1) . . . G(2) G(1) and ORGBR returns P**T as
          !! an N-by-N matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorgbr( vect, m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgbr
#else
               module procedure stdlib_dorgbr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorgbr( vect, m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgbr
#else
               module procedure stdlib_sorgbr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dorgbr( vect, m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgbr
#else
               module procedure stdlib_I64_dorgbr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sorgbr( vect, m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgbr
#else
               module procedure stdlib_I64_sorgbr
#endif
          end interface orgbr

          interface orghr
          !! ORGHR generates a real orthogonal matrix Q which is defined as the
          !! product of IHI-ILO elementary reflectors of order N, as returned by
          !! DGEHRD:
          !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorghr
#else
               module procedure stdlib_dorghr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorghr
#else
               module procedure stdlib_sorghr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dorghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorghr
#else
               module procedure stdlib_I64_dorghr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sorghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorghr
#else
               module procedure stdlib_I64_sorghr
#endif
          end interface orghr

          interface orglq
          !! ORGLQ generates an M-by-N real matrix Q with orthonormal rows,
          !! which is defined as the first M rows of a product of K elementary
          !! reflectors of order N
          !! Q  =  H(k) . . . H(2) H(1)
          !! as returned by DGELQF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorglq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorglq
#else
               module procedure stdlib_dorglq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorglq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorglq
#else
               module procedure stdlib_sorglq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dorglq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorglq
#else
               module procedure stdlib_I64_dorglq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sorglq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorglq
#else
               module procedure stdlib_I64_sorglq
#endif
          end interface orglq

          interface orgql
          !! ORGQL generates an M-by-N real matrix Q with orthonormal columns,
          !! which is defined as the last N columns of a product of K elementary
          !! reflectors of order M
          !! Q  =  H(k) . . . H(2) H(1)
          !! as returned by DGEQLF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorgql( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgql
#else
               module procedure stdlib_dorgql
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorgql( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgql
#else
               module procedure stdlib_sorgql
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dorgql( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgql
#else
               module procedure stdlib_I64_dorgql
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sorgql( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgql
#else
               module procedure stdlib_I64_sorgql
#endif
          end interface orgql

          interface orgqr
          !! ORGQR generates an M-by-N real matrix Q with orthonormal columns,
          !! which is defined as the first N columns of a product of K elementary
          !! reflectors of order M
          !! Q  =  H(1) H(2) . . . H(k)
          !! as returned by DGEQRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorgqr( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgqr
#else
               module procedure stdlib_dorgqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorgqr( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgqr
#else
               module procedure stdlib_sorgqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dorgqr( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgqr
#else
               module procedure stdlib_I64_dorgqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sorgqr( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgqr
#else
               module procedure stdlib_I64_sorgqr
#endif
          end interface orgqr

          interface orgrq
          !! ORGRQ generates an M-by-N real matrix Q with orthonormal rows,
          !! which is defined as the last M rows of a product of K elementary
          !! reflectors of order N
          !! Q  =  H(1) H(2) . . . H(k)
          !! as returned by DGERQF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorgrq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgrq
#else
               module procedure stdlib_dorgrq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorgrq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgrq
#else
               module procedure stdlib_sorgrq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dorgrq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgrq
#else
               module procedure stdlib_I64_dorgrq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sorgrq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgrq
#else
               module procedure stdlib_I64_sorgrq
#endif
          end interface orgrq

          interface orgtr
          !! ORGTR generates a real orthogonal matrix Q which is defined as the
          !! product of n-1 elementary reflectors of order N, as returned by
          !! DSYTRD:
          !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
          !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorgtr( uplo, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgtr
#else
               module procedure stdlib_dorgtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorgtr( uplo, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgtr
#else
               module procedure stdlib_sorgtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dorgtr( uplo, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgtr
#else
               module procedure stdlib_I64_dorgtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sorgtr( uplo, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgtr
#else
               module procedure stdlib_I64_sorgtr
#endif
          end interface orgtr

          interface orgtsqr
          !! ORGTSQR generates an M-by-N real matrix Q_out with orthonormal columns,
          !! which are the first N columns of a product of real orthogonal
          !! matrices of order M which are returned by DLATSQR
          !! Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).
          !! See the documentation for DLATSQR.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorgtsqr( m, n, mb, nb, a, lda, t, ldt, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: t(ldt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgtsqr
#else
               module procedure stdlib_dorgtsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorgtsqr( m, n, mb, nb, a, lda, t, ldt, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: t(ldt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgtsqr
#else
               module procedure stdlib_sorgtsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dorgtsqr( m, n, mb, nb, a, lda, t, ldt, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: t(ldt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgtsqr
#else
               module procedure stdlib_I64_dorgtsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sorgtsqr( m, n, mb, nb, a, lda, t, ldt, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: t(ldt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgtsqr
#else
               module procedure stdlib_I64_sorgtsqr
#endif
          end interface orgtsqr

          interface orgtsqr_row
          !! ORGTSQR_ROW generates an M-by-N real matrix Q_out with
          !! orthonormal columns from the output of DLATSQR. These N orthonormal
          !! columns are the first N columns of a product of complex unitary
          !! matrices Q(k)_in of order M, which are returned by DLATSQR in
          !! a special format.
          !! Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).
          !! The input matrices Q(k)_in are stored in row and column blocks in A.
          !! See the documentation of DLATSQR for more details on the format of
          !! Q(k)_in, where each Q(k)_in is represented by block Householder
          !! transformations. This routine calls an auxiliary routine DLARFB_GETT,
          !! where the computation is performed on each individual block. The
          !! algorithm first sweeps NB-sized column blocks from the right to left
          !! starting in the bottom row block and continues to the top row block
          !! (hence _ROW in the routine name). This sweep is in reverse order of
          !! the order in which DLATSQR generates the output blocks.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorgtsqr_row( m, n, mb, nb, a, lda, t, ldt, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: t(ldt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgtsqr_row
#else
               module procedure stdlib_dorgtsqr_row
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorgtsqr_row( m, n, mb, nb, a, lda, t, ldt, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: t(ldt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgtsqr_row
#else
               module procedure stdlib_sorgtsqr_row
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dorgtsqr_row( m, n, mb, nb, a, lda, t, ldt, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: t(ldt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgtsqr_row
#else
               module procedure stdlib_I64_dorgtsqr_row
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sorgtsqr_row( m, n, mb, nb, a, lda, t, ldt, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: t(ldt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgtsqr_row
#else
               module procedure stdlib_I64_sorgtsqr_row
#endif
          end interface orgtsqr_row

          interface orhr_col
          !! ORHR_COL takes an M-by-N real matrix Q_in with orthonormal columns
          !! as input, stored in A, and performs Householder Reconstruction (HR),
          !! i.e. reconstructs Householder vectors V(i) implicitly representing
          !! another M-by-N matrix Q_out, with the property that Q_in = Q_out*S,
          !! where S is an N-by-N diagonal matrix with diagonal entries
          !! equal to +1 or -1. The Householder vectors (columns V(i) of V) are
          !! stored in A on output, and the diagonal entries of S are stored in D.
          !! Block reflectors are also returned in T
          !! (same output format as DGEQRT).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorhr_col( m, n, nb, a, lda, t, ldt, d, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*),t(ldt,*)
               end subroutine dorhr_col
#else
               module procedure stdlib_dorhr_col
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorhr_col( m, n, nb, a, lda, t, ldt, d, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*),t(ldt,*)
               end subroutine sorhr_col
#else
               module procedure stdlib_sorhr_col
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dorhr_col( m, n, nb, a, lda, t, ldt, d, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,m,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*),t(ldt,*)
               end subroutine dorhr_col
#else
               module procedure stdlib_I64_dorhr_col
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sorhr_col( m, n, nb, a, lda, t, ldt, d, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,m,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*),t(ldt,*)
               end subroutine sorhr_col
#else
               module procedure stdlib_I64_sorhr_col
#endif
          end interface orhr_col

          interface orm2l
          !! ORM2L overwrites the general real m by n matrix C with
          !! Q * C  if SIDE = 'L' and TRANS = 'N', or
          !! Q**T * C  if SIDE = 'L' and TRANS = 'T', or
          !! C * Q  if SIDE = 'R' and TRANS = 'N', or
          !! C * Q**T if SIDE = 'R' and TRANS = 'T',
          !! where Q is a real orthogonal matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(k) . . . H(2) H(1)
          !! as returned by DGEQLF. Q is of order m if SIDE = 'L' and of order n
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorm2l( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorm2l
#else
               module procedure stdlib_dorm2l
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorm2l( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorm2l
#else
               module procedure stdlib_sorm2l
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dorm2l( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorm2l
#else
               module procedure stdlib_I64_dorm2l
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sorm2l( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorm2l
#else
               module procedure stdlib_I64_sorm2l
#endif
          end interface orm2l

          interface orm2r
          !! ORM2R overwrites the general real m by n matrix C with
          !! Q * C  if SIDE = 'L' and TRANS = 'N', or
          !! Q**T* C  if SIDE = 'L' and TRANS = 'T', or
          !! C * Q  if SIDE = 'R' and TRANS = 'N', or
          !! C * Q**T if SIDE = 'R' and TRANS = 'T',
          !! where Q is a real orthogonal matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(1) H(2) . . . H(k)
          !! as returned by DGEQRF. Q is of order m if SIDE = 'L' and of order n
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorm2r( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorm2r
#else
               module procedure stdlib_dorm2r
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorm2r( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorm2r
#else
               module procedure stdlib_sorm2r
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dorm2r( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorm2r
#else
               module procedure stdlib_I64_dorm2r
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sorm2r( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorm2r
#else
               module procedure stdlib_I64_sorm2r
#endif
          end interface orm2r

          interface ormbr
          !! If VECT = 'Q', ORMBR: overwrites the general real M-by-N matrix C
          !! with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! If VECT = 'P', ORMBR overwrites the general real M-by-N matrix C
          !! with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      P * C          C * P
          !! TRANS = 'T':      P**T * C       C * P**T
          !! Here Q and P**T are the orthogonal matrices determined by DGEBRD when
          !! reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
          !! P**T are defined as products of elementary reflectors H(i) and G(i)
          !! respectively.
          !! Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
          !! order of the orthogonal matrix Q or P**T that is applied.
          !! If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
          !! if nq >= k, Q = H(1) H(2) . . . H(k);
          !! if nq < k, Q = H(1) H(2) . . . H(nq-1).
          !! If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
          !! if k < nq, P = G(1) G(2) . . . G(k);
          !! if k >= nq, P = G(1) G(2) . . . G(nq-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dormbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormbr
#else
               module procedure stdlib_dormbr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sormbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormbr
#else
               module procedure stdlib_sormbr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dormbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans,vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormbr
#else
               module procedure stdlib_I64_dormbr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sormbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans,vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormbr
#else
               module procedure stdlib_I64_sormbr
#endif
          end interface ormbr

          interface ormhr
          !! ORMHR overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! where Q is a real orthogonal matrix of order nq, with nq = m if
          !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !! IHI-ILO elementary reflectors, as returned by DGEHRD:
          !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(in) :: ihi,ilo,lda,ldc,lwork,m,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormhr
#else
               module procedure stdlib_dormhr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(in) :: ihi,ilo,lda,ldc,lwork,m,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormhr
#else
               module procedure stdlib_sormhr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(in) :: ihi,ilo,lda,ldc,lwork,m,n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormhr
#else
               module procedure stdlib_I64_dormhr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(in) :: ihi,ilo,lda,ldc,lwork,m,n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormhr
#else
               module procedure stdlib_I64_sormhr
#endif
          end interface ormhr

          interface ormlq
          !! ORMLQ overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! where Q is a real orthogonal matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(k) . . . H(2) H(1)
          !! as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dormlq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormlq
#else
               module procedure stdlib_dormlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sormlq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormlq
#else
               module procedure stdlib_sormlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dormlq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormlq
#else
               module procedure stdlib_I64_dormlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sormlq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormlq
#else
               module procedure stdlib_I64_sormlq
#endif
          end interface ormlq

          interface ormql
          !! ORMQL overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! where Q is a real orthogonal matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(k) . . . H(2) H(1)
          !! as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dormql( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormql
#else
               module procedure stdlib_dormql
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sormql( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormql
#else
               module procedure stdlib_sormql
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dormql( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormql
#else
               module procedure stdlib_I64_dormql
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sormql( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormql
#else
               module procedure stdlib_I64_sormql
#endif
          end interface ormql

          interface ormqr
          !! ORMQR overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! where Q is a real orthogonal matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(1) H(2) . . . H(k)
          !! as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dormqr( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormqr
#else
               module procedure stdlib_dormqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sormqr( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormqr
#else
               module procedure stdlib_sormqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dormqr( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormqr
#else
               module procedure stdlib_I64_dormqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sormqr( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormqr
#else
               module procedure stdlib_I64_sormqr
#endif
          end interface ormqr

          interface ormrq
          !! ORMRQ overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! where Q is a real orthogonal matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(1) H(2) . . . H(k)
          !! as returned by DGERQF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dormrq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormrq
#else
               module procedure stdlib_dormrq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sormrq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormrq
#else
               module procedure stdlib_sormrq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dormrq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormrq
#else
               module procedure stdlib_I64_dormrq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sormrq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormrq
#else
               module procedure stdlib_I64_sormrq
#endif
          end interface ormrq

          interface ormrz
          !! ORMRZ overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! where Q is a real orthogonal matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(1) H(2) . . . H(k)
          !! as returned by DTZRZF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dormrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,l,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormrz
#else
               module procedure stdlib_dormrz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sormrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,l,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormrz
#else
               module procedure stdlib_sormrz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dormrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,l,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormrz
#else
               module procedure stdlib_I64_dormrz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sormrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,l,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormrz
#else
               module procedure stdlib_I64_sormrz
#endif
          end interface ormrz

          interface ormtr
          !! ORMTR overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! where Q is a real orthogonal matrix of order nq, with nq = m if
          !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !! nq-1 elementary reflectors, as returned by DSYTRD:
          !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
          !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dormtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormtr
#else
               module procedure stdlib_dormtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sormtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormtr
#else
               module procedure stdlib_sormtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dormtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormtr
#else
               module procedure stdlib_I64_dormtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sormtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormtr
#else
               module procedure stdlib_I64_sormtr
#endif
          end interface ormtr

          interface pbcon
          !! PBCON estimates the reciprocal of the condition number (in the
          !! 1-norm) of a complex Hermitian positive definite band matrix using
          !! the Cholesky factorization A = U**H*U or A = L*L**H computed by
          !! CPBTRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,rwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cpbcon
#else
               module procedure stdlib_cpbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(in) :: anorm,ab(ldab,*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dpbcon
#else
               module procedure stdlib_dpbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(in) :: anorm,ab(ldab,*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine spbcon
#else
               module procedure stdlib_spbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,rwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zpbcon
#else
               module procedure stdlib_zpbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,rwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cpbcon
#else
               module procedure stdlib_I64_cpbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(dp), intent(in) :: anorm,ab(ldab,*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dpbcon
#else
               module procedure stdlib_I64_dpbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(sp), intent(in) :: anorm,ab(ldab,*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine spbcon
#else
               module procedure stdlib_I64_spbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,rwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zpbcon
#else
               module procedure stdlib_I64_zpbcon
#endif
          end interface pbcon

          interface pbequ
          !! PBEQU computes row and column scalings intended to equilibrate a
          !! Hermitian positive definite band matrix A and reduce its condition
          !! number (with respect to the two-norm).  S contains the scale factors,
          !! S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
          !! elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
          !! choice of S puts the condition number of B within a factor N of the
          !! smallest possible condition number over all possible diagonal
          !! scalings.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end subroutine cpbequ
#else
               module procedure stdlib_cpbequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    real(dp), intent(in) :: ab(ldab,*)
               end subroutine dpbequ
#else
               module procedure stdlib_dpbequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    real(sp), intent(in) :: ab(ldab,*)
               end subroutine spbequ
#else
               module procedure stdlib_spbequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end subroutine zpbequ
#else
               module procedure stdlib_zpbequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end subroutine cpbequ
#else
               module procedure stdlib_I64_cpbequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    real(dp), intent(in) :: ab(ldab,*)
               end subroutine dpbequ
#else
               module procedure stdlib_I64_dpbequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    real(sp), intent(in) :: ab(ldab,*)
               end subroutine spbequ
#else
               module procedure stdlib_I64_spbequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end subroutine zpbequ
#else
               module procedure stdlib_I64_zpbequ
#endif
          end interface pbequ

          interface pbrfs
          !! PBRFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is Hermitian positive definite
          !! and banded, and provides error bounds and backward error estimates
          !! for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,ldb, x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldafb,ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cpbrfs
#else
               module procedure stdlib_cpbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,ldb, x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,ldafb,ldb,ldx,n,nrhs
                    real(dp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dpbrfs
#else
               module procedure stdlib_dpbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,ldb, x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,ldafb,ldb,ldx,n,nrhs
                    real(sp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine spbrfs
#else
               module procedure stdlib_spbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,ldb, x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldafb,ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zpbrfs
#else
               module procedure stdlib_zpbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,ldb, x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldafb,ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cpbrfs
#else
               module procedure stdlib_I64_cpbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,ldb, x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: kd,ldab,ldafb,ldb,ldx,n,nrhs
                    real(dp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dpbrfs
#else
               module procedure stdlib_I64_dpbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,ldb, x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: kd,ldab,ldafb,ldb,ldx,n,nrhs
                    real(sp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine spbrfs
#else
               module procedure stdlib_I64_spbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,ldb, x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldafb,ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zpbrfs
#else
               module procedure stdlib_I64_zpbrfs
#endif
          end interface pbrfs

          interface pbstf
          !! PBSTF computes a split Cholesky factorization of a complex
          !! Hermitian positive definite band matrix A.
          !! This routine is designed to be used in conjunction with CHBGST.
          !! The factorization has the form  A = S**H*S  where S is a band matrix
          !! of the same bandwidth as A and the following structure:
          !! S = ( U    )
          !! ( M  L )
          !! where U is upper triangular of order m = (n+kd)/2, and L is lower
          !! triangular of order n-m.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpbstf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine cpbstf
#else
               module procedure stdlib_cpbstf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpbstf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dpbstf
#else
               module procedure stdlib_dpbstf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spbstf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine spbstf
#else
               module procedure stdlib_spbstf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpbstf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zpbstf
#else
               module procedure stdlib_zpbstf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpbstf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine cpbstf
#else
               module procedure stdlib_I64_cpbstf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpbstf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dpbstf
#else
               module procedure stdlib_I64_dpbstf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spbstf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine spbstf
#else
               module procedure stdlib_I64_spbstf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpbstf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zpbstf
#else
               module procedure stdlib_I64_zpbstf
#endif
          end interface pbstf

          interface pbsv
          !! PBSV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N Hermitian positive definite band matrix and X
          !! and B are N-by-NRHS matrices.
          !! The Cholesky decomposition is used to factor A as
          !! A = U**H * U,  if UPLO = 'U', or
          !! A = L * L**H,  if UPLO = 'L',
          !! where U is an upper triangular band matrix, and L is a lower
          !! triangular band matrix, with the same number of superdiagonals or
          !! subdiagonals as A.  The factored form of A is then used to solve the
          !! system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(sp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine cpbsv
#else
               module procedure stdlib_cpbsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(dp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine dpbsv
#else
               module procedure stdlib_dpbsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(sp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine spbsv
#else
               module procedure stdlib_spbsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(dp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine zpbsv
#else
               module procedure stdlib_zpbsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(sp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine cpbsv
#else
               module procedure stdlib_I64_cpbsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(dp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine dpbsv
#else
               module procedure stdlib_I64_dpbsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(sp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine spbsv
#else
               module procedure stdlib_I64_spbsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(dp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine zpbsv
#else
               module procedure stdlib_I64_zpbsv
#endif
          end interface pbsv

          interface pbtrf
          !! PBTRF computes the Cholesky factorization of a complex Hermitian
          !! positive definite band matrix A.
          !! The factorization has the form
          !! A = U**H * U,  if UPLO = 'U', or
          !! A = L  * L**H,  if UPLO = 'L',
          !! where U is an upper triangular matrix and L is lower triangular.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpbtrf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine cpbtrf
#else
               module procedure stdlib_cpbtrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpbtrf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dpbtrf
#else
               module procedure stdlib_dpbtrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spbtrf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine spbtrf
#else
               module procedure stdlib_spbtrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpbtrf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zpbtrf
#else
               module procedure stdlib_zpbtrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpbtrf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine cpbtrf
#else
               module procedure stdlib_I64_cpbtrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpbtrf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dpbtrf
#else
               module procedure stdlib_I64_dpbtrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spbtrf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine spbtrf
#else
               module procedure stdlib_I64_spbtrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpbtrf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zpbtrf
#else
               module procedure stdlib_I64_zpbtrf
#endif
          end interface pbtrf

          interface pbtrs
          !! PBTRS solves a system of linear equations A*X = B with a Hermitian
          !! positive definite band matrix A using the Cholesky factorization
          !! A = U**H*U or A = L*L**H computed by CPBTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cpbtrs
#else
               module procedure stdlib_cpbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dpbtrs
#else
               module procedure stdlib_dpbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine spbtrs
#else
               module procedure stdlib_spbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zpbtrs
#else
               module procedure stdlib_zpbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cpbtrs
#else
               module procedure stdlib_I64_cpbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dpbtrs
#else
               module procedure stdlib_I64_dpbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine spbtrs
#else
               module procedure stdlib_I64_spbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zpbtrs
#else
               module procedure stdlib_I64_zpbtrs
#endif
          end interface pbtrs

          interface pftrf
          !! PFTRF computes the Cholesky factorization of a complex Hermitian
          !! positive definite matrix A.
          !! The factorization has the form
          !! A = U**H * U,  if UPLO = 'U', or
          !! A = L  * L**H,  if UPLO = 'L',
          !! where U is an upper triangular matrix and L is lower triangular.
          !! This is the block version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpftrf( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(in) :: n
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(inout) :: a(0:*)
               end subroutine cpftrf
#else
               module procedure stdlib_cpftrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpftrf( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(in) :: n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(inout) :: a(0:*)
               end subroutine dpftrf
#else
               module procedure stdlib_dpftrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spftrf( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(in) :: n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(inout) :: a(0:*)
               end subroutine spftrf
#else
               module procedure stdlib_spftrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpftrf( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(in) :: n
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(inout) :: a(0:*)
               end subroutine zpftrf
#else
               module procedure stdlib_zpftrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpftrf( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(in) :: n
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(inout) :: a(0:*)
               end subroutine cpftrf
#else
               module procedure stdlib_I64_cpftrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpftrf( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(in) :: n
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(inout) :: a(0:*)
               end subroutine dpftrf
#else
               module procedure stdlib_I64_dpftrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spftrf( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(in) :: n
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(inout) :: a(0:*)
               end subroutine spftrf
#else
               module procedure stdlib_I64_spftrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpftrf( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(in) :: n
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(inout) :: a(0:*)
               end subroutine zpftrf
#else
               module procedure stdlib_I64_zpftrf
#endif
          end interface pftrf

          interface pftri
          !! PFTRI computes the inverse of a complex Hermitian positive definite
          !! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
          !! computed by CPFTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpftri( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: a(0:*)
               end subroutine cpftri
#else
               module procedure stdlib_cpftri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpftri( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: a(0:*)
               end subroutine dpftri
#else
               module procedure stdlib_dpftri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spftri( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: a(0:*)
               end subroutine spftri
#else
               module procedure stdlib_spftri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpftri( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: a(0:*)
               end subroutine zpftri
#else
               module procedure stdlib_zpftri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpftri( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    complex(sp), intent(inout) :: a(0:*)
               end subroutine cpftri
#else
               module procedure stdlib_I64_cpftri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpftri( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(inout) :: a(0:*)
               end subroutine dpftri
#else
               module procedure stdlib_I64_dpftri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spftri( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(inout) :: a(0:*)
               end subroutine spftri
#else
               module procedure stdlib_I64_spftri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpftri( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    complex(dp), intent(inout) :: a(0:*)
               end subroutine zpftri
#else
               module procedure stdlib_I64_zpftri
#endif
          end interface pftri

          interface pftrs
          !! PFTRS solves a system of linear equations A*X = B with a Hermitian
          !! positive definite matrix A using the Cholesky factorization
          !! A = U**H*U or A = L*L**H computed by CPFTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpftrs( transr, uplo, n, nrhs, a, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(in) :: a(0:*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cpftrs
#else
               module procedure stdlib_cpftrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpftrs( transr, uplo, n, nrhs, a, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(in) :: a(0:*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dpftrs
#else
               module procedure stdlib_dpftrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spftrs( transr, uplo, n, nrhs, a, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(in) :: a(0:*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine spftrs
#else
               module procedure stdlib_spftrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpftrs( transr, uplo, n, nrhs, a, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(in) :: a(0:*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zpftrs
#else
               module procedure stdlib_zpftrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpftrs( transr, uplo, n, nrhs, a, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(in) :: a(0:*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cpftrs
#else
               module procedure stdlib_I64_cpftrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpftrs( transr, uplo, n, nrhs, a, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(dp), intent(in) :: a(0:*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dpftrs
#else
               module procedure stdlib_I64_dpftrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spftrs( transr, uplo, n, nrhs, a, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(sp), intent(in) :: a(0:*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine spftrs
#else
               module procedure stdlib_I64_spftrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpftrs( transr, uplo, n, nrhs, a, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(in) :: a(0:*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zpftrs
#else
               module procedure stdlib_I64_zpftrs
#endif
          end interface pftrs

          interface pocon
          !! POCON estimates the reciprocal of the condition number (in the
          !! 1-norm) of a complex Hermitian positive definite matrix using the
          !! Cholesky factorization A = U**H*U or A = L*L**H computed by CPOTRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpocon( uplo, n, a, lda, anorm, rcond, work, rwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cpocon
#else
               module procedure stdlib_cpocon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpocon( uplo, n, a, lda, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,work(*)
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dpocon
#else
               module procedure stdlib_dpocon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spocon( uplo, n, a, lda, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,work(*)
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine spocon
#else
               module procedure stdlib_spocon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpocon( uplo, n, a, lda, anorm, rcond, work, rwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zpocon
#else
               module procedure stdlib_zpocon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpocon( uplo, n, a, lda, anorm, rcond, work, rwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cpocon
#else
               module procedure stdlib_I64_cpocon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpocon( uplo, n, a, lda, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,work(*)
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dpocon
#else
               module procedure stdlib_I64_dpocon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spocon( uplo, n, a, lda, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,work(*)
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine spocon
#else
               module procedure stdlib_I64_spocon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpocon( uplo, n, a, lda, anorm, rcond, work, rwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zpocon
#else
               module procedure stdlib_I64_zpocon
#endif
          end interface pocon

          interface poequ
          !! POEQU computes row and column scalings intended to equilibrate a
          !! Hermitian positive definite matrix A and reduce its condition number
          !! (with respect to the two-norm).  S contains the scale factors,
          !! S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
          !! elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
          !! choice of S puts the condition number of B within a factor N of the
          !! smallest possible condition number over all possible diagonal
          !! scalings.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpoequ( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    complex(sp), intent(in) :: a(lda,*)
               end subroutine cpoequ
#else
               module procedure stdlib_cpoequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpoequ( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dpoequ
#else
               module procedure stdlib_dpoequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spoequ( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    real(sp), intent(in) :: a(lda,*)
               end subroutine spoequ
#else
               module procedure stdlib_spoequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpoequ( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    complex(dp), intent(in) :: a(lda,*)
               end subroutine zpoequ
#else
               module procedure stdlib_zpoequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpoequ( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    complex(sp), intent(in) :: a(lda,*)
               end subroutine cpoequ
#else
               module procedure stdlib_I64_cpoequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpoequ( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dpoequ
#else
               module procedure stdlib_I64_dpoequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spoequ( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    real(sp), intent(in) :: a(lda,*)
               end subroutine spoequ
#else
               module procedure stdlib_I64_spoequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpoequ( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    complex(dp), intent(in) :: a(lda,*)
               end subroutine zpoequ
#else
               module procedure stdlib_I64_zpoequ
#endif
          end interface poequ

          interface poequb
          !! POEQUB computes row and column scalings intended to equilibrate a
          !! Hermitian positive definite matrix A and reduce its condition number
          !! (with respect to the two-norm).  S contains the scale factors,
          !! S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
          !! elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
          !! choice of S puts the condition number of B within a factor N of the
          !! smallest possible condition number over all possible diagonal
          !! scalings.
          !! This routine differs from CPOEQU by restricting the scaling factors
          !! to a power of the radix.  Barring over- and underflow, scaling by
          !! these factors introduces no additional rounding errors.  However, the
          !! scaled diagonal entries are no longer approximately 1 but lie
          !! between sqrt(radix) and 1/sqrt(radix).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpoequb( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    complex(sp), intent(in) :: a(lda,*)
               end subroutine cpoequb
#else
               module procedure stdlib_cpoequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpoequb( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dpoequb
#else
               module procedure stdlib_dpoequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spoequb( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    real(sp), intent(in) :: a(lda,*)
               end subroutine spoequb
#else
               module procedure stdlib_spoequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpoequb( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    complex(dp), intent(in) :: a(lda,*)
               end subroutine zpoequb
#else
               module procedure stdlib_zpoequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpoequb( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    complex(sp), intent(in) :: a(lda,*)
               end subroutine cpoequb
#else
               module procedure stdlib_I64_cpoequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpoequb( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dpoequb
#else
               module procedure stdlib_I64_dpoequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spoequb( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    real(sp), intent(in) :: a(lda,*)
               end subroutine spoequb
#else
               module procedure stdlib_I64_spoequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpoequb( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    complex(dp), intent(in) :: a(lda,*)
               end subroutine zpoequb
#else
               module procedure stdlib_I64_zpoequb
#endif
          end interface poequb

          interface porfs
          !! PORFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is Hermitian positive definite,
          !! and provides error bounds and backward error estimates for the
          !! solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,ldx, ferr, berr,&
                          work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cporfs
#else
               module procedure stdlib_cporfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,ldx, ferr, berr,&
                          work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dporfs
#else
               module procedure stdlib_dporfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,ldx, ferr, berr,&
                          work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine sporfs
#else
               module procedure stdlib_sporfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,ldx, ferr, berr,&
                          work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zporfs
#else
               module procedure stdlib_zporfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,ldx, ferr, berr,&
                          work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cporfs
#else
               module procedure stdlib_I64_cporfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,ldx, ferr, berr,&
                          work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dporfs
#else
               module procedure stdlib_I64_dporfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,ldx, ferr, berr,&
                          work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine sporfs
#else
               module procedure stdlib_I64_sporfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,ldx, ferr, berr,&
                          work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zporfs
#else
               module procedure stdlib_I64_zporfs
#endif
          end interface porfs

          interface posv
          !! POSV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N Hermitian positive definite matrix and X and B
          !! are N-by-NRHS matrices.
          !! The Cholesky decomposition is used to factor A as
          !! A = U**H* U,  if UPLO = 'U', or
          !! A = L * L**H,  if UPLO = 'L',
          !! where U is an upper triangular matrix and  L is a lower triangular
          !! matrix.  The factored form of A is then used to solve the system of
          !! equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cposv( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine cposv
#else
               module procedure stdlib_cposv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dposv( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine dposv
#else
               module procedure stdlib_dposv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sposv( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine sposv
#else
               module procedure stdlib_sposv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zposv( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine zposv
#else
               module procedure stdlib_zposv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cposv( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine cposv
#else
               module procedure stdlib_I64_cposv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dposv( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine dposv
#else
               module procedure stdlib_I64_dposv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sposv( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine sposv
#else
               module procedure stdlib_I64_sposv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zposv( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine zposv
#else
               module procedure stdlib_I64_zposv
#endif
          end interface posv

          interface potrf
          !! POTRF computes the Cholesky factorization of a complex Hermitian
          !! positive definite matrix A.
          !! The factorization has the form
          !! A = U**H * U,  if UPLO = 'U', or
          !! A = L  * L**H,  if UPLO = 'L',
          !! where U is an upper triangular matrix and L is lower triangular.
          !! This is the block version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpotrf( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cpotrf
#else
               module procedure stdlib_cpotrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpotrf( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dpotrf
#else
               module procedure stdlib_dpotrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spotrf( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine spotrf
#else
               module procedure stdlib_spotrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpotrf( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zpotrf
#else
               module procedure stdlib_zpotrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpotrf( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cpotrf
#else
               module procedure stdlib_I64_cpotrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpotrf( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dpotrf
#else
               module procedure stdlib_I64_dpotrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spotrf( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine spotrf
#else
               module procedure stdlib_I64_spotrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpotrf( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zpotrf
#else
               module procedure stdlib_I64_zpotrf
#endif
          end interface potrf

          interface potrf2
          !! POTRF2 computes the Cholesky factorization of a Hermitian
          !! positive definite matrix A using the recursive algorithm.
          !! The factorization has the form
          !! A = U**H * U,  if UPLO = 'U', or
          !! A = L  * L**H,  if UPLO = 'L',
          !! where U is an upper triangular matrix and L is lower triangular.
          !! This is the recursive version of the algorithm. It divides
          !! the matrix into four submatrices:
          !! [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2
          !! A = [ -----|----- ]  with n1 = n/2
          !! [  A21 | A22  ]       n2 = n-n1
          !! The subroutine calls itself to factor A11. Update and scale A21
          !! or A12, update A22 then calls itself to factor A22.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine cpotrf2( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cpotrf2
#else
               module procedure stdlib_cpotrf2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine dpotrf2( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dpotrf2
#else
               module procedure stdlib_dpotrf2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine spotrf2( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine spotrf2
#else
               module procedure stdlib_spotrf2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine zpotrf2( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zpotrf2
#else
               module procedure stdlib_zpotrf2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine cpotrf2( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cpotrf2
#else
               module procedure stdlib_I64_cpotrf2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine dpotrf2( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dpotrf2
#else
               module procedure stdlib_I64_dpotrf2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine spotrf2( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine spotrf2
#else
               module procedure stdlib_I64_spotrf2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure recursive subroutine zpotrf2( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zpotrf2
#else
               module procedure stdlib_I64_zpotrf2
#endif
          end interface potrf2

          interface potri
          !! POTRI computes the inverse of a complex Hermitian positive definite
          !! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
          !! computed by CPOTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpotri( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cpotri
#else
               module procedure stdlib_cpotri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpotri( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dpotri
#else
               module procedure stdlib_dpotri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spotri( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine spotri
#else
               module procedure stdlib_spotri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpotri( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zpotri
#else
               module procedure stdlib_zpotri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpotri( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cpotri
#else
               module procedure stdlib_I64_cpotri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpotri( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dpotri
#else
               module procedure stdlib_I64_dpotri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spotri( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine spotri
#else
               module procedure stdlib_I64_spotri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpotri( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zpotri
#else
               module procedure stdlib_I64_zpotri
#endif
          end interface potri

          interface potrs
          !! POTRS solves a system of linear equations A*X = B with a Hermitian
          !! positive definite matrix A using the Cholesky factorization
          !! A = U**H*U or A = L*L**H computed by CPOTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cpotrs
#else
               module procedure stdlib_cpotrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dpotrs
#else
               module procedure stdlib_dpotrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spotrs( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine spotrs
#else
               module procedure stdlib_spotrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zpotrs
#else
               module procedure stdlib_zpotrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cpotrs
#else
               module procedure stdlib_I64_cpotrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dpotrs
#else
               module procedure stdlib_I64_dpotrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spotrs( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine spotrs
#else
               module procedure stdlib_I64_spotrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zpotrs
#else
               module procedure stdlib_I64_zpotrs
#endif
          end interface potrs

          interface ppcon
          !! PPCON estimates the reciprocal of the condition number (in the
          !! 1-norm) of a complex Hermitian positive definite packed matrix using
          !! the Cholesky factorization A = U**H*U or A = L*L**H computed by
          !! CPPTRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cppcon( uplo, n, ap, anorm, rcond, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cppcon
#else
               module procedure stdlib_cppcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dppcon( uplo, n, ap, anorm, rcond, work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: anorm,ap(*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dppcon
#else
               module procedure stdlib_dppcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sppcon( uplo, n, ap, anorm, rcond, work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: anorm,ap(*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine sppcon
#else
               module procedure stdlib_sppcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zppcon( uplo, n, ap, anorm, rcond, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zppcon
#else
               module procedure stdlib_zppcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cppcon( uplo, n, ap, anorm, rcond, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cppcon
#else
               module procedure stdlib_I64_cppcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dppcon( uplo, n, ap, anorm, rcond, work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: anorm,ap(*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dppcon
#else
               module procedure stdlib_I64_dppcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sppcon( uplo, n, ap, anorm, rcond, work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: anorm,ap(*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine sppcon
#else
               module procedure stdlib_I64_sppcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zppcon( uplo, n, ap, anorm, rcond, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zppcon
#else
               module procedure stdlib_I64_zppcon
#endif
          end interface ppcon

          interface ppequ
          !! PPEQU computes row and column scalings intended to equilibrate a
          !! Hermitian positive definite matrix A in packed storage and reduce
          !! its condition number (with respect to the two-norm).  S contains the
          !! scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
          !! B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
          !! This choice of S puts the condition number of B within a factor N of
          !! the smallest possible condition number over all possible diagonal
          !! scalings.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cppequ( uplo, n, ap, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: amax,scond,s(*)
                    complex(sp), intent(in) :: ap(*)
               end subroutine cppequ
#else
               module procedure stdlib_cppequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dppequ( uplo, n, ap, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: amax,scond,s(*)
                    real(dp), intent(in) :: ap(*)
               end subroutine dppequ
#else
               module procedure stdlib_dppequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sppequ( uplo, n, ap, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: amax,scond,s(*)
                    real(sp), intent(in) :: ap(*)
               end subroutine sppequ
#else
               module procedure stdlib_sppequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zppequ( uplo, n, ap, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: amax,scond,s(*)
                    complex(dp), intent(in) :: ap(*)
               end subroutine zppequ
#else
               module procedure stdlib_zppequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cppequ( uplo, n, ap, s, scond, amax, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(out) :: amax,scond,s(*)
                    complex(sp), intent(in) :: ap(*)
               end subroutine cppequ
#else
               module procedure stdlib_I64_cppequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dppequ( uplo, n, ap, s, scond, amax, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(out) :: amax,scond,s(*)
                    real(dp), intent(in) :: ap(*)
               end subroutine dppequ
#else
               module procedure stdlib_I64_dppequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sppequ( uplo, n, ap, s, scond, amax, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(out) :: amax,scond,s(*)
                    real(sp), intent(in) :: ap(*)
               end subroutine sppequ
#else
               module procedure stdlib_I64_sppequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zppequ( uplo, n, ap, s, scond, amax, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(out) :: amax,scond,s(*)
                    complex(dp), intent(in) :: ap(*)
               end subroutine zppequ
#else
               module procedure stdlib_I64_zppequ
#endif
          end interface ppequ

          interface pprfs
          !! PPRFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is Hermitian positive definite
          !! and packed, and provides error bounds and backward error estimates
          !! for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,berr, work, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cpprfs
#else
               module procedure stdlib_cpprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,berr, work, &
                         iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dpprfs
#else
               module procedure stdlib_dpprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,berr, work, &
                         iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine spprfs
#else
               module procedure stdlib_spprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,berr, work, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zpprfs
#else
               module procedure stdlib_zpprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,berr, work, &
                         rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cpprfs
#else
               module procedure stdlib_I64_cpprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,berr, work, &
                         iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dpprfs
#else
               module procedure stdlib_I64_dpprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,berr, work, &
                         iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine spprfs
#else
               module procedure stdlib_I64_spprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,berr, work, &
                         rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zpprfs
#else
               module procedure stdlib_I64_zpprfs
#endif
          end interface pprfs

          interface ppsv
          !! PPSV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N Hermitian positive definite matrix stored in
          !! packed format and X and B are N-by-NRHS matrices.
          !! The Cholesky decomposition is used to factor A as
          !! A = U**H * U,  if UPLO = 'U', or
          !! A = L * L**H,  if UPLO = 'L',
          !! where U is an upper triangular matrix and L is a lower triangular
          !! matrix.  The factored form of A is then used to solve the system of
          !! equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cppsv( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine cppsv
#else
               module procedure stdlib_cppsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dppsv( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine dppsv
#else
               module procedure stdlib_dppsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sppsv( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine sppsv
#else
               module procedure stdlib_sppsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zppsv( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine zppsv
#else
               module procedure stdlib_zppsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cppsv( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine cppsv
#else
               module procedure stdlib_I64_cppsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dppsv( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine dppsv
#else
               module procedure stdlib_I64_dppsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sppsv( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine sppsv
#else
               module procedure stdlib_I64_sppsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zppsv( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine zppsv
#else
               module procedure stdlib_I64_zppsv
#endif
          end interface ppsv

          interface pptrf
          !! PPTRF computes the Cholesky factorization of a complex Hermitian
          !! positive definite matrix A stored in packed format.
          !! The factorization has the form
          !! A = U**H * U,  if UPLO = 'U', or
          !! A = L  * L**H,  if UPLO = 'L',
          !! where U is an upper triangular matrix and L is lower triangular.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpptrf( uplo, n, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: ap(*)
               end subroutine cpptrf
#else
               module procedure stdlib_cpptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpptrf( uplo, n, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: ap(*)
               end subroutine dpptrf
#else
               module procedure stdlib_dpptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spptrf( uplo, n, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: ap(*)
               end subroutine spptrf
#else
               module procedure stdlib_spptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpptrf( uplo, n, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zpptrf
#else
               module procedure stdlib_zpptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpptrf( uplo, n, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    complex(sp), intent(inout) :: ap(*)
               end subroutine cpptrf
#else
               module procedure stdlib_I64_cpptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpptrf( uplo, n, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(inout) :: ap(*)
               end subroutine dpptrf
#else
               module procedure stdlib_I64_dpptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spptrf( uplo, n, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(inout) :: ap(*)
               end subroutine spptrf
#else
               module procedure stdlib_I64_spptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpptrf( uplo, n, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zpptrf
#else
               module procedure stdlib_I64_zpptrf
#endif
          end interface pptrf

          interface pptri
          !! PPTRI computes the inverse of a complex Hermitian positive definite
          !! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
          !! computed by CPPTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpptri( uplo, n, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: ap(*)
               end subroutine cpptri
#else
               module procedure stdlib_cpptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpptri( uplo, n, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: ap(*)
               end subroutine dpptri
#else
               module procedure stdlib_dpptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spptri( uplo, n, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: ap(*)
               end subroutine spptri
#else
               module procedure stdlib_spptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpptri( uplo, n, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zpptri
#else
               module procedure stdlib_zpptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpptri( uplo, n, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    complex(sp), intent(inout) :: ap(*)
               end subroutine cpptri
#else
               module procedure stdlib_I64_cpptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpptri( uplo, n, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(inout) :: ap(*)
               end subroutine dpptri
#else
               module procedure stdlib_I64_dpptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spptri( uplo, n, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(inout) :: ap(*)
               end subroutine spptri
#else
               module procedure stdlib_I64_spptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpptri( uplo, n, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zpptri
#else
               module procedure stdlib_I64_zpptri
#endif
          end interface pptri

          interface pptrs
          !! PPTRS solves a system of linear equations A*X = B with a Hermitian
          !! positive definite matrix A in packed storage using the Cholesky
          !! factorization A = U**H*U or A = L*L**H computed by CPPTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpptrs( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cpptrs
#else
               module procedure stdlib_cpptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpptrs( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dpptrs
#else
               module procedure stdlib_dpptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spptrs( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine spptrs
#else
               module procedure stdlib_spptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpptrs( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zpptrs
#else
               module procedure stdlib_zpptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpptrs( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cpptrs
#else
               module procedure stdlib_I64_cpptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpptrs( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dpptrs
#else
               module procedure stdlib_I64_dpptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spptrs( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine spptrs
#else
               module procedure stdlib_I64_spptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpptrs( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zpptrs
#else
               module procedure stdlib_I64_zpptrs
#endif
          end interface pptrs

          interface pstrf
          !! PSTRF computes the Cholesky factorization with complete
          !! pivoting of a complex Hermitian positive semidefinite matrix A.
          !! The factorization has the form
          !! P**T * A * P = U**H * U ,  if UPLO = 'U',
          !! P**T * A * P = L  * L**H,  if UPLO = 'L',
          !! where U is an upper triangular matrix and L is lower triangular, and
          !! P is stored as vector PIV.
          !! This algorithm does not attempt to check that A is positive
          !! semidefinite. This version of the algorithm calls level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpstrf( uplo, n, a, lda, piv, rank, tol, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: tol
                    integer(ilp), intent(out) :: info,rank,piv(n)
                    integer(ilp), intent(in) :: lda,n
                    character, intent(in) :: uplo
                    complex(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(2*n)
               end subroutine cpstrf
#else
               module procedure stdlib_cpstrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpstrf( uplo, n, a, lda, piv, rank, tol, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: tol
                    integer(ilp), intent(out) :: info,rank,piv(n)
                    integer(ilp), intent(in) :: lda,n
                    character, intent(in) :: uplo
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(2*n)
               end subroutine dpstrf
#else
               module procedure stdlib_dpstrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spstrf( uplo, n, a, lda, piv, rank, tol, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: tol
                    integer(ilp), intent(out) :: info,rank,piv(n)
                    integer(ilp), intent(in) :: lda,n
                    character, intent(in) :: uplo
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(2*n)
               end subroutine spstrf
#else
               module procedure stdlib_spstrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpstrf( uplo, n, a, lda, piv, rank, tol, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: tol
                    integer(ilp), intent(out) :: info,rank,piv(n)
                    integer(ilp), intent(in) :: lda,n
                    character, intent(in) :: uplo
                    complex(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(2*n)
               end subroutine zpstrf
#else
               module procedure stdlib_zpstrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpstrf( uplo, n, a, lda, piv, rank, tol, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: tol
                    integer(ilp64), intent(out) :: info,rank,piv(n)
                    integer(ilp64), intent(in) :: lda,n
                    character, intent(in) :: uplo
                    complex(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(2*n)
               end subroutine cpstrf
#else
               module procedure stdlib_I64_cpstrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpstrf( uplo, n, a, lda, piv, rank, tol, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: tol
                    integer(ilp64), intent(out) :: info,rank,piv(n)
                    integer(ilp64), intent(in) :: lda,n
                    character, intent(in) :: uplo
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(2*n)
               end subroutine dpstrf
#else
               module procedure stdlib_I64_dpstrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spstrf( uplo, n, a, lda, piv, rank, tol, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: tol
                    integer(ilp64), intent(out) :: info,rank,piv(n)
                    integer(ilp64), intent(in) :: lda,n
                    character, intent(in) :: uplo
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(2*n)
               end subroutine spstrf
#else
               module procedure stdlib_I64_spstrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpstrf( uplo, n, a, lda, piv, rank, tol, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: tol
                    integer(ilp64), intent(out) :: info,rank,piv(n)
                    integer(ilp64), intent(in) :: lda,n
                    character, intent(in) :: uplo
                    complex(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(2*n)
               end subroutine zpstrf
#else
               module procedure stdlib_I64_zpstrf
#endif
          end interface pstrf

          interface ptcon
          !! PTCON computes the reciprocal of the condition number (in the
          !! 1-norm) of a complex Hermitian positive definite tridiagonal matrix
          !! using the factorization A = L*D*L**H or A = U**H*D*U computed by
          !! CPTTRF.
          !! Norm(inv(A)) is computed by a direct method, and the reciprocal of
          !! the condition number is computed as
          !! RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cptcon( n, d, e, anorm, rcond, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: anorm,d(*)
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: e(*)
               end subroutine cptcon
#else
               module procedure stdlib_cptcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dptcon( n, d, e, anorm, rcond, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: anorm,d(*),e(*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dptcon
#else
               module procedure stdlib_dptcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sptcon( n, d, e, anorm, rcond, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: anorm,d(*),e(*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine sptcon
#else
               module procedure stdlib_sptcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zptcon( n, d, e, anorm, rcond, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: anorm,d(*)
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: e(*)
               end subroutine zptcon
#else
               module procedure stdlib_zptcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cptcon( n, d, e, anorm, rcond, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: anorm,d(*)
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: e(*)
               end subroutine cptcon
#else
               module procedure stdlib_I64_cptcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dptcon( n, d, e, anorm, rcond, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: anorm,d(*),e(*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dptcon
#else
               module procedure stdlib_I64_dptcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sptcon( n, d, e, anorm, rcond, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: anorm,d(*),e(*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine sptcon
#else
               module procedure stdlib_I64_sptcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zptcon( n, d, e, anorm, rcond, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: anorm,d(*)
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: e(*)
               end subroutine zptcon
#else
               module procedure stdlib_I64_zptcon
#endif
          end interface ptcon

          interface pteqr
          !! PTEQR computes all eigenvalues and, optionally, eigenvectors of a
          !! symmetric positive definite tridiagonal matrix by first factoring the
          !! matrix using SPTTRF and then calling CBDSQR to compute the singular
          !! values of the bidiagonal factor.
          !! This routine computes the eigenvalues of the positive definite
          !! tridiagonal matrix to high relative accuracy.  This means that if the
          !! eigenvalues range over many orders of magnitude in size, then the
          !! small eigenvalues and corresponding eigenvectors will be computed
          !! more accurately than, for example, with the standard QR method.
          !! The eigenvectors of a full or band positive definite Hermitian matrix
          !! can also be found if CHETRD, CHPTRD, or CHBTRD has been used to
          !! reduce this matrix to tridiagonal form.  (The reduction to
          !! tridiagonal form, however, may preclude the possibility of obtaining
          !! high relative accuracy in the small eigenvalues of the original
          !! matrix, if these eigenvalues range over many orders of magnitude.)
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: z(ldz,*)
               end subroutine cpteqr
#else
               module procedure stdlib_cpteqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(dp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dpteqr
#else
               module procedure stdlib_dpteqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(sp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(sp), intent(out) :: work(*)
               end subroutine spteqr
#else
               module procedure stdlib_spteqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: z(ldz,*)
               end subroutine zpteqr
#else
               module procedure stdlib_zpteqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldz,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: z(ldz,*)
               end subroutine cpteqr
#else
               module procedure stdlib_I64_cpteqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldz,n
                    real(dp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dpteqr
#else
               module procedure stdlib_I64_dpteqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldz,n
                    real(sp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(sp), intent(out) :: work(*)
               end subroutine spteqr
#else
               module procedure stdlib_I64_spteqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldz,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: z(ldz,*)
               end subroutine zpteqr
#else
               module procedure stdlib_I64_zpteqr
#endif
          end interface pteqr

          interface ptrfs
          !! PTRFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is Hermitian positive definite
          !! and tridiagonal, and provides error bounds and backward error
          !! estimates for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cptrfs( uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    real(sp), intent(in) :: d(*),df(*)
                    complex(sp), intent(in) :: b(ldb,*),e(*),ef(*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cptrfs
#else
               module procedure stdlib_cptrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dptrfs( n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr,berr, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(in) :: b(ldb,*),d(*),df(*),e(*),ef(*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dptrfs
#else
               module procedure stdlib_dptrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sptrfs( n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr,berr, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(in) :: b(ldb,*),d(*),df(*),e(*),ef(*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine sptrfs
#else
               module procedure stdlib_sptrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zptrfs( uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    real(dp), intent(in) :: d(*),df(*)
                    complex(dp), intent(in) :: b(ldb,*),e(*),ef(*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zptrfs
#else
               module procedure stdlib_zptrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cptrfs( uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    real(sp), intent(in) :: d(*),df(*)
                    complex(sp), intent(in) :: b(ldb,*),e(*),ef(*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cptrfs
#else
               module procedure stdlib_I64_cptrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dptrfs( n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr,berr, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(in) :: b(ldb,*),d(*),df(*),e(*),ef(*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dptrfs
#else
               module procedure stdlib_I64_dptrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sptrfs( n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr,berr, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(in) :: b(ldb,*),d(*),df(*),e(*),ef(*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine sptrfs
#else
               module procedure stdlib_I64_sptrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zptrfs( uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    real(dp), intent(in) :: d(*),df(*)
                    complex(dp), intent(in) :: b(ldb,*),e(*),ef(*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zptrfs
#else
               module procedure stdlib_I64_zptrfs
#endif
          end interface ptrfs

          interface ptsv
          !! PTSV computes the solution to a complex system of linear equations
          !! A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal
          !! matrix, and X and B are N-by-NRHS matrices.
          !! A is factored as A = L*D*L**H, and the factored form of A is then
          !! used to solve the system of equations.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cptsv( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: d(*)
                    complex(sp), intent(inout) :: b(ldb,*),e(*)
               end subroutine cptsv
#else
               module procedure stdlib_cptsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dptsv( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: b(ldb,*),d(*),e(*)
               end subroutine dptsv
#else
               module procedure stdlib_dptsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sptsv( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: b(ldb,*),d(*),e(*)
               end subroutine sptsv
#else
               module procedure stdlib_sptsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zptsv( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: d(*)
                    complex(dp), intent(inout) :: b(ldb,*),e(*)
               end subroutine zptsv
#else
               module procedure stdlib_zptsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cptsv( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: d(*)
                    complex(sp), intent(inout) :: b(ldb,*),e(*)
               end subroutine cptsv
#else
               module procedure stdlib_I64_cptsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dptsv( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: b(ldb,*),d(*),e(*)
               end subroutine dptsv
#else
               module procedure stdlib_I64_dptsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sptsv( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: b(ldb,*),d(*),e(*)
               end subroutine sptsv
#else
               module procedure stdlib_I64_sptsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zptsv( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: d(*)
                    complex(dp), intent(inout) :: b(ldb,*),e(*)
               end subroutine zptsv
#else
               module procedure stdlib_I64_zptsv
#endif
          end interface ptsv

          interface pttrf
          !! PTTRF computes the L*D*L**H factorization of a complex Hermitian
          !! positive definite tridiagonal matrix A.  The factorization may also
          !! be regarded as having the form A = U**H *D*U.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpttrf( n, d, e, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: d(*)
                    complex(sp), intent(inout) :: e(*)
               end subroutine cpttrf
#else
               module procedure stdlib_cpttrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpttrf( n, d, e, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: d(*),e(*)
               end subroutine dpttrf
#else
               module procedure stdlib_dpttrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spttrf( n, d, e, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: d(*),e(*)
               end subroutine spttrf
#else
               module procedure stdlib_spttrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpttrf( n, d, e, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: d(*)
                    complex(dp), intent(inout) :: e(*)
               end subroutine zpttrf
#else
               module procedure stdlib_zpttrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpttrf( n, d, e, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(inout) :: d(*)
                    complex(sp), intent(inout) :: e(*)
               end subroutine cpttrf
#else
               module procedure stdlib_I64_cpttrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpttrf( n, d, e, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(inout) :: d(*),e(*)
               end subroutine dpttrf
#else
               module procedure stdlib_I64_dpttrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spttrf( n, d, e, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(inout) :: d(*),e(*)
               end subroutine spttrf
#else
               module procedure stdlib_I64_spttrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpttrf( n, d, e, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(inout) :: d(*)
                    complex(dp), intent(inout) :: e(*)
               end subroutine zpttrf
#else
               module procedure stdlib_I64_zpttrf
#endif
          end interface pttrf

          interface pttrs
          !! PTTRS solves a tridiagonal system of the form
          !! A * X = B
          !! using the factorization A = U**H*D*U or A = L*D*L**H computed by CPTTRF.
          !! D is a diagonal matrix specified in the vector D, U (or L) is a unit
          !! bidiagonal matrix whose superdiagonal (subdiagonal) is specified in
          !! the vector E, and X and B are N by NRHS matrices.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpttrs( uplo, n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(in) :: d(*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(in) :: e(*)
               end subroutine cpttrs
#else
               module procedure stdlib_cpttrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpttrs( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: b(ldb,*)
                    real(dp), intent(in) :: d(*),e(*)
               end subroutine dpttrs
#else
               module procedure stdlib_dpttrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spttrs( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: b(ldb,*)
                    real(sp), intent(in) :: d(*),e(*)
               end subroutine spttrs
#else
               module procedure stdlib_spttrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpttrs( uplo, n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(in) :: d(*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(in) :: e(*)
               end subroutine zpttrs
#else
               module procedure stdlib_zpttrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cpttrs( uplo, n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(sp), intent(in) :: d(*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(in) :: e(*)
               end subroutine cpttrs
#else
               module procedure stdlib_I64_cpttrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dpttrs( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: b(ldb,*)
                    real(dp), intent(in) :: d(*),e(*)
               end subroutine dpttrs
#else
               module procedure stdlib_I64_dpttrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine spttrs( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: b(ldb,*)
                    real(sp), intent(in) :: d(*),e(*)
               end subroutine spttrs
#else
               module procedure stdlib_I64_spttrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zpttrs( uplo, n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(dp), intent(in) :: d(*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(in) :: e(*)
               end subroutine zpttrs
#else
               module procedure stdlib_I64_zpttrs
#endif
          end interface pttrs

          interface rot
          !! ROT applies a plane rotation, where the cos (C) is real and the
          !! sin (S) is complex, and the vectors CX and CY are complex.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine crot( n, cx, incx, cy, incy, c, s )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,incy,n
                    real(sp), intent(in) :: c
                    complex(sp), intent(in) :: s
                    complex(sp), intent(inout) :: cx(*),cy(*)
               end subroutine crot
#else
               module procedure stdlib_crot
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zrot( n, cx, incx, cy, incy, c, s )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,incy,n
                    real(dp), intent(in) :: c
                    complex(dp), intent(in) :: s
                    complex(dp), intent(inout) :: cx(*),cy(*)
               end subroutine zrot
#else
               module procedure stdlib_zrot
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine crot( n, cx, incx, cy, incy, c, s )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,incy,n
                    real(sp), intent(in) :: c
                    complex(sp), intent(in) :: s
                    complex(sp), intent(inout) :: cx(*),cy(*)
               end subroutine crot
#else
               module procedure stdlib_I64_crot
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zrot( n, cx, incx, cy, incy, c, s )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,incy,n
                    real(dp), intent(in) :: c
                    complex(dp), intent(in) :: s
                    complex(dp), intent(inout) :: cx(*),cy(*)
               end subroutine zrot
#else
               module procedure stdlib_I64_zrot
#endif
          end interface rot

          interface rscl
          !! RSCL multiplies an n-element real vector x by the real scalar 1/a.
          !! This is done without overflow or underflow as long as
          !! the final result x/a does not overflow or underflow.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine drscl( n, sa, sx, incx )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,n
                    real(dp), intent(in) :: sa
                    real(dp), intent(inout) :: sx(*)
               end subroutine drscl
#else
               module procedure stdlib_drscl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine srscl( n, sa, sx, incx )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx,n
                    real(sp), intent(in) :: sa
                    real(sp), intent(inout) :: sx(*)
               end subroutine srscl
#else
               module procedure stdlib_srscl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine drscl( n, sa, sx, incx )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,n
                    real(dp), intent(in) :: sa
                    real(dp), intent(inout) :: sx(*)
               end subroutine drscl
#else
               module procedure stdlib_I64_drscl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine srscl( n, sa, sx, incx )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx,n
                    real(sp), intent(in) :: sa
                    real(sp), intent(inout) :: sx(*)
               end subroutine srscl
#else
               module procedure stdlib_I64_srscl
#endif
          end interface rscl

          interface sb2st_kernels
          !! SB2ST_KERNELS is an internal routine used by the DSYTRD_SB2ST
          !! subroutine.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine  dsb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, &
                         lda, v, tau, ldvt, work)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: wantz
                    integer(ilp), intent(in) :: ttype,st,ed,sweep,n,nb,ib,lda,ldvt
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: v(*),tau(*),work(*)
               end subroutine dsb2st_kernels
#else
               module procedure stdlib_dsb2st_kernels
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine  ssb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, &
                         lda, v, tau, ldvt, work)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: wantz
                    integer(ilp), intent(in) :: ttype,st,ed,sweep,n,nb,ib,lda,ldvt
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: v(*),tau(*),work(*)
               end subroutine ssb2st_kernels
#else
               module procedure stdlib_ssb2st_kernels
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine  dsb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, &
                         lda, v, tau, ldvt, work)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: wantz
                    integer(ilp64), intent(in) :: ttype,st,ed,sweep,n,nb,ib,lda,ldvt
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: v(*),tau(*),work(*)
               end subroutine dsb2st_kernels
#else
               module procedure stdlib_I64_dsb2st_kernels
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine  ssb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, &
                         lda, v, tau, ldvt, work)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: wantz
                    integer(ilp64), intent(in) :: ttype,st,ed,sweep,n,nb,ib,lda,ldvt
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: v(*),tau(*),work(*)
               end subroutine ssb2st_kernels
#else
               module procedure stdlib_I64_ssb2st_kernels
#endif
          end interface sb2st_kernels

          interface sbev
          !! SBEV computes all the eigenvalues and, optionally, eigenvectors of
          !! a real symmetric band matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldz,n
                    real(dp), intent(inout) :: ab(ldab,*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsbev
#else
               module procedure stdlib_dsbev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldz,n
                    real(sp), intent(inout) :: ab(ldab,*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssbev
#else
               module procedure stdlib_ssbev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dsbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldz,n
                    real(dp), intent(inout) :: ab(ldab,*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsbev
#else
               module procedure stdlib_I64_dsbev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ssbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldz,n
                    real(sp), intent(inout) :: ab(ldab,*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssbev
#else
               module procedure stdlib_I64_ssbev
#endif
          end interface sbev

          interface sbevd
          !! SBEVD computes all the eigenvalues and, optionally, eigenvectors of
          !! a real symmetric band matrix A. If eigenvectors are desired, it uses
          !! a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,ldz,liwork,lwork,n
                    real(dp), intent(inout) :: ab(ldab,*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsbevd
#else
               module procedure stdlib_dsbevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,ldz,liwork,lwork,n
                    real(sp), intent(inout) :: ab(ldab,*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssbevd
#else
               module procedure stdlib_ssbevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dsbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: kd,ldab,ldz,liwork,lwork,n
                    real(dp), intent(inout) :: ab(ldab,*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsbevd
#else
               module procedure stdlib_I64_dsbevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ssbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: kd,ldab,ldz,liwork,lwork,n
                    real(sp), intent(inout) :: ab(ldab,*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssbevd
#else
               module procedure stdlib_I64_ssbevd
#endif
          end interface sbevd

          interface sbgst
          !! SBGST reduces a real symmetric-definite banded generalized
          !! eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,
          !! such that C has the same bandwidth as A.
          !! B must have been previously factorized as S**T*S by DPBSTF, using a
          !! split Cholesky factorization. A is overwritten by C = X**T*A*X, where
          !! X = S**(-1)*Q and Q is an orthogonal matrix chosen to preserve the
          !! bandwidth of A.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldx,n
                    real(dp), intent(inout) :: ab(ldab,*)
                    real(dp), intent(in) :: bb(ldbb,*)
                    real(dp), intent(out) :: work(*),x(ldx,*)
               end subroutine dsbgst
#else
               module procedure stdlib_dsbgst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldx,n
                    real(sp), intent(inout) :: ab(ldab,*)
                    real(sp), intent(in) :: bb(ldbb,*)
                    real(sp), intent(out) :: work(*),x(ldx,*)
               end subroutine ssbgst
#else
               module procedure stdlib_ssbgst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ka,kb,ldab,ldbb,ldx,n
                    real(dp), intent(inout) :: ab(ldab,*)
                    real(dp), intent(in) :: bb(ldbb,*)
                    real(dp), intent(out) :: work(*),x(ldx,*)
               end subroutine dsbgst
#else
               module procedure stdlib_I64_dsbgst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ka,kb,ldab,ldbb,ldx,n
                    real(sp), intent(inout) :: ab(ldab,*)
                    real(sp), intent(in) :: bb(ldbb,*)
                    real(sp), intent(out) :: work(*),x(ldx,*)
               end subroutine ssbgst
#else
               module procedure stdlib_I64_ssbgst
#endif
          end interface sbgst

          interface sbgv
          !! SBGV computes all the eigenvalues, and optionally, the eigenvectors
          !! of a real generalized symmetric-definite banded eigenproblem, of
          !! the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
          !! and banded, and B is also positive definite.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldz,n
                    real(dp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsbgv
#else
               module procedure stdlib_dsbgv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldz,n
                    real(sp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssbgv
#else
               module procedure stdlib_ssbgv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ka,kb,ldab,ldbb,ldz,n
                    real(dp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsbgv
#else
               module procedure stdlib_I64_dsbgv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ka,kb,ldab,ldbb,ldz,n
                    real(sp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssbgv
#else
               module procedure stdlib_I64_ssbgv
#endif
          end interface sbgv

          interface sbgvd
          !! SBGVD computes all the eigenvalues, and optionally, the eigenvectors
          !! of a real generalized symmetric-definite banded eigenproblem, of the
          !! form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric and
          !! banded, and B is also positive definite.  If eigenvectors are
          !! desired, it uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
                         lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldz,liwork,lwork,n
                    real(dp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsbgvd
#else
               module procedure stdlib_dsbgvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
                         lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldz,liwork,lwork,n
                    real(sp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssbgvd
#else
               module procedure stdlib_ssbgvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
                         lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ka,kb,ldab,ldbb,ldz,liwork,lwork,n
                    real(dp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsbgvd
#else
               module procedure stdlib_I64_dsbgvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
                         lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ka,kb,ldab,ldbb,ldz,liwork,lwork,n
                    real(sp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssbgvd
#else
               module procedure stdlib_I64_ssbgvd
#endif
          end interface sbgvd

          interface sbtrd
          !! SBTRD reduces a real symmetric band matrix A to symmetric
          !! tridiagonal form T by an orthogonal similarity transformation:
          !! Q**T * A * Q = T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldq,n
                    real(dp), intent(inout) :: ab(ldab,*),q(ldq,*)
                    real(dp), intent(out) :: d(*),e(*),work(*)
               end subroutine dsbtrd
#else
               module procedure stdlib_dsbtrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldq,n
                    real(sp), intent(inout) :: ab(ldab,*),q(ldq,*)
                    real(sp), intent(out) :: d(*),e(*),work(*)
               end subroutine ssbtrd
#else
               module procedure stdlib_ssbtrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldq,n
                    real(dp), intent(inout) :: ab(ldab,*),q(ldq,*)
                    real(dp), intent(out) :: d(*),e(*),work(*)
               end subroutine dsbtrd
#else
               module procedure stdlib_I64_dsbtrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldq,n
                    real(sp), intent(inout) :: ab(ldab,*),q(ldq,*)
                    real(sp), intent(out) :: d(*),e(*),work(*)
               end subroutine ssbtrd
#else
               module procedure stdlib_I64_ssbtrd
#endif
          end interface sbtrd

          interface sfrk
          !! Level 3 BLAS like routine for C in RFP Format.
          !! SFRK performs one of the symmetric rank--k operations
          !! C := alpha*A*A**T + beta*C,
          !! or
          !! C := alpha*A**T*A + beta*C,
          !! where alpha and beta are real scalars, C is an n--by--n symmetric
          !! matrix and A is an n--by--k matrix in the first case and a k--by--n
          !! matrix in the second case.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,c )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta,a(lda,*)
                    integer(ilp), intent(in) :: k,lda,n
                    character, intent(in) :: trans,transr,uplo
                    real(dp), intent(inout) :: c(*)
               end subroutine dsfrk
#else
               module procedure stdlib_dsfrk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,c )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta,a(lda,*)
                    integer(ilp), intent(in) :: k,lda,n
                    character, intent(in) :: trans,transr,uplo
                    real(sp), intent(inout) :: c(*)
               end subroutine ssfrk
#else
               module procedure stdlib_ssfrk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,c )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(dp), intent(in) :: alpha,beta,a(lda,*)
                    integer(ilp64), intent(in) :: k,lda,n
                    character, intent(in) :: trans,transr,uplo
                    real(dp), intent(inout) :: c(*)
               end subroutine dsfrk
#else
               module procedure stdlib_I64_dsfrk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,c )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    real(sp), intent(in) :: alpha,beta,a(lda,*)
                    integer(ilp64), intent(in) :: k,lda,n
                    character, intent(in) :: trans,transr,uplo
                    real(sp), intent(inout) :: c(*)
               end subroutine ssfrk
#else
               module procedure stdlib_I64_ssfrk
#endif
          end interface sfrk

          interface spcon
          !! SPCON estimates the reciprocal of the condition number (in the
          !! 1-norm) of a complex symmetric packed matrix A using the
          !! factorization A = U*D*U**T or A = L*D*L**T computed by CSPTRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cspcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cspcon
#else
               module procedure stdlib_cspcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dspcon( uplo, n, ap, ipiv, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(dp), intent(in) :: anorm,ap(*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dspcon
#else
               module procedure stdlib_dspcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sspcon( uplo, n, ap, ipiv, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(sp), intent(in) :: anorm,ap(*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine sspcon
#else
               module procedure stdlib_sspcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zspcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zspcon
#else
               module procedure stdlib_zspcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cspcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cspcon
#else
               module procedure stdlib_I64_cspcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dspcon( uplo, n, ap, ipiv, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: n,ipiv(*)
                    real(dp), intent(in) :: anorm,ap(*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dspcon
#else
               module procedure stdlib_I64_dspcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sspcon( uplo, n, ap, ipiv, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: n,ipiv(*)
                    real(sp), intent(in) :: anorm,ap(*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine sspcon
#else
               module procedure stdlib_I64_sspcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zspcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zspcon
#else
               module procedure stdlib_I64_zspcon
#endif
          end interface spcon

          interface spev
          !! SPEV computes all the eigenvalues and, optionally, eigenvectors of a
          !! real symmetric matrix A in packed storage.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dspev( jobz, uplo, n, ap, w, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(dp), intent(inout) :: ap(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dspev
#else
               module procedure stdlib_dspev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sspev( jobz, uplo, n, ap, w, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(sp), intent(inout) :: ap(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sspev
#else
               module procedure stdlib_sspev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dspev( jobz, uplo, n, ap, w, z, ldz, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldz,n
                    real(dp), intent(inout) :: ap(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dspev
#else
               module procedure stdlib_I64_dspev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sspev( jobz, uplo, n, ap, w, z, ldz, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldz,n
                    real(sp), intent(inout) :: ap(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sspev
#else
               module procedure stdlib_I64_sspev
#endif
          end interface spev

          interface spevd
          !! SPEVD computes all the eigenvalues and, optionally, eigenvectors
          !! of a real symmetric matrix A in packed storage. If eigenvectors are
          !! desired, it uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dspevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,iwork, liwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lwork,n
                    real(dp), intent(inout) :: ap(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dspevd
#else
               module procedure stdlib_dspevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sspevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,iwork, liwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lwork,n
                    real(sp), intent(inout) :: ap(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sspevd
#else
               module procedure stdlib_sspevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dspevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,iwork, liwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldz,liwork,lwork,n
                    real(dp), intent(inout) :: ap(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dspevd
#else
               module procedure stdlib_I64_dspevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sspevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,iwork, liwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldz,liwork,lwork,n
                    real(sp), intent(inout) :: ap(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sspevd
#else
               module procedure stdlib_I64_sspevd
#endif
          end interface spevd

          interface spgst
          !! SPGST reduces a real symmetric-definite generalized eigenproblem
          !! to standard form, using packed storage.
          !! If ITYPE = 1, the problem is A*x = lambda*B*x,
          !! and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)
          !! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
          !! B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.
          !! B must have been previously factorized as U**T*U or L*L**T by DPPTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dspgst( itype, uplo, n, ap, bp, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,n
                    real(dp), intent(inout) :: ap(*)
                    real(dp), intent(in) :: bp(*)
               end subroutine dspgst
#else
               module procedure stdlib_dspgst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sspgst( itype, uplo, n, ap, bp, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,n
                    real(sp), intent(inout) :: ap(*)
                    real(sp), intent(in) :: bp(*)
               end subroutine sspgst
#else
               module procedure stdlib_sspgst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dspgst( itype, uplo, n, ap, bp, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: itype,n
                    real(dp), intent(inout) :: ap(*)
                    real(dp), intent(in) :: bp(*)
               end subroutine dspgst
#else
               module procedure stdlib_I64_dspgst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sspgst( itype, uplo, n, ap, bp, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: itype,n
                    real(sp), intent(inout) :: ap(*)
                    real(sp), intent(in) :: bp(*)
               end subroutine sspgst
#else
               module procedure stdlib_I64_sspgst
#endif
          end interface spgst

          interface spgv
          !! SPGV computes all the eigenvalues and, optionally, the eigenvectors
          !! of a real generalized symmetric-definite eigenproblem, of the form
          !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
          !! Here A and B are assumed to be symmetric, stored in packed format,
          !! and B is also positive definite.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dspgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,ldz,n
                    real(dp), intent(inout) :: ap(*),bp(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dspgv
#else
               module procedure stdlib_dspgv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sspgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,ldz,n
                    real(sp), intent(inout) :: ap(*),bp(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sspgv
#else
               module procedure stdlib_sspgv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dspgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: itype,ldz,n
                    real(dp), intent(inout) :: ap(*),bp(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dspgv
#else
               module procedure stdlib_I64_dspgv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sspgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: itype,ldz,n
                    real(sp), intent(inout) :: ap(*),bp(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sspgv
#else
               module procedure stdlib_I64_sspgv
#endif
          end interface spgv

          interface spgvd
          !! SPGVD computes all the eigenvalues, and optionally, the eigenvectors
          !! of a real generalized symmetric-definite eigenproblem, of the form
          !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
          !! B are assumed to be symmetric, stored in packed format, and B is also
          !! positive definite.
          !! If eigenvectors are desired, it uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dspgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: itype,ldz,liwork,lwork,n
                    real(dp), intent(inout) :: ap(*),bp(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dspgvd
#else
               module procedure stdlib_dspgvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sspgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: itype,ldz,liwork,lwork,n
                    real(sp), intent(inout) :: ap(*),bp(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sspgvd
#else
               module procedure stdlib_sspgvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dspgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: itype,ldz,liwork,lwork,n
                    real(dp), intent(inout) :: ap(*),bp(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dspgvd
#else
               module procedure stdlib_I64_dspgvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine sspgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: itype,ldz,liwork,lwork,n
                    real(sp), intent(inout) :: ap(*),bp(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sspgvd
#else
               module procedure stdlib_I64_sspgvd
#endif
          end interface spgvd

          interface spmv
          !! SPMV performs the matrix-vector operation
          !! y := alpha*A*x + beta*y,
          !! where alpha and beta are scalars, x and y are n element vectors and
          !! A is an n by n symmetric matrix, supplied in packed form.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cspmv( uplo, n, alpha, ap, x, incx, beta, y, incy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incx,incy,n
                    complex(sp), intent(in) :: alpha,beta,ap(*),x(*)
                    complex(sp), intent(inout) :: y(*)
               end subroutine cspmv
#else
               module procedure stdlib_cspmv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zspmv( uplo, n, alpha, ap, x, incx, beta, y, incy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incx,incy,n
                    complex(dp), intent(in) :: alpha,beta,ap(*),x(*)
                    complex(dp), intent(inout) :: y(*)
               end subroutine zspmv
#else
               module procedure stdlib_zspmv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cspmv( uplo, n, alpha, ap, x, incx, beta, y, incy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: incx,incy,n
                    complex(sp), intent(in) :: alpha,beta,ap(*),x(*)
                    complex(sp), intent(inout) :: y(*)
               end subroutine cspmv
#else
               module procedure stdlib_I64_cspmv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zspmv( uplo, n, alpha, ap, x, incx, beta, y, incy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: incx,incy,n
                    complex(dp), intent(in) :: alpha,beta,ap(*),x(*)
                    complex(dp), intent(inout) :: y(*)
               end subroutine zspmv
#else
               module procedure stdlib_I64_zspmv
#endif
          end interface spmv

          interface spr
          !! SPR performs the symmetric rank 1 operation
          !! A := alpha*x*x**H + A,
          !! where alpha is a complex scalar, x is an n element vector and A is an
          !! n by n symmetric matrix, supplied in packed form.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cspr( uplo, n, alpha, x, incx, ap )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incx,n
                    complex(sp), intent(in) :: alpha,x(*)
                    complex(sp), intent(inout) :: ap(*)
               end subroutine cspr
#else
               module procedure stdlib_cspr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zspr( uplo, n, alpha, x, incx, ap )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incx,n
                    complex(dp), intent(in) :: alpha,x(*)
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zspr
#else
               module procedure stdlib_zspr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cspr( uplo, n, alpha, x, incx, ap )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: incx,n
                    complex(sp), intent(in) :: alpha,x(*)
                    complex(sp), intent(inout) :: ap(*)
               end subroutine cspr
#else
               module procedure stdlib_I64_cspr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zspr( uplo, n, alpha, x, incx, ap )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: incx,n
                    complex(dp), intent(in) :: alpha,x(*)
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zspr
#else
               module procedure stdlib_I64_zspr
#endif
          end interface spr

          interface sprfs
          !! SPRFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is symmetric indefinite
          !! and packed, and provides error bounds and backward error estimates
          !! for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine csprfs
#else
               module procedure stdlib_csprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dsprfs
#else
               module procedure stdlib_dsprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine ssprfs
#else
               module procedure stdlib_ssprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zsprfs
#else
               module procedure stdlib_zsprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine csprfs
#else
               module procedure stdlib_I64_csprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dsprfs
#else
               module procedure stdlib_I64_dsprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine ssprfs
#else
               module procedure stdlib_I64_ssprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zsprfs
#else
               module procedure stdlib_I64_zsprfs
#endif
          end interface sprfs

          interface spsv
          !! SPSV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N symmetric matrix stored in packed format and X
          !! and B are N-by-NRHS matrices.
          !! The diagonal pivoting method is used to factor A as
          !! A = U * D * U**T,  if UPLO = 'U', or
          !! A = L * D * L**T,  if UPLO = 'L',
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, D is symmetric and block diagonal with 1-by-1
          !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
          !! solve the system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine cspsv
#else
               module procedure stdlib_cspsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine dspsv
#else
               module procedure stdlib_dspsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine sspsv
#else
               module procedure stdlib_sspsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine zspsv
#else
               module procedure stdlib_zspsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine cspsv
#else
               module procedure stdlib_I64_cspsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine dspsv
#else
               module procedure stdlib_I64_dspsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine sspsv
#else
               module procedure stdlib_I64_sspsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine zspsv
#else
               module procedure stdlib_I64_zspsv
#endif
          end interface spsv

          interface sptrd
          !! SPTRD reduces a real symmetric matrix A stored in packed form to
          !! symmetric tridiagonal form T by an orthogonal similarity
          !! transformation: Q**T * A * Q = T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsptrd( uplo, n, ap, d, e, tau, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: ap(*)
                    real(dp), intent(out) :: d(*),e(*),tau(*)
               end subroutine dsptrd
#else
               module procedure stdlib_dsptrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssptrd( uplo, n, ap, d, e, tau, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: ap(*)
                    real(sp), intent(out) :: d(*),e(*),tau(*)
               end subroutine ssptrd
#else
               module procedure stdlib_ssptrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsptrd( uplo, n, ap, d, e, tau, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(inout) :: ap(*)
                    real(dp), intent(out) :: d(*),e(*),tau(*)
               end subroutine dsptrd
#else
               module procedure stdlib_I64_dsptrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssptrd( uplo, n, ap, d, e, tau, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(inout) :: ap(*)
                    real(sp), intent(out) :: d(*),e(*),tau(*)
               end subroutine ssptrd
#else
               module procedure stdlib_I64_ssptrd
#endif
          end interface sptrd

          interface sptrf
          !! SPTRF computes the factorization of a complex symmetric matrix A
          !! stored in packed format using the Bunch-Kaufman diagonal pivoting
          !! method:
          !! A = U*D*U**T  or  A = L*D*L**T
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is symmetric and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: ap(*)
               end subroutine csptrf
#else
               module procedure stdlib_csptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: ap(*)
               end subroutine dsptrf
#else
               module procedure stdlib_dsptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: ap(*)
               end subroutine ssptrf
#else
               module procedure stdlib_ssptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zsptrf
#else
               module procedure stdlib_zsptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: n
                    complex(sp), intent(inout) :: ap(*)
               end subroutine csptrf
#else
               module procedure stdlib_I64_csptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(inout) :: ap(*)
               end subroutine dsptrf
#else
               module procedure stdlib_I64_dsptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(inout) :: ap(*)
               end subroutine ssptrf
#else
               module procedure stdlib_I64_ssptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: n
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zsptrf
#else
               module procedure stdlib_I64_zsptrf
#endif
          end interface sptrf

          interface sptri
          !! SPTRI computes the inverse of a complex symmetric indefinite matrix
          !! A in packed storage using the factorization A = U*D*U**T or
          !! A = L*D*L**T computed by CSPTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csptri
#else
               module procedure stdlib_csptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(dp), intent(inout) :: ap(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsptri
#else
               module procedure stdlib_dsptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(sp), intent(inout) :: ap(*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssptri
#else
               module procedure stdlib_ssptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsptri
#else
               module procedure stdlib_zsptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,ipiv(*)
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csptri
#else
               module procedure stdlib_I64_csptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,ipiv(*)
                    real(dp), intent(inout) :: ap(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsptri
#else
               module procedure stdlib_I64_dsptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,ipiv(*)
                    real(sp), intent(inout) :: ap(*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssptri
#else
               module procedure stdlib_I64_ssptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,ipiv(*)
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsptri
#else
               module procedure stdlib_I64_zsptri
#endif
          end interface sptri

          interface sptrs
          !! SPTRS solves a system of linear equations A*X = B with a complex
          !! symmetric matrix A stored in packed format using the factorization
          !! A = U*D*U**T or A = L*D*L**T computed by CSPTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine csptrs
#else
               module procedure stdlib_csptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dsptrs
#else
               module procedure stdlib_dsptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine ssptrs
#else
               module procedure stdlib_ssptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zsptrs
#else
               module procedure stdlib_zsptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine csptrs
#else
               module procedure stdlib_I64_csptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dsptrs
#else
               module procedure stdlib_I64_dsptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine ssptrs
#else
               module procedure stdlib_I64_ssptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zsptrs
#else
               module procedure stdlib_I64_zsptrs
#endif
          end interface sptrs

          interface stebz
          !! STEBZ computes the eigenvalues of a symmetric tridiagonal
          !! matrix T.  The user may ask for all eigenvalues, all eigenvalues
          !! in the half-open interval (VL, VU], or the IL-th through IU-th
          !! eigenvalues.
          !! To avoid overflow, the matrix must be scaled so that its
          !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
          !! accuracy, it should not be much smaller than that.
          !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
          !! Matrix", Report CS41, Computer Science Dept., Stanford
          !! University, July 21, 1966.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dstebz( range, order, n, vl, vu, il, iu, abstol, d, e,m, nsplit, w,&
                          iblock, isplit, work, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: order,range
                    integer(ilp), intent(in) :: il,iu,n
                    integer(ilp), intent(out) :: info,m,nsplit,iblock(*),isplit(*),iwork(*)

                    real(dp), intent(in) :: abstol,vl,vu,d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*)
               end subroutine dstebz
#else
               module procedure stdlib_dstebz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sstebz( range, order, n, vl, vu, il, iu, abstol, d, e,m, nsplit, w,&
                          iblock, isplit, work, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: order,range
                    integer(ilp), intent(in) :: il,iu,n
                    integer(ilp), intent(out) :: info,m,nsplit,iblock(*),isplit(*),iwork(*)

                    real(sp), intent(in) :: abstol,vl,vu,d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*)
               end subroutine sstebz
#else
               module procedure stdlib_sstebz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dstebz( range, order, n, vl, vu, il, iu, abstol, d, e,m, nsplit, w,&
                          iblock, isplit, work, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: order,range
                    integer(ilp64), intent(in) :: il,iu,n
                    integer(ilp64), intent(out) :: info,m,nsplit,iblock(*),isplit(*),iwork(*)

                    real(dp), intent(in) :: abstol,vl,vu,d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*)
               end subroutine dstebz
#else
               module procedure stdlib_I64_dstebz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sstebz( range, order, n, vl, vu, il, iu, abstol, d, e,m, nsplit, w,&
                          iblock, isplit, work, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: order,range
                    integer(ilp64), intent(in) :: il,iu,n
                    integer(ilp64), intent(out) :: info,m,nsplit,iblock(*),isplit(*),iwork(*)

                    real(sp), intent(in) :: abstol,vl,vu,d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*)
               end subroutine sstebz
#else
               module procedure stdlib_I64_sstebz
#endif
          end interface stebz

          interface stedc
          !! STEDC computes all eigenvalues and, optionally, eigenvectors of a
          !! symmetric tridiagonal matrix using the divide and conquer method.
          !! The eigenvectors of a full or band complex Hermitian matrix can also
          !! be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
          !! matrix to tridiagonal form.
          !! This code makes very mild assumptions about floating point
          !! arithmetic. It will work on machines with a guard digit in
          !! add/subtract, or on those binary machines without guard digits
          !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
          !! It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.  See SLAED3 for details.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cstedc( compz, n, d, e, z, ldz, work, lwork, rwork,lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lrwork,lwork,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: z(ldz,*)
               end subroutine cstedc
#else
               module procedure stdlib_cstedc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dstedc( compz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lwork,n
                    real(dp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dstedc
#else
               module procedure stdlib_dstedc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sstedc( compz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lwork,n
                    real(sp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sstedc
#else
               module procedure stdlib_sstedc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zstedc( compz, n, d, e, z, ldz, work, lwork, rwork,lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lrwork,lwork,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: z(ldz,*)
               end subroutine zstedc
#else
               module procedure stdlib_zstedc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cstedc( compz, n, d, e, z, ldz, work, lwork, rwork,lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldz,liwork,lrwork,lwork,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: z(ldz,*)
               end subroutine cstedc
#else
               module procedure stdlib_I64_cstedc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dstedc( compz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldz,liwork,lwork,n
                    real(dp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dstedc
#else
               module procedure stdlib_I64_dstedc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sstedc( compz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldz,liwork,lwork,n
                    real(sp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sstedc
#else
               module procedure stdlib_I64_sstedc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zstedc( compz, n, d, e, z, ldz, work, lwork, rwork,lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldz,liwork,lrwork,lwork,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: z(ldz,*)
               end subroutine zstedc
#else
               module procedure stdlib_I64_zstedc
#endif
          end interface stedc

          interface stegr
          !! STEGR computes selected eigenvalues and, optionally, eigenvectors
          !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
          !! a well defined set of pairwise different real eigenvalues, the corresponding
          !! real eigenvectors are pairwise orthogonal.
          !! The spectrum may be computed either completely or partially by specifying
          !! either an interval (VL,VU] or a range of indices IL:IU for the desired
          !! eigenvalues.
          !! STEGR is a compatibility wrapper around the improved CSTEMR routine.
          !! See SSTEMR for further details.
          !! One important change is that the ABSTOL parameter no longer provides any
          !! benefit and hence is no longer used.
          !! Note : STEGR and CSTEMR work only on machines which follow
          !! IEEE-754 floating-point standard in their handling of infinities and
          !! NaNs.  Normal execution may create these exceptiona values and hence
          !! may abort due to a floating point exception in environments which
          !! do not conform to the IEEE-754 standard.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    integer(ilp), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: abstol,vl,vu
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*)
                    complex(sp), intent(out) :: z(ldz,*)
               end subroutine cstegr
#else
               module procedure stdlib_cstegr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    integer(ilp), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: abstol,vl,vu
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dstegr
#else
               module procedure stdlib_dstegr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    integer(ilp), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: abstol,vl,vu
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sstegr
#else
               module procedure stdlib_sstegr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    integer(ilp), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: abstol,vl,vu
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*)
                    complex(dp), intent(out) :: z(ldz,*)
               end subroutine zstegr
#else
               module procedure stdlib_zstegr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    integer(ilp64), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: abstol,vl,vu
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*)
                    complex(sp), intent(out) :: z(ldz,*)
               end subroutine cstegr
#else
               module procedure stdlib_I64_cstegr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    integer(ilp64), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: abstol,vl,vu
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dstegr
#else
               module procedure stdlib_I64_dstegr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    integer(ilp64), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: abstol,vl,vu
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sstegr
#else
               module procedure stdlib_I64_sstegr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    integer(ilp64), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: abstol,vl,vu
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*)
                    complex(dp), intent(out) :: z(ldz,*)
               end subroutine zstegr
#else
               module procedure stdlib_I64_zstegr
#endif
          end interface stegr

          interface stein
          !! STEIN computes the eigenvectors of a real symmetric tridiagonal
          !! matrix T corresponding to specified eigenvalues, using inverse
          !! iteration.
          !! The maximum number of iterations allowed for each eigenvector is
          !! specified by an internal parameter MAXITS (currently set to 5).
          !! Although the eigenvectors are real, they are stored in a complex
          !! array, which may be passed to CUNMTR or CUPMTR for back
          !! transformation to the eigenvectors of a complex Hermitian matrix
          !! which was reduced to tridiagonal form.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ifail(*),iwork(*)
                    integer(ilp), intent(in) :: ldz,m,n,iblock(*),isplit(*)
                    real(sp), intent(in) :: d(*),e(*),w(*)
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(out) :: z(ldz,*)
               end subroutine cstein
#else
               module procedure stdlib_cstein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ifail(*),iwork(*)
                    integer(ilp), intent(in) :: ldz,m,n,iblock(*),isplit(*)
                    real(dp), intent(in) :: d(*),e(*),w(*)
                    real(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine dstein
#else
               module procedure stdlib_dstein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ifail(*),iwork(*)
                    integer(ilp), intent(in) :: ldz,m,n,iblock(*),isplit(*)
                    real(sp), intent(in) :: d(*),e(*),w(*)
                    real(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine sstein
#else
               module procedure stdlib_sstein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info,ifail(*),iwork(*)
                    integer(ilp), intent(in) :: ldz,m,n,iblock(*),isplit(*)
                    real(dp), intent(in) :: d(*),e(*),w(*)
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(out) :: z(ldz,*)
               end subroutine zstein
#else
               module procedure stdlib_zstein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ifail(*),iwork(*)
                    integer(ilp64), intent(in) :: ldz,m,n,iblock(*),isplit(*)
                    real(sp), intent(in) :: d(*),e(*),w(*)
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(out) :: z(ldz,*)
               end subroutine cstein
#else
               module procedure stdlib_I64_cstein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ifail(*),iwork(*)
                    integer(ilp64), intent(in) :: ldz,m,n,iblock(*),isplit(*)
                    real(dp), intent(in) :: d(*),e(*),w(*)
                    real(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine dstein
#else
               module procedure stdlib_I64_dstein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ifail(*),iwork(*)
                    integer(ilp64), intent(in) :: ldz,m,n,iblock(*),isplit(*)
                    real(sp), intent(in) :: d(*),e(*),w(*)
                    real(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine sstein
#else
               module procedure stdlib_I64_sstein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info,ifail(*),iwork(*)
                    integer(ilp64), intent(in) :: ldz,m,n,iblock(*),isplit(*)
                    real(dp), intent(in) :: d(*),e(*),w(*)
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(out) :: z(ldz,*)
               end subroutine zstein
#else
               module procedure stdlib_I64_zstein
#endif
          end interface stein

          interface stemr
          !! STEMR computes selected eigenvalues and, optionally, eigenvectors
          !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
          !! a well defined set of pairwise different real eigenvalues, the corresponding
          !! real eigenvectors are pairwise orthogonal.
          !! The spectrum may be computed either completely or partially by specifying
          !! either an interval (VL,VU] or a range of indices IL:IU for the desired
          !! eigenvalues.
          !! Depending on the number of desired eigenvalues, these are computed either
          !! by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
          !! computed by the use of various suitable L D L^T factorizations near clusters
          !! of close eigenvalues (referred to as RRRs, Relatively Robust
          !! Representations). An informal sketch of the algorithm follows.
          !! For each unreduced block (submatrix) of T,
          !! (a) Compute T - sigma I  = L D L^T, so that L and D
          !! define all the wanted eigenvalues to high relative accuracy.
          !! This means that small relative changes in the entries of D and L
          !! cause only small relative changes in the eigenvalues and
          !! eigenvectors. The standard (unfactored) representation of the
          !! tridiagonal matrix T does not have this property in general.
          !! (b) Compute the eigenvalues to suitable accuracy.
          !! If the eigenvectors are desired, the algorithm attains full
          !! accuracy of the computed eigenvalues only right before
          !! the corresponding vectors have to be computed, see steps c) and d).
          !! (c) For each cluster of close eigenvalues, select a new
          !! shift close to the cluster, find a new factorization, and refine
          !! the shifted eigenvalues to suitable accuracy.
          !! (d) For each eigenvalue with a large enough relative separation compute
          !! the corresponding eigenvector by forming a rank revealing twisted
          !! factorization. Go back to (c) for any clusters that remain.
          !! For more details, see:
          !! - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
          !! to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
          !! Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
          !! - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
          !! Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
          !! 2004.  Also LAPACK Working Note 154.
          !! - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
          !! tridiagonal eigenvalue/eigenvector problem",
          !! Computer Science Division Technical Report No. UCB/CSD-97-971,
          !! UC Berkeley, May 1997.
          !! Further Details
          !! 1.STEMR works only on machines which follow IEEE-754
          !! floating-point standard in their handling of infinities and NaNs.
          !! This permits the use of efficient inner loops avoiding a check for
          !! zero divisors.
          !! 2. LAPACK routines can be used to reduce a complex Hermitean matrix to
          !! real symmetric tridiagonal form.
          !! (Any complex Hermitean tridiagonal matrix has real values on its diagonal
          !! and potentially complex numbers on its off-diagonals. By applying a
          !! similarity transform with an appropriate diagonal matrix
          !! diag(1,e^{i \phy_1}, ... , e^{i \phy_{n-1}}), the complex Hermitean
          !! matrix can be transformed into a real symmetric matrix and complex
          !! arithmetic can be entirely avoided.)
          !! While the eigenvectors of the real symmetric tridiagonal matrix are real,
          !! the eigenvectors of original complex Hermitean matrix have complex entries
          !! in general.
          !! Since LAPACK drivers overwrite the matrix data with the eigenvectors,
          !! STEMR accepts complex workspace to facilitate interoperability
          !! with CUNMTR or CUPMTR.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
                         isuppz, tryrac, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    logical(lk), intent(inout) :: tryrac
                    integer(ilp), intent(in) :: il,iu,ldz,nzc,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: vl,vu
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*)
                    complex(sp), intent(out) :: z(ldz,*)
               end subroutine cstemr
#else
               module procedure stdlib_cstemr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
                         isuppz, tryrac, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    logical(lk), intent(inout) :: tryrac
                    integer(ilp), intent(in) :: il,iu,ldz,nzc,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: vl,vu
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dstemr
#else
               module procedure stdlib_dstemr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
                         isuppz, tryrac, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    logical(lk), intent(inout) :: tryrac
                    integer(ilp), intent(in) :: il,iu,ldz,nzc,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: vl,vu
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sstemr
#else
               module procedure stdlib_sstemr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
                         isuppz, tryrac, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    logical(lk), intent(inout) :: tryrac
                    integer(ilp), intent(in) :: il,iu,ldz,nzc,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: vl,vu
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*)
                    complex(dp), intent(out) :: z(ldz,*)
               end subroutine zstemr
#else
               module procedure stdlib_zstemr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
                         isuppz, tryrac, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    logical(lk), intent(inout) :: tryrac
                    integer(ilp64), intent(in) :: il,iu,ldz,nzc,liwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: vl,vu
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*)
                    complex(sp), intent(out) :: z(ldz,*)
               end subroutine cstemr
#else
               module procedure stdlib_I64_cstemr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
                         isuppz, tryrac, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    logical(lk), intent(inout) :: tryrac
                    integer(ilp64), intent(in) :: il,iu,ldz,nzc,liwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: vl,vu
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dstemr
#else
               module procedure stdlib_I64_dstemr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
                         isuppz, tryrac, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    logical(lk), intent(inout) :: tryrac
                    integer(ilp64), intent(in) :: il,iu,ldz,nzc,liwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: vl,vu
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sstemr
#else
               module procedure stdlib_I64_sstemr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
                         isuppz, tryrac, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    logical(lk), intent(inout) :: tryrac
                    integer(ilp64), intent(in) :: il,iu,ldz,nzc,liwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: vl,vu
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*)
                    complex(dp), intent(out) :: z(ldz,*)
               end subroutine zstemr
#else
               module procedure stdlib_I64_zstemr
#endif
          end interface stemr

          interface steqr
          !! STEQR computes all eigenvalues and, optionally, eigenvectors of a
          !! symmetric tridiagonal matrix using the implicit QL or QR method.
          !! The eigenvectors of a full or band complex Hermitian matrix can also
          !! be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
          !! matrix to tridiagonal form.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: z(ldz,*)
               end subroutine csteqr
#else
               module procedure stdlib_csteqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(dp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsteqr
#else
               module procedure stdlib_dsteqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(sp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssteqr
#else
               module procedure stdlib_ssteqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: z(ldz,*)
               end subroutine zsteqr
#else
               module procedure stdlib_zsteqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldz,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: z(ldz,*)
               end subroutine csteqr
#else
               module procedure stdlib_I64_csteqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldz,n
                    real(dp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsteqr
#else
               module procedure stdlib_I64_dsteqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldz,n
                    real(sp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssteqr
#else
               module procedure stdlib_I64_ssteqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compz
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldz,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: z(ldz,*)
               end subroutine zsteqr
#else
               module procedure stdlib_I64_zsteqr
#endif
          end interface steqr

          interface sterf
          !! STERF computes all eigenvalues of a symmetric tridiagonal matrix
          !! using the Pal-Walker-Kahan variant of the QL or QR algorithm.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsterf( n, d, e, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: d(*),e(*)
               end subroutine dsterf
#else
               module procedure stdlib_dsterf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssterf( n, d, e, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: d(*),e(*)
               end subroutine ssterf
#else
               module procedure stdlib_ssterf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsterf( n, d, e, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(inout) :: d(*),e(*)
               end subroutine dsterf
#else
               module procedure stdlib_I64_dsterf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssterf( n, d, e, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(inout) :: d(*),e(*)
               end subroutine ssterf
#else
               module procedure stdlib_I64_ssterf
#endif
          end interface sterf

          interface stev
          !! STEV computes all eigenvalues and, optionally, eigenvectors of a
          !! real symmetric tridiagonal matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dstev( jobz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine dstev
#else
               module procedure stdlib_dstev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sstev( jobz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine sstev
#else
               module procedure stdlib_sstev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dstev( jobz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldz,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine dstev
#else
               module procedure stdlib_I64_dstev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sstev( jobz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldz,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine sstev
#else
               module procedure stdlib_I64_sstev
#endif
          end interface stev

          interface stevd
          !! STEVD computes all eigenvalues and, optionally, eigenvectors of a
          !! real symmetric tridiagonal matrix. If eigenvectors are desired, it
          !! uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dstevd( jobz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lwork,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine dstevd
#else
               module procedure stdlib_dstevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sstevd( jobz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lwork,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine sstevd
#else
               module procedure stdlib_sstevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dstevd( jobz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldz,liwork,lwork,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine dstevd
#else
               module procedure stdlib_I64_dstevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sstevd( jobz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldz,liwork,lwork,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine sstevd
#else
               module procedure stdlib_I64_sstevd
#endif
          end interface stevd

          interface stevr
          !! STEVR computes selected eigenvalues and, optionally, eigenvectors
          !! of a real symmetric tridiagonal matrix T.  Eigenvalues and
          !! eigenvectors can be selected by specifying either a range of values
          !! or a range of indices for the desired eigenvalues.
          !! Whenever possible, STEVR calls DSTEMR to compute the
          !! eigenspectrum using Relatively Robust Representations.  DSTEMR
          !! computes eigenvalues by the dqds algorithm, while orthogonal
          !! eigenvectors are computed from various "good" L D L^T representations
          !! (also known as Relatively Robust Representations). Gram-Schmidt
          !! orthogonalization is avoided as far as possible. More specifically,
          !! the various steps of the algorithm are as follows. For the i-th
          !! unreduced block of T,
          !! (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
          !! is a relatively robust representation,
          !! (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
          !! relative accuracy by the dqds algorithm,
          !! (c) If there is a cluster of close eigenvalues, "choose" sigma_i
          !! close to the cluster, and go to step (a),
          !! (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
          !! compute the corresponding eigenvector by forming a
          !! rank-revealing twisted factorization.
          !! The desired accuracy of the output can be specified by the input
          !! parameter ABSTOL.
          !! For more details, see "A new O(n^2) algorithm for the symmetric
          !! tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
          !! Computer Science Division Technical Report No. UCB//CSD-97-971,
          !! UC Berkeley, May 1997.
          !! Note 1 : STEVR calls DSTEMR when the full spectrum is requested
          !! on machines which conform to the ieee-754 floating point standard.
          !! STEVR calls DSTEBZ and DSTEIN on non-ieee machines and
          !! when partial spectrum requests are made.
          !! Normal execution of DSTEMR may create NaNs and infinities and
          !! hence may abort due to a floating point exception in environments
          !! which do not handle NaNs and infinities in the ieee standard default
          !! manner.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dstevr( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    integer(ilp), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: abstol,vl,vu
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dstevr
#else
               module procedure stdlib_dstevr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sstevr( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    integer(ilp), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: abstol,vl,vu
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sstevr
#else
               module procedure stdlib_sstevr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dstevr( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    integer(ilp64), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: abstol,vl,vu
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dstevr
#else
               module procedure stdlib_I64_dstevr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine sstevr( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,range
                    integer(ilp64), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: abstol,vl,vu
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sstevr
#else
               module procedure stdlib_I64_sstevr
#endif
          end interface stevr

          interface sycon
          !! SYCON estimates the reciprocal of the condition number (in the
          !! 1-norm) of a complex symmetric matrix A using the factorization
          !! A = U*D*U**T or A = L*D*L**T computed by CSYTRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csycon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csycon
#else
               module procedure stdlib_csycon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsycon( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm,a(lda,*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dsycon
#else
               module procedure stdlib_dsycon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssycon( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm,a(lda,*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine ssycon
#else
               module procedure stdlib_ssycon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsycon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsycon
#else
               module procedure stdlib_zsycon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csycon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csycon
#else
               module procedure stdlib_I64_csycon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsycon( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm,a(lda,*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dsycon
#else
               module procedure stdlib_I64_dsycon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssycon( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm,a(lda,*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine ssycon
#else
               module procedure stdlib_I64_ssycon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsycon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsycon
#else
               module procedure stdlib_I64_zsycon
#endif
          end interface sycon

          interface sycon_rook
          !! SYCON_ROOK estimates the reciprocal of the condition number (in the
          !! 1-norm) of a complex symmetric matrix A using the factorization
          !! A = U*D*U**T or A = L*D*L**T computed by CSYTRF_ROOK.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csycon_rook
#else
               module procedure stdlib_csycon_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm,a(lda,*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dsycon_rook
#else
               module procedure stdlib_dsycon_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm,a(lda,*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine ssycon_rook
#else
               module procedure stdlib_ssycon_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsycon_rook
#else
               module procedure stdlib_zsycon_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csycon_rook
#else
               module procedure stdlib_I64_csycon_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm,a(lda,*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dsycon_rook
#else
               module procedure stdlib_I64_dsycon_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm,a(lda,*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine ssycon_rook
#else
               module procedure stdlib_I64_ssycon_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsycon_rook
#else
               module procedure stdlib_I64_zsycon_rook
#endif
          end interface sycon_rook

          interface syconv
          !! SYCONV convert A given by TRF into L and D and vice-versa.
          !! Get Non-diag elements of D (returned in workspace) and
          !! apply or reverse permutation done in TRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csyconv( uplo, way, n, a, lda, ipiv, e, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*)
               end subroutine csyconv
#else
               module procedure stdlib_csyconv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsyconv( uplo, way, n, a, lda, ipiv, e, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: e(*)
               end subroutine dsyconv
#else
               module procedure stdlib_dsyconv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssyconv( uplo, way, n, a, lda, ipiv, e, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: e(*)
               end subroutine ssyconv
#else
               module procedure stdlib_ssyconv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsyconv( uplo, way, n, a, lda, ipiv, e, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*)
               end subroutine zsyconv
#else
               module procedure stdlib_zsyconv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csyconv( uplo, way, n, a, lda, ipiv, e, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*)
               end subroutine csyconv
#else
               module procedure stdlib_I64_csyconv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsyconv( uplo, way, n, a, lda, ipiv, e, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: e(*)
               end subroutine dsyconv
#else
               module procedure stdlib_I64_dsyconv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssyconv( uplo, way, n, a, lda, ipiv, e, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: e(*)
               end subroutine ssyconv
#else
               module procedure stdlib_I64_ssyconv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsyconv( uplo, way, n, a, lda, ipiv, e, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*)
               end subroutine zsyconv
#else
               module procedure stdlib_I64_zsyconv
#endif
          end interface syconv

          interface syconvf
          !! If parameter WAY = 'C':
          !! SYCONVF converts the factorization output format used in
          !! CSYTRF provided on entry in parameter A into the factorization
          !! output format used in CSYTRF_RK (or CSYTRF_BK) that is stored
          !! on exit in parameters A and E. It also converts in place details of
          !! the intechanges stored in IPIV from the format used in CSYTRF into
          !! the format used in CSYTRF_RK (or CSYTRF_BK).
          !! If parameter WAY = 'R':
          !! SYCONVF performs the conversion in reverse direction, i.e.
          !! converts the factorization output format used in CSYTRF_RK
          !! (or CSYTRF_BK) provided on entry in parameters A and E into
          !! the factorization output format used in CSYTRF that is stored
          !! on exit in parameter A. It also converts in place details of
          !! the intechanges stored in IPIV from the format used in CSYTRF_RK
          !! (or CSYTRF_BK) into the format used in CSYTRF.
          !! SYCONVF can also convert in Hermitian matrix case, i.e. between
          !! formats used in CHETRF and CHETRF_RK (or CHETRF_BK).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csyconvf( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    integer(ilp), intent(inout) :: ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),e(*)
               end subroutine csyconvf
#else
               module procedure stdlib_csyconvf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsyconvf( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    integer(ilp), intent(inout) :: ipiv(*)
                    real(dp), intent(inout) :: a(lda,*),e(*)
               end subroutine dsyconvf
#else
               module procedure stdlib_dsyconvf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssyconvf( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    integer(ilp), intent(inout) :: ipiv(*)
                    real(sp), intent(inout) :: a(lda,*),e(*)
               end subroutine ssyconvf
#else
               module procedure stdlib_ssyconvf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsyconvf( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    integer(ilp), intent(inout) :: ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),e(*)
               end subroutine zsyconvf
#else
               module procedure stdlib_zsyconvf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csyconvf( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    integer(ilp64), intent(inout) :: ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),e(*)
               end subroutine csyconvf
#else
               module procedure stdlib_I64_csyconvf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsyconvf( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    integer(ilp64), intent(inout) :: ipiv(*)
                    real(dp), intent(inout) :: a(lda,*),e(*)
               end subroutine dsyconvf
#else
               module procedure stdlib_I64_dsyconvf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssyconvf( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    integer(ilp64), intent(inout) :: ipiv(*)
                    real(sp), intent(inout) :: a(lda,*),e(*)
               end subroutine ssyconvf
#else
               module procedure stdlib_I64_ssyconvf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsyconvf( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    integer(ilp64), intent(inout) :: ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),e(*)
               end subroutine zsyconvf
#else
               module procedure stdlib_I64_zsyconvf
#endif
          end interface syconvf

          interface syconvf_rook
          !! If parameter WAY = 'C':
          !! SYCONVF_ROOK converts the factorization output format used in
          !! CSYTRF_ROOK provided on entry in parameter A into the factorization
          !! output format used in CSYTRF_RK (or CSYTRF_BK) that is stored
          !! on exit in parameters A and E. IPIV format for CSYTRF_ROOK and
          !! CSYTRF_RK (or CSYTRF_BK) is the same and is not converted.
          !! If parameter WAY = 'R':
          !! SYCONVF_ROOK performs the conversion in reverse direction, i.e.
          !! converts the factorization output format used in CSYTRF_RK
          !! (or CSYTRF_BK) provided on entry in parameters A and E into
          !! the factorization output format used in CSYTRF_ROOK that is stored
          !! on exit in parameter A. IPIV format for CSYTRF_ROOK and
          !! CSYTRF_RK (or CSYTRF_BK) is the same and is not converted.
          !! SYCONVF_ROOK can also convert in Hermitian matrix case, i.e. between
          !! formats used in CHETRF_ROOK and CHETRF_RK (or CHETRF_BK).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),e(*)
               end subroutine csyconvf_rook
#else
               module procedure stdlib_csyconvf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*),e(*)
               end subroutine dsyconvf_rook
#else
               module procedure stdlib_dsyconvf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*),e(*)
               end subroutine ssyconvf_rook
#else
               module procedure stdlib_ssyconvf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),e(*)
               end subroutine zsyconvf_rook
#else
               module procedure stdlib_zsyconvf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),e(*)
               end subroutine csyconvf_rook
#else
               module procedure stdlib_I64_csyconvf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*),e(*)
               end subroutine dsyconvf_rook
#else
               module procedure stdlib_I64_dsyconvf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*),e(*)
               end subroutine ssyconvf_rook
#else
               module procedure stdlib_I64_ssyconvf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo,way
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),e(*)
               end subroutine zsyconvf_rook
#else
               module procedure stdlib_I64_zsyconvf_rook
#endif
          end interface syconvf_rook

          interface syequb
          !! SYEQUB computes row and column scalings intended to equilibrate a
          !! symmetric matrix A (with respect to the Euclidean norm) and reduce
          !! its condition number. The scale factors S are computed by the BIN
          !! algorithm (see references) so that the scaled matrix B with elements
          !! B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
          !! the smallest possible condition number over all possible diagonal
          !! scalings.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csyequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    character, intent(in) :: uplo
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csyequb
#else
               module procedure stdlib_csyequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsyequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*),work(*)
                    character, intent(in) :: uplo
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dsyequb
#else
               module procedure stdlib_dsyequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssyequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*),work(*)
                    character, intent(in) :: uplo
                    real(sp), intent(in) :: a(lda,*)
               end subroutine ssyequb
#else
               module procedure stdlib_ssyequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsyequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    character, intent(in) :: uplo
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsyequb
#else
               module procedure stdlib_zsyequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csyequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    character, intent(in) :: uplo
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csyequb
#else
               module procedure stdlib_I64_csyequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsyequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*),work(*)
                    character, intent(in) :: uplo
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dsyequb
#else
               module procedure stdlib_I64_dsyequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssyequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*),work(*)
                    character, intent(in) :: uplo
                    real(sp), intent(in) :: a(lda,*)
               end subroutine ssyequb
#else
               module procedure stdlib_I64_ssyequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsyequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    character, intent(in) :: uplo
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsyequb
#else
               module procedure stdlib_I64_zsyequb
#endif
          end interface syequb

          interface syev
          !! SYEV computes all eigenvalues and, optionally, eigenvectors of a
          !! real symmetric matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsyev( jobz, uplo, n, a, lda, w, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: w(*),work(*)
               end subroutine dsyev
#else
               module procedure stdlib_dsyev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssyev( jobz, uplo, n, a, lda, w, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: w(*),work(*)
               end subroutine ssyev
#else
               module procedure stdlib_ssyev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dsyev( jobz, uplo, n, a, lda, w, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: w(*),work(*)
               end subroutine dsyev
#else
               module procedure stdlib_I64_dsyev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ssyev( jobz, uplo, n, a, lda, w, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: w(*),work(*)
               end subroutine ssyev
#else
               module procedure stdlib_I64_ssyev
#endif
          end interface syev

          interface syevd
          !! SYEVD computes all eigenvalues and, optionally, eigenvectors of a
          !! real symmetric matrix A. If eigenvectors are desired, it uses a
          !! divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
          !! Because of large use of BLAS of level 3, SYEVD needs N**2 more
          !! workspace than DSYEVX.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsyevd( jobz, uplo, n, a, lda, w, work, lwork, iwork,liwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,liwork,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: w(*),work(*)
               end subroutine dsyevd
#else
               module procedure stdlib_dsyevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssyevd( jobz, uplo, n, a, lda, w, work, lwork, iwork,liwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,liwork,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: w(*),work(*)
               end subroutine ssyevd
#else
               module procedure stdlib_ssyevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dsyevd( jobz, uplo, n, a, lda, w, work, lwork, iwork,liwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,liwork,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: w(*),work(*)
               end subroutine dsyevd
#else
               module procedure stdlib_I64_dsyevd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ssyevd( jobz, uplo, n, a, lda, w, work, lwork, iwork,liwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,liwork,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: w(*),work(*)
               end subroutine ssyevd
#else
               module procedure stdlib_I64_ssyevd
#endif
          end interface syevd

          interface syevr
          !! SYEVR computes selected eigenvalues and, optionally, eigenvectors
          !! of a real symmetric matrix A.  Eigenvalues and eigenvectors can be
          !! selected by specifying either a range of values or a range of
          !! indices for the desired eigenvalues.
          !! SYEVR first reduces the matrix A to tridiagonal form T with a call
          !! to DSYTRD.  Then, whenever possible, SYEVR calls DSTEMR to compute
          !! the eigenspectrum using Relatively Robust Representations.  DSTEMR
          !! computes eigenvalues by the dqds algorithm, while orthogonal
          !! eigenvectors are computed from various "good" L D L^T representations
          !! (also known as Relatively Robust Representations). Gram-Schmidt
          !! orthogonalization is avoided as far as possible. More specifically,
          !! the various steps of the algorithm are as follows.
          !! For each unreduced block (submatrix) of T,
          !! (a) Compute T - sigma I  = L D L^T, so that L and D
          !! define all the wanted eigenvalues to high relative accuracy.
          !! This means that small relative changes in the entries of D and L
          !! cause only small relative changes in the eigenvalues and
          !! eigenvectors. The standard (unfactored) representation of the
          !! tridiagonal matrix T does not have this property in general.
          !! (b) Compute the eigenvalues to suitable accuracy.
          !! If the eigenvectors are desired, the algorithm attains full
          !! accuracy of the computed eigenvalues only right before
          !! the corresponding vectors have to be computed, see steps c) and d).
          !! (c) For each cluster of close eigenvalues, select a new
          !! shift close to the cluster, find a new factorization, and refine
          !! the shifted eigenvalues to suitable accuracy.
          !! (d) For each eigenvalue with a large enough relative separation compute
          !! the corresponding eigenvector by forming a rank revealing twisted
          !! factorization. Go back to (c) for any clusters that remain.
          !! The desired accuracy of the output can be specified by the input
          !! parameter ABSTOL.
          !! For more details, see DSTEMR's documentation and:
          !! - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
          !! to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
          !! Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
          !! - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
          !! Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
          !! 2004.  Also LAPACK Working Note 154.
          !! - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
          !! tridiagonal eigenvalue/eigenvector problem",
          !! Computer Science Division Technical Report No. UCB/CSD-97-971,
          !! UC Berkeley, May 1997.
          !! Note 1 : SYEVR calls DSTEMR when the full spectrum is requested
          !! on machines which conform to the ieee-754 floating point standard.
          !! SYEVR calls DSTEBZ and DSTEIN on non-ieee machines and
          !! when partial spectrum requests are made.
          !! Normal execution of DSTEMR may create NaNs and infinities and
          !! hence may abort due to a floating point exception in environments
          !! which do not handle NaNs and infinities in the ieee standard default
          !! manner.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsyevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, &
                         ldz, isuppz, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,range,uplo
                    integer(ilp), intent(in) :: il,iu,lda,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: abstol,vl,vu
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsyevr
#else
               module procedure stdlib_dsyevr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssyevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, &
                         ldz, isuppz, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,range,uplo
                    integer(ilp), intent(in) :: il,iu,lda,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: abstol,vl,vu
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssyevr
#else
               module procedure stdlib_ssyevr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dsyevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, &
                         ldz, isuppz, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,range,uplo
                    integer(ilp64), intent(in) :: il,iu,lda,ldz,liwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: abstol,vl,vu
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsyevr
#else
               module procedure stdlib_I64_dsyevr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ssyevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, &
                         ldz, isuppz, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,range,uplo
                    integer(ilp64), intent(in) :: il,iu,lda,ldz,liwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: abstol,vl,vu
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssyevr
#else
               module procedure stdlib_I64_ssyevr
#endif
          end interface syevr

          interface sygst
          !! SYGST reduces a real symmetric-definite generalized eigenproblem
          !! to standard form.
          !! If ITYPE = 1, the problem is A*x = lambda*B*x,
          !! and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)
          !! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
          !! B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.
          !! B must have been previously factorized as U**T*U or L*L**T by DPOTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsygst( itype, uplo, n, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,lda,ldb,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: b(ldb,*)
               end subroutine dsygst
#else
               module procedure stdlib_dsygst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssygst( itype, uplo, n, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,lda,ldb,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: b(ldb,*)
               end subroutine ssygst
#else
               module procedure stdlib_ssygst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsygst( itype, uplo, n, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: itype,lda,ldb,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: b(ldb,*)
               end subroutine dsygst
#else
               module procedure stdlib_I64_dsygst
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssygst( itype, uplo, n, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: itype,lda,ldb,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: b(ldb,*)
               end subroutine ssygst
#else
               module procedure stdlib_I64_ssygst
#endif
          end interface sygst

          interface sygv
          !! SYGV computes all the eigenvalues, and optionally, the eigenvectors
          !! of a real generalized symmetric-definite eigenproblem, of the form
          !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
          !! Here A and B are assumed to be symmetric and B is also
          !! positive definite.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsygv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,lda,ldb,lwork,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: w(*),work(*)
               end subroutine dsygv
#else
               module procedure stdlib_dsygv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssygv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,lda,ldb,lwork,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: w(*),work(*)
               end subroutine ssygv
#else
               module procedure stdlib_ssygv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dsygv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: itype,lda,ldb,lwork,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: w(*),work(*)
               end subroutine dsygv
#else
               module procedure stdlib_I64_dsygv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ssygv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: itype,lda,ldb,lwork,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: w(*),work(*)
               end subroutine ssygv
#else
               module procedure stdlib_I64_ssygv
#endif
          end interface sygv

          interface sygvd
          !! SYGVD computes all the eigenvalues, and optionally, the eigenvectors
          !! of a real generalized symmetric-definite eigenproblem, of the form
          !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
          !! B are assumed to be symmetric and B is also positive definite.
          !! If eigenvectors are desired, it uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsygvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: itype,lda,ldb,liwork,lwork,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: w(*),work(*)
               end subroutine dsygvd
#else
               module procedure stdlib_dsygvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssygvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: itype,lda,ldb,liwork,lwork,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: w(*),work(*)
               end subroutine ssygvd
#else
               module procedure stdlib_ssygvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dsygvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: itype,lda,ldb,liwork,lwork,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: w(*),work(*)
               end subroutine dsygvd
#else
               module procedure stdlib_I64_dsygvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ssygvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobz,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: itype,lda,ldb,liwork,lwork,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: w(*),work(*)
               end subroutine ssygvd
#else
               module procedure stdlib_I64_ssygvd
#endif
          end interface sygvd

          interface symv
          !! SYMV performs the matrix-vector  operation
          !! y := alpha*A*x + beta*y,
          !! where alpha and beta are scalars, x and y are n element vectors and
          !! A is an n by n symmetric matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csymv( uplo, n, alpha, a, lda, x, incx, beta, y, incy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incx,incy,lda,n
                    complex(sp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    complex(sp), intent(inout) :: y(*)
               end subroutine csymv
#else
               module procedure stdlib_csymv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsymv( uplo, n, alpha, a, lda, x, incx, beta, y, incy )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incx,incy,lda,n
                    complex(dp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    complex(dp), intent(inout) :: y(*)
               end subroutine zsymv
#else
               module procedure stdlib_zsymv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csymv( uplo, n, alpha, a, lda, x, incx, beta, y, incy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: incx,incy,lda,n
                    complex(sp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    complex(sp), intent(inout) :: y(*)
               end subroutine csymv
#else
               module procedure stdlib_I64_csymv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsymv( uplo, n, alpha, a, lda, x, incx, beta, y, incy )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: incx,incy,lda,n
                    complex(dp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    complex(dp), intent(inout) :: y(*)
               end subroutine zsymv
#else
               module procedure stdlib_I64_zsymv
#endif
          end interface symv

          interface syr
          !! SYR performs the symmetric rank 1 operation
          !! A := alpha*x*x**H + A,
          !! where alpha is a complex scalar, x is an n element vector and A is an
          !! n by n symmetric matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csyr( uplo, n, alpha, x, incx, a, lda )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incx,lda,n
                    complex(sp), intent(in) :: alpha,x(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine csyr
#else
               module procedure stdlib_csyr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsyr( uplo, n, alpha, x, incx, a, lda )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incx,lda,n
                    complex(dp), intent(in) :: alpha,x(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zsyr
#else
               module procedure stdlib_zsyr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csyr( uplo, n, alpha, x, incx, a, lda )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: incx,lda,n
                    complex(sp), intent(in) :: alpha,x(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine csyr
#else
               module procedure stdlib_I64_csyr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsyr( uplo, n, alpha, x, incx, a, lda )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: incx,lda,n
                    complex(dp), intent(in) :: alpha,x(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zsyr
#else
               module procedure stdlib_I64_zsyr
#endif
          end interface syr

          interface syrfs
          !! SYRFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is symmetric indefinite, and
          !! provides error bounds and backward error estimates for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine csyrfs
#else
               module procedure stdlib_csyrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dsyrfs
#else
               module procedure stdlib_dsyrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine ssyrfs
#else
               module procedure stdlib_ssyrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zsyrfs
#else
               module procedure stdlib_zsyrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine csyrfs
#else
               module procedure stdlib_I64_csyrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dsyrfs
#else
               module procedure stdlib_I64_dsyrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine ssyrfs
#else
               module procedure stdlib_I64_ssyrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zsyrfs
#else
               module procedure stdlib_I64_zsyrfs
#endif
          end interface syrfs

          interface sysv
          !! SYSV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
          !! matrices.
          !! The diagonal pivoting method is used to factor A as
          !! A = U * D * U**T,  if UPLO = 'U', or
          !! A = L * D * L**T,  if UPLO = 'L',
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is symmetric and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
          !! used to solve the system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csysv
#else
               module procedure stdlib_csysv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsysv
#else
               module procedure stdlib_dsysv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssysv
#else
               module procedure stdlib_ssysv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsysv
#else
               module procedure stdlib_zsysv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csysv
#else
               module procedure stdlib_I64_csysv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsysv
#else
               module procedure stdlib_I64_dsysv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssysv
#else
               module procedure stdlib_I64_ssysv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsysv
#else
               module procedure stdlib_I64_zsysv
#endif
          end interface sysv

          interface sysv_aa
          !! CSYSV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
          !! matrices.
          !! Aasen's algorithm is used to factor A as
          !! A = U**T * T * U,  if UPLO = 'U', or
          !! A = L * T * L**T,  if UPLO = 'L',
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and T is symmetric tridiagonal. The factored
          !! form of A is then used to solve the system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csysv_aa
#else
               module procedure stdlib_csysv_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsysv_aa
#else
               module procedure stdlib_dsysv_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssysv_aa
#else
               module procedure stdlib_ssysv_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsysv_aa
#else
               module procedure stdlib_zsysv_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csysv_aa
#else
               module procedure stdlib_I64_csysv_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsysv_aa
#else
               module procedure stdlib_I64_dsysv_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssysv_aa
#else
               module procedure stdlib_I64_ssysv_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsysv_aa
#else
               module procedure stdlib_I64_zsysv_aa
#endif
          end interface sysv_aa

          interface sysv_rk
          !! SYSV_RK computes the solution to a complex system of linear
          !! equations A * X = B, where A is an N-by-N symmetric matrix
          !! and X and B are N-by-NRHS matrices.
          !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
          !! to factor A as
          !! A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
          !! A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
          !! where U (or L) is unit upper (or lower) triangular matrix,
          !! U**T (or L**T) is the transpose of U (or L), P is a permutation
          !! matrix, P**T is the transpose of P, and D is symmetric and block
          !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! CSYTRF_RK is called to compute the factorization of a complex
          !! symmetric matrix.  The factored form of A is then used to solve
          !! the system of equations A * X = B by calling BLAS3 routine CSYTRS_3.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: e(*),work(*)
               end subroutine csysv_rk
#else
               module procedure stdlib_csysv_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,work, lwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: e(*),work(*)
               end subroutine dsysv_rk
#else
               module procedure stdlib_dsysv_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,work, lwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: e(*),work(*)
               end subroutine ssysv_rk
#else
               module procedure stdlib_ssysv_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: e(*),work(*)
               end subroutine zsysv_rk
#else
               module procedure stdlib_zsysv_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: e(*),work(*)
               end subroutine csysv_rk
#else
               module procedure stdlib_I64_csysv_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,work, lwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: e(*),work(*)
               end subroutine dsysv_rk
#else
               module procedure stdlib_I64_dsysv_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,work, lwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: e(*),work(*)
               end subroutine ssysv_rk
#else
               module procedure stdlib_I64_ssysv_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: e(*),work(*)
               end subroutine zsysv_rk
#else
               module procedure stdlib_I64_zsysv_rk
#endif
          end interface sysv_rk

          interface sysv_rook
          !! SYSV_ROOK computes the solution to a complex system of linear
          !! equations
          !! A * X = B,
          !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
          !! matrices.
          !! The diagonal pivoting method is used to factor A as
          !! A = U * D * U**T,  if UPLO = 'U', or
          !! A = L * D * L**T,  if UPLO = 'L',
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is symmetric and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.
          !! CSYTRF_ROOK is called to compute the factorization of a complex
          !! symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
          !! pivoting method.
          !! The factored form of A is then used to solve the system
          !! of equations A * X = B by calling CSYTRS_ROOK.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csysv_rook
#else
               module procedure stdlib_csysv_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsysv_rook
#else
               module procedure stdlib_dsysv_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssysv_rook
#else
               module procedure stdlib_ssysv_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsysv_rook
#else
               module procedure stdlib_zsysv_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csysv_rook
#else
               module procedure stdlib_I64_csysv_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsysv_rook
#else
               module procedure stdlib_I64_dsysv_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssysv_rook
#else
               module procedure stdlib_I64_ssysv_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsysv_rook
#else
               module procedure stdlib_I64_zsysv_rook
#endif
          end interface sysv_rook

          interface syswapr
          !! SYSWAPR applies an elementary permutation on the rows and the columns of
          !! a symmetric matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csyswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: i1,i2,lda,n
                    complex(sp), intent(inout) :: a(lda,n)
               end subroutine csyswapr
#else
               module procedure stdlib_csyswapr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsyswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: i1,i2,lda,n
                    real(dp), intent(inout) :: a(lda,n)
               end subroutine dsyswapr
#else
               module procedure stdlib_dsyswapr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssyswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: i1,i2,lda,n
                    real(sp), intent(inout) :: a(lda,n)
               end subroutine ssyswapr
#else
               module procedure stdlib_ssyswapr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsyswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: i1,i2,lda,n
                    complex(dp), intent(inout) :: a(lda,n)
               end subroutine zsyswapr
#else
               module procedure stdlib_zsyswapr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csyswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: i1,i2,lda,n
                    complex(sp), intent(inout) :: a(lda,n)
               end subroutine csyswapr
#else
               module procedure stdlib_I64_csyswapr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsyswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: i1,i2,lda,n
                    real(dp), intent(inout) :: a(lda,n)
               end subroutine dsyswapr
#else
               module procedure stdlib_I64_dsyswapr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssyswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: i1,i2,lda,n
                    real(sp), intent(inout) :: a(lda,n)
               end subroutine ssyswapr
#else
               module procedure stdlib_I64_ssyswapr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsyswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: i1,i2,lda,n
                    complex(dp), intent(inout) :: a(lda,n)
               end subroutine zsyswapr
#else
               module procedure stdlib_I64_zsyswapr
#endif
          end interface syswapr

          interface sytf2_rk
          !! SYTF2_RK computes the factorization of a complex symmetric matrix A
          !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
          !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
          !! where U (or L) is unit upper (or lower) triangular matrix,
          !! U**T (or L**T) is the transpose of U (or L), P is a permutation
          !! matrix, P**T is the transpose of P, and D is symmetric and block
          !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
          !! For more information see Further Details section.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*)
               end subroutine csytf2_rk
#else
               module procedure stdlib_csytf2_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: e(*)
               end subroutine dsytf2_rk
#else
               module procedure stdlib_dsytf2_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: e(*)
               end subroutine ssytf2_rk
#else
               module procedure stdlib_ssytf2_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*)
               end subroutine zsytf2_rk
#else
               module procedure stdlib_zsytf2_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csytf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*)
               end subroutine csytf2_rk
#else
               module procedure stdlib_I64_csytf2_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsytf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: e(*)
               end subroutine dsytf2_rk
#else
               module procedure stdlib_I64_dsytf2_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssytf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: e(*)
               end subroutine ssytf2_rk
#else
               module procedure stdlib_I64_ssytf2_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsytf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*)
               end subroutine zsytf2_rk
#else
               module procedure stdlib_I64_zsytf2_rk
#endif
          end interface sytf2_rk

          interface sytf2_rook
          !! SYTF2_ROOK computes the factorization of a complex symmetric matrix A
          !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
          !! A = U*D*U**T  or  A = L*D*L**T
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, U**T is the transpose of U, and D is symmetric and
          !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine csytf2_rook
#else
               module procedure stdlib_csytf2_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dsytf2_rook
#else
               module procedure stdlib_dsytf2_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine ssytf2_rook
#else
               module procedure stdlib_ssytf2_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zsytf2_rook
#else
               module procedure stdlib_zsytf2_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csytf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine csytf2_rook
#else
               module procedure stdlib_I64_csytf2_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsytf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dsytf2_rook
#else
               module procedure stdlib_I64_dsytf2_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssytf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine ssytf2_rook
#else
               module procedure stdlib_I64_ssytf2_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsytf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zsytf2_rook
#else
               module procedure stdlib_I64_zsytf2_rook
#endif
          end interface sytf2_rook

          interface sytrd
          !! SYTRD reduces a real symmetric matrix A to real symmetric
          !! tridiagonal form T by an orthogonal similarity transformation:
          !! Q**T * A * Q = T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*),e(*),tau(*),work(*)
               end subroutine dsytrd
#else
               module procedure stdlib_dsytrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*),e(*),tau(*),work(*)
               end subroutine ssytrd
#else
               module procedure stdlib_ssytrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsytrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*),e(*),tau(*),work(*)
               end subroutine dsytrd
#else
               module procedure stdlib_I64_dsytrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssytrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*),e(*),tau(*),work(*)
               end subroutine ssytrd
#else
               module procedure stdlib_I64_ssytrd
#endif
          end interface sytrd

          interface sytrd_sb2st
          !! SYTRD_SB2ST reduces a real symmetric band matrix A to real symmetric
          !! tridiagonal form T by a orthogonal similarity transformation:
          !! Q**T * A * Q = T.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsytrd_sb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, &
                         lhous, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: stage1,uplo,vect
                    integer(ilp), intent(in) :: n,kd,ldab,lhous,lwork
                    integer(ilp), intent(out) :: info
                    real(dp), intent(out) :: d(*),e(*),hous(*),work(*)
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dsytrd_sb2st
#else
               module procedure stdlib_dsytrd_sb2st
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssytrd_sb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, &
                         lhous, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: stage1,uplo,vect
                    integer(ilp), intent(in) :: n,kd,ldab,lhous,lwork
                    integer(ilp), intent(out) :: info
                    real(sp), intent(out) :: d(*),e(*),hous(*),work(*)
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine ssytrd_sb2st
#else
               module procedure stdlib_ssytrd_sb2st
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dsytrd_sb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, &
                         lhous, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: stage1,uplo,vect
                    integer(ilp64), intent(in) :: n,kd,ldab,lhous,lwork
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(out) :: d(*),e(*),hous(*),work(*)
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dsytrd_sb2st
#else
               module procedure stdlib_I64_dsytrd_sb2st
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ssytrd_sb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, &
                         lhous, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: stage1,uplo,vect
                    integer(ilp64), intent(in) :: n,kd,ldab,lhous,lwork
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(out) :: d(*),e(*),hous(*),work(*)
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine ssytrd_sb2st
#else
               module procedure stdlib_I64_ssytrd_sb2st
#endif
          end interface sytrd_sb2st

          interface sytrd_sy2sb
          !! SYTRD_SY2SB reduces a real symmetric matrix A to real symmetric
          !! band-diagonal form AB by a orthogonal similarity transformation:
          !! Q**T * A * Q = AB.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsytrd_sy2sb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldab,lwork,n,kd
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: ab(ldab,*),tau(*),work(*)
               end subroutine dsytrd_sy2sb
#else
               module procedure stdlib_dsytrd_sy2sb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssytrd_sy2sb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info &
                         )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldab,lwork,n,kd
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: ab(ldab,*),tau(*),work(*)
               end subroutine ssytrd_sy2sb
#else
               module procedure stdlib_ssytrd_sy2sb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dsytrd_sy2sb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldab,lwork,n,kd
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: ab(ldab,*),tau(*),work(*)
               end subroutine dsytrd_sy2sb
#else
               module procedure stdlib_I64_dsytrd_sy2sb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ssytrd_sy2sb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info &
                         )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldab,lwork,n,kd
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: ab(ldab,*),tau(*),work(*)
               end subroutine ssytrd_sy2sb
#else
               module procedure stdlib_I64_ssytrd_sy2sb
#endif
          end interface sytrd_sy2sb

          interface sytrf
          !! SYTRF computes the factorization of a complex symmetric matrix A
          !! using the Bunch-Kaufman diagonal pivoting method.  The form of the
          !! factorization is
          !! A = U*D*U**T  or  A = L*D*L**T
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is symmetric and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytrf
#else
               module procedure stdlib_csytrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytrf
#else
               module procedure stdlib_dsytrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytrf
#else
               module procedure stdlib_ssytrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytrf
#else
               module procedure stdlib_zsytrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csytrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytrf
#else
               module procedure stdlib_I64_csytrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsytrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytrf
#else
               module procedure stdlib_I64_dsytrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssytrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytrf
#else
               module procedure stdlib_I64_ssytrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsytrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytrf
#else
               module procedure stdlib_I64_zsytrf
#endif
          end interface sytrf

          interface sytrf_aa
          !! SYTRF_AA computes the factorization of a complex symmetric matrix A
          !! using the Aasen's algorithm.  The form of the factorization is
          !! A = U**T*T*U  or  A = L*T*L**T
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and T is a complex symmetric tridiagonal matrix.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,lwork
                    integer(ilp), intent(out) :: info,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytrf_aa
#else
               module procedure stdlib_csytrf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,lwork
                    integer(ilp), intent(out) :: info,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytrf_aa
#else
               module procedure stdlib_dsytrf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,lwork
                    integer(ilp), intent(out) :: info,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytrf_aa
#else
               module procedure stdlib_ssytrf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,lwork
                    integer(ilp), intent(out) :: info,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytrf_aa
#else
               module procedure stdlib_zsytrf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,lda,lwork
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytrf_aa
#else
               module procedure stdlib_I64_csytrf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,lda,lwork
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytrf_aa
#else
               module procedure stdlib_I64_dsytrf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,lda,lwork
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytrf_aa
#else
               module procedure stdlib_I64_ssytrf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,lda,lwork
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytrf_aa
#else
               module procedure stdlib_I64_zsytrf_aa
#endif
          end interface sytrf_aa

          interface sytrf_rk
          !! SYTRF_RK computes the factorization of a complex symmetric matrix A
          !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
          !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
          !! where U (or L) is unit upper (or lower) triangular matrix,
          !! U**T (or L**T) is the transpose of U (or L), P is a permutation
          !! matrix, P**T is the transpose of P, and D is symmetric and block
          !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
          !! For more information see Further Details section.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*),work(*)
               end subroutine csytrf_rk
#else
               module procedure stdlib_csytrf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: e(*),work(*)
               end subroutine dsytrf_rk
#else
               module procedure stdlib_dsytrf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: e(*),work(*)
               end subroutine ssytrf_rk
#else
               module procedure stdlib_ssytrf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*),work(*)
               end subroutine zsytrf_rk
#else
               module procedure stdlib_zsytrf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*),work(*)
               end subroutine csytrf_rk
#else
               module procedure stdlib_I64_csytrf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: e(*),work(*)
               end subroutine dsytrf_rk
#else
               module procedure stdlib_I64_dsytrf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: e(*),work(*)
               end subroutine ssytrf_rk
#else
               module procedure stdlib_I64_ssytrf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*),work(*)
               end subroutine zsytrf_rk
#else
               module procedure stdlib_I64_zsytrf_rk
#endif
          end interface sytrf_rk

          interface sytrf_rook
          !! SYTRF_ROOK computes the factorization of a complex symmetric matrix A
          !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
          !! The form of the factorization is
          !! A = U*D*U**T  or  A = L*D*L**T
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is symmetric and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytrf_rook
#else
               module procedure stdlib_csytrf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytrf_rook
#else
               module procedure stdlib_dsytrf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytrf_rook
#else
               module procedure stdlib_ssytrf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytrf_rook
#else
               module procedure stdlib_zsytrf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytrf_rook
#else
               module procedure stdlib_I64_csytrf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytrf_rook
#else
               module procedure stdlib_I64_dsytrf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytrf_rook
#else
               module procedure stdlib_I64_ssytrf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info,ipiv(*)
                    integer(ilp64), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytrf_rook
#else
               module procedure stdlib_I64_zsytrf_rook
#endif
          end interface sytrf_rook

          interface sytri
          !! SYTRI computes the inverse of a complex symmetric indefinite matrix
          !! A using the factorization A = U*D*U**T or A = L*D*L**T computed by
          !! CSYTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytri
#else
               module procedure stdlib_csytri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytri
#else
               module procedure stdlib_dsytri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytri
#else
               module procedure stdlib_ssytri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytri
#else
               module procedure stdlib_zsytri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csytri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytri
#else
               module procedure stdlib_I64_csytri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsytri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytri
#else
               module procedure stdlib_I64_dsytri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssytri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytri
#else
               module procedure stdlib_I64_ssytri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsytri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytri
#else
               module procedure stdlib_I64_zsytri
#endif
          end interface sytri

          interface sytri_rook
          !! SYTRI_ROOK computes the inverse of a complex symmetric
          !! matrix A using the factorization A = U*D*U**T or A = L*D*L**T
          !! computed by CSYTRF_ROOK.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytri_rook
#else
               module procedure stdlib_csytri_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytri_rook
#else
               module procedure stdlib_dsytri_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytri_rook
#else
               module procedure stdlib_ssytri_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytri_rook
#else
               module procedure stdlib_zsytri_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csytri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytri_rook
#else
               module procedure stdlib_I64_csytri_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsytri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytri_rook
#else
               module procedure stdlib_I64_dsytri_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssytri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytri_rook
#else
               module procedure stdlib_I64_ssytri_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsytri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytri_rook
#else
               module procedure stdlib_I64_zsytri_rook
#endif
          end interface sytri_rook

          interface sytrs
          !! SYTRS solves a system of linear equations A*X = B with a complex
          !! symmetric matrix A using the factorization A = U*D*U**T or
          !! A = L*D*L**T computed by CSYTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine csytrs
#else
               module procedure stdlib_csytrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dsytrs
#else
               module procedure stdlib_dsytrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine ssytrs
#else
               module procedure stdlib_ssytrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zsytrs
#else
               module procedure stdlib_zsytrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine csytrs
#else
               module procedure stdlib_I64_csytrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dsytrs
#else
               module procedure stdlib_I64_dsytrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine ssytrs
#else
               module procedure stdlib_I64_ssytrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zsytrs
#else
               module procedure stdlib_I64_zsytrs
#endif
          end interface sytrs

          interface sytrs2
          !! SYTRS2 solves a system of linear equations A*X = B with a complex
          !! symmetric matrix A using the factorization A = U*D*U**T or
          !! A = L*D*L**T computed by CSYTRF and converted by CSYCONV.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytrs2
#else
               module procedure stdlib_csytrs2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytrs2
#else
               module procedure stdlib_dsytrs2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytrs2
#else
               module procedure stdlib_ssytrs2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytrs2
#else
               module procedure stdlib_zsytrs2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytrs2
#else
               module procedure stdlib_I64_csytrs2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytrs2
#else
               module procedure stdlib_I64_dsytrs2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytrs2
#else
               module procedure stdlib_I64_ssytrs2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytrs2
#else
               module procedure stdlib_I64_zsytrs2
#endif
          end interface sytrs2

          interface sytrs_3
          !! SYTRS_3 solves a system of linear equations A * X = B with a complex
          !! symmetric matrix A using the factorization computed
          !! by CSYTRF_RK or CSYTRF_BK:
          !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
          !! where U (or L) is unit upper (or lower) triangular matrix,
          !! U**T (or L**T) is the transpose of U (or L), P is a permutation
          !! matrix, P**T is the transpose of P, and D is symmetric and block
          !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! This algorithm is using Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*),e(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine csytrs_3
#else
               module procedure stdlib_csytrs_3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*),e(*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dsytrs_3
#else
               module procedure stdlib_dsytrs_3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*),e(*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine ssytrs_3
#else
               module procedure stdlib_ssytrs_3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*),e(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zsytrs_3
#else
               module procedure stdlib_zsytrs_3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*),e(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine csytrs_3
#else
               module procedure stdlib_I64_csytrs_3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*),e(*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dsytrs_3
#else
               module procedure stdlib_I64_dsytrs_3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*),e(*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine ssytrs_3
#else
               module procedure stdlib_I64_ssytrs_3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*),e(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zsytrs_3
#else
               module procedure stdlib_I64_zsytrs_3
#endif
          end interface sytrs_3

          interface sytrs_aa
          !! SYTRS_AA solves a system of linear equations A*X = B with a complex
          !! symmetric matrix A using the factorization A = U**T*T*U or
          !! A = L*T*L**T computed by CSYTRF_AA.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytrs_aa
#else
               module procedure stdlib_csytrs_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytrs_aa
#else
               module procedure stdlib_dsytrs_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytrs_aa
#else
               module procedure stdlib_ssytrs_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytrs_aa
#else
               module procedure stdlib_zsytrs_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytrs_aa
#else
               module procedure stdlib_I64_csytrs_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp64), intent(out) :: info
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytrs_aa
#else
               module procedure stdlib_I64_dsytrs_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp64), intent(out) :: info
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytrs_aa
#else
               module procedure stdlib_I64_ssytrs_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytrs_aa
#else
               module procedure stdlib_I64_zsytrs_aa
#endif
          end interface sytrs_aa

          interface sytrs_rook
          !! SYTRS_ROOK solves a system of linear equations A*X = B with
          !! a complex symmetric matrix A using the factorization A = U*D*U**T or
          !! A = L*D*L**T computed by CSYTRF_ROOK.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine csytrs_rook
#else
               module procedure stdlib_csytrs_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dsytrs_rook
#else
               module procedure stdlib_dsytrs_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine ssytrs_rook
#else
               module procedure stdlib_ssytrs_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zsytrs_rook
#else
               module procedure stdlib_zsytrs_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine csytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine csytrs_rook
#else
               module procedure stdlib_I64_csytrs_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dsytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dsytrs_rook
#else
               module procedure stdlib_I64_dsytrs_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ssytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine ssytrs_rook
#else
               module procedure stdlib_I64_ssytrs_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zsytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zsytrs_rook
#else
               module procedure stdlib_I64_zsytrs_rook
#endif
          end interface sytrs_rook

          interface tbcon
          !! TBCON estimates the reciprocal of the condition number of a
          !! triangular band matrix A, in either the 1-norm or the infinity-norm.
          !! The norm of A is computed and an estimate is obtained for
          !! norm(inv(A)), then the reciprocal of the condition number is
          !! computed as
          !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ctbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,rwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctbcon
#else
               module procedure stdlib_ctbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dtbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: rcond,work(*)
                    real(dp), intent(in) :: ab(ldab,*)
               end subroutine dtbcon
#else
               module procedure stdlib_dtbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine stbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,iwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: rcond,work(*)
                    real(sp), intent(in) :: ab(ldab,*)
               end subroutine stbcon
#else
               module procedure stdlib_stbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ztbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,rwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztbcon
#else
               module procedure stdlib_ztbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ctbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,rwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctbcon
#else
               module procedure stdlib_I64_ctbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dtbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: rcond,work(*)
                    real(dp), intent(in) :: ab(ldab,*)
               end subroutine dtbcon
#else
               module procedure stdlib_I64_dtbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine stbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,iwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: rcond,work(*)
                    real(sp), intent(in) :: ab(ldab,*)
               end subroutine stbcon
#else
               module procedure stdlib_I64_stbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ztbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,rwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztbcon
#else
               module procedure stdlib_I64_ztbcon
#endif
          end interface tbcon

          interface tbrfs
          !! TBRFS provides error bounds and backward error estimates for the
          !! solution to a system of linear equations with a triangular band
          !! coefficient matrix.
          !! The solution matrix X must be computed by CTBTRS or some other
          !! means before entering this routine.  TBRFS does not do iterative
          !! refinement because doing so cannot improve the backward error.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*),b(ldb,*),x(ldx,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctbrfs
#else
               module procedure stdlib_ctbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,ldb,ldx,n,nrhs
                    real(dp), intent(in) :: ab(ldab,*),b(ldb,*),x(ldx,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine dtbrfs
#else
               module procedure stdlib_dtbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,ldb,ldx,n,nrhs
                    real(sp), intent(in) :: ab(ldab,*),b(ldb,*),x(ldx,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine stbrfs
#else
               module procedure stdlib_stbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*),b(ldb,*),x(ldx,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztbrfs
#else
               module procedure stdlib_ztbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*),b(ldb,*),x(ldx,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctbrfs
#else
               module procedure stdlib_I64_ctbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: kd,ldab,ldb,ldx,n,nrhs
                    real(dp), intent(in) :: ab(ldab,*),b(ldb,*),x(ldx,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine dtbrfs
#else
               module procedure stdlib_I64_dtbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: kd,ldab,ldb,ldx,n,nrhs
                    real(sp), intent(in) :: ab(ldab,*),b(ldb,*),x(ldx,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine stbrfs
#else
               module procedure stdlib_I64_stbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*),b(ldb,*),x(ldx,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztbrfs
#else
               module procedure stdlib_I64_ztbrfs
#endif
          end interface tbrfs

          interface tbtrs
          !! TBTRS solves a triangular system of the form
          !! A * X = B,  A**T * X = B,  or  A**H * X = B,
          !! where A is a triangular band matrix of order N, and B is an
          !! N-by-NRHS matrix.  A check is made to verify that A is nonsingular.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine ctbtrs
#else
               module procedure stdlib_ctbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dtbtrs
#else
               module procedure stdlib_dtbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine stbtrs
#else
               module procedure stdlib_stbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine ztbtrs
#else
               module procedure stdlib_ztbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine ctbtrs
#else
               module procedure stdlib_I64_ctbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dtbtrs
#else
               module procedure stdlib_I64_dtbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine stbtrs
#else
               module procedure stdlib_I64_stbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine ztbtrs
#else
               module procedure stdlib_I64_ztbtrs
#endif
          end interface tbtrs

          interface tfsm
          !! Level 3 BLAS like routine for A in RFP Format.
          !! TFSM solves the matrix equation
          !! op( A )*X = alpha*B  or  X*op( A ) = alpha*B
          !! where alpha is a scalar, X and B are m by n matrices, A is a unit, or
          !! non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
          !! op( A ) = A   or   op( A ) = A**H.
          !! A is in Rectangular Full Packed (RFP) Format.
          !! The matrix X is overwritten on B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctfsm( transr, side, uplo, trans, diag, m, n, alpha, a,b, ldb )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,diag,side,trans,uplo
                    integer(ilp), intent(in) :: ldb,m,n
                    complex(sp), intent(in) :: alpha,a(0:*)
                    complex(sp), intent(inout) :: b(0:ldb-1,0:*)
               end subroutine ctfsm
#else
               module procedure stdlib_ctfsm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtfsm( transr, side, uplo, trans, diag, m, n, alpha, a,b, ldb )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,diag,side,trans,uplo
                    integer(ilp), intent(in) :: ldb,m,n
                    real(dp), intent(in) :: alpha,a(0:*)
                    real(dp), intent(inout) :: b(0:ldb-1,0:*)
               end subroutine dtfsm
#else
               module procedure stdlib_dtfsm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stfsm( transr, side, uplo, trans, diag, m, n, alpha, a,b, ldb )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,diag,side,trans,uplo
                    integer(ilp), intent(in) :: ldb,m,n
                    real(sp), intent(in) :: alpha,a(0:*)
                    real(sp), intent(inout) :: b(0:ldb-1,0:*)
               end subroutine stfsm
#else
               module procedure stdlib_stfsm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztfsm( transr, side, uplo, trans, diag, m, n, alpha, a,b, ldb )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,diag,side,trans,uplo
                    integer(ilp), intent(in) :: ldb,m,n
                    complex(dp), intent(in) :: alpha,a(0:*)
                    complex(dp), intent(inout) :: b(0:ldb-1,0:*)
               end subroutine ztfsm
#else
               module procedure stdlib_ztfsm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctfsm( transr, side, uplo, trans, diag, m, n, alpha, a,b, ldb )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,diag,side,trans,uplo
                    integer(ilp64), intent(in) :: ldb,m,n
                    complex(sp), intent(in) :: alpha,a(0:*)
                    complex(sp), intent(inout) :: b(0:ldb-1,0:*)
               end subroutine ctfsm
#else
               module procedure stdlib_I64_ctfsm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtfsm( transr, side, uplo, trans, diag, m, n, alpha, a,b, ldb )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,diag,side,trans,uplo
                    integer(ilp64), intent(in) :: ldb,m,n
                    real(dp), intent(in) :: alpha,a(0:*)
                    real(dp), intent(inout) :: b(0:ldb-1,0:*)
               end subroutine dtfsm
#else
               module procedure stdlib_I64_dtfsm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stfsm( transr, side, uplo, trans, diag, m, n, alpha, a,b, ldb )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,diag,side,trans,uplo
                    integer(ilp64), intent(in) :: ldb,m,n
                    real(sp), intent(in) :: alpha,a(0:*)
                    real(sp), intent(inout) :: b(0:ldb-1,0:*)
               end subroutine stfsm
#else
               module procedure stdlib_I64_stfsm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztfsm( transr, side, uplo, trans, diag, m, n, alpha, a,b, ldb )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,diag,side,trans,uplo
                    integer(ilp64), intent(in) :: ldb,m,n
                    complex(dp), intent(in) :: alpha,a(0:*)
                    complex(dp), intent(inout) :: b(0:ldb-1,0:*)
               end subroutine ztfsm
#else
               module procedure stdlib_I64_ztfsm
#endif
          end interface tfsm

          interface tftri
          !! TFTRI computes the inverse of a triangular matrix A stored in RFP
          !! format.
          !! This is a Level 3 BLAS version of the algorithm.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctftri( transr, uplo, diag, n, a, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo,diag
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: a(0:*)
               end subroutine ctftri
#else
               module procedure stdlib_ctftri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtftri( transr, uplo, diag, n, a, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo,diag
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: a(0:*)
               end subroutine dtftri
#else
               module procedure stdlib_dtftri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stftri( transr, uplo, diag, n, a, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo,diag
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: a(0:*)
               end subroutine stftri
#else
               module procedure stdlib_stftri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztftri( transr, uplo, diag, n, a, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo,diag
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: a(0:*)
               end subroutine ztftri
#else
               module procedure stdlib_ztftri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctftri( transr, uplo, diag, n, a, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo,diag
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    complex(sp), intent(inout) :: a(0:*)
               end subroutine ctftri
#else
               module procedure stdlib_I64_ctftri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtftri( transr, uplo, diag, n, a, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo,diag
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(inout) :: a(0:*)
               end subroutine dtftri
#else
               module procedure stdlib_I64_dtftri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stftri( transr, uplo, diag, n, a, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo,diag
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(inout) :: a(0:*)
               end subroutine stftri
#else
               module procedure stdlib_I64_stftri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztftri( transr, uplo, diag, n, a, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo,diag
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    complex(dp), intent(inout) :: a(0:*)
               end subroutine ztftri
#else
               module procedure stdlib_I64_ztftri
#endif
          end interface tftri

          interface tfttp
          !! TFTTP copies a triangular matrix A from rectangular full packed
          !! format (TF) to standard packed format (TP).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctfttp( transr, uplo, n, arf, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(out) :: ap(0:*)
                    complex(sp), intent(in) :: arf(0:*)
               end subroutine ctfttp
#else
               module procedure stdlib_ctfttp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtfttp( transr, uplo, n, arf, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: ap(0:*)
                    real(dp), intent(in) :: arf(0:*)
               end subroutine dtfttp
#else
               module procedure stdlib_dtfttp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stfttp( transr, uplo, n, arf, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: ap(0:*)
                    real(sp), intent(in) :: arf(0:*)
               end subroutine stfttp
#else
               module procedure stdlib_stfttp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztfttp( transr, uplo, n, arf, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(out) :: ap(0:*)
                    complex(dp), intent(in) :: arf(0:*)
               end subroutine ztfttp
#else
               module procedure stdlib_ztfttp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctfttp( transr, uplo, n, arf, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    complex(sp), intent(out) :: ap(0:*)
                    complex(sp), intent(in) :: arf(0:*)
               end subroutine ctfttp
#else
               module procedure stdlib_I64_ctfttp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtfttp( transr, uplo, n, arf, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(out) :: ap(0:*)
                    real(dp), intent(in) :: arf(0:*)
               end subroutine dtfttp
#else
               module procedure stdlib_I64_dtfttp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stfttp( transr, uplo, n, arf, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(out) :: ap(0:*)
                    real(sp), intent(in) :: arf(0:*)
               end subroutine stfttp
#else
               module procedure stdlib_I64_stfttp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztfttp( transr, uplo, n, arf, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    complex(dp), intent(out) :: ap(0:*)
                    complex(dp), intent(in) :: arf(0:*)
               end subroutine ztfttp
#else
               module procedure stdlib_I64_ztfttp
#endif
          end interface tfttp

          interface tfttr
          !! TFTTR copies a triangular matrix A from rectangular full packed
          !! format (TF) to standard full format (TR).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctfttr( transr, uplo, n, arf, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    complex(sp), intent(out) :: a(0:lda-1,0:*)
                    complex(sp), intent(in) :: arf(0:*)
               end subroutine ctfttr
#else
               module procedure stdlib_ctfttr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtfttr( transr, uplo, n, arf, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    real(dp), intent(out) :: a(0:lda-1,0:*)
                    real(dp), intent(in) :: arf(0:*)
               end subroutine dtfttr
#else
               module procedure stdlib_dtfttr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stfttr( transr, uplo, n, arf, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    real(sp), intent(out) :: a(0:lda-1,0:*)
                    real(sp), intent(in) :: arf(0:*)
               end subroutine stfttr
#else
               module procedure stdlib_stfttr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztfttr( transr, uplo, n, arf, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    complex(dp), intent(out) :: a(0:lda-1,0:*)
                    complex(dp), intent(in) :: arf(0:*)
               end subroutine ztfttr
#else
               module procedure stdlib_ztfttr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctfttr( transr, uplo, n, arf, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,lda
                    complex(sp), intent(out) :: a(0:lda-1,0:*)
                    complex(sp), intent(in) :: arf(0:*)
               end subroutine ctfttr
#else
               module procedure stdlib_I64_ctfttr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtfttr( transr, uplo, n, arf, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,lda
                    real(dp), intent(out) :: a(0:lda-1,0:*)
                    real(dp), intent(in) :: arf(0:*)
               end subroutine dtfttr
#else
               module procedure stdlib_I64_dtfttr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stfttr( transr, uplo, n, arf, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,lda
                    real(sp), intent(out) :: a(0:lda-1,0:*)
                    real(sp), intent(in) :: arf(0:*)
               end subroutine stfttr
#else
               module procedure stdlib_I64_stfttr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztfttr( transr, uplo, n, arf, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,lda
                    complex(dp), intent(out) :: a(0:lda-1,0:*)
                    complex(dp), intent(in) :: arf(0:*)
               end subroutine ztfttr
#else
               module procedure stdlib_I64_ztfttr
#endif
          end interface tfttr

          interface tgevc
          !! TGEVC computes some or all of the right and/or left eigenvectors of
          !! a pair of complex matrices (S,P), where S and P are upper triangular.
          !! Matrix pairs of this type are produced by the generalized Schur
          !! factorization of a complex matrix pair (A,B):
          !! A = Q*S*Z**H,  B = Q*P*Z**H
          !! as computed by CGGHRD + CHGEQZ.
          !! The right eigenvector x and the left eigenvector y of (S,P)
          !! corresponding to an eigenvalue w are defined by:
          !! S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
          !! where y**H denotes the conjugate tranpose of y.
          !! The eigenvalues are not input to this routine, but are computed
          !! directly from the diagonal elements of S and P.
          !! This routine returns the matrices X and/or Y of right and left
          !! eigenvectors of (S,P), or the products Z*X and/or Q*Y,
          !! where Z and Q are input matrices.
          !! If Q and Z are the unitary factors from the generalized Schur
          !! factorization of a matrix pair (A,B), then Z*X and Q*Y
          !! are the matrices of right and left eigenvectors of (A,B).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr,&
                          mm, m, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldp,lds,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(in) :: p(ldp,*),s(lds,*)
                    complex(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctgevc
#else
               module procedure stdlib_ctgevc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr,&
                          mm, m, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldp,lds,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(in) :: p(ldp,*),s(lds,*)
                    real(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtgevc
#else
               module procedure stdlib_dtgevc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr,&
                          mm, m, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldp,lds,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(in) :: p(ldp,*),s(lds,*)
                    real(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(sp), intent(out) :: work(*)
               end subroutine stgevc
#else
               module procedure stdlib_stgevc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr,&
                          mm, m, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldp,lds,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(in) :: p(ldp,*),s(lds,*)
                    complex(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztgevc
#else
               module procedure stdlib_ztgevc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr,&
                          mm, m, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp64), intent(out) :: info,m
                    integer(ilp64), intent(in) :: ldp,lds,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(in) :: p(ldp,*),s(lds,*)
                    complex(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctgevc
#else
               module procedure stdlib_I64_ctgevc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr,&
                          mm, m, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp64), intent(out) :: info,m
                    integer(ilp64), intent(in) :: ldp,lds,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(in) :: p(ldp,*),s(lds,*)
                    real(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtgevc
#else
               module procedure stdlib_I64_dtgevc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr,&
                          mm, m, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp64), intent(out) :: info,m
                    integer(ilp64), intent(in) :: ldp,lds,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(in) :: p(ldp,*),s(lds,*)
                    real(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(sp), intent(out) :: work(*)
               end subroutine stgevc
#else
               module procedure stdlib_I64_stgevc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr,&
                          mm, m, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp64), intent(out) :: info,m
                    integer(ilp64), intent(in) :: ldp,lds,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(in) :: p(ldp,*),s(lds,*)
                    complex(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztgevc
#else
               module procedure stdlib_I64_ztgevc
#endif
          end interface tgevc

          interface tgexc
          !! TGEXC reorders the generalized Schur decomposition of a complex
          !! matrix pair (A,B), using an unitary equivalence transformation
          !! (A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with
          !! row index IFST is moved to row ILST.
          !! (A, B) must be in generalized Schur canonical form, that is, A and
          !! B are both upper triangular.
          !! Optionally, the matrices Q and Z of generalized Schur vectors are
          !! updated.
          !! Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
          !! Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst,&
                          info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: wantq,wantz
                    integer(ilp), intent(in) :: ifst,lda,ldb,ldq,ldz,n
                    integer(ilp), intent(inout) :: ilst
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine ctgexc
#else
               module procedure stdlib_ctgexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst,&
                          work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: wantq,wantz
                    integer(ilp), intent(inout) :: ifst,ilst
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldq,ldz,lwork,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtgexc
#else
               module procedure stdlib_dtgexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst,&
                          work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: wantq,wantz
                    integer(ilp), intent(inout) :: ifst,ilst
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldq,ldz,lwork,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    real(sp), intent(out) :: work(*)
               end subroutine stgexc
#else
               module procedure stdlib_stgexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst,&
                          info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: wantq,wantz
                    integer(ilp), intent(in) :: ifst,lda,ldb,ldq,ldz,n
                    integer(ilp), intent(inout) :: ilst
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine ztgexc
#else
               module procedure stdlib_ztgexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst,&
                          info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: wantq,wantz
                    integer(ilp64), intent(in) :: ifst,lda,ldb,ldq,ldz,n
                    integer(ilp64), intent(inout) :: ilst
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine ctgexc
#else
               module procedure stdlib_I64_ctgexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst,&
                          work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: wantq,wantz
                    integer(ilp64), intent(inout) :: ifst,ilst
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldq,ldz,lwork,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtgexc
#else
               module procedure stdlib_I64_dtgexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst,&
                          work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: wantq,wantz
                    integer(ilp64), intent(inout) :: ifst,ilst
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldq,ldz,lwork,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    real(sp), intent(out) :: work(*)
               end subroutine stgexc
#else
               module procedure stdlib_I64_stgexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst,&
                          info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: wantq,wantz
                    integer(ilp64), intent(in) :: ifst,lda,ldb,ldq,ldz,n
                    integer(ilp64), intent(inout) :: ilst
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine ztgexc
#else
               module procedure stdlib_I64_ztgexc
#endif
          end interface tgexc

          interface tgsen
          !! TGSEN reorders the generalized Schur decomposition of a complex
          !! matrix pair (A, B) (in terms of an unitary equivalence trans-
          !! formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues
          !! appears in the leading diagonal blocks of the pair (A,B). The leading
          !! columns of Q and Z form unitary bases of the corresponding left and
          !! right eigenspaces (deflating subspaces). (A, B) must be in
          !! generalized Schur canonical form, that is, A and B are both upper
          !! triangular.
          !! TGSEN also computes the generalized eigenvalues
          !! w(j)= ALPHA(j) / BETA(j)
          !! of the reordered matrix pair (A, B).
          !! Optionally, the routine computes estimates of reciprocal condition
          !! numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
          !! (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
          !! between the matrix pairs (A11, B11) and (A22,B22) that correspond to
          !! the selected cluster and the eigenvalues outside the cluster, resp.,
          !! and norms of "projections" onto left and right eigenspaces w.r.t.
          !! the selected cluster in the (1,1)-block.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alpha, beta, &
                         q, ldq, z, ldz, m, pl, pr, dif,work, lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: wantq,wantz,select(*)
                    integer(ilp), intent(in) :: ijob,lda,ldb,ldq,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    real(sp), intent(out) :: pl,pr,dif(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    complex(sp), intent(out) :: alpha(*),beta(*),work(*)
               end subroutine ctgsen
#else
               module procedure stdlib_ctgsen
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alphar, &
               alphai, beta, q, ldq, z, ldz, m, pl,pr, dif, work, lwork, iwork, liwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: wantq,wantz,select(*)
                    integer(ilp), intent(in) :: ijob,lda,ldb,ldq,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    real(dp), intent(out) :: pl,pr,alphai(*),alphar(*),beta(*),dif(*),work(*)

                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine dtgsen
#else
               module procedure stdlib_dtgsen
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alphar, &
               alphai, beta, q, ldq, z, ldz, m, pl,pr, dif, work, lwork, iwork, liwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: wantq,wantz,select(*)
                    integer(ilp), intent(in) :: ijob,lda,ldb,ldq,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    real(sp), intent(out) :: pl,pr,alphai(*),alphar(*),beta(*),dif(*),work(*)

                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine stgsen
#else
               module procedure stdlib_stgsen
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alpha, beta, &
                         q, ldq, z, ldz, m, pl, pr, dif,work, lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    logical(lk), intent(in) :: wantq,wantz,select(*)
                    integer(ilp), intent(in) :: ijob,lda,ldb,ldq,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    real(dp), intent(out) :: pl,pr,dif(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    complex(dp), intent(out) :: alpha(*),beta(*),work(*)
               end subroutine ztgsen
#else
               module procedure stdlib_ztgsen
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alpha, beta, &
                         q, ldq, z, ldz, m, pl, pr, dif,work, lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: wantq,wantz,select(*)
                    integer(ilp64), intent(in) :: ijob,lda,ldb,ldq,ldz,liwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,iwork(*)
                    real(sp), intent(out) :: pl,pr,dif(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    complex(sp), intent(out) :: alpha(*),beta(*),work(*)
               end subroutine ctgsen
#else
               module procedure stdlib_I64_ctgsen
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alphar, &
               alphai, beta, q, ldq, z, ldz, m, pl,pr, dif, work, lwork, iwork, liwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: wantq,wantz,select(*)
                    integer(ilp64), intent(in) :: ijob,lda,ldb,ldq,ldz,liwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,iwork(*)
                    real(dp), intent(out) :: pl,pr,alphai(*),alphar(*),beta(*),dif(*),work(*)

                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine dtgsen
#else
               module procedure stdlib_I64_dtgsen
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alphar, &
               alphai, beta, q, ldq, z, ldz, m, pl,pr, dif, work, lwork, iwork, liwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: wantq,wantz,select(*)
                    integer(ilp64), intent(in) :: ijob,lda,ldb,ldq,ldz,liwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,iwork(*)
                    real(sp), intent(out) :: pl,pr,alphai(*),alphar(*),beta(*),dif(*),work(*)

                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine stgsen
#else
               module procedure stdlib_I64_stgsen
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alpha, beta, &
                         q, ldq, z, ldz, m, pl, pr, dif,work, lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    logical(lk), intent(in) :: wantq,wantz,select(*)
                    integer(ilp64), intent(in) :: ijob,lda,ldb,ldq,ldz,liwork,lwork,n
                    integer(ilp64), intent(out) :: info,m,iwork(*)
                    real(dp), intent(out) :: pl,pr,dif(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    complex(dp), intent(out) :: alpha(*),beta(*),work(*)
               end subroutine ztgsen
#else
               module procedure stdlib_I64_ztgsen
#endif
          end interface tgsen

          interface tgsja
          !! TGSJA computes the generalized singular value decomposition (GSVD)
          !! of two complex upper triangular (or trapezoidal) matrices A and B.
          !! On entry, it is assumed that matrices A and B have the following
          !! forms, which may be obtained by the preprocessing subroutine CGGSVP
          !! from a general M-by-N matrix A and P-by-N matrix B:
          !! N-K-L  K    L
          !! A =    K ( 0    A12  A13 ) if M-K-L >= 0;
          !! L ( 0     0   A23 )
          !! M-K-L ( 0     0    0  )
          !! N-K-L  K    L
          !! A =  K ( 0    A12  A13 ) if M-K-L < 0;
          !! M-K ( 0     0   A23 )
          !! N-K-L  K    L
          !! B =  L ( 0     0   B13 )
          !! P-L ( 0     0    0  )
          !! where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
          !! upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
          !! otherwise A23 is (M-K)-by-L upper trapezoidal.
          !! On exit,
          !! U**H *A*Q = D1*( 0 R ),    V**H *B*Q = D2*( 0 R ),
          !! where U, V and Q are unitary matrices.
          !! R is a nonsingular upper triangular matrix, and D1
          !! and D2 are ``diagonal'' matrices, which are of the following
          !! structures:
          !! If M-K-L >= 0,
          !! K  L
          !! D1 =     K ( I  0 )
          !! L ( 0  C )
          !! M-K-L ( 0  0 )
          !! K  L
          !! D2 = L   ( 0  S )
          !! P-L ( 0  0 )
          !! N-K-L  K    L
          !! ( 0 R ) = K (  0   R11  R12 ) K
          !! L (  0    0   R22 ) L
          !! where
          !! C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
          !! S = diag( BETA(K+1),  ... , BETA(K+L) ),
          !! C**2 + S**2 = I.
          !! R is stored in A(1:K+L,N-K-L+1:N) on exit.
          !! If M-K-L < 0,
          !! K M-K K+L-M
          !! D1 =   K ( I  0    0   )
          !! M-K ( 0  C    0   )
          !! K M-K K+L-M
          !! D2 =   M-K ( 0  S    0   )
          !! K+L-M ( 0  0    I   )
          !! P-L ( 0  0    0   )
          !! N-K-L  K   M-K  K+L-M
          !! ( 0 R ) =    K ( 0    R11  R12  R13  )
          !! M-K ( 0     0   R22  R23  )
          !! K+L-M ( 0     0    0   R33  )
          !! where
          !! C = diag( ALPHA(K+1), ... , ALPHA(M) ),
          !! S = diag( BETA(K+1),  ... , BETA(M) ),
          !! C**2 + S**2 = I.
          !! R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
          !! (  0  R22 R23 )
          !! in B(M-K+1:L,N+M-K-L+1:N) on exit.
          !! The computation of the unitary transformation matrices U, V or Q
          !! is optional.  These matrices may either be formed explicitly, or they
          !! may be postmultiplied into input matrices U1, V1, or Q1.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb,&
                          alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobq,jobu,jobv
                    integer(ilp), intent(out) :: info,ncycle
                    integer(ilp), intent(in) :: k,l,lda,ldb,ldq,ldu,ldv,m,n,p
                    real(sp), intent(in) :: tola,tolb
                    real(sp), intent(out) :: alpha(*),beta(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),u(ldu,*),v(ldv,*)

                    complex(sp), intent(out) :: work(*)
               end subroutine ctgsja
#else
               module procedure stdlib_ctgsja
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb,&
                          alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobq,jobu,jobv
                    integer(ilp), intent(out) :: info,ncycle
                    integer(ilp), intent(in) :: k,l,lda,ldb,ldq,ldu,ldv,m,n,p
                    real(dp), intent(in) :: tola,tolb
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),u(ldu,*),v(ldv,*)

                    real(dp), intent(out) :: alpha(*),beta(*),work(*)
               end subroutine dtgsja
#else
               module procedure stdlib_dtgsja
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb,&
                          alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobq,jobu,jobv
                    integer(ilp), intent(out) :: info,ncycle
                    integer(ilp), intent(in) :: k,l,lda,ldb,ldq,ldu,ldv,m,n,p
                    real(sp), intent(in) :: tola,tolb
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),u(ldu,*),v(ldv,*)

                    real(sp), intent(out) :: alpha(*),beta(*),work(*)
               end subroutine stgsja
#else
               module procedure stdlib_stgsja
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb,&
                          alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobq,jobu,jobv
                    integer(ilp), intent(out) :: info,ncycle
                    integer(ilp), intent(in) :: k,l,lda,ldb,ldq,ldu,ldv,m,n,p
                    real(dp), intent(in) :: tola,tolb
                    real(dp), intent(out) :: alpha(*),beta(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),u(ldu,*),v(ldv,*)

                    complex(dp), intent(out) :: work(*)
               end subroutine ztgsja
#else
               module procedure stdlib_ztgsja
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb,&
                          alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobq,jobu,jobv
                    integer(ilp64), intent(out) :: info,ncycle
                    integer(ilp64), intent(in) :: k,l,lda,ldb,ldq,ldu,ldv,m,n,p
                    real(sp), intent(in) :: tola,tolb
                    real(sp), intent(out) :: alpha(*),beta(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),u(ldu,*),v(ldv,*)

                    complex(sp), intent(out) :: work(*)
               end subroutine ctgsja
#else
               module procedure stdlib_I64_ctgsja
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb,&
                          alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobq,jobu,jobv
                    integer(ilp64), intent(out) :: info,ncycle
                    integer(ilp64), intent(in) :: k,l,lda,ldb,ldq,ldu,ldv,m,n,p
                    real(dp), intent(in) :: tola,tolb
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),u(ldu,*),v(ldv,*)

                    real(dp), intent(out) :: alpha(*),beta(*),work(*)
               end subroutine dtgsja
#else
               module procedure stdlib_I64_dtgsja
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb,&
                          alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobq,jobu,jobv
                    integer(ilp64), intent(out) :: info,ncycle
                    integer(ilp64), intent(in) :: k,l,lda,ldb,ldq,ldu,ldv,m,n,p
                    real(sp), intent(in) :: tola,tolb
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),u(ldu,*),v(ldv,*)

                    real(sp), intent(out) :: alpha(*),beta(*),work(*)
               end subroutine stgsja
#else
               module procedure stdlib_I64_stgsja
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb,&
                          alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobq,jobu,jobv
                    integer(ilp64), intent(out) :: info,ncycle
                    integer(ilp64), intent(in) :: k,l,lda,ldb,ldq,ldu,ldv,m,n,p
                    real(dp), intent(in) :: tola,tolb
                    real(dp), intent(out) :: alpha(*),beta(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),u(ldu,*),v(ldv,*)

                    complex(dp), intent(out) :: work(*)
               end subroutine ztgsja
#else
               module procedure stdlib_I64_ztgsja
#endif
          end interface tgsja

          interface tgsna
          !! TGSNA estimates reciprocal condition numbers for specified
          !! eigenvalues and/or eigenvectors of a matrix pair (A, B).
          !! (A, B) must be in generalized Schur canonical form, that is, A and
          !! B are both upper triangular.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                         s, dif, mm, m, work, lwork,iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,job
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: dif(*),s(*)
                    complex(sp), intent(in) :: a(lda,*),b(ldb,*),vl(ldvl,*),vr(ldvr,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctgsna
#else
               module procedure stdlib_ctgsna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                         s, dif, mm, m, work, lwork,iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,job
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(in) :: a(lda,*),b(ldb,*),vl(ldvl,*),vr(ldvr,*)
                    real(dp), intent(out) :: dif(*),s(*),work(*)
               end subroutine dtgsna
#else
               module procedure stdlib_dtgsna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                         s, dif, mm, m, work, lwork,iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,job
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(in) :: a(lda,*),b(ldb,*),vl(ldvl,*),vr(ldvr,*)
                    real(sp), intent(out) :: dif(*),s(*),work(*)
               end subroutine stgsna
#else
               module procedure stdlib_stgsna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                         s, dif, mm, m, work, lwork,iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,job
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: dif(*),s(*)
                    complex(dp), intent(in) :: a(lda,*),b(ldb,*),vl(ldvl,*),vr(ldvr,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztgsna
#else
               module procedure stdlib_ztgsna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                         s, dif, mm, m, work, lwork,iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,job
                    integer(ilp64), intent(out) :: info,m,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldb,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: dif(*),s(*)
                    complex(sp), intent(in) :: a(lda,*),b(ldb,*),vl(ldvl,*),vr(ldvr,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctgsna
#else
               module procedure stdlib_I64_ctgsna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                         s, dif, mm, m, work, lwork,iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,job
                    integer(ilp64), intent(out) :: info,m,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldb,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(in) :: a(lda,*),b(ldb,*),vl(ldvl,*),vr(ldvr,*)
                    real(dp), intent(out) :: dif(*),s(*),work(*)
               end subroutine dtgsna
#else
               module procedure stdlib_I64_dtgsna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                         s, dif, mm, m, work, lwork,iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,job
                    integer(ilp64), intent(out) :: info,m,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldb,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(in) :: a(lda,*),b(ldb,*),vl(ldvl,*),vr(ldvr,*)
                    real(sp), intent(out) :: dif(*),s(*),work(*)
               end subroutine stgsna
#else
               module procedure stdlib_I64_stgsna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                         s, dif, mm, m, work, lwork,iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,job
                    integer(ilp64), intent(out) :: info,m,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldb,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: dif(*),s(*)
                    complex(dp), intent(in) :: a(lda,*),b(ldb,*),vl(ldvl,*),vr(ldvr,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztgsna
#else
               module procedure stdlib_I64_ztgsna
#endif
          end interface tgsna

          interface tgsyl
          !! TGSYL solves the generalized Sylvester equation:
          !! A * R - L * B = scale * C            (1)
          !! D * R - L * E = scale * F
          !! where R and L are unknown m-by-n matrices, (A, D), (B, E) and
          !! (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
          !! respectively, with complex entries. A, B, D and E are upper
          !! triangular (i.e., (A,D) and (B,E) in generalized Schur form).
          !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
          !! is an output scaling factor chosen to avoid overflow.
          !! In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
          !! is defined as
          !! Z = [ kron(In, A)  -kron(B**H, Im) ]        (2)
          !! [ kron(In, D)  -kron(E**H, Im) ],
          !! Here Ix is the identity matrix of size x and X**H is the conjugate
          !! transpose of X. Kron(X, Y) is the Kronecker product between the
          !! matrices X and Y.
          !! If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b
          !! is solved for, which is equivalent to solve for R and L in
          !! A**H * R + D**H * L = scale * C           (3)
          !! R * B**H + L * E**H = scale * -F
          !! This case (TRANS = 'C') is used to compute an one-norm-based estimate
          !! of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
          !! and (B,E), using CLACON.
          !! If IJOB >= 1, TGSYL computes a Frobenius norm-based estimate of
          !! Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
          !! reciprocal of the smallest singular value of Z.
          !! This is a level-3 BLAS algorithm.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, &
                         f, ldf, scale, dif, work, lwork,iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: ijob,lda,ldb,ldc,ldd,lde,ldf,lwork,m,n
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(out) :: dif,scale
                    complex(sp), intent(in) :: a(lda,*),b(ldb,*),d(ldd,*),e(lde,*)
                    complex(sp), intent(inout) :: c(ldc,*),f(ldf,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctgsyl
#else
               module procedure stdlib_ctgsyl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, &
                         f, ldf, scale, dif, work, lwork,iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: ijob,lda,ldb,ldc,ldd,lde,ldf,lwork,m,n
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(out) :: dif,scale,work(*)
                    real(dp), intent(in) :: a(lda,*),b(ldb,*),d(ldd,*),e(lde,*)
                    real(dp), intent(inout) :: c(ldc,*),f(ldf,*)
               end subroutine dtgsyl
#else
               module procedure stdlib_dtgsyl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, &
                         f, ldf, scale, dif, work, lwork,iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: ijob,lda,ldb,ldc,ldd,lde,ldf,lwork,m,n
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(out) :: dif,scale,work(*)
                    real(sp), intent(in) :: a(lda,*),b(ldb,*),d(ldd,*),e(lde,*)
                    real(sp), intent(inout) :: c(ldc,*),f(ldf,*)
               end subroutine stgsyl
#else
               module procedure stdlib_stgsyl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, &
                         f, ldf, scale, dif, work, lwork,iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: ijob,lda,ldb,ldc,ldd,lde,ldf,lwork,m,n
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(out) :: dif,scale
                    complex(dp), intent(in) :: a(lda,*),b(ldb,*),d(ldd,*),e(lde,*)
                    complex(dp), intent(inout) :: c(ldc,*),f(ldf,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztgsyl
#else
               module procedure stdlib_ztgsyl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, &
                         f, ldf, scale, dif, work, lwork,iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(in) :: ijob,lda,ldb,ldc,ldd,lde,ldf,lwork,m,n
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(sp), intent(out) :: dif,scale
                    complex(sp), intent(in) :: a(lda,*),b(ldb,*),d(ldd,*),e(lde,*)
                    complex(sp), intent(inout) :: c(ldc,*),f(ldf,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctgsyl
#else
               module procedure stdlib_I64_ctgsyl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, &
                         f, ldf, scale, dif, work, lwork,iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(in) :: ijob,lda,ldb,ldc,ldd,lde,ldf,lwork,m,n
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(dp), intent(out) :: dif,scale,work(*)
                    real(dp), intent(in) :: a(lda,*),b(ldb,*),d(ldd,*),e(lde,*)
                    real(dp), intent(inout) :: c(ldc,*),f(ldf,*)
               end subroutine dtgsyl
#else
               module procedure stdlib_I64_dtgsyl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, &
                         f, ldf, scale, dif, work, lwork,iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(in) :: ijob,lda,ldb,ldc,ldd,lde,ldf,lwork,m,n
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(sp), intent(out) :: dif,scale,work(*)
                    real(sp), intent(in) :: a(lda,*),b(ldb,*),d(ldd,*),e(lde,*)
                    real(sp), intent(inout) :: c(ldc,*),f(ldf,*)
               end subroutine stgsyl
#else
               module procedure stdlib_I64_stgsyl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, &
                         f, ldf, scale, dif, work, lwork,iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trans
                    integer(ilp64), intent(in) :: ijob,lda,ldb,ldc,ldd,lde,ldf,lwork,m,n
                    integer(ilp64), intent(out) :: info,iwork(*)
                    real(dp), intent(out) :: dif,scale
                    complex(dp), intent(in) :: a(lda,*),b(ldb,*),d(ldd,*),e(lde,*)
                    complex(dp), intent(inout) :: c(ldc,*),f(ldf,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztgsyl
#else
               module procedure stdlib_I64_ztgsyl
#endif
          end interface tgsyl

          interface tpcon
          !! TPCON estimates the reciprocal of the condition number of a packed
          !! triangular matrix A, in either the 1-norm or the infinity-norm.
          !! The norm of A is computed and an estimate is obtained for
          !! norm(inv(A)), then the reciprocal of the condition number is
          !! computed as
          !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ctpcon( norm, uplo, diag, n, ap, rcond, work, rwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctpcon
#else
               module procedure stdlib_ctpcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dtpcon( norm, uplo, diag, n, ap, rcond, work, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: rcond,work(*)
                    real(dp), intent(in) :: ap(*)
               end subroutine dtpcon
#else
               module procedure stdlib_dtpcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine stpcon( norm, uplo, diag, n, ap, rcond, work, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: rcond,work(*)
                    real(sp), intent(in) :: ap(*)
               end subroutine stpcon
#else
               module procedure stdlib_stpcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ztpcon( norm, uplo, diag, n, ap, rcond, work, rwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztpcon
#else
               module procedure stdlib_ztpcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ctpcon( norm, uplo, diag, n, ap, rcond, work, rwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctpcon
#else
               module procedure stdlib_I64_ctpcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dtpcon( norm, uplo, diag, n, ap, rcond, work, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(out) :: rcond,work(*)
                    real(dp), intent(in) :: ap(*)
               end subroutine dtpcon
#else
               module procedure stdlib_I64_dtpcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine stpcon( norm, uplo, diag, n, ap, rcond, work, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(out) :: rcond,work(*)
                    real(sp), intent(in) :: ap(*)
               end subroutine stpcon
#else
               module procedure stdlib_I64_stpcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ztpcon( norm, uplo, diag, n, ap, rcond, work, rwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztpcon
#else
               module procedure stdlib_I64_ztpcon
#endif
          end interface tpcon

          interface tplqt
          !! TPLQT computes a blocked LQ factorization of a complex
          !! "triangular-pentagonal" matrix C, which is composed of a
          !! triangular block A and pentagonal block B, using the compact
          !! WY representation for Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctplqt( m, n, l, mb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l,mb
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine ctplqt
#else
               module procedure stdlib_ctplqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtplqt( m, n, l, mb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l,mb
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine dtplqt
#else
               module procedure stdlib_dtplqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stplqt( m, n, l, mb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l,mb
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine stplqt
#else
               module procedure stdlib_stplqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztplqt( m, n, l, mb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l,mb
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine ztplqt
#else
               module procedure stdlib_ztplqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctplqt( m, n, l, mb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldt,n,m,l,mb
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine ctplqt
#else
               module procedure stdlib_I64_ctplqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtplqt( m, n, l, mb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldt,n,m,l,mb
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine dtplqt
#else
               module procedure stdlib_I64_dtplqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stplqt( m, n, l, mb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldt,n,m,l,mb
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine stplqt
#else
               module procedure stdlib_I64_stplqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztplqt( m, n, l, mb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldt,n,m,l,mb
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine ztplqt
#else
               module procedure stdlib_I64_ztplqt
#endif
          end interface tplqt

          interface tplqt2
          !! TPLQT2 computes a LQ a factorization of a complex "triangular-pentagonal"
          !! matrix C, which is composed of a triangular block A and pentagonal block B,
          !! using the compact WY representation for Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctplqt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: t(ldt,*)
               end subroutine ctplqt2
#else
               module procedure stdlib_ctplqt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtplqt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: t(ldt,*)
               end subroutine dtplqt2
#else
               module procedure stdlib_dtplqt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stplqt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: t(ldt,*)
               end subroutine stplqt2
#else
               module procedure stdlib_stplqt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztplqt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: t(ldt,*)
               end subroutine ztplqt2
#else
               module procedure stdlib_ztplqt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctplqt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldt,n,m,l
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: t(ldt,*)
               end subroutine ctplqt2
#else
               module procedure stdlib_I64_ctplqt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtplqt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldt,n,m,l
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: t(ldt,*)
               end subroutine dtplqt2
#else
               module procedure stdlib_I64_dtplqt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stplqt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldt,n,m,l
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: t(ldt,*)
               end subroutine stplqt2
#else
               module procedure stdlib_I64_stplqt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztplqt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldt,n,m,l
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: t(ldt,*)
               end subroutine ztplqt2
#else
               module procedure stdlib_I64_ztplqt2
#endif
          end interface tplqt2

          interface tpmlqt
          !! TPMLQT applies a complex unitary matrix Q obtained from a
          !! "triangular-pentagonal" complex block reflector H to a general
          !! complex matrix C, which consists of two blocks A and B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctpmlqt( side, trans, m, n, k, l, mb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,lda,ldb,m,n,l,mb,ldt
                    complex(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctpmlqt
#else
               module procedure stdlib_ctpmlqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtpmlqt( side, trans, m, n, k, l, mb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,lda,ldb,m,n,l,mb,ldt
                    real(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtpmlqt
#else
               module procedure stdlib_dtpmlqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stpmlqt( side, trans, m, n, k, l, mb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,lda,ldb,m,n,l,mb,ldt
                    real(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine stpmlqt
#else
               module procedure stdlib_stpmlqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztpmlqt( side, trans, m, n, k, l, mb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,lda,ldb,m,n,l,mb,ldt
                    complex(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztpmlqt
#else
               module procedure stdlib_ztpmlqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctpmlqt( side, trans, m, n, k, l, mb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,ldv,lda,ldb,m,n,l,mb,ldt
                    complex(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctpmlqt
#else
               module procedure stdlib_I64_ctpmlqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtpmlqt( side, trans, m, n, k, l, mb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,ldv,lda,ldb,m,n,l,mb,ldt
                    real(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtpmlqt
#else
               module procedure stdlib_I64_dtpmlqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stpmlqt( side, trans, m, n, k, l, mb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,ldv,lda,ldb,m,n,l,mb,ldt
                    real(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine stpmlqt
#else
               module procedure stdlib_I64_stpmlqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztpmlqt( side, trans, m, n, k, l, mb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,ldv,lda,ldb,m,n,l,mb,ldt
                    complex(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztpmlqt
#else
               module procedure stdlib_I64_ztpmlqt
#endif
          end interface tpmlqt

          interface tpmqrt
          !! TPMQRT applies a complex orthogonal matrix Q obtained from a
          !! "triangular-pentagonal" complex block reflector H to a general
          !! complex matrix C, which consists of two blocks A and B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,lda,ldb,m,n,l,nb,ldt
                    complex(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctpmqrt
#else
               module procedure stdlib_ctpmqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,lda,ldb,m,n,l,nb,ldt
                    real(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtpmqrt
#else
               module procedure stdlib_dtpmqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,lda,ldb,m,n,l,nb,ldt
                    real(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine stpmqrt
#else
               module procedure stdlib_stpmqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,lda,ldb,m,n,l,nb,ldt
                    complex(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztpmqrt
#else
               module procedure stdlib_ztpmqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,ldv,lda,ldb,m,n,l,nb,ldt
                    complex(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctpmqrt
#else
               module procedure stdlib_I64_ctpmqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,ldv,lda,ldb,m,n,l,nb,ldt
                    real(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtpmqrt
#else
               module procedure stdlib_I64_dtpmqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,ldv,lda,ldb,m,n,l,nb,ldt
                    real(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine stpmqrt
#else
               module procedure stdlib_I64_stpmqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,ldv,lda,ldb,m,n,l,nb,ldt
                    complex(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztpmqrt
#else
               module procedure stdlib_I64_ztpmqrt
#endif
          end interface tpmqrt

          interface tpqrt
          !! TPQRT computes a blocked QR factorization of a complex
          !! "triangular-pentagonal" matrix C, which is composed of a
          !! triangular block A and pentagonal block B, using the compact
          !! WY representation for Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l,nb
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine ctpqrt
#else
               module procedure stdlib_ctpqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l,nb
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine dtpqrt
#else
               module procedure stdlib_dtpqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l,nb
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine stpqrt
#else
               module procedure stdlib_stpqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l,nb
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine ztpqrt
#else
               module procedure stdlib_ztpqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldt,n,m,l,nb
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine ctpqrt
#else
               module procedure stdlib_I64_ctpqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldt,n,m,l,nb
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine dtpqrt
#else
               module procedure stdlib_I64_dtpqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldt,n,m,l,nb
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine stpqrt
#else
               module procedure stdlib_I64_stpqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldt,n,m,l,nb
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine ztpqrt
#else
               module procedure stdlib_I64_ztpqrt
#endif
          end interface tpqrt

          interface tpqrt2
          !! TPQRT2 computes a QR factorization of a complex "triangular-pentagonal"
          !! matrix C, which is composed of a triangular block A and pentagonal block B,
          !! using the compact WY representation for Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: t(ldt,*)
               end subroutine ctpqrt2
#else
               module procedure stdlib_ctpqrt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: t(ldt,*)
               end subroutine dtpqrt2
#else
               module procedure stdlib_dtpqrt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: t(ldt,*)
               end subroutine stpqrt2
#else
               module procedure stdlib_stpqrt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: t(ldt,*)
               end subroutine ztpqrt2
#else
               module procedure stdlib_ztpqrt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldt,n,m,l
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: t(ldt,*)
               end subroutine ctpqrt2
#else
               module procedure stdlib_I64_ctpqrt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldt,n,m,l
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: t(ldt,*)
               end subroutine dtpqrt2
#else
               module procedure stdlib_I64_dtpqrt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldt,n,m,l
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: t(ldt,*)
               end subroutine stpqrt2
#else
               module procedure stdlib_I64_stpqrt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldt,n,m,l
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: t(ldt,*)
               end subroutine ztpqrt2
#else
               module procedure stdlib_I64_ztpqrt2
#endif
          end interface tpqrt2

          interface tprfb
          !! TPRFB applies a complex "triangular-pentagonal" block reflector H or its
          !! conjugate transpose H**H to a complex matrix C, which is composed of two
          !! blocks A and B, either from the left or right.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctprfb( side, trans, direct, storev, m, n, k, l,v, ldv, t, ldt, a, &
                         lda, b, ldb, work, ldwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,l,lda,ldb,ldt,ldv,ldwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(in) :: t(ldt,*),v(ldv,*)
                    complex(sp), intent(out) :: work(ldwork,*)
               end subroutine ctprfb
#else
               module procedure stdlib_ctprfb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtprfb( side, trans, direct, storev, m, n, k, l,v, ldv, t, ldt, a, &
                         lda, b, ldb, work, ldwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,l,lda,ldb,ldt,ldv,ldwork,m,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(in) :: t(ldt,*),v(ldv,*)
                    real(dp), intent(out) :: work(ldwork,*)
               end subroutine dtprfb
#else
               module procedure stdlib_dtprfb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stprfb( side, trans, direct, storev, m, n, k, l,v, ldv, t, ldt, a, &
                         lda, b, ldb, work, ldwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,l,lda,ldb,ldt,ldv,ldwork,m,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(in) :: t(ldt,*),v(ldv,*)
                    real(sp), intent(out) :: work(ldwork,*)
               end subroutine stprfb
#else
               module procedure stdlib_stprfb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztprfb( side, trans, direct, storev, m, n, k, l,v, ldv, t, ldt, a, &
                         lda, b, ldb, work, ldwork )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,l,lda,ldb,ldt,ldv,ldwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(in) :: t(ldt,*),v(ldv,*)
                    complex(dp), intent(out) :: work(ldwork,*)
               end subroutine ztprfb
#else
               module procedure stdlib_ztprfb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctprfb( side, trans, direct, storev, m, n, k, l,v, ldv, t, ldt, a, &
                         lda, b, ldb, work, ldwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp64), intent(in) :: k,l,lda,ldb,ldt,ldv,ldwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(in) :: t(ldt,*),v(ldv,*)
                    complex(sp), intent(out) :: work(ldwork,*)
               end subroutine ctprfb
#else
               module procedure stdlib_I64_ctprfb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtprfb( side, trans, direct, storev, m, n, k, l,v, ldv, t, ldt, a, &
                         lda, b, ldb, work, ldwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp64), intent(in) :: k,l,lda,ldb,ldt,ldv,ldwork,m,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(in) :: t(ldt,*),v(ldv,*)
                    real(dp), intent(out) :: work(ldwork,*)
               end subroutine dtprfb
#else
               module procedure stdlib_I64_dtprfb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stprfb( side, trans, direct, storev, m, n, k, l,v, ldv, t, ldt, a, &
                         lda, b, ldb, work, ldwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp64), intent(in) :: k,l,lda,ldb,ldt,ldv,ldwork,m,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(in) :: t(ldt,*),v(ldv,*)
                    real(sp), intent(out) :: work(ldwork,*)
               end subroutine stprfb
#else
               module procedure stdlib_I64_stprfb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztprfb( side, trans, direct, storev, m, n, k, l,v, ldv, t, ldt, a, &
                         lda, b, ldb, work, ldwork )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp64), intent(in) :: k,l,lda,ldb,ldt,ldv,ldwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(in) :: t(ldt,*),v(ldv,*)
                    complex(dp), intent(out) :: work(ldwork,*)
               end subroutine ztprfb
#else
               module procedure stdlib_I64_ztprfb
#endif
          end interface tprfb

          interface tprfs
          !! TPRFS provides error bounds and backward error estimates for the
          !! solution to a system of linear equations with a triangular packed
          !! coefficient matrix.
          !! The solution matrix X must be computed by CTPTRS or some other
          !! means before entering this routine.  TPRFS does not do iterative
          !! refinement because doing so cannot improve the backward error.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: ap(*),b(ldb,*),x(ldx,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctprfs
#else
               module procedure stdlib_ctprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,ferr, berr, &
                         work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(in) :: ap(*),b(ldb,*),x(ldx,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine dtprfs
#else
               module procedure stdlib_dtprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,ferr, berr, &
                         work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(in) :: ap(*),b(ldb,*),x(ldx,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine stprfs
#else
               module procedure stdlib_stprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: ap(*),b(ldb,*),x(ldx,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztprfs
#else
               module procedure stdlib_ztprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: ap(*),b(ldb,*),x(ldx,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctprfs
#else
               module procedure stdlib_I64_ctprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,ferr, berr, &
                         work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(in) :: ap(*),b(ldb,*),x(ldx,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine dtprfs
#else
               module procedure stdlib_I64_dtprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,ferr, berr, &
                         work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(in) :: ap(*),b(ldb,*),x(ldx,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine stprfs
#else
               module procedure stdlib_I64_stprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: ap(*),b(ldb,*),x(ldx,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztprfs
#else
               module procedure stdlib_I64_ztprfs
#endif
          end interface tprfs

          interface tptri
          !! TPTRI computes the inverse of a complex upper or lower triangular
          !! matrix A stored in packed format.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctptri( uplo, diag, n, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: ap(*)
               end subroutine ctptri
#else
               module procedure stdlib_ctptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtptri( uplo, diag, n, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: ap(*)
               end subroutine dtptri
#else
               module procedure stdlib_dtptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stptri( uplo, diag, n, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: ap(*)
               end subroutine stptri
#else
               module procedure stdlib_stptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztptri( uplo, diag, n, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: ap(*)
               end subroutine ztptri
#else
               module procedure stdlib_ztptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctptri( uplo, diag, n, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    complex(sp), intent(inout) :: ap(*)
               end subroutine ctptri
#else
               module procedure stdlib_I64_ctptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtptri( uplo, diag, n, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(inout) :: ap(*)
               end subroutine dtptri
#else
               module procedure stdlib_I64_dtptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stptri( uplo, diag, n, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(inout) :: ap(*)
               end subroutine stptri
#else
               module procedure stdlib_I64_stptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztptri( uplo, diag, n, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    complex(dp), intent(inout) :: ap(*)
               end subroutine ztptri
#else
               module procedure stdlib_I64_ztptri
#endif
          end interface tptri

          interface tptrs
          !! TPTRS solves a triangular system of the form
          !! A * X = B,  A**T * X = B,  or  A**H * X = B,
          !! where A is a triangular matrix of order N stored in packed format,
          !! and B is an N-by-NRHS matrix.  A check is made to verify that A is
          !! nonsingular.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine ctptrs
#else
               module procedure stdlib_ctptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dtptrs
#else
               module procedure stdlib_dtptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine stptrs
#else
               module procedure stdlib_stptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine ztptrs
#else
               module procedure stdlib_ztptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine ctptrs
#else
               module procedure stdlib_I64_ctptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dtptrs
#else
               module procedure stdlib_I64_dtptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine stptrs
#else
               module procedure stdlib_I64_stptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine ztptrs
#else
               module procedure stdlib_I64_ztptrs
#endif
          end interface tptrs

          interface tpttf
          !! TPTTF copies a triangular matrix A from standard packed format (TP)
          !! to rectangular full packed format (TF).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctpttf( transr, uplo, n, ap, arf, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(in) :: ap(0:*)
                    complex(sp), intent(out) :: arf(0:*)
               end subroutine ctpttf
#else
               module procedure stdlib_ctpttf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtpttf( transr, uplo, n, ap, arf, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: ap(0:*)
                    real(dp), intent(out) :: arf(0:*)
               end subroutine dtpttf
#else
               module procedure stdlib_dtpttf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stpttf( transr, uplo, n, ap, arf, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: ap(0:*)
                    real(sp), intent(out) :: arf(0:*)
               end subroutine stpttf
#else
               module procedure stdlib_stpttf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztpttf( transr, uplo, n, ap, arf, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(in) :: ap(0:*)
                    complex(dp), intent(out) :: arf(0:*)
               end subroutine ztpttf
#else
               module procedure stdlib_ztpttf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctpttf( transr, uplo, n, ap, arf, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    complex(sp), intent(in) :: ap(0:*)
                    complex(sp), intent(out) :: arf(0:*)
               end subroutine ctpttf
#else
               module procedure stdlib_I64_ctpttf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtpttf( transr, uplo, n, ap, arf, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(dp), intent(in) :: ap(0:*)
                    real(dp), intent(out) :: arf(0:*)
               end subroutine dtpttf
#else
               module procedure stdlib_I64_dtpttf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stpttf( transr, uplo, n, ap, arf, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    real(sp), intent(in) :: ap(0:*)
                    real(sp), intent(out) :: arf(0:*)
               end subroutine stpttf
#else
               module procedure stdlib_I64_stpttf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztpttf( transr, uplo, n, ap, arf, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n
                    complex(dp), intent(in) :: ap(0:*)
                    complex(dp), intent(out) :: arf(0:*)
               end subroutine ztpttf
#else
               module procedure stdlib_I64_ztpttf
#endif
          end interface tpttf

          interface tpttr
          !! TPTTR copies a triangular matrix A from standard packed format (TP)
          !! to standard full format (TR).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctpttr( uplo, n, ap, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    complex(sp), intent(out) :: a(lda,*)
                    complex(sp), intent(in) :: ap(*)
               end subroutine ctpttr
#else
               module procedure stdlib_ctpttr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtpttr( uplo, n, ap, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    real(dp), intent(out) :: a(lda,*)
                    real(dp), intent(in) :: ap(*)
               end subroutine dtpttr
#else
               module procedure stdlib_dtpttr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stpttr( uplo, n, ap, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    real(sp), intent(out) :: a(lda,*)
                    real(sp), intent(in) :: ap(*)
               end subroutine stpttr
#else
               module procedure stdlib_stpttr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztpttr( uplo, n, ap, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    complex(dp), intent(out) :: a(lda,*)
                    complex(dp), intent(in) :: ap(*)
               end subroutine ztpttr
#else
               module procedure stdlib_ztpttr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctpttr( uplo, n, ap, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,lda
                    complex(sp), intent(out) :: a(lda,*)
                    complex(sp), intent(in) :: ap(*)
               end subroutine ctpttr
#else
               module procedure stdlib_I64_ctpttr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtpttr( uplo, n, ap, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,lda
                    real(dp), intent(out) :: a(lda,*)
                    real(dp), intent(in) :: ap(*)
               end subroutine dtpttr
#else
               module procedure stdlib_I64_dtpttr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stpttr( uplo, n, ap, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,lda
                    real(sp), intent(out) :: a(lda,*)
                    real(sp), intent(in) :: ap(*)
               end subroutine stpttr
#else
               module procedure stdlib_I64_stpttr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztpttr( uplo, n, ap, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,lda
                    complex(dp), intent(out) :: a(lda,*)
                    complex(dp), intent(in) :: ap(*)
               end subroutine ztpttr
#else
               module procedure stdlib_I64_ztpttr
#endif
          end interface tpttr

          interface trcon
          !! TRCON estimates the reciprocal of the condition number of a
          !! triangular matrix A, in either the 1-norm or the infinity-norm.
          !! The norm of A is computed and an estimate is obtained for
          !! norm(inv(A)), then the reciprocal of the condition number is
          !! computed as
          !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ctrcon( norm, uplo, diag, n, a, lda, rcond, work,rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctrcon
#else
               module procedure stdlib_ctrcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dtrcon( norm, uplo, diag, n, a, lda, rcond, work,iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: rcond,work(*)
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dtrcon
#else
               module procedure stdlib_dtrcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine strcon( norm, uplo, diag, n, a, lda, rcond, work,iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: rcond,work(*)
                    real(sp), intent(in) :: a(lda,*)
               end subroutine strcon
#else
               module procedure stdlib_strcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ztrcon( norm, uplo, diag, n, a, lda, rcond, work,rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztrcon
#else
               module procedure stdlib_ztrcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ctrcon( norm, uplo, diag, n, a, lda, rcond, work,rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctrcon
#else
               module procedure stdlib_I64_ctrcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dtrcon( norm, uplo, diag, n, a, lda, rcond, work,iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(out) :: rcond,work(*)
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dtrcon
#else
               module procedure stdlib_I64_dtrcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine strcon( norm, uplo, diag, n, a, lda, rcond, work,iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(out) :: rcond,work(*)
                    real(sp), intent(in) :: a(lda,*)
               end subroutine strcon
#else
               module procedure stdlib_I64_strcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ztrcon( norm, uplo, diag, n, a, lda, rcond, work,rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztrcon
#else
               module procedure stdlib_I64_ztrcon
#endif
          end interface trcon

          interface trevc
          !! TREVC computes some or all of the right and/or left eigenvectors of
          !! a complex upper triangular matrix T.
          !! Matrices of this type are produced by the Schur factorization of
          !! a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.
          !! The right eigenvector x and the left eigenvector y of T corresponding
          !! to an eigenvalue w are defined by:
          !! T*x = w*x,     (y**H)*T = w*(y**H)
          !! where y**H denotes the conjugate transpose of the vector y.
          !! The eigenvalues are not input to this routine, but are read directly
          !! from the diagonal of T.
          !! This routine returns the matrices X and/or Y of right and left
          !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
          !! input matrix.  If Q is the unitary factor that reduces a matrix A to
          !! Schur form T, then Q*X and Q*Y are the matrices of right and left
          !! eigenvectors of A.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctrevc
#else
               module procedure stdlib_ctrevc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
                         work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(dp), intent(in) :: t(ldt,*)
                    real(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtrevc
#else
               module procedure stdlib_dtrevc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine strevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
                         work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(sp), intent(in) :: t(ldt,*)
                    real(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(sp), intent(out) :: work(*)
               end subroutine strevc
#else
               module procedure stdlib_strevc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztrevc
#else
               module procedure stdlib_ztrevc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
                         work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp64), intent(out) :: info,m
                    integer(ilp64), intent(in) :: ldt,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctrevc
#else
               module procedure stdlib_I64_ctrevc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
                         work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp64), intent(out) :: info,m
                    integer(ilp64), intent(in) :: ldt,ldvl,ldvr,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(dp), intent(in) :: t(ldt,*)
                    real(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtrevc
#else
               module procedure stdlib_I64_dtrevc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine strevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
                         work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp64), intent(out) :: info,m
                    integer(ilp64), intent(in) :: ldt,ldvl,ldvr,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(sp), intent(in) :: t(ldt,*)
                    real(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(sp), intent(out) :: work(*)
               end subroutine strevc
#else
               module procedure stdlib_I64_strevc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
                         work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp64), intent(out) :: info,m
                    integer(ilp64), intent(in) :: ldt,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztrevc
#else
               module procedure stdlib_I64_ztrevc
#endif
          end interface trevc

          interface trevc3
          !! TREVC3 computes some or all of the right and/or left eigenvectors of
          !! a complex upper triangular matrix T.
          !! Matrices of this type are produced by the Schur factorization of
          !! a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.
          !! The right eigenvector x and the left eigenvector y of T corresponding
          !! to an eigenvalue w are defined by:
          !! T*x = w*x,     (y**H)*T = w*(y**H)
          !! where y**H denotes the conjugate transpose of the vector y.
          !! The eigenvalues are not input to this routine, but are read directly
          !! from the diagonal of T.
          !! This routine returns the matrices X and/or Y of right and left
          !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
          !! input matrix. If Q is the unitary factor that reduces a matrix A to
          !! Schur form T, then Q*X and Q*Y are the matrices of right and left
          !! eigenvectors of A.
          !! This uses a Level 3 BLAS version of the back transformation.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrevc3( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m,&
                          work, lwork, rwork, lrwork, info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,lwork,lrwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctrevc3
#else
               module procedure stdlib_ctrevc3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtrevc3( side, howmny, select, n, t, ldt, vl, ldvl,vr, ldvr, mm, m,&
                          work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(dp), intent(in) :: t(ldt,*)
                    real(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtrevc3
#else
               module procedure stdlib_dtrevc3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine strevc3( side, howmny, select, n, t, ldt, vl, ldvl,vr, ldvr, mm, m,&
                          work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(sp), intent(in) :: t(ldt,*)
                    real(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(sp), intent(out) :: work(*)
               end subroutine strevc3
#else
               module procedure stdlib_strevc3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrevc3( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m,&
                          work, lwork, rwork, lrwork, info)
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,lwork,lrwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztrevc3
#else
               module procedure stdlib_ztrevc3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctrevc3( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m,&
                          work, lwork, rwork, lrwork, info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp64), intent(out) :: info,m
                    integer(ilp64), intent(in) :: ldt,ldvl,ldvr,lwork,lrwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctrevc3
#else
               module procedure stdlib_I64_ctrevc3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtrevc3( side, howmny, select, n, t, ldt, vl, ldvl,vr, ldvr, mm, m,&
                          work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp64), intent(out) :: info,m
                    integer(ilp64), intent(in) :: ldt,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(dp), intent(in) :: t(ldt,*)
                    real(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtrevc3
#else
               module procedure stdlib_I64_dtrevc3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine strevc3( side, howmny, select, n, t, ldt, vl, ldvl,vr, ldvr, mm, m,&
                          work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp64), intent(out) :: info,m
                    integer(ilp64), intent(in) :: ldt,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(sp), intent(in) :: t(ldt,*)
                    real(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(sp), intent(out) :: work(*)
               end subroutine strevc3
#else
               module procedure stdlib_I64_strevc3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztrevc3( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m,&
                          work, lwork, rwork, lrwork, info)
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,side
                    integer(ilp64), intent(out) :: info,m
                    integer(ilp64), intent(in) :: ldt,ldvl,ldvr,lwork,lrwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztrevc3
#else
               module procedure stdlib_I64_ztrevc3
#endif
          end interface trevc3

          interface trexc
          !! TREXC reorders the Schur factorization of a complex matrix
          !! A = Q*T*Q**H, so that the diagonal element of T with row index IFST
          !! is moved to row ILST.
          !! The Schur form T is reordered by a unitary similarity transformation
          !! Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
          !! postmultplying it with Z.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq
                    integer(ilp), intent(in) :: ifst,ilst,ldq,ldt,n
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(inout) :: q(ldq,*),t(ldt,*)
               end subroutine ctrexc
#else
               module procedure stdlib_ctrexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dtrexc( compq, n, t, ldt, q, ldq, ifst, ilst, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq
                    integer(ilp), intent(inout) :: ifst,ilst
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldq,ldt,n
                    real(dp), intent(inout) :: q(ldq,*),t(ldt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtrexc
#else
               module procedure stdlib_dtrexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine strexc( compq, n, t, ldt, q, ldq, ifst, ilst, work,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq
                    integer(ilp), intent(inout) :: ifst,ilst
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldq,ldt,n
                    real(sp), intent(inout) :: q(ldq,*),t(ldt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine strexc
#else
               module procedure stdlib_strexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq
                    integer(ilp), intent(in) :: ifst,ilst,ldq,ldt,n
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(inout) :: q(ldq,*),t(ldt,*)
               end subroutine ztrexc
#else
               module procedure stdlib_ztrexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctrexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq
                    integer(ilp64), intent(in) :: ifst,ilst,ldq,ldt,n
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(inout) :: q(ldq,*),t(ldt,*)
               end subroutine ctrexc
#else
               module procedure stdlib_I64_ctrexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dtrexc( compq, n, t, ldt, q, ldq, ifst, ilst, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq
                    integer(ilp64), intent(inout) :: ifst,ilst
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldq,ldt,n
                    real(dp), intent(inout) :: q(ldq,*),t(ldt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtrexc
#else
               module procedure stdlib_I64_dtrexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine strexc( compq, n, t, ldt, q, ldq, ifst, ilst, work,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq
                    integer(ilp64), intent(inout) :: ifst,ilst
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldq,ldt,n
                    real(sp), intent(inout) :: q(ldq,*),t(ldt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine strexc
#else
               module procedure stdlib_I64_strexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztrexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq
                    integer(ilp64), intent(in) :: ifst,ilst,ldq,ldt,n
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(inout) :: q(ldq,*),t(ldt,*)
               end subroutine ztrexc
#else
               module procedure stdlib_I64_ztrexc
#endif
          end interface trexc

          interface trrfs
          !! TRRFS provides error bounds and backward error estimates for the
          !! solution to a system of linear equations with a triangular
          !! coefficient matrix.
          !! The solution matrix X must be computed by CTRTRS or some other
          !! means before entering this routine.  TRRFS does not do iterative
          !! refinement because doing so cannot improve the backward error.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,ldx, ferr, &
                         berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: a(lda,*),b(ldb,*),x(ldx,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctrrfs
#else
               module procedure stdlib_ctrrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtrrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,ldx, ferr, &
                         berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,ldx,n,nrhs
                    real(dp), intent(in) :: a(lda,*),b(ldb,*),x(ldx,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine dtrrfs
#else
               module procedure stdlib_dtrrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine strrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,ldx, ferr, &
                         berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,ldx,n,nrhs
                    real(sp), intent(in) :: a(lda,*),b(ldb,*),x(ldx,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine strrfs
#else
               module procedure stdlib_strrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,ldx, ferr, &
                         berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: a(lda,*),b(ldb,*),x(ldx,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztrrfs
#else
               module procedure stdlib_ztrrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctrrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,ldx, ferr, &
                         berr, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: a(lda,*),b(ldb,*),x(ldx,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctrrfs
#else
               module procedure stdlib_I64_ctrrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtrrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,ldx, ferr, &
                         berr, work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldb,ldx,n,nrhs
                    real(dp), intent(in) :: a(lda,*),b(ldb,*),x(ldx,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine dtrrfs
#else
               module procedure stdlib_I64_dtrrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine strrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,ldx, ferr, &
                         berr, work, iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: lda,ldb,ldx,n,nrhs
                    real(sp), intent(in) :: a(lda,*),b(ldb,*),x(ldx,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine strrfs
#else
               module procedure stdlib_I64_strrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztrrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,ldx, ferr, &
                         berr, work, rwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: a(lda,*),b(ldb,*),x(ldx,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztrrfs
#else
               module procedure stdlib_I64_ztrrfs
#endif
          end interface trrfs

          interface trsen
          !! TRSEN reorders the Schur factorization of a complex matrix
          !! A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in
          !! the leading positions on the diagonal of the upper triangular matrix
          !! T, and the leading columns of Q form an orthonormal basis of the
          !! corresponding right invariant subspace.
          !! Optionally the routine computes the reciprocal condition numbers of
          !! the cluster of eigenvalues and/or the invariant subspace.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ctrsen( job, compq, select, n, t, ldt, q, ldq, w, m, s,sep, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq,job
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldq,ldt,lwork,n
                    real(sp), intent(out) :: s,sep
                    logical(lk), intent(in) :: select(*)
                    complex(sp), intent(inout) :: q(ldq,*),t(ldt,*)
                    complex(sp), intent(out) :: w(*),work(*)
               end subroutine ctrsen
#else
               module procedure stdlib_ctrsen
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dtrsen( job, compq, select, n, t, ldt, q, ldq, wr, wi,m, s, sep, work, &
                         lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq,job
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    integer(ilp), intent(in) :: ldq,ldt,liwork,lwork,n
                    real(dp), intent(out) :: s,sep,wi(*),work(*),wr(*)
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(inout) :: q(ldq,*),t(ldt,*)
               end subroutine dtrsen
#else
               module procedure stdlib_dtrsen
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine strsen( job, compq, select, n, t, ldt, q, ldq, wr, wi,m, s, sep, work, &
                         lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq,job
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    integer(ilp), intent(in) :: ldq,ldt,liwork,lwork,n
                    real(sp), intent(out) :: s,sep,wi(*),work(*),wr(*)
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(inout) :: q(ldq,*),t(ldt,*)
               end subroutine strsen
#else
               module procedure stdlib_strsen
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ztrsen( job, compq, select, n, t, ldt, q, ldq, w, m, s,sep, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: compq,job
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldq,ldt,lwork,n
                    real(dp), intent(out) :: s,sep
                    logical(lk), intent(in) :: select(*)
                    complex(dp), intent(inout) :: q(ldq,*),t(ldt,*)
                    complex(dp), intent(out) :: w(*),work(*)
               end subroutine ztrsen
#else
               module procedure stdlib_ztrsen
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ctrsen( job, compq, select, n, t, ldt, q, ldq, w, m, s,sep, work, lwork,&
                          info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq,job
                    integer(ilp64), intent(out) :: info,m
                    integer(ilp64), intent(in) :: ldq,ldt,lwork,n
                    real(sp), intent(out) :: s,sep
                    logical(lk), intent(in) :: select(*)
                    complex(sp), intent(inout) :: q(ldq,*),t(ldt,*)
                    complex(sp), intent(out) :: w(*),work(*)
               end subroutine ctrsen
#else
               module procedure stdlib_I64_ctrsen
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dtrsen( job, compq, select, n, t, ldt, q, ldq, wr, wi,m, s, sep, work, &
                         lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq,job
                    integer(ilp64), intent(out) :: info,m,iwork(*)
                    integer(ilp64), intent(in) :: ldq,ldt,liwork,lwork,n
                    real(dp), intent(out) :: s,sep,wi(*),work(*),wr(*)
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(inout) :: q(ldq,*),t(ldt,*)
               end subroutine dtrsen
#else
               module procedure stdlib_I64_dtrsen
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine strsen( job, compq, select, n, t, ldt, q, ldq, wr, wi,m, s, sep, work, &
                         lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq,job
                    integer(ilp64), intent(out) :: info,m,iwork(*)
                    integer(ilp64), intent(in) :: ldq,ldt,liwork,lwork,n
                    real(sp), intent(out) :: s,sep,wi(*),work(*),wr(*)
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(inout) :: q(ldq,*),t(ldt,*)
               end subroutine strsen
#else
               module procedure stdlib_I64_strsen
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ztrsen( job, compq, select, n, t, ldt, q, ldq, w, m, s,sep, work, lwork,&
                          info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: compq,job
                    integer(ilp64), intent(out) :: info,m
                    integer(ilp64), intent(in) :: ldq,ldt,lwork,n
                    real(dp), intent(out) :: s,sep
                    logical(lk), intent(in) :: select(*)
                    complex(dp), intent(inout) :: q(ldq,*),t(ldt,*)
                    complex(dp), intent(out) :: w(*),work(*)
               end subroutine ztrsen
#else
               module procedure stdlib_I64_ztrsen
#endif
          end interface trsen

          interface trsna
          !! TRSNA estimates reciprocal condition numbers for specified
          !! eigenvalues and/or right eigenvectors of a complex upper triangular
          !! matrix T (or of any matrix Q*T*Q**H with Q unitary).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, &
                         mm, m, work, ldwork, rwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,job
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,ldwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: rwork(*),s(*),sep(*)
                    complex(sp), intent(in) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(sp), intent(out) :: work(ldwork,*)
               end subroutine ctrsna
#else
               module procedure stdlib_ctrsna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dtrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm, &
                         m, work, ldwork, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,job
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,ldwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: s(*),sep(*),work(ldwork,*)
                    real(dp), intent(in) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
               end subroutine dtrsna
#else
               module procedure stdlib_dtrsna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine strsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm, &
                         m, work, ldwork, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,job
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,ldwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: s(*),sep(*),work(ldwork,*)
                    real(sp), intent(in) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
               end subroutine strsna
#else
               module procedure stdlib_strsna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, &
                         mm, m, work, ldwork, rwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: howmny,job
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,ldwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: rwork(*),s(*),sep(*)
                    complex(dp), intent(in) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(dp), intent(out) :: work(ldwork,*)
               end subroutine ztrsna
#else
               module procedure stdlib_ztrsna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, &
                         mm, m, work, ldwork, rwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,job
                    integer(ilp64), intent(out) :: info,m
                    integer(ilp64), intent(in) :: ldt,ldvl,ldvr,ldwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: rwork(*),s(*),sep(*)
                    complex(sp), intent(in) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(sp), intent(out) :: work(ldwork,*)
               end subroutine ctrsna
#else
               module procedure stdlib_I64_ctrsna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dtrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm, &
                         m, work, ldwork, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,job
                    integer(ilp64), intent(out) :: info,m,iwork(*)
                    integer(ilp64), intent(in) :: ldt,ldvl,ldvr,ldwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: s(*),sep(*),work(ldwork,*)
                    real(dp), intent(in) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
               end subroutine dtrsna
#else
               module procedure stdlib_I64_dtrsna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine strsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm, &
                         m, work, ldwork, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,job
                    integer(ilp64), intent(out) :: info,m,iwork(*)
                    integer(ilp64), intent(in) :: ldt,ldvl,ldvr,ldwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: s(*),sep(*),work(ldwork,*)
                    real(sp), intent(in) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
               end subroutine strsna
#else
               module procedure stdlib_I64_strsna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, &
                         mm, m, work, ldwork, rwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: howmny,job
                    integer(ilp64), intent(out) :: info,m
                    integer(ilp64), intent(in) :: ldt,ldvl,ldvr,ldwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: rwork(*),s(*),sep(*)
                    complex(dp), intent(in) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(dp), intent(out) :: work(ldwork,*)
               end subroutine ztrsna
#else
               module procedure stdlib_I64_ztrsna
#endif
          end interface trsna

          interface trsyl
          !! TRSYL solves the complex Sylvester matrix equation:
          !! op(A)*X + X*op(B) = scale*C or
          !! op(A)*X - X*op(B) = scale*C,
          !! where op(A) = A or A**H, and A and B are both upper triangular. A is
          !! M-by-M and B is N-by-N; the right hand side C and the solution X are
          !! M-by-N; and scale is an output scale factor, set <= 1 to avoid
          !! overflow in X.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ctrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trana,tranb
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: isgn,lda,ldb,ldc,m,n
                    real(sp), intent(out) :: scale
                    complex(sp), intent(in) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(inout) :: c(ldc,*)
               end subroutine ctrsyl
#else
               module procedure stdlib_ctrsyl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dtrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trana,tranb
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: isgn,lda,ldb,ldc,m,n
                    real(dp), intent(out) :: scale
                    real(dp), intent(in) :: a(lda,*),b(ldb,*)
                    real(dp), intent(inout) :: c(ldc,*)
               end subroutine dtrsyl
#else
               module procedure stdlib_dtrsyl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine strsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trana,tranb
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: isgn,lda,ldb,ldc,m,n
                    real(sp), intent(out) :: scale
                    real(sp), intent(in) :: a(lda,*),b(ldb,*)
                    real(sp), intent(inout) :: c(ldc,*)
               end subroutine strsyl
#else
               module procedure stdlib_strsyl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ztrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: trana,tranb
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: isgn,lda,ldb,ldc,m,n
                    real(dp), intent(out) :: scale
                    complex(dp), intent(in) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(inout) :: c(ldc,*)
               end subroutine ztrsyl
#else
               module procedure stdlib_ztrsyl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ctrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trana,tranb
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: isgn,lda,ldb,ldc,m,n
                    real(sp), intent(out) :: scale
                    complex(sp), intent(in) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(inout) :: c(ldc,*)
               end subroutine ctrsyl
#else
               module procedure stdlib_I64_ctrsyl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine dtrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trana,tranb
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: isgn,lda,ldb,ldc,m,n
                    real(dp), intent(out) :: scale
                    real(dp), intent(in) :: a(lda,*),b(ldb,*)
                    real(dp), intent(inout) :: c(ldc,*)
               end subroutine dtrsyl
#else
               module procedure stdlib_I64_dtrsyl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine strsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trana,tranb
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: isgn,lda,ldb,ldc,m,n
                    real(sp), intent(out) :: scale
                    real(sp), intent(in) :: a(lda,*),b(ldb,*)
                    real(sp), intent(inout) :: c(ldc,*)
               end subroutine strsyl
#else
               module procedure stdlib_I64_strsyl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine ztrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: trana,tranb
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: isgn,lda,ldb,ldc,m,n
                    real(dp), intent(out) :: scale
                    complex(dp), intent(in) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(inout) :: c(ldc,*)
               end subroutine ztrsyl
#else
               module procedure stdlib_I64_ztrsyl
#endif
          end interface trsyl

          interface trtri
          !! TRTRI computes the inverse of a complex upper or lower triangular
          !! matrix A.
          !! This is the Level 3 BLAS version of the algorithm.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrtri( uplo, diag, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine ctrtri
#else
               module procedure stdlib_ctrtri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtrtri( uplo, diag, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dtrtri
#else
               module procedure stdlib_dtrtri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine strtri( uplo, diag, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine strtri
#else
               module procedure stdlib_strtri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrtri( uplo, diag, n, a, lda, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine ztrtri
#else
               module procedure stdlib_ztrtri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctrtri( uplo, diag, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine ctrtri
#else
               module procedure stdlib_I64_ctrtri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtrtri( uplo, diag, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dtrtri
#else
               module procedure stdlib_I64_dtrtri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine strtri( uplo, diag, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine strtri
#else
               module procedure stdlib_I64_strtri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztrtri( uplo, diag, n, a, lda, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine ztrtri
#else
               module procedure stdlib_I64_ztrtri
#endif
          end interface trtri

          interface trtrs
          !! TRTRS solves a triangular system of the form
          !! A * X = B,  A**T * X = B,  or  A**H * X = B,
          !! where A is a triangular matrix of order N, and B is an N-by-NRHS
          !! matrix.  A check is made to verify that A is nonsingular.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine ctrtrs
#else
               module procedure stdlib_ctrtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtrtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dtrtrs
#else
               module procedure stdlib_dtrtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine strtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine strtrs
#else
               module procedure stdlib_strtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine ztrtrs
#else
               module procedure stdlib_ztrtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctrtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine ctrtrs
#else
               module procedure stdlib_I64_ctrtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtrtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dtrtrs
#else
               module procedure stdlib_I64_dtrtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine strtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine strtrs
#else
               module procedure stdlib_I64_strtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztrtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldb,n,nrhs
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine ztrtrs
#else
               module procedure stdlib_I64_ztrtrs
#endif
          end interface trtrs

          interface trttf
          !! TRTTF copies a triangular matrix A from standard full format (TR)
          !! to rectangular full packed format (TF) .
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrttf( transr, uplo, n, a, lda, arf, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    complex(sp), intent(in) :: a(0:lda-1,0:*)
                    complex(sp), intent(out) :: arf(0:*)
               end subroutine ctrttf
#else
               module procedure stdlib_ctrttf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtrttf( transr, uplo, n, a, lda, arf, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    real(dp), intent(in) :: a(0:lda-1,0:*)
                    real(dp), intent(out) :: arf(0:*)
               end subroutine dtrttf
#else
               module procedure stdlib_dtrttf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine strttf( transr, uplo, n, a, lda, arf, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    real(sp), intent(in) :: a(0:lda-1,0:*)
                    real(sp), intent(out) :: arf(0:*)
               end subroutine strttf
#else
               module procedure stdlib_strttf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrttf( transr, uplo, n, a, lda, arf, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    complex(dp), intent(in) :: a(0:lda-1,0:*)
                    complex(dp), intent(out) :: arf(0:*)
               end subroutine ztrttf
#else
               module procedure stdlib_ztrttf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctrttf( transr, uplo, n, a, lda, arf, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,lda
                    complex(sp), intent(in) :: a(0:lda-1,0:*)
                    complex(sp), intent(out) :: arf(0:*)
               end subroutine ctrttf
#else
               module procedure stdlib_I64_ctrttf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtrttf( transr, uplo, n, a, lda, arf, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,lda
                    real(dp), intent(in) :: a(0:lda-1,0:*)
                    real(dp), intent(out) :: arf(0:*)
               end subroutine dtrttf
#else
               module procedure stdlib_I64_dtrttf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine strttf( transr, uplo, n, a, lda, arf, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,lda
                    real(sp), intent(in) :: a(0:lda-1,0:*)
                    real(sp), intent(out) :: arf(0:*)
               end subroutine strttf
#else
               module procedure stdlib_I64_strttf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztrttf( transr, uplo, n, a, lda, arf, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: transr,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,lda
                    complex(dp), intent(in) :: a(0:lda-1,0:*)
                    complex(dp), intent(out) :: arf(0:*)
               end subroutine ztrttf
#else
               module procedure stdlib_I64_ztrttf
#endif
          end interface trttf

          interface trttp
          !! TRTTP copies a triangular matrix A from full format (TR) to standard
          !! packed format (TP).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrttp( uplo, n, a, lda, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: ap(*)
               end subroutine ctrttp
#else
               module procedure stdlib_ctrttp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtrttp( uplo, n, a, lda, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: ap(*)
               end subroutine dtrttp
#else
               module procedure stdlib_dtrttp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine strttp( uplo, n, a, lda, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: ap(*)
               end subroutine strttp
#else
               module procedure stdlib_strttp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrttp( uplo, n, a, lda, ap, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: ap(*)
               end subroutine ztrttp
#else
               module procedure stdlib_ztrttp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctrttp( uplo, n, a, lda, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,lda
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: ap(*)
               end subroutine ctrttp
#else
               module procedure stdlib_I64_ctrttp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtrttp( uplo, n, a, lda, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,lda
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: ap(*)
               end subroutine dtrttp
#else
               module procedure stdlib_I64_dtrttp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine strttp( uplo, n, a, lda, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,lda
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: ap(*)
               end subroutine strttp
#else
               module procedure stdlib_I64_strttp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztrttp( uplo, n, a, lda, ap, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: n,lda
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: ap(*)
               end subroutine ztrttp
#else
               module procedure stdlib_I64_ztrttp
#endif
          end interface trttp

          interface tzrzf
          !! TZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
          !! to upper triangular form by means of unitary transformations.
          !! The upper trapezoidal matrix A is factored as
          !! A = ( R  0 ) * Z,
          !! where Z is an N-by-N unitary matrix and R is an M-by-M upper
          !! triangular matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctzrzf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine ctzrzf
#else
               module procedure stdlib_ctzrzf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtzrzf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dtzrzf
#else
               module procedure stdlib_dtzrzf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stzrzf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine stzrzf
#else
               module procedure stdlib_stzrzf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztzrzf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine ztzrzf
#else
               module procedure stdlib_ztzrzf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ctzrzf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine ctzrzf
#else
               module procedure stdlib_I64_ctzrzf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine dtzrzf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dtzrzf
#else
               module procedure stdlib_I64_dtzrzf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine stzrzf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine stzrzf
#else
               module procedure stdlib_I64_stzrzf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine ztzrzf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine ztzrzf
#else
               module procedure stdlib_I64_ztzrzf
#endif
          end interface tzrzf

          interface unbdb
          !! UNBDB simultaneously bidiagonalizes the blocks of an M-by-M
          !! partitioned unitary matrix X:
          !! [ B11 | B12 0  0 ]
          !! [ X11 | X12 ]   [ P1 |    ] [  0  |  0 -I  0 ] [ Q1 |    ]**H
          !! X = [-----------] = [---------] [----------------] [---------]   .
          !! [ X21 | X22 ]   [    | P2 ] [ B21 | B22 0  0 ] [    | Q2 ]
          !! [  0  |  0  0  I ]
          !! X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
          !! not the case, then X must be transposed and/or permuted. This can be
          !! done in constant time using the TRANS and SIGNS options. See CUNCSD
          !! for details.)
          !! The unitary matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
          !! (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
          !! represented implicitly by Householder vectors.
          !! B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
          !! implicitly by angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cunbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
                         ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: signs,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldx11,ldx12,ldx21,ldx22,lwork,m,p,q
                    real(sp), intent(out) :: phi(*),theta(*)
                    complex(sp), intent(out) :: taup1(*),taup2(*),tauq1(*),tauq2(*),work(*)

                    complex(sp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(&
                              ldx22,*)
               end subroutine cunbdb
#else
               module procedure stdlib_cunbdb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zunbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
                         ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: signs,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldx11,ldx12,ldx21,ldx22,lwork,m,p,q
                    real(dp), intent(out) :: phi(*),theta(*)
                    complex(dp), intent(out) :: taup1(*),taup2(*),tauq1(*),tauq2(*),work(*)

                    complex(dp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(&
                              ldx22,*)
               end subroutine zunbdb
#else
               module procedure stdlib_zunbdb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cunbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
                         ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: signs,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldx11,ldx12,ldx21,ldx22,lwork,m,p,q
                    real(sp), intent(out) :: phi(*),theta(*)
                    complex(sp), intent(out) :: taup1(*),taup2(*),tauq1(*),tauq2(*),work(*)

                    complex(sp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(&
                              ldx22,*)
               end subroutine cunbdb
#else
               module procedure stdlib_I64_cunbdb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zunbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
                         ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: signs,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldx11,ldx12,ldx21,ldx22,lwork,m,p,q
                    real(dp), intent(out) :: phi(*),theta(*)
                    complex(dp), intent(out) :: taup1(*),taup2(*),tauq1(*),tauq2(*),work(*)

                    complex(dp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(&
                              ldx22,*)
               end subroutine zunbdb
#else
               module procedure stdlib_I64_zunbdb
#endif
          end interface unbdb

          interface unbdb1
          !! UNBDB1 simultaneously bidiagonalizes the blocks of a tall and skinny
          !! matrix X with orthonomal columns:
          !! [ B11 ]
          !! [ X11 ]   [ P1 |    ] [  0  ]
          !! [-----] = [---------] [-----] Q1**T .
          !! [ X21 ]   [    | P2 ] [ B21 ]
          !! [  0  ]
          !! X11 is P-by-Q, and X21 is (M-P)-by-Q. Q must be no larger than P,
          !! M-P, or M-Q. Routines CUNBDB2, CUNBDB3, and CUNBDB4 handle cases in
          !! which Q is not the minimum dimension.
          !! The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !! Householder vectors.
          !! B11 and B12 are Q-by-Q bidiagonal matrices represented implicitly by
          !! angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cunbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*)
                    complex(sp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cunbdb1
#else
               module procedure stdlib_cunbdb1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zunbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*)
                    complex(dp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zunbdb1
#else
               module procedure stdlib_zunbdb1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cunbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*)
                    complex(sp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cunbdb1
#else
               module procedure stdlib_I64_cunbdb1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zunbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*)
                    complex(dp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zunbdb1
#else
               module procedure stdlib_I64_zunbdb1
#endif
          end interface unbdb1

          interface unbdb2
          !! UNBDB2 simultaneously bidiagonalizes the blocks of a tall and skinny
          !! matrix X with orthonomal columns:
          !! [ B11 ]
          !! [ X11 ]   [ P1 |    ] [  0  ]
          !! [-----] = [---------] [-----] Q1**T .
          !! [ X21 ]   [    | P2 ] [ B21 ]
          !! [  0  ]
          !! X11 is P-by-Q, and X21 is (M-P)-by-Q. P must be no larger than M-P,
          !! Q, or M-Q. Routines CUNBDB1, CUNBDB3, and CUNBDB4 handle cases in
          !! which P is not the minimum dimension.
          !! The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !! Householder vectors.
          !! B11 and B12 are P-by-P bidiagonal matrices represented implicitly by
          !! angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cunbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*)
                    complex(sp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cunbdb2
#else
               module procedure stdlib_cunbdb2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zunbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*)
                    complex(dp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zunbdb2
#else
               module procedure stdlib_zunbdb2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cunbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*)
                    complex(sp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cunbdb2
#else
               module procedure stdlib_I64_cunbdb2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zunbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*)
                    complex(dp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zunbdb2
#else
               module procedure stdlib_I64_zunbdb2
#endif
          end interface unbdb2

          interface unbdb3
          !! UNBDB3 simultaneously bidiagonalizes the blocks of a tall and skinny
          !! matrix X with orthonomal columns:
          !! [ B11 ]
          !! [ X11 ]   [ P1 |    ] [  0  ]
          !! [-----] = [---------] [-----] Q1**T .
          !! [ X21 ]   [    | P2 ] [ B21 ]
          !! [  0  ]
          !! X11 is P-by-Q, and X21 is (M-P)-by-Q. M-P must be no larger than P,
          !! Q, or M-Q. Routines CUNBDB1, CUNBDB2, and CUNBDB4 handle cases in
          !! which M-P is not the minimum dimension.
          !! The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !! Householder vectors.
          !! B11 and B12 are (M-P)-by-(M-P) bidiagonal matrices represented
          !! implicitly by angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cunbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*)
                    complex(sp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cunbdb3
#else
               module procedure stdlib_cunbdb3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zunbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*)
                    complex(dp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zunbdb3
#else
               module procedure stdlib_zunbdb3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cunbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*)
                    complex(sp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cunbdb3
#else
               module procedure stdlib_I64_cunbdb3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zunbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*)
                    complex(dp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zunbdb3
#else
               module procedure stdlib_I64_zunbdb3
#endif
          end interface unbdb3

          interface unbdb4
          !! UNBDB4 simultaneously bidiagonalizes the blocks of a tall and skinny
          !! matrix X with orthonomal columns:
          !! [ B11 ]
          !! [ X11 ]   [ P1 |    ] [  0  ]
          !! [-----] = [---------] [-----] Q1**T .
          !! [ X21 ]   [    | P2 ] [ B21 ]
          !! [  0  ]
          !! X11 is P-by-Q, and X21 is (M-P)-by-Q. M-Q must be no larger than P,
          !! M-P, or Q. Routines CUNBDB1, CUNBDB2, and CUNBDB3 handle cases in
          !! which M-Q is not the minimum dimension.
          !! The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !! Householder vectors.
          !! B11 and B12 are (M-Q)-by-(M-Q) bidiagonal matrices represented
          !! implicitly by angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cunbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, phantom, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*)
                    complex(sp), intent(out) :: phantom(*),taup1(*),taup2(*),tauq1(*),work(*)

                    complex(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cunbdb4
#else
               module procedure stdlib_cunbdb4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zunbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, phantom, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*)
                    complex(dp), intent(out) :: phantom(*),taup1(*),taup2(*),tauq1(*),work(*)

                    complex(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zunbdb4
#else
               module procedure stdlib_zunbdb4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cunbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, phantom, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*)
                    complex(sp), intent(out) :: phantom(*),taup1(*),taup2(*),tauq1(*),work(*)

                    complex(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cunbdb4
#else
               module procedure stdlib_I64_cunbdb4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zunbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, phantom, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*)
                    complex(dp), intent(out) :: phantom(*),taup1(*),taup2(*),tauq1(*),work(*)

                    complex(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zunbdb4
#else
               module procedure stdlib_I64_zunbdb4
#endif
          end interface unbdb4

          interface unbdb5
          !! UNBDB5 orthogonalizes the column vector
          !! X = [ X1 ]
          !! [ X2 ]
          !! with respect to the columns of
          !! Q = [ Q1 ] .
          !! [ Q2 ]
          !! The columns of Q must be orthonormal.
          !! If the projection is zero according to Kahan's "twice is enough"
          !! criterion, then some other vector from the orthogonal complement
          !! is returned. This vector is chosen in an arbitrary but deterministic
          !! way.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x1(*),x2(*)
               end subroutine cunbdb5
#else
               module procedure stdlib_cunbdb5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x1(*),x2(*)
               end subroutine zunbdb5
#else
               module procedure stdlib_zunbdb5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cunbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x1(*),x2(*)
               end subroutine cunbdb5
#else
               module procedure stdlib_I64_cunbdb5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zunbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x1(*),x2(*)
               end subroutine zunbdb5
#else
               module procedure stdlib_I64_zunbdb5
#endif
          end interface unbdb5

          interface unbdb6
          !! UNBDB6 orthogonalizes the column vector
          !! X = [ X1 ]
          !! [ X2 ]
          !! with respect to the columns of
          !! Q = [ Q1 ] .
          !! [ Q2 ]
          !! The columns of Q must be orthonormal.
          !! If the projection is zero according to Kahan's "twice is enough"
          !! criterion, then the zero vector is returned.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x1(*),x2(*)
               end subroutine cunbdb6
#else
               module procedure stdlib_cunbdb6
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x1(*),x2(*)
               end subroutine zunbdb6
#else
               module procedure stdlib_zunbdb6
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x1(*),x2(*)
               end subroutine cunbdb6
#else
               module procedure stdlib_I64_cunbdb6
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x1(*),x2(*)
               end subroutine zunbdb6
#else
               module procedure stdlib_I64_zunbdb6
#endif
          end interface unbdb6

          interface uncsd
          !! UNCSD computes the CS decomposition of an M-by-M partitioned
          !! unitary matrix X:
          !! [  I  0  0 |  0  0  0 ]
          !! [  0  C  0 |  0 -S  0 ]
          !! [ X11 | X12 ]   [ U1 |    ] [  0  0  0 |  0  0 -I ] [ V1 |    ]**H
          !! X = [-----------] = [---------] [---------------------] [---------]   .
          !! [ X21 | X22 ]   [    | U2 ] [  0  0  0 |  I  0  0 ] [    | V2 ]
          !! [  0  S  0 |  0  C  0 ]
          !! [  0  0  I |  0  0  0 ]
          !! X11 is P-by-Q. The unitary matrices U1, U2, V1, and V2 are P-by-P,
          !! (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
          !! R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
          !! which R = MIN(P,M-P,Q,M-Q).
#ifdef STDLIB_EXTERNAL_LAPACK
               recursive subroutine cuncsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, &
               x11, ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, &
                         ldv1t, v2t,ldv2t, work, lwork, rwork, lrwork,iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,signs,trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,ldx11,ldx12,ldx21,ldx22,&
                              lrwork,lwork,m,p,q
                    real(sp), intent(out) :: theta(*),rwork(*)
                    complex(sp), intent(out) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*),&
                              work(*)
                    complex(sp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(&
                              ldx22,*)
               end subroutine cuncsd
#else
               module procedure stdlib_cuncsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               recursive subroutine zuncsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, &
               x11, ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, &
                         ldv1t, v2t,ldv2t, work, lwork, rwork, lrwork,iwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,signs,trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,ldx11,ldx12,ldx21,ldx22,&
                              lrwork,lwork,m,p,q
                    real(dp), intent(out) :: theta(*),rwork(*)
                    complex(dp), intent(out) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*),&
                              work(*)
                    complex(dp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(&
                              ldx22,*)
               end subroutine zuncsd
#else
               module procedure stdlib_zuncsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               recursive subroutine cuncsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, &
               x11, ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, &
                         ldv1t, v2t,ldv2t, work, lwork, rwork, lrwork,iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,signs,trans
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,ldx11,ldx12,ldx21,ldx22,&
                              lrwork,lwork,m,p,q
                    real(sp), intent(out) :: theta(*),rwork(*)
                    complex(sp), intent(out) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*),&
                              work(*)
                    complex(sp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(&
                              ldx22,*)
               end subroutine cuncsd
#else
               module procedure stdlib_I64_cuncsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               recursive subroutine zuncsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, &
               x11, ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, &
                         ldv1t, v2t,ldv2t, work, lwork, rwork, lrwork,iwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,signs,trans
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,ldx11,ldx12,ldx21,ldx22,&
                              lrwork,lwork,m,p,q
                    real(dp), intent(out) :: theta(*),rwork(*)
                    complex(dp), intent(out) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*),&
                              work(*)
                    complex(dp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(&
                              ldx22,*)
               end subroutine zuncsd
#else
               module procedure stdlib_I64_zuncsd
#endif
          end interface uncsd

          interface uncsd2by1
          !! UNCSD2BY1 computes the CS decomposition of an M-by-Q matrix X with
          !! orthonormal columns that has been partitioned into a 2-by-1 block
          !! structure:
          !! [  I1 0  0 ]
          !! [  0  C  0 ]
          !! [ X11 ]   [ U1 |    ] [  0  0  0 ]
          !! X = [-----] = [---------] [----------] V1**T .
          !! [ X21 ]   [    | U2 ] [  0  0  0 ]
          !! [  0  S  0 ]
          !! [  0  0  I2]
          !! X11 is P-by-Q. The unitary matrices U1, U2, and V1 are P-by-P,
          !! (M-P)-by-(M-P), and Q-by-Q, respectively. C and S are R-by-R
          !! nonnegative diagonal matrices satisfying C^2 + S^2 = I, in which
          !! R = MIN(P,M-P,Q,M-Q). I1 is a K1-by-K1 identity matrix and I2 is a
          !! K2-by-K2 identity matrix, where K1 = MAX(Q+P-M,0), K2 = MAX(Q-P,0).
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cuncsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta,&
                          u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, rwork, lrwork, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,lwork,ldx11,ldx21,m,p,q,&
                              lrwork
                    real(sp), intent(out) :: rwork(*),theta(*)
                    complex(sp), intent(out) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),work(*)
                    complex(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cuncsd2by1
#else
               module procedure stdlib_cuncsd2by1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zuncsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta,&
                          u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, rwork, lrwork, iwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,lwork,ldx11,ldx21,m,p,q,&
                              lrwork
                    real(dp), intent(out) :: rwork(*),theta(*)
                    complex(dp), intent(out) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),work(*)
                    complex(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zuncsd2by1
#else
               module procedure stdlib_zuncsd2by1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine cuncsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta,&
                          u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, rwork, lrwork, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldu1,ldu2,ldv1t,lwork,ldx11,ldx21,m,p,q,&
                              lrwork
                    real(sp), intent(out) :: rwork(*),theta(*)
                    complex(sp), intent(out) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),work(*)
                    complex(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cuncsd2by1
#else
               module procedure stdlib_I64_cuncsd2by1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               subroutine zuncsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta,&
                          u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, rwork, lrwork, iwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: jobu1,jobu2,jobv1t
                    integer(ilp64), intent(out) :: info,iwork(*)
                    integer(ilp64), intent(in) :: ldu1,ldu2,ldv1t,lwork,ldx11,ldx21,m,p,q,&
                              lrwork
                    real(dp), intent(out) :: rwork(*),theta(*)
                    complex(dp), intent(out) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),work(*)
                    complex(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zuncsd2by1
#else
               module procedure stdlib_I64_zuncsd2by1
#endif
          end interface uncsd2by1

          interface ung2l
          !! UNG2L generates an m by n complex matrix Q with orthonormal columns,
          !! which is defined as the last n columns of a product of k elementary
          !! reflectors of order m
          !! Q  =  H(k) . . . H(2) H(1)
          !! as returned by CGEQLF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cung2l( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cung2l
#else
               module procedure stdlib_cung2l
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zung2l( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zung2l
#else
               module procedure stdlib_zung2l
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cung2l( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cung2l
#else
               module procedure stdlib_I64_cung2l
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zung2l( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zung2l
#else
               module procedure stdlib_I64_zung2l
#endif
          end interface ung2l

          interface ung2r
          !! UNG2R generates an m by n complex matrix Q with orthonormal columns,
          !! which is defined as the first n columns of a product of k elementary
          !! reflectors of order m
          !! Q  =  H(1) H(2) . . . H(k)
          !! as returned by CGEQRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cung2r( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cung2r
#else
               module procedure stdlib_cung2r
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zung2r( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zung2r
#else
               module procedure stdlib_zung2r
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cung2r( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cung2r
#else
               module procedure stdlib_I64_cung2r
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zung2r( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zung2r
#else
               module procedure stdlib_I64_zung2r
#endif
          end interface ung2r

          interface ungbr
          !! UNGBR generates one of the complex unitary matrices Q or P**H
          !! determined by CGEBRD when reducing a complex matrix A to bidiagonal
          !! form: A = Q * B * P**H.  Q and P**H are defined as products of
          !! elementary reflectors H(i) or G(i) respectively.
          !! If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
          !! is of order M:
          !! if m >= k, Q = H(1) H(2) . . . H(k) and UNGBR returns the first n
          !! columns of Q, where m >= n >= k;
          !! if m < k, Q = H(1) H(2) . . . H(m-1) and UNGBR returns Q as an
          !! M-by-M matrix.
          !! If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
          !! is of order N:
          !! if k < n, P**H = G(k) . . . G(2) G(1) and UNGBR returns the first m
          !! rows of P**H, where n >= m >= k;
          !! if k >= n, P**H = G(n-1) . . . G(2) G(1) and UNGBR returns P**H as
          !! an N-by-N matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cungbr( vect, m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungbr
#else
               module procedure stdlib_cungbr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zungbr( vect, m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungbr
#else
               module procedure stdlib_zungbr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cungbr( vect, m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungbr
#else
               module procedure stdlib_I64_cungbr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zungbr( vect, m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungbr
#else
               module procedure stdlib_I64_zungbr
#endif
          end interface ungbr

          interface unghr
          !! UNGHR generates a complex unitary matrix Q which is defined as the
          !! product of IHI-ILO elementary reflectors of order N, as returned by
          !! CGEHRD:
          !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunghr
#else
               module procedure stdlib_cunghr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunghr
#else
               module procedure stdlib_zunghr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cunghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunghr
#else
               module procedure stdlib_I64_cunghr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zunghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunghr
#else
               module procedure stdlib_I64_zunghr
#endif
          end interface unghr

          interface unglq
          !! UNGLQ generates an M-by-N complex matrix Q with orthonormal rows,
          !! which is defined as the first M rows of a product of K elementary
          !! reflectors of order N
          !! Q  =  H(k)**H . . . H(2)**H H(1)**H
          !! as returned by CGELQF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunglq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunglq
#else
               module procedure stdlib_cunglq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunglq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunglq
#else
               module procedure stdlib_zunglq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cunglq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunglq
#else
               module procedure stdlib_I64_cunglq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zunglq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunglq
#else
               module procedure stdlib_I64_zunglq
#endif
          end interface unglq

          interface ungql
          !! UNGQL generates an M-by-N complex matrix Q with orthonormal columns,
          !! which is defined as the last N columns of a product of K elementary
          !! reflectors of order M
          !! Q  =  H(k) . . . H(2) H(1)
          !! as returned by CGEQLF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cungql( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungql
#else
               module procedure stdlib_cungql
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zungql( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungql
#else
               module procedure stdlib_zungql
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cungql( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungql
#else
               module procedure stdlib_I64_cungql
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zungql( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungql
#else
               module procedure stdlib_I64_zungql
#endif
          end interface ungql

          interface ungqr
          !! UNGQR generates an M-by-N complex matrix Q with orthonormal columns,
          !! which is defined as the first N columns of a product of K elementary
          !! reflectors of order M
          !! Q  =  H(1) H(2) . . . H(k)
          !! as returned by CGEQRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cungqr( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungqr
#else
               module procedure stdlib_cungqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zungqr( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungqr
#else
               module procedure stdlib_zungqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cungqr( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungqr
#else
               module procedure stdlib_I64_cungqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zungqr( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungqr
#else
               module procedure stdlib_I64_zungqr
#endif
          end interface ungqr

          interface ungrq
          !! UNGRQ generates an M-by-N complex matrix Q with orthonormal rows,
          !! which is defined as the last M rows of a product of K elementary
          !! reflectors of order N
          !! Q  =  H(1)**H H(2)**H . . . H(k)**H
          !! as returned by CGERQF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cungrq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungrq
#else
               module procedure stdlib_cungrq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zungrq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungrq
#else
               module procedure stdlib_zungrq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cungrq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungrq
#else
               module procedure stdlib_I64_cungrq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zungrq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungrq
#else
               module procedure stdlib_I64_zungrq
#endif
          end interface ungrq

          interface ungtr
          !! UNGTR generates a complex unitary matrix Q which is defined as the
          !! product of n-1 elementary reflectors of order N, as returned by
          !! CHETRD:
          !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
          !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cungtr( uplo, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungtr
#else
               module procedure stdlib_cungtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zungtr( uplo, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungtr
#else
               module procedure stdlib_zungtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cungtr( uplo, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungtr
#else
               module procedure stdlib_I64_cungtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zungtr( uplo, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungtr
#else
               module procedure stdlib_I64_zungtr
#endif
          end interface ungtr

          interface ungtsqr
          !! UNGTSQR generates an M-by-N complex matrix Q_out with orthonormal
          !! columns, which are the first N columns of a product of comlpex unitary
          !! matrices of order M which are returned by CLATSQR
          !! Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).
          !! See the documentation for CLATSQR.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cungtsqr( m, n, mb, nb, a, lda, t, ldt, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: t(ldt,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungtsqr
#else
               module procedure stdlib_cungtsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zungtsqr( m, n, mb, nb, a, lda, t, ldt, work, lwork,info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: t(ldt,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungtsqr
#else
               module procedure stdlib_zungtsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cungtsqr( m, n, mb, nb, a, lda, t, ldt, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: t(ldt,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungtsqr
#else
               module procedure stdlib_I64_cungtsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zungtsqr( m, n, mb, nb, a, lda, t, ldt, work, lwork,info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: t(ldt,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungtsqr
#else
               module procedure stdlib_I64_zungtsqr
#endif
          end interface ungtsqr

          interface ungtsqr_row
          !! UNGTSQR_ROW generates an M-by-N complex matrix Q_out with
          !! orthonormal columns from the output of CLATSQR. These N orthonormal
          !! columns are the first N columns of a product of complex unitary
          !! matrices Q(k)_in of order M, which are returned by CLATSQR in
          !! a special format.
          !! Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).
          !! The input matrices Q(k)_in are stored in row and column blocks in A.
          !! See the documentation of CLATSQR for more details on the format of
          !! Q(k)_in, where each Q(k)_in is represented by block Householder
          !! transformations. This routine calls an auxiliary routine CLARFB_GETT,
          !! where the computation is performed on each individual block. The
          !! algorithm first sweeps NB-sized column blocks from the right to left
          !! starting in the bottom row block and continues to the top row block
          !! (hence _ROW in the routine name). This sweep is in reverse order of
          !! the order in which CLATSQR generates the output blocks.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cungtsqr_row( m, n, mb, nb, a, lda, t, ldt, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: t(ldt,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungtsqr_row
#else
               module procedure stdlib_cungtsqr_row
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zungtsqr_row( m, n, mb, nb, a, lda, t, ldt, work,lwork, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: t(ldt,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungtsqr_row
#else
               module procedure stdlib_zungtsqr_row
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cungtsqr_row( m, n, mb, nb, a, lda, t, ldt, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: t(ldt,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungtsqr_row
#else
               module procedure stdlib_I64_cungtsqr_row
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zungtsqr_row( m, n, mb, nb, a, lda, t, ldt, work,lwork, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: t(ldt,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungtsqr_row
#else
               module procedure stdlib_I64_zungtsqr_row
#endif
          end interface ungtsqr_row

          interface unhr_col
          !! UNHR_COL takes an M-by-N complex matrix Q_in with orthonormal columns
          !! as input, stored in A, and performs Householder Reconstruction (HR),
          !! i.e. reconstructs Householder vectors V(i) implicitly representing
          !! another M-by-N matrix Q_out, with the property that Q_in = Q_out*S,
          !! where S is an N-by-N diagonal matrix with diagonal entries
          !! equal to +1 or -1. The Householder vectors (columns V(i) of V) are
          !! stored in A on output, and the diagonal entries of S are stored in D.
          !! Block reflectors are also returned in T
          !! (same output format as CGEQRT).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunhr_col( m, n, nb, a, lda, t, ldt, d, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: d(*),t(ldt,*)
               end subroutine cunhr_col
#else
               module procedure stdlib_cunhr_col
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunhr_col( m, n, nb, a, lda, t, ldt, d, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: d(*),t(ldt,*)
               end subroutine zunhr_col
#else
               module procedure stdlib_zunhr_col
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cunhr_col( m, n, nb, a, lda, t, ldt, d, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,m,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: d(*),t(ldt,*)
               end subroutine cunhr_col
#else
               module procedure stdlib_I64_cunhr_col
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zunhr_col( m, n, nb, a, lda, t, ldt, d, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldt,m,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: d(*),t(ldt,*)
               end subroutine zunhr_col
#else
               module procedure stdlib_I64_zunhr_col
#endif
          end interface unhr_col

          interface unm2l
          !! UNM2L overwrites the general complex m-by-n matrix C with
          !! Q * C  if SIDE = 'L' and TRANS = 'N', or
          !! Q**H* C  if SIDE = 'L' and TRANS = 'C', or
          !! C * Q  if SIDE = 'R' and TRANS = 'N', or
          !! C * Q**H if SIDE = 'R' and TRANS = 'C',
          !! where Q is a complex unitary matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(k) . . . H(2) H(1)
          !! as returned by CGEQLF. Q is of order m if SIDE = 'L' and of order n
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunm2l( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunm2l
#else
               module procedure stdlib_cunm2l
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunm2l( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunm2l
#else
               module procedure stdlib_zunm2l
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cunm2l( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunm2l
#else
               module procedure stdlib_I64_cunm2l
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zunm2l( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunm2l
#else
               module procedure stdlib_I64_zunm2l
#endif
          end interface unm2l

          interface unm2r
          !! UNM2R overwrites the general complex m-by-n matrix C with
          !! Q * C  if SIDE = 'L' and TRANS = 'N', or
          !! Q**H* C  if SIDE = 'L' and TRANS = 'C', or
          !! C * Q  if SIDE = 'R' and TRANS = 'N', or
          !! C * Q**H if SIDE = 'R' and TRANS = 'C',
          !! where Q is a complex unitary matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(1) H(2) . . . H(k)
          !! as returned by CGEQRF. Q is of order m if SIDE = 'L' and of order n
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunm2r( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunm2r
#else
               module procedure stdlib_cunm2r
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunm2r( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunm2r
#else
               module procedure stdlib_zunm2r
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cunm2r( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunm2r
#else
               module procedure stdlib_I64_cunm2r
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zunm2r( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunm2r
#else
               module procedure stdlib_I64_zunm2r
#endif
          end interface unm2r

          interface unmbr
          !! If VECT = 'Q', UNMBR: overwrites the general complex M-by-N matrix C
          !! with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! If VECT = 'P', UNMBR overwrites the general complex M-by-N matrix C
          !! with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      P * C          C * P
          !! TRANS = 'C':      P**H * C       C * P**H
          !! Here Q and P**H are the unitary matrices determined by CGEBRD when
          !! reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
          !! and P**H are defined as products of elementary reflectors H(i) and
          !! G(i) respectively.
          !! Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
          !! order of the unitary matrix Q or P**H that is applied.
          !! If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
          !! if nq >= k, Q = H(1) H(2) . . . H(k);
          !! if nq < k, Q = H(1) H(2) . . . H(nq-1).
          !! If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
          !! if k < nq, P = G(1) G(2) . . . G(k);
          !! if k >= nq, P = G(1) G(2) . . . G(nq-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunmbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmbr
#else
               module procedure stdlib_cunmbr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunmbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmbr
#else
               module procedure stdlib_zunmbr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cunmbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans,vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmbr
#else
               module procedure stdlib_I64_cunmbr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zunmbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans,vect
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmbr
#else
               module procedure stdlib_I64_zunmbr
#endif
          end interface unmbr

          interface unmhr
          !! UNMHR overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix of order nq, with nq = m if
          !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !! IHI-ILO elementary reflectors, as returned by CGEHRD:
          !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(in) :: ihi,ilo,lda,ldc,lwork,m,n
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmhr
#else
               module procedure stdlib_cunmhr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(in) :: ihi,ilo,lda,ldc,lwork,m,n
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmhr
#else
               module procedure stdlib_zunmhr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cunmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(in) :: ihi,ilo,lda,ldc,lwork,m,n
                    integer(ilp64), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmhr
#else
               module procedure stdlib_I64_cunmhr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zunmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(in) :: ihi,ilo,lda,ldc,lwork,m,n
                    integer(ilp64), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmhr
#else
               module procedure stdlib_I64_zunmhr
#endif
          end interface unmhr

          interface unmlq
          !! UNMLQ overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(k)**H . . . H(2)**H H(1)**H
          !! as returned by CGELQF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunmlq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmlq
#else
               module procedure stdlib_cunmlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunmlq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmlq
#else
               module procedure stdlib_zunmlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cunmlq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmlq
#else
               module procedure stdlib_I64_cunmlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zunmlq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmlq
#else
               module procedure stdlib_I64_zunmlq
#endif
          end interface unmlq

          interface unmql
          !! UNMQL overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(k) . . . H(2) H(1)
          !! as returned by CGEQLF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunmql( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmql
#else
               module procedure stdlib_cunmql
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunmql( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmql
#else
               module procedure stdlib_zunmql
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cunmql( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmql
#else
               module procedure stdlib_I64_cunmql
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zunmql( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmql
#else
               module procedure stdlib_I64_zunmql
#endif
          end interface unmql

          interface unmqr
          !! UNMQR overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(1) H(2) . . . H(k)
          !! as returned by CGEQRF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunmqr( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmqr
#else
               module procedure stdlib_cunmqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunmqr( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmqr
#else
               module procedure stdlib_zunmqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cunmqr( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmqr
#else
               module procedure stdlib_I64_cunmqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zunmqr( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmqr
#else
               module procedure stdlib_I64_zunmqr
#endif
          end interface unmqr

          interface unmrq
          !! UNMRQ overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(1)**H H(2)**H . . . H(k)**H
          !! as returned by CGERQF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunmrq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmrq
#else
               module procedure stdlib_cunmrq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunmrq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmrq
#else
               module procedure stdlib_zunmrq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cunmrq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmrq
#else
               module procedure stdlib_I64_cunmrq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zunmrq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmrq
#else
               module procedure stdlib_I64_zunmrq
#endif
          end interface unmrq

          interface unmrz
          !! UNMRZ overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(1) H(2) . . . H(k)
          !! as returned by CTZRZF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunmrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,l,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmrz
#else
               module procedure stdlib_cunmrz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunmrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,l,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmrz
#else
               module procedure stdlib_zunmrz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cunmrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,l,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmrz
#else
               module procedure stdlib_I64_cunmrz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zunmrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: k,l,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmrz
#else
               module procedure stdlib_I64_zunmrz
#endif
          end interface unmrz

          interface unmtr
          !! UNMTR overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix of order nq, with nq = m if
          !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !! nq-1 elementary reflectors, as returned by CHETRD:
          !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
          !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunmtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmtr
#else
               module procedure stdlib_cunmtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunmtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmtr
#else
               module procedure stdlib_zunmtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cunmtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmtr
#else
               module procedure stdlib_I64_cunmtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zunmtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmtr
#else
               module procedure stdlib_I64_zunmtr
#endif
          end interface unmtr

          interface upgtr
          !! UPGTR generates a complex unitary matrix Q which is defined as the
          !! product of n-1 elementary reflectors H(i) of order n, as returned by
          !! CHPTRD using packed storage:
          !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
          !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cupgtr( uplo, n, ap, tau, q, ldq, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldq,n
                    complex(sp), intent(in) :: ap(*),tau(*)
                    complex(sp), intent(out) :: q(ldq,*),work(*)
               end subroutine cupgtr
#else
               module procedure stdlib_cupgtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zupgtr( uplo, n, ap, tau, q, ldq, work, info )
                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldq,n
                    complex(dp), intent(in) :: ap(*),tau(*)
                    complex(dp), intent(out) :: q(ldq,*),work(*)
               end subroutine zupgtr
#else
               module procedure stdlib_zupgtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cupgtr( uplo, n, ap, tau, q, ldq, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldq,n
                    complex(sp), intent(in) :: ap(*),tau(*)
                    complex(sp), intent(out) :: q(ldq,*),work(*)
               end subroutine cupgtr
#else
               module procedure stdlib_I64_cupgtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zupgtr( uplo, n, ap, tau, q, ldq, work, info )
                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldq,n
                    complex(dp), intent(in) :: ap(*),tau(*)
                    complex(dp), intent(out) :: q(ldq,*),work(*)
               end subroutine zupgtr
#else
               module procedure stdlib_I64_zupgtr
#endif
          end interface upgtr

          interface upmtr
          !! UPMTR overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix of order nq, with nq = m if
          !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !! nq-1 elementary reflectors, as returned by CHPTRD using packed
          !! storage:
          !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
          !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cupmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,m,n
                    complex(sp), intent(inout) :: ap(*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cupmtr
#else
               module procedure stdlib_cupmtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zupmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )

                    import sp,dp,qp,ilp,lk
                    implicit none
                    character, intent(in) :: side,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,m,n
                    complex(dp), intent(inout) :: ap(*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zupmtr
#else
               module procedure stdlib_zupmtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine cupmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldc,m,n
                    complex(sp), intent(inout) :: ap(*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cupmtr
#else
               module procedure stdlib_I64_cupmtr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK_I64
               pure subroutine zupmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )

                    import sp,dp,qp,ilp64,lk
                    implicit none
                    character, intent(in) :: side,trans,uplo
                    integer(ilp64), intent(out) :: info
                    integer(ilp64), intent(in) :: ldc,m,n
                    complex(dp), intent(inout) :: ap(*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zupmtr
#else
               module procedure stdlib_I64_zupmtr
#endif
          end interface upmtr

end module stdlib_linalg_lapack
