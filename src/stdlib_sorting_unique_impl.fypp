#:include "common.fypp"

#:set INT_TYPES_ALT_NAME = list(zip(INT_TYPES, INT_TYPES, INT_KINDS))
#:set REAL_TYPES_ALT_NAME = list(zip(REAL_TYPES, REAL_TYPES, REAL_KINDS))
#:set STRING_TYPES_ALT_NAME = list(zip(STRING_TYPES, STRING_TYPES, STRING_KINDS))
#:set CHAR_TYPES_ALT_NAME = list(zip(["character(len=*)"], ["character(len=len(array))"], ["char"]))
#:set COMPLEX_TYPES_ALT_NAME = list(zip(CMPLX_TYPES, CMPLX_TYPES, CMPLX_KINDS))

#! For better code reuse in fypp, make lists that contain the input types,
#! with each having output types and a separate name prefix for subroutines
#! This approach allows us to have the same code for all input types.
#:set IRSC_TYPES_ALT_NAME = INT_TYPES_ALT_NAME + REAL_TYPES_ALT_NAME + STRING_TYPES_ALT_NAME + CHAR_TYPES_ALT_NAME + COMPLEX_TYPES_ALT_NAME

submodule (stdlib_sorting_unique) stdlib_sorting_unique_impl
    use stdlib_sorting, only: sort
    implicit none

contains

#:for t1, t2, name1 in IRSC_TYPES_ALT_NAME
    pure module function ${name1}$_unique(array, sorted) result(unique_values)
        ${t1}$, intent(in) :: array(:)
        logical(lk), intent(in), optional :: sorted
        ${t2}$, allocatable :: unique_values(:)

        ${t2}$ :: temp_array(size(array))
        logical :: mask(size(array))
        integer :: i, n
        logical :: is_input_sorted

        n = size(array)
        
        ! Handle edge cases first
        if (n == 0) then
            ! Return empty array for empty input
            allocate(unique_values(0))
            return
        else if (n == 1) then
            ! For single-element arrays, return that element directly
            allocate(unique_values(1))
            unique_values(1) = array(1)
            return
        endif

        ! Determine if the input is already sorted
        is_input_sorted = optval(sorted, .false.)

        ! Create a temporary copy and sort it if needed
        temp_array = array
        if (.not. is_input_sorted) call sort(temp_array)

        ! Find unique elements using a mask
        ! Start with first element always marked as unique
        mask(1) = .true.

        ! Compare each element with previous to mark duplicates
        do concurrent (i=2:n)
            mask(i) = temp_array(i) /= temp_array(i-1)
        end do

        ! Extract unique elements to result array using pack
        unique_values = pack(temp_array, mask)
    end function ${name1}$_unique

#:endfor

end submodule stdlib_sorting_unique_impl 