#:include "common.fypp"
#:set R_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES, REAL_SUFFIX))
#:set C_KINDS_TYPES = list(zip(CMPLX_KINDS, CMPLX_TYPES, CMPLX_SUFFIX))
#:set MATRIX_TYPES = ["dense", "CSR"]
#:set RANKS = range(1, 2+1)

submodule(stdlib_linalg_iterative_solvers) stdlib_linalg_iterative_pcg
    use stdlib_kinds
    use stdlib_sparse
    use stdlib_constants
    use stdlib_linalg_iterative_solvers
    implicit none

    enum, bind(c)
        enumerator :: pc_none = 0
        enumerator :: pc_jacobi
        enumerator :: pc_ssor 
        enumerator :: pc_ldlt
    end enum

contains

    #:for k, t, s in R_KINDS_TYPES
    module subroutine solve_pcg_kernel_${s}$(A,M,b,x,tol,maxiter,workspace)
        class(linop_${s}$), intent(in) :: A
        class(linop_${s}$), intent(in) :: M !> preconditionner
        ${t}$, intent(in) :: b(:), tol
        ${t}$, intent(inout) :: x(:)
        integer, intent(in) :: maxiter
        type(solver_workspace_${s}$), intent(inout) :: workspace
        !-------------------------
        integer :: iter
        ${t}$ :: norm_sq, norm_sq0, norm_sq_old
        ${t}$ :: zr1, zr2, zv2, alpha, beta, tolsq
        !-------------------------
        iter = 0
        associate(  R => workspace%tmp(:,1), &
                    S => workspace%tmp(:,2), &
                    P => workspace%tmp(:,3), &
                    Q => workspace%tmp(:,4))
        norm_sq = A%inner_product( b, b )
        norm_sq0 = norm_sq
        if(associated(workspace%callback)) call workspace%callback(x, norm_sq, iter)
        
        if ( norm_sq0 > zero_${s}$ ) then
            
            R = B
            call A%apply(X, R, alpha= -one_${s}$, beta=one_${s}$) !> R = B - A*X
            
            call M%apply(R,P, alpha= one_${s}$, beta=zero_${s}$) !> P = M^{-1}*R
            
            tolsq = tol*tol
            
            zr1 = zero_${s}$
            zr2 = one_${s}$
            do while ( (iter < maxiter) .AND. (norm_sq > tolsq * norm_sq0) )
                
                call M%apply(R,S, alpha= one_${s}$, beta=zero_${s}$) !> S = M^{-1}*R
                zr2 = A%inner_product( R, S )
            
                if (iter>0) then
                    beta = zr2 / zr1
                    P = S + beta * P
                end if
                
                call A%apply(P, Q, alpha= one_${s}$, beta=zero_${s}$) !> Q = A*P
                zv2 = A%inner_product( P, Q )
            
                alpha = zr2 / zv2
            
                X = X + alpha * P
                R = R - alpha * Q

                norm_sq = A%inner_product( R, R )
                norm_sq_old = norm_sq

                zr1 = zr2
                iter = iter + 1
                if(associated(workspace%callback)) call workspace%callback(x, norm_sq, iter)
            end do
        end if
        end associate
    end subroutine
    #:endfor

    #:for matrix in MATRIX_TYPES
    #:for k, t, s in R_KINDS_TYPES
    module subroutine solve_pcg_${matrix}$_${s}$(A,b,x,di,tol,maxiter,restart,precond,M,workspace)
        #:if matrix == "dense"
        use stdlib_linalg, only: diag
        ${t}$, intent(in) :: A(:,:)
        #:else 
        type(${matrix}$_${s}$_type), intent(in) :: A
        #:endif
        ${t}$, intent(in) :: b(:)
        ${t}$, intent(inout) :: x(:)
        ${t}$, intent(in), optional :: tol
        logical(1), intent(in), optional, target  :: di(:)
        integer, intent(in), optional  :: maxiter
        logical, intent(in), optional  :: restart
        integer, intent(in), optional  :: precond !> preconditionner method flag
        class(linop_${s}$), optional , intent(in), target :: M !> preconditionner
        type(solver_workspace_${s}$), optional, intent(inout), target :: workspace
        !-------------------------
        type(linop_${s}$) :: op
        type(linop_${s}$), pointer :: M_ => null()
        type(solver_workspace_${s}$), pointer :: workspace_
        integer :: n, maxiter_
        ${t}$ :: tol_
        logical :: restart_
        logical(1), pointer :: di_(:)
        !-------------------------
        ! working data for preconditionner
        integer :: precond_
        ${t}$, allocatable :: diagonal(:)
        #:if matrix == "dense"
        ${t}$, allocatable:: L(:,:) !> lower triangular
        #:else 
        type(${matrix}$_${s}$_type) :: L !> lower triangular
        #:endif
        !-------------------------
        n = size(b)
        maxiter_ = n;       if(present(maxiter)) maxiter_ = maxiter
        restart_ = .true.;  if(present(restart)) restart_ = restart
        tol_ = 1.e-4_${s}$; if(present(tol)) tol_ = tol
        precond_ = pc_none; if(present(precond)) precond_ = precond
        !-------------------------
        ! internal memory setup
        ! Preconditionner
        if(present(M)) then
            M_ => M
        else 
            allocate( M_ )
            allocate(diagonal(n),source=zero_${s}$)

            select case(precond_)
            case(pc_jacobi)
                #:if matrix == "dense"
                diagonal = diag(A)
                #:else 
                call diag(A,diagonal)
                #:endif
                M_%apply => precond_jacobi
            case(pc_ssor)
                #:if matrix == "dense"
                diagonal = diag(A)
                #:else 
                call diag(A,diagonal)
                #:endif
                L = A !> copy A structure to L
                call ssor( A , one_${s}$ , L, diagonal )
                M_%apply => precond_ldlt
            case(pc_ldlt)
                L = A !> copy A structure to L
                call ldlt( A , L, diagonal )
                M_%apply => precond_ldlt
            case default
                M_%apply => precond_none
            end select
            where(abs(diagonal)>epsilon(zero_${s}$)) diagonal = one_${s}$/diagonal
        end if
        ! matvec for the operator
        op%apply => matvec
        
        ! direchlet boundary conditions mask
        if(present(di))then
            di_ => di
        else 
            allocate(di_(n),source=.false._1)
        end if
        
        ! workspace for the solver
        if(present(workspace)) then
            workspace_ => workspace
        else
            allocate( workspace_ )
        end if
        if(.not.allocated(workspace_%tmp)) allocate( workspace_%tmp(n,size_wksp_pcg) , source = zero_${s}$ )
        !-------------------------
        ! main call to the solver
        if(restart_) x = zero_${s}$
        x = merge( b, x, di_ ) !> copy dirichlet load conditions encoded in B and indicated by di
        call solve_pcg_kernel(op,M_,b,x,tol_,maxiter_,workspace_)

        !-------------------------
        ! internal memory cleanup
        if(.not.present(di)) deallocate(di_)
        di_ => null()
        
        if(.not.present(workspace)) then
            deallocate( workspace_%tmp )
            deallocate( workspace_ )
        end if
        M_ => null()
        workspace_ => null()
        contains
        
        subroutine matvec(x,y,alpha,beta)
            ${t}$, intent(in)  :: x(:)
            ${t}$, intent(inout) :: y(:)
            ${t}$, intent(in) :: alpha
            ${t}$, intent(in) :: beta
            #:if matrix == "dense"
            y = alpha * matmul(A,x) + beta * y
            #:else 
            call spmv( A , x, y , alpha, beta )
            #:endif
            y = merge( zero_${s}$, y, di_ )
        end subroutine

        subroutine precond_none(x,y,alpha,beta)
            ${t}$, intent(in)  :: x(:)
            ${t}$, intent(inout) :: y(:)
            ${t}$, intent(in) :: alpha
            ${t}$, intent(in) :: beta
            y = merge( zero_${s}$, x, di_ )
        end subroutine
        subroutine precond_jacobi(x,y,alpha,beta)
            ${t}$, intent(in)  :: x(:)
            ${t}$, intent(inout) :: y(:)
            ${t}$, intent(in) :: alpha
            ${t}$, intent(in) :: beta
            y = merge( zero_${s}$, diagonal * x, di_ ) !> inverted diagonal
        end subroutine
        subroutine precond_ldlt(x,y,alpha,beta)
            ${t}$, intent(in)  :: x(:)
            ${t}$, intent(inout) :: y(:)
            ${t}$, intent(in) :: alpha
            ${t}$, intent(in) :: beta
            call solve_forward_triangular( L , x , y )
            y = merge( zero_${s}$, diagonal * y, di_ ) !> inverted diagonal
            call solve_backward_triangular( L , y , y )
        end subroutine
    end subroutine

    #:endfor
    #:endfor

end submodule stdlib_linalg_iterative_pcg