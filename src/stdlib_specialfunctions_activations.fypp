#:include "common.fypp"
submodule(stdlib_specialfunctions) stdlib_specialfunctions_activations
    implicit none
    
    #:for rk, rt in REAL_KINDS_TYPES
    ${rt}$, parameter :: isqrt2_${rk}$ = 1._${rk}$ / sqrt(2._${rk}$)
    #:endfor

contains

!==================================================
! Gaussian
!==================================================
#:for rk, rt in REAL_KINDS_TYPES
elemental ${rt}$ module function gaussian_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x
    
    y = exp(-x**2)
end function

elemental ${rt}$ module function gaussian_grad_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x
    
    y = -2._${rk}$ * x * exp(-x**2)
end function

#:endfor

!==================================================
! Exponential Linear Unit
!==================================================
#:for rk, rt in REAL_KINDS_TYPES
elemental ${rt}$ module function elu_${rk}$( x , a ) result ( y )
    ${rt}$, intent(in) :: x
    ${rt}$, intent(in) :: a
    
    if(x >= 0._${rk}$)then
        y = x
    else
        y = a * (exp(x) - 1._${rk}$)
    end if
end function

elemental ${rt}$ module function elu_grad_${rk}$( x , a ) result ( y )
    ${rt}$, intent(in) :: x
    ${rt}$, intent(in) :: a
    
    if(x >= 0._${rk}$)then
        y = 1._${rk}$ 
    else
        y = a * exp(x)
    end if
end function

#:endfor

!==================================================
! Rectified Linear Unit
!==================================================
#:for rk, rt in REAL_KINDS_TYPES
elemental ${rt}$ module function relu_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x
    
    y = max(0._${rk}$, x)
end function

elemental ${rt}$ module function relu_grad_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x

    if(x > 0._${rk}$)then
        y = 1._${rk}$ 
    else
        y = 0._${rk}$
    end if
end function

#:endfor

!==================================================
! GELU: Gaussian Error Linear Units function
!==================================================
#:for rk, rt in REAL_KINDS_TYPES
elemental ${rt}$ module function gelu_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x
    
    y = 0.5_${rk}$ * x * (1 + erf(x * isqrt2_${rk}$))
end function

elemental ${rt}$ module function gelu_grad_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x
    
    y = 0.5_${rk}$ * (1 + erf(x * isqrt2_${rk}$) )
    y = y + x * isqrt2_${rk}$ * exp( - 0.5_${rk}$ * x**2 )
end function

#:endfor

#:for rk, rt in REAL_KINDS_TYPES
elemental ${rt}$ module function gelu_approx_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x
    
    y = 0.5_${rk}$ * x * (1._${rk}$ + ferf(x * isqrt2_${rk}$))
end function

elemental ${rt}$ module function gelu_approx_grad_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x
    
    y = 0.5_${rk}$ * (1._${rk}$ + ferf(x * isqrt2_${rk}$) )
    y = y + x * isqrt2_${rk}$ * exp( - 0.5_${rk}$ * x**2 )
end function

#:endfor

!==================================================
! Sigmoid
!==================================================
#:for rk, rt in REAL_KINDS_TYPES
elemental ${rt}$ module function sigmoid_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x
    
    y = 1._${rk}$ / (1._${rk}$ + exp(-x))
end function

elemental ${rt}$ module function sigmoid_grad_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x
    
    y = exp(x) / (1._${rk}$ + exp(x))**2
end function

#:endfor

!==================================================
! Step
!==================================================
#:for rk, rt in REAL_KINDS_TYPES
elemental ${rt}$ module function Step_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x

    if(x > 0._${rk}$)then
        y = 1._${rk}$ 
    else
        y = 0._${rk}$
    end if
end function

elemental ${rt}$ module function Step_grad_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x
    
    y = 0._${rk}$
end function

#:endfor

!==================================================
! tanh
!==================================================
#:for rk, rt in REAL_KINDS_TYPES
elemental ${rt}$ module function tanh_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x
    
    y = ftanh(x)
end function

elemental ${rt}$ module function tanh_grad_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x
    
    y = 1._${rk}$ - ftanh(x)**2
end function

#:endfor

!==================================================
! Softmax
!==================================================
#:for rk, rt in REAL_KINDS_TYPES
pure function Softmax_r1_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x(:)
    ${rt}$ :: y(size(x))

    y = exp(x - maxval(x))
    y = y / sum(y)
end function

pure function Softmax_r2_${rk}$( x , dim ) result( y )
    ${rt}$, intent(in) :: x(:,:)
    ${rt}$ :: y(size(x,dim=1),size(x,dim=2))

    integer, intent(in), optional :: dim
    integer :: dim_, j

    dim_ = 1; if(present(dim)) dim_ = dim

    if(dim_==1)then
        do j = 1, size(x,dim=2)
            y(:,j) = Softmax( x(:,j) )
        end do
    else
        do j = 1, size(x,dim=1)
            y(j,:) = Softmax( x(j,:) )
        end do
    end if
end function

pure function Softmax_r3_${rk}$( x , dim ) result( y )
    ${rt}$, intent(in) :: x(:,:,:)
    ${rt}$ :: y(size(x,dim=1),size(x,dim=2),size(x,dim=3))

    integer, intent(in), optional :: dim
    integer :: dim_, j

    dim_ = 1; if(present(dim)) dim_ = dim

    if(dim_<=2)then
        do j = 1, size(x,dim=3)
            y(:,:,j) = Softmax( x(:,:,j) , dim = dim_ )
        end do
    else
        do j = 1, size(x,dim=1)
            y(j,:,:) = Softmax( x(j,:,:) , dim = 2 )
        end do
    end if
end function

pure function Softmax_r4_${rk}$( x , dim ) result( y )
    ${rt}$, intent(in) :: x(:,:,:,:)
    ${rt}$ :: y(size(x,dim=1),size(x,dim=2),size(x,dim=3),size(x,dim=4))

    integer, intent(in), optional :: dim
    integer :: dim_, j

    dim_ = 1; if(present(dim)) dim_ = dim

    if(dim_<=3)then
        do j = 1, size(x,dim=4)
            y(:,:,:,j) = Softmax( x(:,:,:,j) , dim = dim_ )
        end do
    else
        do j = 1, size(x,dim=1)
            y(j,:,:,:) = Softmax( x(j,:,:,:) , dim = 3 )
        end do
    end if
end function

pure function Softmax_grad_r1_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x(:)
    ${rt}$ :: y(size(x))
    
    y = Softmax(x)
    y = y * (1._${rk}$ - y)
end function

pure function Softmax_grad_r2_${rk}$( x , dim ) result( y )
    ${rt}$, intent(in) :: x(:,:)
    ${rt}$ :: y(size(x,dim=1),size(x,dim=2))

    integer, intent(in), optional :: dim
    integer :: dim_

    dim_ = 1; if(present(dim)) dim_ = dim

    y = Softmax(x,dim_)
    y = y * (1._${rk}$ - y)
end function

pure function Softmax_grad_r3_${rk}$( x , dim ) result( y )
    ${rt}$, intent(in) :: x(:,:,:)
    ${rt}$ :: y(size(x,dim=1),size(x,dim=2),size(x,dim=3))
    
    integer, intent(in), optional :: dim
    integer :: dim_

    dim_ = 1; if(present(dim)) dim_ = dim
    
    y = Softmax(x,dim_)
    y = y * (1._${rk}$ - y)
end function

pure function Softmax_grad_r4_${rk}$( x , dim ) result( y )
    ${rt}$, intent(in) :: x(:,:,:,:)
    ${rt}$ :: y(size(x,dim=1),size(x,dim=2),size(x,dim=3),size(x,dim=4))
    
    integer, intent(in), optional :: dim
    integer :: dim_

    dim_ = 1; if(present(dim)) dim_ = dim
    
    y = Softmax(x,dim_)
    y = y * (1._${rk}$ - y)
end function

#:endfor

!==================================================
! Softplus
!==================================================
#:for rk, rt in REAL_KINDS_TYPES
elemental ${rt}$ module function Softplus_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x
    
    y = log(exp(x) + 1._${rk}$)
end function

elemental ${rt}$ module function Softplus_grad_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x
    
    y = exp(x) / (exp(x) + 1._${rk}$)
end function

#:endfor

!==================================================
! Fast intrinsics for accelerated activations
!==================================================

#:for rk, rt in REAL_KINDS_TYPES
elemental ${rt}$ module function ftanh_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x
    ${rt}$ :: x2, a, b
    
    if (x > 5_${rk}$) then
        y = 1._${rk}$
    elseif (x < -5_${rk}$) then
        y = -1._${rk}$
    else
        x2 = x*x
        a = x * (135135.0_${rk}$ + x2 * (17325.0_${rk}$ + x2 * (378.0_${rk}$ + x2)))
        b = 135135.0_${rk}$ + x2 * (62370.0_${rk}$ + x2 * (3150.0_${rk}$ + x2 * 28.0_${rk}$))
        y = a / b
    end if
end function

elemental ${rt}$ module function ferf_${rk}$( x ) result( y )
    ${rt}$, intent(in) :: x
    ${rt}$ :: abs_x
    
    abs_x = abs(x)
    y = 1._${rk}$ - 1._${rk}$ / (1._${rk}$+ 0.278393_${rk}$*abs_x + 0.230389_${rk}$*abs_x**2 + 0.000972_${rk}$*abs_x**3 + 0.078108_${rk}$*abs_x**4)**4
    y = y * sign(1.0_${rk}$,x)
end function

#:endfor

end submodule