#:include "common.fypp"
#:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
Module stdlib_stats_distribution_beta
    use stdlib_kinds
    use stdlib_error, only : error_stop
    use stdlib_stats_distribution_uniform, only : uni=>uniform_distribution_rvs
    use stdlib_stats_distribution_gamma, only : rgamma=>gamma_distribution_rvs
    use stdlib_stats_distribution_special, only : beta, inbeta


    implicit none
    private
    integer(int64), parameter :: INT_ONE = 1_int64

    public :: beta_distribution_rvs
    public :: beta_distribution_pdf
    public :: beta_distribution_cdf

    interface beta_distribution_rvs
    !! Version experimental
    !!
    !! Beta Distribution Random Variates
    !! ([Specification](../page/specs/stdlib_stats_distribution_beta.html#
    !! description))
    !!
        #:for k1, t1 in RC_KINDS_TYPES
        module procedure beta_dist_rvs_${t1[0]}$${k1}$       ! 2 arguments
        #:endfor

        #:for k1, t1 in RC_KINDS_TYPES
        module procedure beta_dist_rvs_array_${t1[0]}$${k1}$ ! 3 arguments
        #:endfor
    end interface beta_distribution_rvs

    interface beta_distribution_pdf
    !! Version experimental
    !!
    !! Beta Distribution Probability Density Function
    !! ([Specification](../page/specs/stdlib_stats_distribution_beta.html#
    !! description))
    !!
        #:for k1, t1 in RC_KINDS_TYPES
        module procedure beta_dist_pdf_${t1[0]}$${k1}$
        #:endfor
    end interface beta_distribution_pdf

    interface beta_distribution_cdf
    !! Version experimental
    !!
    !! Beta Distribution Cumulative Distribution Function
    !! ([Specification](../page/specs/stdlib_stats_distribution_beta.html#
    !! description))
    !!
        #:for k1, t1 in RC_KINDS_TYPES
        module procedure beta_dist_cdf_${t1[0]}$${k1}$
        #:endfor
    end interface beta_distribution_cdf


    contains

    #:for k1, t1 in REAL_KINDS_TYPES
    impure elemental function beta_dist_rvs_${t1[0]}$${k1}$(a, b) result(res)
    ! Beta random variate
    !
        ${t1}$, intent(in) :: a, b
        ${t1}$ :: res, x, y, xx(2)
        ${t1}$, parameter :: z = 0.0_${k1}$, one = 1.0_${k1}$

        if(a <= z .or. b <= z) call error_stop("Error(beta_dist_rvs): Beta"     &
        //" distribution paramters a, b must be greater than zero")
        if( a < one .or. b < one) then
            do
                xx = uni(z, one, 2)
                x = xx(1) ** (one / a)
                y = xx(2) ** (one / b)
                y = x + y
                if(y <= one .and. y /= z) exit
            end do
        else
            do
                x = rgamma(a); y = rgamma(b)
                y = x + y
                if( y /= z) exit
            end do
        endif
        res = x / y
        return
    end function beta_dist_rvs_${t1[0]}$${k1}$

    #:endfor

    #:for k1, t1 in CMPLX_KINDS_TYPES
    impure elemental function beta_dist_rvs_${t1[0]}$${k1}$(a, b) result(res)
    ! Beta distributed complex. The real part and imaginary part are
    ! independent of each other.
    !
        ${t1}$, intent(in) :: a, b
        ${t1}$ :: res
        real(${k1}$), parameter :: z = 0.0_${k1}$
        real(${k1}$) :: tr, ti

        tr = beta_dist_rvs_r${k1}$(real(a), real(b))
        ti = beta_dist_rvs_r${k1}$(aimag(a), aimag(b))
        res = cmplx(tr, ti, kind = ${k1}$)
        return
    end function beta_dist_rvs_${t1[0]}$${k1}$

    #:endfor

    #:for k1, t1 in REAL_KINDS_TYPES
    function beta_dist_rvs_array_${t1[0]}$${k1}$(a, b, array_size) result(res)
        ${t1}$, intent(in) :: a, b
        ${t1}$, allocatable :: res(:)
        integer, intent(in) :: array_size
        integer :: i
        ${t1}$ :: x, y, xx(2)
        real(${k1}$), parameter :: z = 0.0_${k1}$, one = 1.0_${k1}$

        if(a <= z .or. b <= z) call error_stop("Error(beta_dist_rvs_array):"    &
        //" Beta distribution paramters a, b must be greater than zero")

        allocate(res(array_size))

        if( a < one .or. b < one) then
            do i = 1, array_size
                do
                    xx = uni(z, one, 2)
                    x = xx(1) ** (one / a)
                    y = xx(2) ** (one / b)
                    y = x + y
                    if(y <= one .and. y /= z) exit
                end do
                res(i) = x / y
            end do
        else
            do i = 1, array_size
                do
                    x = rgamma(a); y = rgamma(b)
                    y = x + y
                    if( y /= z) exit
                end do
                res(i) = x / y
            end do
        endif
        return
    end function beta_dist_rvs_array_${t1[0]}$${k1}$

    #:endfor

    #:for k1, t1 in CMPLX_KINDS_TYPES
    function beta_dist_rvs_array_${t1[0]}$${k1}$(a, b, array_size) result(res)
        ${t1}$, intent(in) :: a, b
        ${t1}$, allocatable :: res(:)
        integer, intent(in) :: array_size
        integer :: i
        real(${k1}$), allocatable :: tr(:), ti(:)

        allocate(res(array_size), tr(array_size), ti(array_size))
        tr = beta_dist_rvs_array_r${k1}$(real(a), real(b), array_size)
        ti = beta_dist_rvs_array_r${k1}$(aimag(a), aimag(b), array_size)
        res = cmplx(tr, ti, kind = ${k1}$)
        return
    end function beta_dist_rvs_array_${t1[0]}$${k1}$

    #:endfor

    #:for k1, t1 in REAL_KINDS_TYPES
    impure elemental function beta_dist_pdf_${t1[0]}$${k1}$(x, a, b) result(res)
    ! Beta distributed probability function
    !
        ${t1}$, intent(in) :: x, a, b
        real :: res
        ${t1}$ :: z = 0.0_${k1}$, one = 1.0_${k1}$

        if(a <= z .or. b <= z) call error_stop("Error(beta_dist_pdf): Beta"     &
        //" distribution parameters a, b must be greater than zero")
        if(x == z) then
            if(a <= one) then
                res = huge(1.0)
            else
                res = z
            endif
        elseif(x == one) then
            if(b <= one) then
                res = huge(1.0)
             else
                res = z
            endif
        else
            res = x ** (a - 1) * (1 - x) ** (b - 1) / beta(a, b)
        endif
        return
    end function beta_dist_pdf_${t1[0]}$${k1}$

    #:endfor

    #:for k1, t1 in CMPLX_KINDS_TYPES
    impure elemental function beta_dist_pdf_${t1[0]}$${k1}$(x, a, b) result(res)
        ${t1}$, intent(in) :: x, a, b
        real :: res

        res = beta_dist_pdf_r${k1}$(real(x), real(a), real(b))
        res = res * beta_dist_pdf_r${k1}$(aimag(x), aimag(a), aimag(b))
        return
    end function beta_dist_pdf_${t1[0]}$${k1}$

    #:endfor

    #:for k1, t1 in REAL_KINDS_TYPES
    impure elemental function beta_dist_cdf_${t1[0]}$${k1}$(x, a, b) result(res)
    ! Beta cumulative distribution function
    !
        ${t1}$, intent(in) :: x, a, b
        real :: res
        ${t1}$ :: z = 0.0_${k1}$, one = 1.0_${k1}$

        if(a <= z .or. b <= z) call error_stop("Error(beta_dist_cdf): Beta"     &
        //" distribution parameters a, b must be greater than zero")
        if(x == z) then
            res = 0.0
        elseif(x == one) then
            res = 1.0
        else
            res = inbeta(x, a, b)
        endif
        return
    end function beta_dist_cdf_${t1[0]}$${k1}$

    #:endfor

    #:for k1, t1 in CMPLX_KINDS_TYPES
    impure elemental function beta_dist_cdf_${t1[0]}$${k1}$(x, a, b) result(res)
        ${t1}$, intent(in) :: x, a, b
        real :: res

        res = beta_dist_cdf_r${k1}$(real(x), real(a), real(b))
        res = res * beta_dist_cdf_r${k1}$(aimag(x), aimag(a), aimag(b))
    end function beta_dist_cdf_${t1[0]}$${k1}$

    #:endfor

end module stdlib_stats_distribution_beta