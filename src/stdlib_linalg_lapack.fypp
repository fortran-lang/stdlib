#:include "common.fypp" 
#:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
module stdlib_linalg_lapack
     use stdlib_linalg_constants
     use stdlib_linalg_blas
     use stdlib_linalg_lapack_aux
     #:for rk,rt,ri in RC_KINDS_TYPES
     use stdlib_linalg_lapack_${ri}$
     #:endfor     
     implicit none(type,external)
     public

          interface bbcsd
          !! BBCSD computes the CS decomposition of a unitary matrix in
          !! bidiagonal-block form,
          !!     [ B11 | B12 0  0 ]
          !!     [  0  |  0 -I  0 ]
          !! X = [----------------]
          !!     [ B21 | B22 0  0 ]
          !!     [  0  |  0  0  I ]
          !!     [  C | -S  0  0 ]
          !!     [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**H
          !!   = [---------] [---------------] [---------]   .
          !!     [    | U2 ] [  S |  C  0  0 ] [    | V2 ]
          !!                 [  0 |  0  0  I ]
          !! X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
          !! than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
          !! transposed and/or permuted. This can be done in constant time using
          !! the TRANS and SIGNS options. See CUNCSD for details.)
          !! The bidiagonal matrices B11, B12, B21, and B22 are represented
          !! implicitly by angles THETA(1:Q) and PHI(1:Q-1).
          !! The unitary matrices U1, U2, V1T, and V2T are input/output.
          !! The input matrices are pre- or post-multiplied by the appropriate
          !! singular vector matrices.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, &
               u1, ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d,&
                          b22e, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,lrwork,m,p,q
                    real(sp), intent(out) :: b11d(*),b11e(*),b12d(*),b12e(*),b21d(*),b21e(*),b22d(&
                              *),b22e(*),rwork(*)
                    real(sp), intent(inout) :: phi(*),theta(*)
                    complex(sp), intent(inout) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*)
                              
               end subroutine cbbcsd
#else 
               module procedure stdlib_cbbcsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, &
               u1, ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d,&
                          b22e, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,lwork,m,p,q
                    real(dp), intent(out) :: b11d(*),b11e(*),b12d(*),b12e(*),b21d(*),b21e(*),b22d(&
                              *),b22e(*),work(*)
                    real(dp), intent(inout) :: phi(*),theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),&
                              v2t(ldv2t,*)
               end subroutine dbbcsd
#else 
               module procedure stdlib_dbbcsd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$bbcsd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, &
               u1, ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d,&
                          b22e, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,lwork,m,p,q
                    real(sp), intent(out) :: b11d(*),b11e(*),b12d(*),b12e(*),b21d(*),b21e(*),b22d(&
                              *),b22e(*),work(*)
                    real(sp), intent(inout) :: phi(*),theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),&
                              v2t(ldv2t,*)
               end subroutine sbbcsd
#else 
               module procedure stdlib_sbbcsd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$bbcsd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, &
               u1, ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d,&
                          b22e, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,lrwork,m,p,q
                    real(dp), intent(out) :: b11d(*),b11e(*),b12d(*),b12e(*),b21d(*),b21e(*),b22d(&
                              *),b22e(*),rwork(*)
                    real(dp), intent(inout) :: phi(*),theta(*)
                    complex(dp), intent(inout) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*)
                              
               end subroutine zbbcsd
#else 
               module procedure stdlib_zbbcsd
#endif
          end interface bbcsd



          interface bdsdc
          !! BDSDC computes the singular value decomposition (SVD) of a real
          !! N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
          !! using a divide and conquer method, where S is a diagonal matrix
          !! with non-negative diagonal elements (the singular values of B), and
          !! U and VT are orthogonal matrices of left and right singular vectors,
          !! respectively. BDSDC can be used to compute all singular values,
          !! and optionally, singular vectors or singular vectors in compact form.
          !! This code makes very mild assumptions about floating point
          !! arithmetic. It will work on machines with a guard digit in
          !! add/subtract, or on those binary machines without guard digits
          !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
          !! It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.  See DLASD3 for details.
          !! The code currently calls DLASDQ if singular values only are desired.
          !! However, it can be slightly modified to compute singular values
          !! using the divide and conquer method.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dbdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,work, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq,uplo
                    integer(ilp), intent(out) :: info,iq(*),iwork(*)
                    integer(ilp), intent(in) :: ldu,ldvt,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: q(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine dbdsdc
#else 
               module procedure stdlib_dbdsdc
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$bdsdc

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sbdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,work, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq,uplo
                    integer(ilp), intent(out) :: info,iq(*),iwork(*)
                    integer(ilp), intent(in) :: ldu,ldvt,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: q(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine sbdsdc
#else 
               module procedure stdlib_sbdsdc
#endif
          end interface bdsdc



          interface bdsqr
          !! BDSQR computes the singular values and, optionally, the right and/or
          !! left singular vectors from the singular value decomposition (SVD) of
          !! a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
          !! zero-shift QR algorithm.  The SVD of B has the form
          !! B = Q * S * P**H
          !! where S is the diagonal matrix of singular values, Q is an orthogonal
          !! matrix of left singular vectors, and P is an orthogonal matrix of
          !! right singular vectors.  If left singular vectors are requested, this
          !! subroutine actually returns U*Q instead of Q, and, if right singular
          !! vectors are requested, this subroutine returns P**H*VT instead of
          !! P**H, for given complex input matrices U and VT.  When U and VT are
          !! the unitary matrices that reduce a general matrix A to bidiagonal
          !! form: A = U*B*VT, as computed by CGEBRD, then
          !! A = (U*Q) * S * (P**H*VT)
          !! is the SVD of A.  Optionally, the subroutine may also compute Q**H*C
          !! for a given complex input matrix C.
          !! See "Computing  Small Singular Values of Bidiagonal Matrices With
          !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
          !! LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
          !! no. 5, pp. 873-912, Sept 1990) and
          !! "Accurate singular values and differential qd algorithms," by
          !! B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
          !! Department, University of California at Berkeley, July 1992
          !! for a detailed description of the algorithm.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: c(ldc,*),u(ldu,*),vt(ldvt,*)
               end subroutine cbdsqr
#else 
               module procedure stdlib_cbdsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, &
                         work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru
                    real(dp), intent(inout) :: c(ldc,*),d(*),e(*),u(ldu,*),vt(ldvt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dbdsqr
#else 
               module procedure stdlib_dbdsqr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$bdsqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, &
                         work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru
                    real(sp), intent(inout) :: c(ldc,*),d(*),e(*),u(ldu,*),vt(ldvt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sbdsqr
#else 
               module procedure stdlib_sbdsqr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$bdsqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: c(ldc,*),u(ldu,*),vt(ldvt,*)
               end subroutine zbdsqr
#else 
               module procedure stdlib_zbdsqr
#endif
          end interface bdsqr



          interface disna
          !! DISNA computes the reciprocal condition numbers for the eigenvectors
          !! of a real symmetric or complex Hermitian matrix or for the left or
          !! right singular vectors of a general m-by-n matrix. The reciprocal
          !! condition number is the 'gap' between the corresponding eigenvalue or
          !! singular value and the nearest other one.
          !! The bound on the error, measured by angle in radians, in the I-th
          !! computed vector is given by
          !! DLAMCH( 'E' ) * ( ANORM / SEP( I ) )
          !! where ANORM = 2-norm(A) = max( abs( D(j) ) ).  SEP(I) is not allowed
          !! to be smaller than DLAMCH( 'E' )*ANORM in order to limit the size of
          !! the error bound.
          !! DISNA may also be used to compute error bounds for eigenvectors of
          !! the generalized symmetric definite eigenproblem.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ddisna( job, m, n, d, sep, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: m,n
                    real(dp), intent(in) :: d(*)
                    real(dp), intent(out) :: sep(*)
               end subroutine ddisna
#else 
               module procedure stdlib_ddisna
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$disna

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sdisna( job, m, n, d, sep, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: m,n
                    real(sp), intent(in) :: d(*)
                    real(sp), intent(out) :: sep(*)
               end subroutine sdisna
#else 
               module procedure stdlib_sdisna
#endif
          end interface disna



          interface gbbrd
          !! GBBRD reduces a complex general m-by-n band matrix A to real upper
          !! bidiagonal form B by a unitary transformation: Q**H * A * P = B.
          !! The routine computes B, and optionally forms Q or P**H, or computes
          !! Q**H*C for a given matrix C.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, &
                         c, ldc, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldc,ldpt,ldq,m,n,ncc
                    real(sp), intent(out) :: d(*),e(*),rwork(*)
                    complex(sp), intent(inout) :: ab(ldab,*),c(ldc,*)
                    complex(sp), intent(out) :: pt(ldpt,*),q(ldq,*),work(*)
               end subroutine cgbbrd
#else 
               module procedure stdlib_cgbbrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, &
                         c, ldc, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldc,ldpt,ldq,m,n,ncc
                    real(dp), intent(inout) :: ab(ldab,*),c(ldc,*)
                    real(dp), intent(out) :: d(*),e(*),pt(ldpt,*),q(ldq,*),work(*)
               end subroutine dgbbrd
#else 
               module procedure stdlib_dgbbrd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gbbrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, &
                         c, ldc, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldc,ldpt,ldq,m,n,ncc
                    real(sp), intent(inout) :: ab(ldab,*),c(ldc,*)
                    real(sp), intent(out) :: d(*),e(*),pt(ldpt,*),q(ldq,*),work(*)
               end subroutine sgbbrd
#else 
               module procedure stdlib_sgbbrd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gbbrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, &
                         c, ldc, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldc,ldpt,ldq,m,n,ncc
                    real(dp), intent(out) :: d(*),e(*),rwork(*)
                    complex(dp), intent(inout) :: ab(ldab,*),c(ldc,*)
                    complex(dp), intent(out) :: pt(ldpt,*),q(ldq,*),work(*)
               end subroutine zgbbrd
#else 
               module procedure stdlib_zgbbrd
#endif
          end interface gbbrd



          interface gbcon
          !! GBCON estimates the reciprocal of the condition number of a complex
          !! general band matrix A, in either the 1-norm or the infinity-norm,
          !! using the LU factorization computed by CGBTRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as
          !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,work, rwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgbcon
#else 
               module procedure stdlib_cgbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,work, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,n,ipiv(*)
                    real(dp), intent(in) :: anorm,ab(ldab,*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dgbcon
#else 
               module procedure stdlib_dgbcon
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gbcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,work, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,n,ipiv(*)
                    real(sp), intent(in) :: anorm,ab(ldab,*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine sgbcon
#else 
               module procedure stdlib_sgbcon
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gbcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgbcon( norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond,work, rwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgbcon
#else 
               module procedure stdlib_zgbcon
#endif
          end interface gbcon



          interface gbequ
          !! GBEQU computes row and column scalings intended to equilibrate an
          !! M-by-N band matrix A and reduce its condition number.  R returns the
          !! row scale factors and C the column scale factors, chosen to try to
          !! make the largest element in each row and column of the matrix B with
          !! elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
          !! R(i) and C(j) are restricted to be between SMLNUM = smallest safe
          !! number and BIGNUM = largest safe number.  Use of these scaling
          !! factors is not guaranteed to reduce the condition number of A but
          !! works well in practice.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end subroutine cgbequ
#else 
               module procedure stdlib_cgbequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(in) :: ab(ldab,*)
               end subroutine dgbequ
#else 
               module procedure stdlib_dgbequ
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gbequ

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(in) :: ab(ldab,*)
               end subroutine sgbequ
#else 
               module procedure stdlib_sgbequ
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gbequ

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgbequ( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end subroutine zgbequ
#else 
               module procedure stdlib_zgbequ
#endif
          end interface gbequ



          interface gbequb
          !! GBEQUB computes row and column scalings intended to equilibrate an
          !! M-by-N matrix A and reduce its condition number.  R returns the row
          !! scale factors and C the column scale factors, chosen to try to make
          !! the largest element in each row and column of the matrix B with
          !! elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
          !! the radix.
          !! R(i) and C(j) are restricted to be a power of the radix between
          !! SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use
          !! of these scaling factors is not guaranteed to reduce the condition
          !! number of A but works well in practice.
          !! This routine differs from CGEEQU by restricting the scaling factors
          !! to a power of the radix.  Barring over- and underflow, scaling by
          !! these factors introduces no additional rounding errors.  However, the
          !! scaled entries' magnitudes are no longer approximately 1 but lie
          !! between sqrt(radix) and 1/sqrt(radix).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end subroutine cgbequb
#else 
               module procedure stdlib_cgbequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(in) :: ab(ldab,*)
               end subroutine dgbequb
#else 
               module procedure stdlib_dgbequb
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gbequb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(in) :: ab(ldab,*)
               end subroutine sgbequb
#else 
               module procedure stdlib_sgbequb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gbequb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgbequb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end subroutine zgbequb
#else 
               module procedure stdlib_zgbequb
#endif
          end interface gbequb



          interface gbrfs
          !! GBRFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is banded, and provides
          !! error bounds and backward error estimates for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, rwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldafb,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cgbrfs
#else 
               module procedure stdlib_cgbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,ldafb,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dgbrfs
#else 
               module procedure stdlib_dgbrfs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gbrfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,ldafb,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine sgbrfs
#else 
               module procedure stdlib_sgbrfs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gbrfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgbrfs( trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, rwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldafb,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zgbrfs
#else 
               module procedure stdlib_zgbrfs
#endif
          end interface gbrfs



          interface gbsv
          !! GBSV computes the solution to a complex system of linear equations
          !! A * X = B, where A is a band matrix of order N with KL subdiagonals
          !! and KU superdiagonals, and X and B are N-by-NRHS matrices.
          !! The LU decomposition with partial pivoting and row interchanges is
          !! used to factor A as A = L * U, where L is a product of permutation
          !! and unit lower triangular matrices with KL subdiagonals, and U is
          !! upper triangular with KL+KU superdiagonals.  The factored form of A
          !! is then used to solve the system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,ldb,n,nrhs
                    complex(sp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine cgbsv
#else 
               module procedure stdlib_cgbsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,ldb,n,nrhs
                    real(dp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine dgbsv
#else 
               module procedure stdlib_dgbsv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gbsv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,ldb,n,nrhs
                    real(sp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine sgbsv
#else 
               module procedure stdlib_sgbsv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gbsv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgbsv( n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,ldb,n,nrhs
                    complex(dp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine zgbsv
#else 
               module procedure stdlib_zgbsv
#endif
          end interface gbsv



          interface gbtrf
          !! GBTRF computes an LU factorization of a complex m-by-n band matrix A
          !! using partial pivoting with row interchanges.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine cgbtrf
#else 
               module procedure stdlib_cgbtrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dgbtrf
#else 
               module procedure stdlib_dgbtrf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gbtrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine sgbtrf
#else 
               module procedure stdlib_sgbtrf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gbtrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgbtrf( m, n, kl, ku, ab, ldab, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zgbtrf
#else 
               module procedure stdlib_zgbtrf
#endif
          end interface gbtrf



          interface gbtrs
          !! GBTRS solves a system of linear equations
          !! A * X = B,  A**T * X = B,  or  A**H * X = B
          !! with a general band matrix A using the LU factorization computed
          !! by CGBTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cgbtrs
#else 
               module procedure stdlib_cgbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dgbtrs
#else 
               module procedure stdlib_dgbtrs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gbtrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine sgbtrs
#else 
               module procedure stdlib_sgbtrs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gbtrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgbtrs( trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,ldab,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zgbtrs
#else 
               module procedure stdlib_zgbtrs
#endif
          end interface gbtrs



          interface gebak
          !! GEBAK forms the right or left eigenvectors of a complex general
          !! matrix by backward transformation on the computed eigenvectors of the
          !! balanced matrix output by CGEBAL.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job,side
                    integer(ilp), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: scale(*)
                    complex(sp), intent(inout) :: v(ldv,*)
               end subroutine cgebak
#else 
               module procedure stdlib_cgebak
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job,side
                    integer(ilp), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: scale(*)
                    real(dp), intent(inout) :: v(ldv,*)
               end subroutine dgebak
#else 
               module procedure stdlib_dgebak
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gebak

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job,side
                    integer(ilp), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(inout) :: v(ldv,*)
                    real(sp), intent(in) :: scale(*)
               end subroutine sgebak
#else 
               module procedure stdlib_sgebak
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gebak

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job,side
                    integer(ilp), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: scale(*)
                    complex(dp), intent(inout) :: v(ldv,*)
               end subroutine zgebak
#else 
               module procedure stdlib_zgebak
#endif
          end interface gebak



          interface gebal
          !! GEBAL balances a general complex matrix A.  This involves, first,
          !! permuting A by a similarity transformation to isolate eigenvalues
          !! in the first 1 to ILO-1 and last IHI+1 to N elements on the
          !! diagonal; and second, applying a diagonal similarity transformation
          !! to rows and columns ILO to IHI to make the rows and columns as
          !! close in norm as possible.  Both steps are optional.
          !! Balancing may reduce the 1-norm of the matrix, and improve the
          !! accuracy of the computed eigenvalues and/or eigenvectors.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgebal( job, n, a, lda, ilo, ihi, scale, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: ihi,ilo,info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: scale(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cgebal
#else 
               module procedure stdlib_cgebal
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgebal( job, n, a, lda, ilo, ihi, scale, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: ihi,ilo,info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: scale(*)
               end subroutine dgebal
#else 
               module procedure stdlib_dgebal
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gebal

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgebal( job, n, a, lda, ilo, ihi, scale, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: ihi,ilo,info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: scale(*)
               end subroutine sgebal
#else 
               module procedure stdlib_sgebal
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gebal

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgebal( job, n, a, lda, ilo, ihi, scale, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: ihi,ilo,info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: scale(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zgebal
#else 
               module procedure stdlib_zgebal
#endif
          end interface gebal



          interface gebrd
          !! GEBRD reduces a general complex M-by-N matrix A to upper or lower
          !! bidiagonal form B by a unitary transformation: Q**H * A * P = B.
          !! If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: taup(*),tauq(*),work(*)
               end subroutine cgebrd
#else 
               module procedure stdlib_cgebrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*),e(*),taup(*),tauq(*),work(*)
               end subroutine dgebrd
#else 
               module procedure stdlib_dgebrd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gebrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*),e(*),taup(*),tauq(*),work(*)
               end subroutine sgebrd
#else 
               module procedure stdlib_sgebrd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gebrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: taup(*),tauq(*),work(*)
               end subroutine zgebrd
#else 
               module procedure stdlib_zgebrd
#endif
          end interface gebrd



          interface gecon
          !! GECON estimates the reciprocal of the condition number of a general
          !! complex matrix A, in either the 1-norm or the infinity-norm, using
          !! the LU factorization computed by CGETRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as
          !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgecon( norm, n, a, lda, anorm, rcond, work, rwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgecon
#else 
               module procedure stdlib_cgecon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgecon( norm, n, a, lda, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,work(*)
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dgecon
#else 
               module procedure stdlib_dgecon
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gecon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgecon( norm, n, a, lda, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,work(*)
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine sgecon
#else 
               module procedure stdlib_sgecon
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gecon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgecon( norm, n, a, lda, anorm, rcond, work, rwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgecon
#else 
               module procedure stdlib_zgecon
#endif
          end interface gecon



          interface geequ
          !! GEEQU computes row and column scalings intended to equilibrate an
          !! M-by-N matrix A and reduce its condition number.  R returns the row
          !! scale factors and C the column scale factors, chosen to try to make
          !! the largest element in each row and column of the matrix B with
          !! elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.
          !! R(i) and C(j) are restricted to be between SMLNUM = smallest safe
          !! number and BIGNUM = largest safe number.  Use of these scaling
          !! factors is not guaranteed to reduce the condition number of A but
          !! works well in practice.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(in) :: a(lda,*)
               end subroutine cgeequ
#else 
               module procedure stdlib_cgeequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dgeequ
#else 
               module procedure stdlib_dgeequ
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geequ

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(in) :: a(lda,*)
               end subroutine sgeequ
#else 
               module procedure stdlib_sgeequ
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geequ

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgeequ( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(in) :: a(lda,*)
               end subroutine zgeequ
#else 
               module procedure stdlib_zgeequ
#endif
          end interface geequ



          interface geequb
          !! GEEQUB computes row and column scalings intended to equilibrate an
          !! M-by-N matrix A and reduce its condition number.  R returns the row
          !! scale factors and C the column scale factors, chosen to try to make
          !! the largest element in each row and column of the matrix B with
          !! elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most
          !! the radix.
          !! R(i) and C(j) are restricted to be a power of the radix between
          !! SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use
          !! of these scaling factors is not guaranteed to reduce the condition
          !! number of A but works well in practice.
          !! This routine differs from CGEEQU by restricting the scaling factors
          !! to a power of the radix.  Barring over- and underflow, scaling by
          !! these factors introduces no additional rounding errors.  However, the
          !! scaled entries' magnitudes are no longer approximately 1 but lie
          !! between sqrt(radix) and 1/sqrt(radix).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(in) :: a(lda,*)
               end subroutine cgeequb
#else 
               module procedure stdlib_cgeequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dgeequb
#else 
               module procedure stdlib_dgeequb
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geequb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(in) :: a(lda,*)
               end subroutine sgeequb
#else 
               module procedure stdlib_sgeequb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geequb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgeequb( m, n, a, lda, r, c, rowcnd, colcnd, amax,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(out) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(in) :: a(lda,*)
               end subroutine zgeequb
#else 
               module procedure stdlib_zgeequb
#endif
          end interface geequb



          interface gees
          !! GEES computes for an N-by-N complex nonsymmetric matrix A, the
          !! eigenvalues, the Schur form T, and, optionally, the matrix of Schur
          !! vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).
          !! Optionally, it also orders the eigenvalues on the diagonal of the
          !! Schur form so that selected eigenvalues are at the top left.
          !! The leading columns of Z then form an orthonormal basis for the
          !! invariant subspace corresponding to the selected eigenvalues.
          !! A complex matrix is in Schur form if it is upper triangular.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgees( jobvs, sort, select, n, a, lda, sdim, w, vs,ldvs, work, lwork, &
                         rwork, bwork, info )
                    import sp,dp,qp,ilp,lk,stdlib_select_c
                    implicit none(type,external) 
                    character, intent(in) :: jobvs,sort
                    integer(ilp), intent(out) :: info,sdim
                    integer(ilp), intent(in) :: lda,ldvs,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: vs(ldvs,*),w(*),work(*)
                    procedure(stdlib_select_c) :: select
               end subroutine cgees
#else 
               module procedure stdlib_cgees
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgees( jobvs, sort, select, n, a, lda, sdim, wr, wi,vs, ldvs, work, &
                         lwork, bwork, info )
                    import sp,dp,qp,ilp,lk,stdlib_select_d
                    implicit none(type,external) 
                    character, intent(in) :: jobvs,sort
                    integer(ilp), intent(out) :: info,sdim
                    integer(ilp), intent(in) :: lda,ldvs,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: vs(ldvs,*),wi(*),work(*),wr(*)
                    procedure(stdlib_select_d) :: select
               end subroutine dgees
#else 
               module procedure stdlib_dgees
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gees

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgees( jobvs, sort, select, n, a, lda, sdim, wr, wi,vs, ldvs, work, &
                         lwork, bwork, info )
                    import sp,dp,qp,ilp,lk,stdlib_select_s 
                    implicit none(type,external) 
                    character, intent(in) :: jobvs,sort
                    integer(ilp), intent(out) :: info,sdim
                    integer(ilp), intent(in) :: lda,ldvs,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: vs(ldvs,*),wi(*),work(*),wr(*)
                    procedure(stdlib_select_s) :: select
               end subroutine sgees
#else 
               module procedure stdlib_sgees
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gees

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgees( jobvs, sort, select, n, a, lda, sdim, w, vs,ldvs, work, lwork, &
                         rwork, bwork, info )
                    import sp,dp,qp,ilp,lk,stdlib_select_z 
                    implicit none(type,external) 
                    character, intent(in) :: jobvs,sort
                    integer(ilp), intent(out) :: info,sdim
                    integer(ilp), intent(in) :: lda,ldvs,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: vs(ldvs,*),w(*),work(*)
                    procedure(stdlib_select_z) :: select
               end subroutine zgees
#else 
               module procedure stdlib_zgees
#endif
          end interface gees



          interface geev
          !! GEEV computes for an N-by-N complex nonsymmetric matrix A, the
          !! eigenvalues and, optionally, the left and/or right eigenvectors.
          !! The right eigenvector v(j) of A satisfies
          !! A * v(j) = lambda(j) * v(j)
          !! where lambda(j) is its eigenvalue.
          !! The left eigenvector u(j) of A satisfies
          !! u(j)**H * A = lambda(j) * u(j)**H
          !! where u(j)**H denotes the conjugate transpose of u(j).
          !! The computed eigenvectors are normalized to have Euclidean norm
          !! equal to 1 and largest component real.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgeev( jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr,work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldvl,ldvr,lwork,n
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: vl(ldvl,*),vr(ldvr,*),w(*),work(*)
               end subroutine cgeev
#else 
               module procedure stdlib_cgeev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgeev( jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr,ldvr, work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldvl,ldvr,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: vl(ldvl,*),vr(ldvr,*),wi(*),work(*),wr(*)
               end subroutine dgeev
#else 
               module procedure stdlib_dgeev
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geev

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgeev( jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr,ldvr, work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldvl,ldvr,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: vl(ldvl,*),vr(ldvr,*),wi(*),work(*),wr(*)
               end subroutine sgeev
#else 
               module procedure stdlib_sgeev
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geev

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgeev( jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr,work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldvl,ldvr,lwork,n
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: vl(ldvl,*),vr(ldvr,*),w(*),work(*)
               end subroutine zgeev
#else 
               module procedure stdlib_zgeev
#endif
          end interface geev



          interface gehrd
          !! GEHRD reduces a complex general matrix A to upper Hessenberg form H by
          !! an unitary similarity transformation:  Q**H * A * Q = H .
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgehrd
#else 
               module procedure stdlib_cgehrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgehrd
#else 
               module procedure stdlib_dgehrd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gehrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgehrd
#else 
               module procedure stdlib_sgehrd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gehrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgehrd
#else 
               module procedure stdlib_zgehrd
#endif
          end interface gehrd



          interface gejsv
          !! GEJSV computes the singular value decomposition (SVD) of a complex M-by-N
          !! matrix [A], where M >= N. The SVD of [A] is written as
          !! [A] = [U] * [SIGMA] * [V]^*,
          !! where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
          !! diagonal elements, [U] is an M-by-N (or M-by-M) unitary matrix, and
          !! [V] is an N-by-N unitary matrix. The diagonal elements of [SIGMA] are
          !! the singular values of [A]. The columns of [U] and [V] are the left and
          !! the right singular vectors of [A], respectively. The matrices [U] and [V]
          !! are computed and stored in the arrays U and V, respectively. The diagonal
          !! of [SIGMA] is computed and stored in the array SVA.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, &
                         ldu, v, ldv,cwork, lwork, rwork, lrwork, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldu,ldv,lwork,lrwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: u(ldu,*),v(ldv,*),cwork(lwork)
                    real(sp), intent(out) :: sva(n),rwork(lrwork)
                    character, intent(in) :: joba,jobp,jobr,jobt,jobu,jobv
               end subroutine cgejsv
#else 
               module procedure stdlib_cgejsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, &
                         ldu, v, ldv,work, lwork, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldu,ldv,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: sva(n),u(ldu,*),v(ldv,*),work(lwork)
                    character, intent(in) :: joba,jobp,jobr,jobt,jobu,jobv
               end subroutine dgejsv
#else 
               module procedure stdlib_dgejsv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gejsv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, &
                         ldu, v, ldv,work, lwork, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldu,ldv,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: sva(n),u(ldu,*),v(ldv,*),work(lwork)
                    character, intent(in) :: joba,jobp,jobr,jobt,jobu,jobv
               end subroutine sgejsv
#else 
               module procedure stdlib_sgejsv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gejsv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, &
                         ldu, v, ldv,cwork, lwork, rwork, lrwork, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldu,ldv,lwork,lrwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: u(ldu,*),v(ldv,*),cwork(lwork)
                    real(dp), intent(out) :: sva(n),rwork(lrwork)
                    character, intent(in) :: joba,jobp,jobr,jobt,jobu,jobv
               end subroutine zgejsv
#else 
               module procedure stdlib_zgejsv
#endif
          end interface gejsv



          interface gelq
          !! GELQ computes an LQ factorization of a complex M-by-N matrix A:
          !! A = ( L 0 ) *  Q
          !! where:
          !! Q is a N-by-N orthogonal matrix;
          !! L is a lower-triangular M-by-M matrix;
          !! 0 is a M-by-(N-M) zero matrix, if M < N.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgelq( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,tsize,lwork
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(*),work(*)
               end subroutine cgelq
#else 
               module procedure stdlib_cgelq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgelq( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,tsize,lwork
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(*),work(*)
               end subroutine dgelq
#else 
               module procedure stdlib_dgelq
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gelq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgelq( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,tsize,lwork
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(*),work(*)
               end subroutine sgelq
#else 
               module procedure stdlib_sgelq
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gelq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgelq( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,tsize,lwork
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(*),work(*)
               end subroutine zgelq
#else 
               module procedure stdlib_zgelq
#endif
          end interface gelq



          interface gelqf
          !! GELQF computes an LQ factorization of a complex M-by-N matrix A:
          !! A = ( L 0 ) *  Q
          !! where:
          !! Q is a N-by-N orthogonal matrix;
          !! L is a lower-triangular M-by-M matrix;
          !! 0 is a M-by-(N-M) zero matrix, if M < N.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgelqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgelqf
#else 
               module procedure stdlib_cgelqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgelqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgelqf
#else 
               module procedure stdlib_dgelqf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gelqf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgelqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgelqf
#else 
               module procedure stdlib_sgelqf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gelqf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgelqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgelqf
#else 
               module procedure stdlib_zgelqf
#endif
          end interface gelqf



          interface gelqt
          !! GELQT computes a blocked LQ factorization of a complex M-by-N matrix A
          !! using the compact WY representation of Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgelqt( m, n, mb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,mb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine cgelqt
#else 
               module procedure stdlib_cgelqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgelqt( m, n, mb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,mb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine dgelqt
#else 
               module procedure stdlib_dgelqt
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gelqt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgelqt( m, n, mb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,mb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine sgelqt
#else 
               module procedure stdlib_sgelqt
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gelqt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgelqt( m, n, mb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,mb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine zgelqt
#else 
               module procedure stdlib_zgelqt
#endif
          end interface gelqt



          interface gelqt3
          !! GELQT3 recursively computes a LQ factorization of a complex M-by-N
          !! matrix A, using the compact WY representation of Q.
          !! Based on the algorithm of Elmroth and Gustavson,
          !! IBM J. Res. Develop. Vol 44 No. 4 July 2000.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine cgelqt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,ldt
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*)
               end subroutine cgelqt3
#else 
               module procedure stdlib_cgelqt3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine dgelqt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,ldt
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*)
               end subroutine dgelqt3
#else 
               module procedure stdlib_dgelqt3
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gelqt3

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine sgelqt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,ldt
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*)
               end subroutine sgelqt3
#else 
               module procedure stdlib_sgelqt3
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gelqt3

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine zgelqt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,ldt
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*)
               end subroutine zgelqt3
#else 
               module procedure stdlib_zgelqt3
#endif
          end interface gelqt3



          interface gels
          !! GELS solves overdetermined or underdetermined complex linear systems
          !! involving an M-by-N matrix A, or its conjugate-transpose, using a QR
          !! or LQ factorization of A.  It is assumed that A has full rank.
          !! The following options are provided:
          !! 1. If TRANS = 'N' and m >= n:  find the least squares solution of
          !! an overdetermined system, i.e., solve the least squares problem
          !! minimize || B - A*X ||.
          !! 2. If TRANS = 'N' and m < n:  find the minimum norm solution of
          !! an underdetermined system A * X = B.
          !! 3. If TRANS = 'C' and m >= n:  find the minimum norm solution of
          !! an underdetermined system A**H * X = B.
          !! 4. If TRANS = 'C' and m < n:  find the least squares solution of
          !! an overdetermined system, i.e., solve the least squares problem
          !! minimize || B - A**H * X ||.
          !! Several right hand side vectors b and solution vectors x can be
          !! handled in a single call; they are stored as the columns of the
          !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution
          !! matrix X.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgels
#else 
               module procedure stdlib_cgels
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgels
#else 
               module procedure stdlib_dgels
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gels

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgels
#else 
               module procedure stdlib_sgels
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gels

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgels
#else 
               module procedure stdlib_zgels
#endif
          end interface gels



          interface gelsd
          !! GELSD computes the minimum-norm solution to a real linear least
          !! squares problem:
          !! minimize 2-norm(| b - A*x |)
          !! using the singular value decomposition (SVD) of A. A is an M-by-N
          !! matrix which may be rank-deficient.
          !! Several right hand side vectors b and solution vectors x can be
          !! handled in a single call; they are stored as the columns of the
          !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution
          !! matrix X.
          !! The problem is solved in three steps:
          !! (1) Reduce the coefficient matrix A to bidiagonal form with
          !! Householder transformations, reducing the original problem
          !! into a "bidiagonal least squares problem" (BLS)
          !! (2) Solve the BLS using a divide and conquer approach.
          !! (3) Apply back all the Householder transformations to solve
          !! the original least squares problem.
          !! The effective rank of A is determined by treating as zero those
          !! singular values which are less than RCOND times the largest singular
          !! value.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
                         iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,rank,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    real(sp), intent(out) :: rwork(*),s(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgelsd
#else 
               module procedure stdlib_cgelsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,rank,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: s(*),work(*)
               end subroutine dgelsd
#else 
               module procedure stdlib_dgelsd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gelsd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond,rank, work, lwork, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,rank,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: s(*),work(*)
               end subroutine sgelsd
#else 
               module procedure stdlib_sgelsd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gelsd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
                         iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,rank,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    real(dp), intent(out) :: rwork(*),s(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgelsd
#else 
               module procedure stdlib_zgelsd
#endif
          end interface gelsd



          interface gelss
          !! GELSS computes the minimum norm solution to a complex linear
          !! least squares problem:
          !! Minimize 2-norm(| b - A*x |).
          !! using the singular value decomposition (SVD) of A. A is an M-by-N
          !! matrix which may be rank-deficient.
          !! Several right hand side vectors b and solution vectors x can be
          !! handled in a single call; they are stored as the columns of the
          !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
          !! X.
          !! The effective rank of A is determined by treating as zero those
          !! singular values which are less than RCOND times the largest singular
          !! value.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,rank
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    real(sp), intent(out) :: rwork(*),s(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgelss
#else 
               module procedure stdlib_cgelss
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,rank
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: s(*),work(*)
               end subroutine dgelss
#else 
               module procedure stdlib_dgelss
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gelss

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,rank
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: s(*),work(*)
               end subroutine sgelss
#else 
               module procedure stdlib_sgelss
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gelss

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,rank
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    real(dp), intent(out) :: rwork(*),s(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgelss
#else 
               module procedure stdlib_zgelss
#endif
          end interface gelss



          interface gelsy
          !! GELSY computes the minimum-norm solution to a complex linear least
          !! squares problem:
          !! minimize || A * X - B ||
          !! using a complete orthogonal factorization of A.  A is an M-by-N
          !! matrix which may be rank-deficient.
          !! Several right hand side vectors b and solution vectors x can be
          !! handled in a single call; they are stored as the columns of the
          !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution
          !! matrix X.
          !! The routine first computes a QR factorization with column pivoting:
          !! A * P = Q * [ R11 R12 ]
          !! [  0  R22 ]
          !! with R11 defined as the largest leading submatrix whose estimated
          !! condition number is less than 1/RCOND.  The order of R11, RANK,
          !! is the effective rank of A.
          !! Then, R22 is considered to be negligible, and R12 is annihilated
          !! by unitary transformations from the right, arriving at the
          !! complete orthogonal factorization:
          !! A * P = Q * [ T11 0 ] * Z
          !! [  0  0 ]
          !! The minimum-norm solution is then
          !! X = P * Z**H [ inv(T11)*Q1**H*B ]
          !! [        0         ]
          !! where Q1 consists of the first RANK columns of Q.
          !! This routine is basically identical to the original xGELSX except
          !! three differences:
          !! o The permutation of matrix B (the right hand side) is faster and
          !! more simple.
          !! o The call to the subroutine xGEQPF has been substituted by the
          !! the call to the subroutine xGEQP3. This subroutine is a Blas-3
          !! version of the QR factorization with column pivoting.
          !! o Matrix B (the right hand side) is updated with Blas-3.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,rank
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    integer(ilp), intent(inout) :: jpvt(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgelsy
#else 
               module procedure stdlib_cgelsy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,rank
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    integer(ilp), intent(inout) :: jpvt(*)
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgelsy
#else 
               module procedure stdlib_dgelsy
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gelsy

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,rank
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(in) :: rcond
                    integer(ilp), intent(inout) :: jpvt(*)
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgelsy
#else 
               module procedure stdlib_sgelsy
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gelsy

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,rank
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(in) :: rcond
                    integer(ilp), intent(inout) :: jpvt(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgelsy
#else 
               module procedure stdlib_zgelsy
#endif
          end interface gelsy



          interface gemlq
          !! GEMLQ overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product
          !! of blocked elementary reflectors computed by short wide
          !! LQ factorization (CGELQ)
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgemlq( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    complex(sp), intent(in) :: a(lda,*),t(*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgemlq
#else 
               module procedure stdlib_cgemlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgemlq( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    real(dp), intent(in) :: a(lda,*),t(*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgemlq
#else 
               module procedure stdlib_dgemlq
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gemlq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgemlq( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    real(sp), intent(in) :: a(lda,*),t(*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgemlq
#else 
               module procedure stdlib_sgemlq
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gemlq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgemlq( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    complex(dp), intent(in) :: a(lda,*),t(*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgemlq
#else 
               module procedure stdlib_zgemlq
#endif
          end interface gemlq



          interface gemlqt
          !! GEMLQT overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q C            C Q
          !! TRANS = 'C':   Q**H C            C Q**H
          !! where Q is a complex unitary matrix defined as the product of K
          !! elementary reflectors:
          !! Q = H(1) H(2) . . . H(K) = I - V T V**H
          !! generated using the compact WY representation as returned by CGELQT.
          !! Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgemlqt( side, trans, m, n, k, mb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,ldc,m,n,mb,ldt
                    complex(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgemlqt
#else 
               module procedure stdlib_cgemlqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgemlqt( side, trans, m, n, k, mb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,ldc,m,n,mb,ldt
                    real(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgemlqt
#else 
               module procedure stdlib_dgemlqt
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gemlqt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgemlqt( side, trans, m, n, k, mb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,ldc,m,n,mb,ldt
                    real(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgemlqt
#else 
               module procedure stdlib_sgemlqt
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gemlqt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgemlqt( side, trans, m, n, k, mb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,ldc,m,n,mb,ldt
                    complex(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgemlqt
#else 
               module procedure stdlib_zgemlqt
#endif
          end interface gemlqt



          interface gemqr
          !! GEMQR overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product
          !! of blocked elementary reflectors computed by tall skinny
          !! QR factorization (CGEQR)
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgemqr( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    complex(sp), intent(in) :: a(lda,*),t(*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgemqr
#else 
               module procedure stdlib_cgemqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgemqr( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    real(dp), intent(in) :: a(lda,*),t(*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgemqr
#else 
               module procedure stdlib_dgemqr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gemqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgemqr( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    real(sp), intent(in) :: a(lda,*),t(*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgemqr
#else 
               module procedure stdlib_sgemqr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gemqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgemqr( side, trans, m, n, k, a, lda, t, tsize,c, ldc, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,tsize,lwork,ldc
                    complex(dp), intent(in) :: a(lda,*),t(*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgemqr
#else 
               module procedure stdlib_zgemqr
#endif
          end interface gemqr



          interface gemqrt
          !! GEMQRT overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q C            C Q
          !! TRANS = 'C':    Q**H C            C Q**H
          !! where Q is a complex orthogonal matrix defined as the product of K
          !! elementary reflectors:
          !! Q = H(1) H(2) . . . H(K) = I - V T V**H
          !! generated using the compact WY representation as returned by CGEQRT.
          !! Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,ldc,m,n,nb,ldt
                    complex(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgemqrt
#else 
               module procedure stdlib_cgemqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,ldc,m,n,nb,ldt
                    real(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgemqrt
#else 
               module procedure stdlib_dgemqrt
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gemqrt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,ldc,m,n,nb,ldt
                    real(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgemqrt
#else 
               module procedure stdlib_sgemqrt
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gemqrt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgemqrt( side, trans, m, n, k, nb, v, ldv, t, ldt,c, ldc, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,ldc,m,n,nb,ldt
                    complex(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgemqrt
#else 
               module procedure stdlib_zgemqrt
#endif
          end interface gemqrt



          interface geqlf
          !! GEQLF computes a QL factorization of a complex M-by-N matrix A:
          !! A = Q * L.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgeqlf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgeqlf
#else 
               module procedure stdlib_cgeqlf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgeqlf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgeqlf
#else 
               module procedure stdlib_dgeqlf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geqlf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgeqlf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgeqlf
#else 
               module procedure stdlib_sgeqlf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geqlf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgeqlf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgeqlf
#else 
               module procedure stdlib_zgeqlf
#endif
          end interface geqlf



          interface geqr
          !! GEQR computes a QR factorization of a complex M-by-N matrix A:
          !! A = Q * ( R ),
          !! ( 0 )
          !! where:
          !! Q is a M-by-M orthogonal matrix;
          !! R is an upper-triangular N-by-N matrix;
          !! 0 is a (M-N)-by-N zero matrix, if M > N.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgeqr( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,tsize,lwork
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(*),work(*)
               end subroutine cgeqr
#else 
               module procedure stdlib_cgeqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgeqr( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,tsize,lwork
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(*),work(*)
               end subroutine dgeqr
#else 
               module procedure stdlib_dgeqr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgeqr( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,tsize,lwork
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(*),work(*)
               end subroutine sgeqr
#else 
               module procedure stdlib_sgeqr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgeqr( m, n, a, lda, t, tsize, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,tsize,lwork
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(*),work(*)
               end subroutine zgeqr
#else 
               module procedure stdlib_zgeqr
#endif
          end interface geqr



          interface geqr2p
          !! GEQR2P computes a QR factorization of a complex m-by-n matrix A:
          !! A = Q * ( R ),
          !! ( 0 )
          !! where:
          !! Q is a m-by-m orthogonal matrix;
          !! R is an upper-triangular n-by-n matrix with nonnegative diagonal
          !! entries;
          !! 0 is a (m-n)-by-n zero matrix, if m > n.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgeqr2p( m, n, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgeqr2p
#else 
               module procedure stdlib_cgeqr2p
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgeqr2p( m, n, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgeqr2p
#else 
               module procedure stdlib_dgeqr2p
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geqr2p

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgeqr2p( m, n, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgeqr2p
#else 
               module procedure stdlib_sgeqr2p
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geqr2p

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgeqr2p( m, n, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgeqr2p
#else 
               module procedure stdlib_zgeqr2p
#endif
          end interface geqr2p



          interface geqrf
          !! GEQRF computes a QR factorization of a complex M-by-N matrix A:
          !! A = Q * ( R ),
          !! ( 0 )
          !! where:
          !! Q is a M-by-M orthogonal matrix;
          !! R is an upper-triangular N-by-N matrix;
          !! 0 is a (M-N)-by-N zero matrix, if M > N.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgeqrf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgeqrf
#else 
               module procedure stdlib_cgeqrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgeqrf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgeqrf
#else 
               module procedure stdlib_dgeqrf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geqrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgeqrf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgeqrf
#else 
               module procedure stdlib_sgeqrf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geqrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgeqrf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgeqrf
#else 
               module procedure stdlib_zgeqrf
#endif
          end interface geqrf



          interface geqrfp
          !! CGEQR2P computes a QR factorization of a complex M-by-N matrix A:
          !! A = Q * ( R ),
          !! ( 0 )
          !! where:
          !! Q is a M-by-M orthogonal matrix;
          !! R is an upper-triangular N-by-N matrix with nonnegative diagonal
          !! entries;
          !! 0 is a (M-N)-by-N zero matrix, if M > N.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgeqrfp( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgeqrfp
#else 
               module procedure stdlib_cgeqrfp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgeqrfp( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgeqrfp
#else 
               module procedure stdlib_dgeqrfp
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geqrfp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgeqrfp( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgeqrfp
#else 
               module procedure stdlib_sgeqrfp
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geqrfp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgeqrfp( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgeqrfp
#else 
               module procedure stdlib_zgeqrfp
#endif
          end interface geqrfp



          interface geqrt
          !! GEQRT computes a blocked QR factorization of a complex M-by-N matrix A
          !! using the compact WY representation of Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgeqrt( m, n, nb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine cgeqrt
#else 
               module procedure stdlib_cgeqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgeqrt( m, n, nb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine dgeqrt
#else 
               module procedure stdlib_dgeqrt
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geqrt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgeqrt( m, n, nb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine sgeqrt
#else 
               module procedure stdlib_sgeqrt
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geqrt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgeqrt( m, n, nb, a, lda, t, ldt, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine zgeqrt
#else 
               module procedure stdlib_zgeqrt
#endif
          end interface geqrt



          interface geqrt2
          !! GEQRT2 computes a QR factorization of a complex M-by-N matrix A,
          !! using the compact WY representation of Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgeqrt2( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*)
               end subroutine cgeqrt2
#else 
               module procedure stdlib_cgeqrt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgeqrt2( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*)
               end subroutine dgeqrt2
#else 
               module procedure stdlib_dgeqrt2
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geqrt2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgeqrt2( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*)
               end subroutine sgeqrt2
#else 
               module procedure stdlib_sgeqrt2
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geqrt2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgeqrt2( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*)
               end subroutine zgeqrt2
#else 
               module procedure stdlib_zgeqrt2
#endif
          end interface geqrt2



          interface geqrt3
          !! GEQRT3 recursively computes a QR factorization of a complex M-by-N matrix A,
          !! using the compact WY representation of Q.
          !! Based on the algorithm of Elmroth and Gustavson,
          !! IBM J. Res. Develop. Vol 44 No. 4 July 2000.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine cgeqrt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,ldt
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*)
               end subroutine cgeqrt3
#else 
               module procedure stdlib_cgeqrt3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine dgeqrt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,ldt
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*)
               end subroutine dgeqrt3
#else 
               module procedure stdlib_dgeqrt3
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geqrt3

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine sgeqrt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,ldt
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*)
               end subroutine sgeqrt3
#else 
               module procedure stdlib_sgeqrt3
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$geqrt3

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine zgeqrt3( m, n, a, lda, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,ldt
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*)
               end subroutine zgeqrt3
#else 
               module procedure stdlib_zgeqrt3
#endif
          end interface geqrt3



          interface gerfs
          !! GERFS improves the computed solution to a system of linear
          !! equations and provides error bounds and backward error estimates for
          !! the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cgerfs
#else 
               module procedure stdlib_cgerfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dgerfs
#else 
               module procedure stdlib_dgerfs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gerfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine sgerfs
#else 
               module procedure stdlib_sgerfs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gerfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgerfs( trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zgerfs
#else 
               module procedure stdlib_zgerfs
#endif
          end interface gerfs



          interface gerqf
          !! GERQF computes an RQ factorization of a complex M-by-N matrix A:
          !! A = R * Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgerqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine cgerqf
#else 
               module procedure stdlib_cgerqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgerqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dgerqf
#else 
               module procedure stdlib_dgerqf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gerqf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgerqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine sgerqf
#else 
               module procedure stdlib_sgerqf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gerqf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgerqf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zgerqf
#else 
               module procedure stdlib_zgerqf
#endif
          end interface gerqf



          interface gesdd
          !! GESDD computes the singular value decomposition (SVD) of a complex
          !! M-by-N matrix A, optionally computing the left and/or right singular
          !! vectors, by using divide-and-conquer method. The SVD is written
          !! A = U * SIGMA * conjugate-transpose(V)
          !! where SIGMA is an M-by-N matrix which is zero except for its
          !! min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
          !! V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
          !! are the singular values of A; they are real and non-negative, and
          !! are returned in descending order.  The first min(m,n) columns of
          !! U and V are the left and right singular vectors of A.
          !! Note that the routine returns VT = V**H, not V.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, rwork, &
                         iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(sp), intent(out) :: rwork(*),s(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine cgesdd
#else 
               module procedure stdlib_cgesdd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: s(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine dgesdd
#else 
               module procedure stdlib_dgesdd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gesdd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: s(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine sgesdd
#else 
               module procedure stdlib_sgesdd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gesdd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, rwork, &
                         iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(dp), intent(out) :: rwork(*),s(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine zgesdd
#else 
               module procedure stdlib_zgesdd
#endif
          end interface gesdd



          interface gesv
          !! GESV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
          !! The LU decomposition with partial pivoting and row interchanges is
          !! used to factor A as
          !! A = P * L * U,
          !! where P is a permutation matrix, L is unit lower triangular, and U is
          !! upper triangular.  The factored form of A is then used to solve the
          !! system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine cgesv
#else 
               module procedure stdlib_cgesv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine dgesv
#else 
               module procedure stdlib_dgesv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gesv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine sgesv
#else 
               module procedure stdlib_sgesv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gesv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgesv( n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine zgesv
#else 
               module procedure stdlib_zgesv
#endif
          end interface gesv



          interface gesvd
          !! GESVD computes the singular value decomposition (SVD) of a complex
          !! M-by-N matrix A, optionally computing the left and/or right singular
          !! vectors. The SVD is written
          !! A = U * SIGMA * conjugate-transpose(V)
          !! where SIGMA is an M-by-N matrix which is zero except for its
          !! min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
          !! V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
          !! are the singular values of A; they are real and non-negative, and
          !! are returned in descending order.  The first min(m,n) columns of
          !! U and V are the left and right singular vectors of A.
          !! Note that the routine returns V**H, not V.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobu,jobvt
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(sp), intent(out) :: rwork(*),s(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine cgesvd
#else 
               module procedure stdlib_cgesvd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,vt, ldvt, work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobu,jobvt
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: s(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine dgesvd
#else 
               module procedure stdlib_dgesvd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gesvd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobu,jobvt
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: s(*),u(ldu,*),vt(ldvt,*),work(*)
               end subroutine sgesvd
#else 
               module procedure stdlib_sgesvd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gesvd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,vt, ldvt, work, lwork, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobu,jobvt
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldu,ldvt,lwork,m,n
                    real(dp), intent(out) :: rwork(*),s(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine zgesvd
#else 
               module procedure stdlib_zgesvd
#endif
          end interface gesvd



          interface gesvdq
          !! GESVDQ computes the singular value decomposition (SVD) of a complex
          !! M-by-N matrix A, where M >= N. The SVD of A is written as
          !! [++]   [xx]   [x0]   [xx]
          !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
          !! [++]   [xx]
          !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
          !! matrix, and V is an N-by-N unitary matrix. The diagonal elements
          !! of SIGMA are the singular values of A. The columns of U and V are the
          !! left and the right singular vectors of A, respectively.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
                         numrank, iwork, liwork,cwork, lcwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: joba,jobp,jobr,jobu,jobv
                    integer(ilp), intent(in) :: m,n,lda,ldu,ldv,liwork,lrwork
                    integer(ilp), intent(out) :: numrank,info,iwork(*)
                    integer(ilp), intent(inout) :: lcwork
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: u(ldu,*),v(ldv,*),cwork(*)
                    real(sp), intent(out) :: s(*),rwork(*)
               end subroutine cgesvdq
#else 
               module procedure stdlib_cgesvdq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
                         numrank, iwork, liwork,work, lwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: joba,jobp,jobr,jobu,jobv
                    integer(ilp), intent(in) :: m,n,lda,ldu,ldv,liwork,lrwork
                    integer(ilp), intent(out) :: numrank,info,iwork(*)
                    integer(ilp), intent(inout) :: lwork
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: u(ldu,*),v(ldv,*),work(*),s(*),rwork(*)
               end subroutine dgesvdq
#else 
               module procedure stdlib_dgesvdq
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gesvdq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
                         numrank, iwork, liwork,work, lwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: joba,jobp,jobr,jobu,jobv
                    integer(ilp), intent(in) :: m,n,lda,ldu,ldv,liwork,lrwork
                    integer(ilp), intent(out) :: numrank,info,iwork(*)
                    integer(ilp), intent(inout) :: lwork
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: u(ldu,*),v(ldv,*),work(*),s(*),rwork(*)
               end subroutine sgesvdq
#else 
               module procedure stdlib_sgesvdq
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gesvdq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
                         numrank, iwork, liwork,cwork, lcwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: joba,jobp,jobr,jobu,jobv
                    integer(ilp), intent(in) :: m,n,lda,ldu,ldv,liwork,lrwork
                    integer(ilp), intent(out) :: numrank,info,iwork(*)
                    integer(ilp), intent(inout) :: lcwork
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: u(ldu,*),v(ldv,*),cwork(*)
                    real(dp), intent(out) :: s(*),rwork(*)
               end subroutine zgesvdq
#else 
               module procedure stdlib_zgesvdq
#endif
          end interface gesvdq



          interface gesvj
          !! GESVJ computes the singular value decomposition (SVD) of a complex
          !! M-by-N matrix A, where M >= N. The SVD of A is written as
          !! [++]   [xx]   [x0]   [xx]
          !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
          !! [++]   [xx]
          !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
          !! matrix, and V is an N-by-N unitary matrix. The diagonal elements
          !! of SIGMA are the singular values of A. The columns of U and V are the
          !! left and the right singular vectors of A, respectively.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, cwork, &
                         lwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,lrwork,m,mv,n
                    character, intent(in) :: joba,jobu,jobv
                    complex(sp), intent(inout) :: a(lda,*),v(ldv,*),cwork(lwork)
                    real(sp), intent(inout) :: rwork(lrwork)
                    real(sp), intent(out) :: sva(n)
               end subroutine cgesvj
#else 
               module procedure stdlib_cgesvj
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n
                    character, intent(in) :: joba,jobu,jobv
                    real(dp), intent(inout) :: a(lda,*),v(ldv,*),work(lwork)
                    real(dp), intent(out) :: sva(n)
               end subroutine dgesvj
#else 
               module procedure stdlib_dgesvj
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gesvj

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n
                    character, intent(in) :: joba,jobu,jobv
                    real(sp), intent(inout) :: a(lda,*),v(ldv,*),work(lwork)
                    real(sp), intent(out) :: sva(n)
               end subroutine sgesvj
#else 
               module procedure stdlib_sgesvj
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gesvj

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, cwork, &
                         lwork, rwork, lrwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,lrwork,m,mv,n
                    character, intent(in) :: joba,jobu,jobv
                    complex(dp), intent(inout) :: a(lda,*),v(ldv,*),cwork(lwork)
                    real(dp), intent(inout) :: rwork(lrwork)
                    real(dp), intent(out) :: sva(n)
               end subroutine zgesvj
#else 
               module procedure stdlib_zgesvj
#endif
          end interface gesvj



          interface getrf
          !! GETRF computes an LU factorization of a general M-by-N matrix A
          !! using partial pivoting with row interchanges.
          !! The factorization has the form
          !! A = P * L * U
          !! where P is a permutation matrix, L is lower triangular with unit
          !! diagonal elements (lower trapezoidal if m > n), and U is upper
          !! triangular (upper trapezoidal if m < n).
          !! This is the right-looking Level 3 BLAS version of the algorithm.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgetrf( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cgetrf
#else 
               module procedure stdlib_cgetrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgetrf( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dgetrf
#else 
               module procedure stdlib_dgetrf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$getrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgetrf( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine sgetrf
#else 
               module procedure stdlib_sgetrf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$getrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgetrf( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zgetrf
#else 
               module procedure stdlib_zgetrf
#endif
          end interface getrf



          interface getrf2
          !! GETRF2 computes an LU factorization of a general M-by-N matrix A
          !! using partial pivoting with row interchanges.
          !! The factorization has the form
          !! A = P * L * U
          !! where P is a permutation matrix, L is lower triangular with unit
          !! diagonal elements (lower trapezoidal if m > n), and U is upper
          !! triangular (upper trapezoidal if m < n).
          !! This is the recursive version of the algorithm. It divides
          !! the matrix into four submatrices:
          !! [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2
          !! A = [ -----|----- ]  with n1 = min(m,n)/2
          !! [  A21 | A22  ]       n2 = n-n1
          !! [ A11 ]
          !! The subroutine calls itself to factor [ --- ],
          !! [ A12 ]
          !! [ A12 ]
          !! do the swaps on [ --- ], solve A12, update A22,
          !! [ A22 ]
          !! then calls itself to factor A22 and do the swaps on A21.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine cgetrf2( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cgetrf2
#else 
               module procedure stdlib_cgetrf2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine dgetrf2( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dgetrf2
#else 
               module procedure stdlib_dgetrf2
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$getrf2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine sgetrf2( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine sgetrf2
#else 
               module procedure stdlib_sgetrf2
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$getrf2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine zgetrf2( m, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zgetrf2
#else 
               module procedure stdlib_zgetrf2
#endif
          end interface getrf2



          interface getri
          !! GETRI computes the inverse of a matrix using the LU factorization
          !! computed by CGETRF.
          !! This method inverts U and then computes inv(A) by solving the system
          !! inv(A)*L = inv(U) for inv(A).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgetri( n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgetri
#else 
               module procedure stdlib_cgetri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgetri( n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgetri
#else 
               module procedure stdlib_dgetri
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$getri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgetri( n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgetri
#else 
               module procedure stdlib_sgetri
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$getri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgetri( n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgetri
#else 
               module procedure stdlib_zgetri
#endif
          end interface getri



          interface getrs
          !! GETRS solves a system of linear equations
          !! A * X = B,  A**T * X = B,  or  A**H * X = B
          !! with a general N-by-N matrix A using the LU factorization computed
          !! by CGETRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cgetrs
#else 
               module procedure stdlib_cgetrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dgetrs
#else 
               module procedure stdlib_dgetrs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$getrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine sgetrs
#else 
               module procedure stdlib_sgetrs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$getrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgetrs( trans, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zgetrs
#else 
               module procedure stdlib_zgetrs
#endif
          end interface getrs



          interface getsls
          !! GETSLS solves overdetermined or underdetermined complex linear systems
          !! involving an M-by-N matrix A, using a tall skinny QR or short wide LQ
          !! factorization of A.  It is assumed that A has full rank.
          !! The following options are provided:
          !! 1. If TRANS = 'N' and m >= n:  find the least squares solution of
          !! an overdetermined system, i.e., solve the least squares problem
          !! minimize || B - A*X ||.
          !! 2. If TRANS = 'N' and m < n:  find the minimum norm solution of
          !! an underdetermined system A * X = B.
          !! 3. If TRANS = 'C' and m >= n:  find the minimum norm solution of
          !! an undetermined system A**T * X = B.
          !! 4. If TRANS = 'C' and m < n:  find the least squares solution of
          !! an overdetermined system, i.e., solve the least squares problem
          !! minimize || B - A**T * X ||.
          !! Several right hand side vectors b and solution vectors x can be
          !! handled in a single call; they are stored as the columns of the
          !! M-by-NRHS right hand side matrix B and the N-by-NRHS solution
          !! matrix X.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgetsls
#else 
               module procedure stdlib_cgetsls
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dgetsls
#else 
               module procedure stdlib_dgetsls
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$getsls

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sgetsls
#else 
               module procedure stdlib_sgetsls
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$getsls

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgetsls
#else 
               module procedure stdlib_zgetsls
#endif
          end interface getsls



          interface getsqrhrt
          !! GETSQRHRT computes a NB2-sized column blocked QR-factorization
          !! of a complex M-by-N matrix A with M >= N,
          !! A = Q * R.
          !! The routine uses internally a NB1-sized column blocked and MB1-sized
          !! row blocked TSQR-factorization and perfors the reconstruction
          !! of the Householder vectors from the TSQR output. The routine also
          !! converts the R_tsqr factor from the TSQR-factorization output into
          !! the R factor that corresponds to the Householder QR-factorization,
          !! A = Q_tsqr * R_tsqr = Q * R.
          !! The output Q and R factors are stored in the same format as in CGEQRT
          !! (Q is in blocked compact WY-representation). See the documentation
          !! of CGEQRT for more details on the format.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgetsqrhrt( m, n, mb1, nb1, nb2, a, lda, t, ldt, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,nb1,nb2,mb1
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine cgetsqrhrt
#else 
               module procedure stdlib_cgetsqrhrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgetsqrhrt( m, n, mb1, nb1, nb2, a, lda, t, ldt, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,nb1,nb2,mb1
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine dgetsqrhrt
#else 
               module procedure stdlib_dgetsqrhrt
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$getsqrhrt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgetsqrhrt( m, n, mb1, nb1, nb2, a, lda, t, ldt, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,nb1,nb2,mb1
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine sgetsqrhrt
#else 
               module procedure stdlib_sgetsqrhrt
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$getsqrhrt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgetsqrhrt( m, n, mb1, nb1, nb2, a, lda, t, ldt, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,nb1,nb2,mb1
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine zgetsqrhrt
#else 
               module procedure stdlib_zgetsqrhrt
#endif
          end interface getsqrhrt



          interface ggbak
          !! GGBAK forms the right or left eigenvectors of a complex generalized
          !! eigenvalue problem A*x = lambda*B*x, by backward transformation on
          !! the computed eigenvectors of the balanced pair of matrices output by
          !! CGGBAL.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job,side
                    integer(ilp), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: lscale(*),rscale(*)
                    complex(sp), intent(inout) :: v(ldv,*)
               end subroutine cggbak
#else 
               module procedure stdlib_cggbak
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job,side
                    integer(ilp), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: lscale(*),rscale(*)
                    real(dp), intent(inout) :: v(ldv,*)
               end subroutine dggbak
#else 
               module procedure stdlib_dggbak
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ggbak

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job,side
                    integer(ilp), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: lscale(*),rscale(*)
                    real(sp), intent(inout) :: v(ldv,*)
               end subroutine sggbak
#else 
               module procedure stdlib_sggbak
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ggbak

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job,side
                    integer(ilp), intent(in) :: ihi,ilo,ldv,m,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: lscale(*),rscale(*)
                    complex(dp), intent(inout) :: v(ldv,*)
               end subroutine zggbak
#else 
               module procedure stdlib_zggbak
#endif
          end interface ggbak



          interface ggbal
          !! GGBAL balances a pair of general complex matrices (A,B).  This
          !! involves, first, permuting A and B by similarity transformations to
          !! isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
          !! elements on the diagonal; and second, applying a diagonal similarity
          !! transformation to rows and columns ILO to IHI to make the rows
          !! and columns as close in norm as possible. Both steps are optional.
          !! Balancing may reduce the 1-norm of the matrices, and improve the
          !! accuracy of the computed eigenvalues and/or eigenvectors in the
          !! generalized eigenvalue problem A*x = lambda*B*x.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: ihi,ilo,info
                    integer(ilp), intent(in) :: lda,ldb,n
                    real(sp), intent(out) :: lscale(*),rscale(*),work(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine cggbal
#else 
               module procedure stdlib_cggbal
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: ihi,ilo,info
                    integer(ilp), intent(in) :: lda,ldb,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: lscale(*),rscale(*),work(*)
               end subroutine dggbal
#else 
               module procedure stdlib_dggbal
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ggbal

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: ihi,ilo,info
                    integer(ilp), intent(in) :: lda,ldb,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: lscale(*),rscale(*),work(*)
               end subroutine sggbal
#else 
               module procedure stdlib_sggbal
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ggbal

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: job
                    integer(ilp), intent(out) :: ihi,ilo,info
                    integer(ilp), intent(in) :: lda,ldb,n
                    real(dp), intent(out) :: lscale(*),rscale(*),work(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine zggbal
#else 
               module procedure stdlib_zggbal
#endif
          end interface ggbal



          interface gges
          !! GGES computes for a pair of N-by-N complex nonsymmetric matrices
          !! (A,B), the generalized eigenvalues, the generalized complex Schur
          !! form (S, T), and optionally left and/or right Schur vectors (VSL
          !! and VSR). This gives the generalized Schur factorization
          !! (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )
          !! where (VSR)**H is the conjugate-transpose of VSR.
          !! Optionally, it also orders the eigenvalues so that a selected cluster
          !! of eigenvalues appears in the leading diagonal blocks of the upper
          !! triangular matrix S and the upper triangular matrix T. The leading
          !! columns of VSL and VSR then form an unitary basis for the
          !! corresponding left and right eigenspaces (deflating subspaces).
          !! (If only the generalized eigenvalues are needed, use the driver
          !! CGGEV instead, which is faster.)
          !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
          !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
          !! usually represented as the pair (alpha,beta), as there is a
          !! reasonable interpretation for beta=0, and even for both being zero.
          !! A pair of matrices (S,T) is in generalized complex Schur form if S
          !! and T are upper triangular and, in addition, the diagonal elements
          !! of T are non-negative real numbers.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alpha, &
                         beta, vsl, ldvsl, vsr, ldvsr, work,lwork, rwork, bwork, info )
                    import sp,dp,qp,ilp,lk,stdlib_selctg_c 
                    implicit none(type,external) 
                    character, intent(in) :: jobvsl,jobvsr,sort
                    integer(ilp), intent(out) :: info,sdim
                    integer(ilp), intent(in) :: lda,ldb,ldvsl,ldvsr,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: alpha(*),beta(*),vsl(ldvsl,*),vsr(ldvsr,*),work(*)
                              
                    procedure(stdlib_selctg_c) :: selctg
               end subroutine cgges
#else 
               module procedure stdlib_cgges
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alphar, &
                         alphai, beta, vsl, ldvsl, vsr,ldvsr, work, lwork, bwork, info )
                    import sp,dp,qp,ilp,lk,stdlib_selctg_d 
                    implicit none(type,external) 
                    character, intent(in) :: jobvsl,jobvsr,sort
                    integer(ilp), intent(out) :: info,sdim
                    integer(ilp), intent(in) :: lda,ldb,ldvsl,ldvsr,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: alphai(*),alphar(*),beta(*),vsl(ldvsl,*),vsr(ldvsr,*)&
                              ,work(*)
                    procedure(stdlib_selctg_d) :: selctg
               end subroutine dgges
#else 
               module procedure stdlib_dgges
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gges

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alphar, &
                         alphai, beta, vsl, ldvsl, vsr,ldvsr, work, lwork, bwork, info )
                    import sp,dp,qp,ilp,lk,stdlib_selctg_s 
                    implicit none(type,external) 
                    character, intent(in) :: jobvsl,jobvsr,sort
                    integer(ilp), intent(out) :: info,sdim
                    integer(ilp), intent(in) :: lda,ldb,ldvsl,ldvsr,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: alphai(*),alphar(*),beta(*),vsl(ldvsl,*),vsr(ldvsr,*)&
                              ,work(*)
                    procedure(stdlib_selctg_s) :: selctg
               end subroutine sgges
#else 
               module procedure stdlib_sgges
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gges

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alpha, &
                         beta, vsl, ldvsl, vsr, ldvsr, work,lwork, rwork, bwork, info )
                    import sp,dp,qp,ilp,lk,stdlib_selctg_z
                    implicit none(type,external) 
                    character, intent(in) :: jobvsl,jobvsr,sort
                    integer(ilp), intent(out) :: info,sdim
                    integer(ilp), intent(in) :: lda,ldb,ldvsl,ldvsr,lwork,n
                    logical(lk), intent(out) :: bwork(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: alpha(*),beta(*),vsl(ldvsl,*),vsr(ldvsr,*),work(*)
                              
                    procedure(stdlib_selctg_z) :: selctg
               end subroutine zgges
#else 
               module procedure stdlib_zgges
#endif
          end interface gges



          interface ggev
          !! GGEV computes for a pair of N-by-N complex nonsymmetric matrices
          !! (A,B), the generalized eigenvalues, and optionally, the left and/or
          !! right generalized eigenvectors.
          !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
          !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
          !! singular. It is usually represented as the pair (alpha,beta), as
          !! there is a reasonable interpretation for beta=0, and even for both
          !! being zero.
          !! The right generalized eigenvector v(j) corresponding to the
          !! generalized eigenvalue lambda(j) of (A,B) satisfies
          !! A * v(j) = lambda(j) * B * v(j).
          !! The left generalized eigenvector u(j) corresponding to the
          !! generalized eigenvalues lambda(j) of (A,B) satisfies
          !! u(j)**H * A = lambda(j) * u(j)**H * B
          !! where u(j)**H is the conjugate-transpose of u(j).
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cggev( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
                         work, lwork, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldvl,ldvr,lwork,n
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: alpha(*),beta(*),vl(ldvl,*),vr(ldvr,*),work(*)
                              
               end subroutine cggev
#else 
               module procedure stdlib_cggev
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,beta, vl, ldvl, &
                         vr, ldvr, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldvl,ldvr,lwork,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: alphai(*),alphar(*),beta(*),vl(ldvl,*),vr(ldvr,*),&
                              work(*)
               end subroutine dggev
#else 
               module procedure stdlib_dggev
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ggev

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,beta, vl, ldvl, &
                         vr, ldvr, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldvl,ldvr,lwork,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: alphai(*),alphar(*),beta(*),vl(ldvl,*),vr(ldvr,*),&
                              work(*)
               end subroutine sggev
#else 
               module procedure stdlib_sggev
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ggev

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zggev( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
                         work, lwork, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobvl,jobvr
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldvl,ldvr,lwork,n
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: alpha(*),beta(*),vl(ldvl,*),vr(ldvr,*),work(*)
                              
               end subroutine zggev
#else 
               module procedure stdlib_zggev
#endif
          end interface ggev



          interface ggglm
          !! GGGLM solves a general Gauss-Markov linear model (GLM) problem:
          !! minimize || y ||_2   subject to   d = A*x + B*y
          !! x
          !! where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
          !! given N-vector. It is assumed that M <= N <= M+P, and
          !! rank(A) = M    and    rank( A B ) = N.
          !! Under these assumptions, the constrained equation is always
          !! consistent, and there is a unique solution x and a minimal 2-norm
          !! solution y, which is obtained using a generalized QR factorization
          !! of the matrices (A, B) given by
          !! A = Q*(R),   B = Q*T*Z.
          !! (0)
          !! In particular, if matrix B is square nonsingular, then the problem
          !! GLM is equivalent to the following weighted linear least squares
          !! problem
          !! minimize || inv(B)*(d-A*x) ||_2
          !! x
          !! where inv(B) denotes the inverse of B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),d(*)
                    complex(sp), intent(out) :: work(*),x(*),y(*)
               end subroutine cggglm
#else 
               module procedure stdlib_cggglm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),d(*)
                    real(dp), intent(out) :: work(*),x(*),y(*)
               end subroutine dggglm
#else 
               module procedure stdlib_dggglm
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ggglm

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),d(*)
                    real(sp), intent(out) :: work(*),x(*),y(*)
               end subroutine sggglm
#else 
               module procedure stdlib_sggglm
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ggglm

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),d(*)
                    complex(dp), intent(out) :: work(*),x(*),y(*)
               end subroutine zggglm
#else 
               module procedure stdlib_zggglm
#endif
          end interface ggglm



          interface gghrd
          !! GGHRD reduces a pair of complex matrices (A,B) to generalized upper
          !! Hessenberg form using unitary transformations, where A is a
          !! general matrix and B is upper triangular.  The form of the generalized
          !! eigenvalue problem is
          !! A*x = lambda*B*x,
          !! and B is typically made upper triangular by computing its QR
          !! factorization and moving the unitary matrix Q to the left side
          !! of the equation.
          !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
          !! Q**H*A*Z = H
          !! and transforms B to another upper triangular matrix T:
          !! Q**H*B*Z = T
          !! in order to reduce the problem to its standard form
          !! H*y = lambda*T*y
          !! where y = Z**H*x.
          !! The unitary matrices Q and Z are determined as products of Givens
          !! rotations.  They may either be formed explicitly, or they may be
          !! postmultiplied into input matrices Q1 and Z1, so that
          !! Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
          !! Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
          !! If Q1 is the unitary matrix from the QR factorization of B in the
          !! original equation A*x = lambda*B*x, then GGHRD reduces the original
          !! problem to generalized Hessenberg form.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq,compz
                    integer(ilp), intent(in) :: ihi,ilo,lda,ldb,ldq,ldz,n
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine cgghrd
#else 
               module procedure stdlib_cgghrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq,compz
                    integer(ilp), intent(in) :: ihi,ilo,lda,ldb,ldq,ldz,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine dgghrd
#else 
               module procedure stdlib_dgghrd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gghrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq,compz
                    integer(ilp), intent(in) :: ihi,ilo,lda,ldb,ldq,ldz,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine sgghrd
#else 
               module procedure stdlib_sgghrd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gghrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq,compz
                    integer(ilp), intent(in) :: ihi,ilo,lda,ldb,ldq,ldz,n
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine zgghrd
#else 
               module procedure stdlib_zgghrd
#endif
          end interface gghrd



          interface gglse
          !! GGLSE solves the linear equality-constrained least squares (LSE)
          !! problem:
          !! minimize || c - A*x ||_2   subject to   B*x = d
          !! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
          !! M-vector, and d is a given P-vector. It is assumed that
          !! P <= N <= M+P, and
          !! rank(B) = P and  rank( (A) ) = N.
          !! ( (B) )
          !! These conditions ensure that the LSE problem has a unique solution,
          !! which is obtained using a generalized RQ factorization of the
          !! matrices (B, A) given by
          !! B = (0 R)*Q,   A = Z*T*Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),c(*),d(*)
                    complex(sp), intent(out) :: work(*),x(*)
               end subroutine cgglse
#else 
               module procedure stdlib_cgglse
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),c(*),d(*)
                    real(dp), intent(out) :: work(*),x(*)
               end subroutine dgglse
#else 
               module procedure stdlib_dgglse
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gglse

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),c(*),d(*)
                    real(sp), intent(out) :: work(*),x(*)
               end subroutine sgglse
#else 
               module procedure stdlib_sgglse
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gglse

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),c(*),d(*)
                    complex(dp), intent(out) :: work(*),x(*)
               end subroutine zgglse
#else 
               module procedure stdlib_zgglse
#endif
          end interface gglse



          interface ggqrf
          !! GGQRF computes a generalized QR factorization of an N-by-M matrix A
          !! and an N-by-P matrix B:
          !! A = Q*R,        B = Q*T*Z,
          !! where Q is an N-by-N unitary matrix, Z is a P-by-P unitary matrix,
          !! and R and T assume one of the forms:
          !! if N >= M,  R = ( R11 ) M  ,   or if N < M,  R = ( R11  R12 ) N,
          !! (  0  ) N-M                         N   M-N
          !! M
          !! where R11 is upper triangular, and
          !! if N <= P,  T = ( 0  T12 ) N,   or if N > P,  T = ( T11 ) N-P,
          !! P-N  N                           ( T21 ) P
          !! P
          !! where T12 or T21 is upper triangular.
          !! In particular, if B is square and nonsingular, the GQR factorization
          !! of A and B implicitly gives the QR factorization of inv(B)*A:
          !! inv(B)*A = Z**H * (inv(T)*R)
          !! where inv(B) denotes the inverse of the matrix B, and Z' denotes the
          !! conjugate transpose of matrix Z.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine cggqrf
#else 
               module procedure stdlib_cggqrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine dggqrf
#else 
               module procedure stdlib_dggqrf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ggqrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine sggqrf
#else 
               module procedure stdlib_sggqrf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ggqrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zggqrf( n, m, p, a, lda, taua, b, ldb, taub, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine zggqrf
#else 
               module procedure stdlib_zggqrf
#endif
          end interface ggqrf



          interface ggrqf
          !! GGRQF computes a generalized RQ factorization of an M-by-N matrix A
          !! and a P-by-N matrix B:
          !! A = R*Q,        B = Z*T*Q,
          !! where Q is an N-by-N unitary matrix, Z is a P-by-P unitary
          !! matrix, and R and T assume one of the forms:
          !! if M <= N,  R = ( 0  R12 ) M,   or if M > N,  R = ( R11 ) M-N,
          !! N-M  M                           ( R21 ) N
          !! N
          !! where R12 or R21 is upper triangular, and
          !! if P >= N,  T = ( T11 ) N  ,   or if P < N,  T = ( T11  T12 ) P,
          !! (  0  ) P-N                         P   N-P
          !! N
          !! where T11 is upper triangular.
          !! In particular, if B is square and nonsingular, the GRQ factorization
          !! of A and B implicitly gives the RQ factorization of A*inv(B):
          !! A*inv(B) = (R*inv(T))*Z**H
          !! where inv(B) denotes the inverse of the matrix B, and Z**H denotes the
          !! conjugate transpose of the matrix Z.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine cggrqf
#else 
               module procedure stdlib_cggrqf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine dggrqf
#else 
               module procedure stdlib_dggrqf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ggrqf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine sggrqf
#else 
               module procedure stdlib_sggrqf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ggrqf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zggrqf( m, p, n, a, lda, taua, b, ldb, taub, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,lwork,m,n,p
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: taua(*),taub(*),work(*)
               end subroutine zggrqf
#else 
               module procedure stdlib_zggrqf
#endif
          end interface ggrqf



          interface gsvj0
          !! GSVJ0 is called from CGESVJ as a pre-processor and that is its main
          !! purpose. It applies Jacobi rotations in the same way as CGESVJ does, but
          !! it does not check convergence (stopping criterion). Few tuning
          !! parameters (marked by [TP]) are available for the implementer.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
                         nsweep, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n,nsweep
                    real(sp), intent(in) :: eps,sfmin,tol
                    character, intent(in) :: jobv
                    complex(sp), intent(inout) :: a(lda,*),d(n),v(ldv,*)
                    complex(sp), intent(out) :: work(lwork)
                    real(sp), intent(inout) :: sva(n)
               end subroutine cgsvj0
#else 
               module procedure stdlib_cgsvj0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
                         nsweep, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n,nsweep
                    real(dp), intent(in) :: eps,sfmin,tol
                    character, intent(in) :: jobv
                    real(dp), intent(inout) :: a(lda,*),sva(n),d(n),v(ldv,*)
                    real(dp), intent(out) :: work(lwork)
               end subroutine dgsvj0
#else 
               module procedure stdlib_dgsvj0
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gsvj0

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
                         nsweep, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n,nsweep
                    real(sp), intent(in) :: eps,sfmin,tol
                    character, intent(in) :: jobv
                    real(sp), intent(inout) :: a(lda,*),sva(n),d(n),v(ldv,*)
                    real(sp), intent(out) :: work(lwork)
               end subroutine sgsvj0
#else 
               module procedure stdlib_sgsvj0
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gsvj0

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
                         nsweep, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n,nsweep
                    real(dp), intent(in) :: eps,sfmin,tol
                    character, intent(in) :: jobv
                    complex(dp), intent(inout) :: a(lda,*),d(n),v(ldv,*)
                    complex(dp), intent(out) :: work(lwork)
                    real(dp), intent(inout) :: sva(n)
               end subroutine zgsvj0
#else 
               module procedure stdlib_zgsvj0
#endif
          end interface gsvj0



          interface gsvj1
          !! GSVJ1 is called from CGESVJ as a pre-processor and that is its main
          !! purpose. It applies Jacobi rotations in the same way as CGESVJ does, but
          !! it targets only particular pivots and it does not check convergence
          !! (stopping criterion). Few tuning parameters (marked by [TP]) are
          !! available for the implementer.
          !! Further Details
          !! ~~~~~~~~~~~~~~~
          !! GSVJ1 applies few sweeps of Jacobi rotations in the column space of
          !! the input M-by-N matrix A. The pivot pairs are taken from the (1,2)
          !! off-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The
          !! block-entries (tiles) of the (1,2) off-diagonal block are marked by the
          !! [x]'s in the following scheme:
          !! | *  *  * [x] [x] [x]|
          !! | *  *  * [x] [x] [x]|    Row-cycling in the nblr-by-nblc [x] blocks.
          !! | *  *  * [x] [x] [x]|    Row-cyclic pivoting inside each [x] block.
          !! |[x] [x] [x] *  *  * |
          !! |[x] [x] [x] *  *  * |
          !! |[x] [x] [x] *  *  * |
          !! In terms of the columns of A, the first N1 columns are rotated 'against'
          !! the remaining N-N1 columns, trying to increase the angle between the
          !! corresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is
          !! tiled using quadratic tiles of side KBL. Here, KBL is a tuning parameter.
          !! The number of sweeps is given in NSWEEP and the orthogonality threshold
          !! is given in TOL.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol,&
                          nsweep, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: eps,sfmin,tol
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n,n1,nsweep
                    character, intent(in) :: jobv
                    complex(sp), intent(inout) :: a(lda,*),d(n),v(ldv,*)
                    complex(sp), intent(out) :: work(lwork)
                    real(sp), intent(inout) :: sva(n)
               end subroutine cgsvj1
#else 
               module procedure stdlib_cgsvj1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol,&
                          nsweep, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: eps,sfmin,tol
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n,n1,nsweep
                    character, intent(in) :: jobv
                    real(dp), intent(inout) :: a(lda,*),d(n),sva(n),v(ldv,*)
                    real(dp), intent(out) :: work(lwork)
               end subroutine dgsvj1
#else 
               module procedure stdlib_dgsvj1
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gsvj1

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol,&
                          nsweep, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: eps,sfmin,tol
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n,n1,nsweep
                    character, intent(in) :: jobv
                    real(sp), intent(inout) :: a(lda,*),d(n),sva(n),v(ldv,*)
                    real(sp), intent(out) :: work(lwork)
               end subroutine sgsvj1
#else 
               module procedure stdlib_sgsvj1
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gsvj1

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol,&
                          nsweep, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: eps,sfmin,tol
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldv,lwork,m,mv,n,n1,nsweep
                    character, intent(in) :: jobv
                    complex(dp), intent(inout) :: a(lda,*),d(n),v(ldv,*)
                    complex(dp), intent(out) :: work(lwork)
                    real(dp), intent(inout) :: sva(n)
               end subroutine zgsvj1
#else 
               module procedure stdlib_zgsvj1
#endif
          end interface gsvj1



          interface gtcon
          !! GTCON estimates the reciprocal of the condition number of a complex
          !! tridiagonal matrix A using the LU factorization as computed by
          !! CGTTRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,work, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: d(*),dl(*),du(*),du2(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cgtcon
#else 
               module procedure stdlib_cgtcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,work, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(dp), intent(in) :: anorm,d(*),dl(*),du(*),du2(*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dgtcon
#else 
               module procedure stdlib_dgtcon
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gtcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,work, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(sp), intent(in) :: anorm,d(*),dl(*),du(*),du2(*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine sgtcon
#else 
               module procedure stdlib_sgtcon
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gtcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgtcon( norm, n, dl, d, du, du2, ipiv, anorm, rcond,work, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: d(*),dl(*),du(*),du2(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zgtcon
#else 
               module procedure stdlib_zgtcon
#endif
          end interface gtcon



          interface gtrfs
          !! GTRFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is tridiagonal, and provides
          !! error bounds and backward error estimates for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, rwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: b(ldb,*),d(*),df(*),dl(*),dlf(*),du(*),du2(*),duf(&
                              *)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cgtrfs
#else 
               module procedure stdlib_cgtrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: b(ldb,*),d(*),df(*),dl(*),dlf(*),du(*),du2(*),duf(*)
                              
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dgtrfs
#else 
               module procedure stdlib_dgtrfs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gtrfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: b(ldb,*),d(*),df(*),dl(*),dlf(*),du(*),du2(*),duf(*)
                              
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine sgtrfs
#else 
               module procedure stdlib_sgtrfs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gtrfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgtrfs( trans, n, nrhs, dl, d, du, dlf, df, duf, du2,ipiv, b, ldb, &
                         x, ldx, ferr, berr, work, rwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: b(ldb,*),d(*),df(*),dl(*),dlf(*),du(*),du2(*),duf(&
                              *)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zgtrfs
#else 
               module procedure stdlib_zgtrfs
#endif
          end interface gtrfs



          interface gtsv
          !! GTSV solves the equation
          !! A*X = B,
          !! where A is an N-by-N tridiagonal matrix, by Gaussian elimination with
          !! partial pivoting.
          !! Note that the equation  A**T *X = B  may be solved by interchanging the
          !! order of the arguments DU and DL.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgtsv( n, nrhs, dl, d, du, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(inout) :: b(ldb,*),d(*),dl(*),du(*)
               end subroutine cgtsv
#else 
               module procedure stdlib_cgtsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgtsv( n, nrhs, dl, d, du, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: b(ldb,*),d(*),dl(*),du(*)
               end subroutine dgtsv
#else 
               module procedure stdlib_dgtsv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gtsv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgtsv( n, nrhs, dl, d, du, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: b(ldb,*),d(*),dl(*),du(*)
               end subroutine sgtsv
#else 
               module procedure stdlib_sgtsv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gtsv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgtsv( n, nrhs, dl, d, du, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(inout) :: b(ldb,*),d(*),dl(*),du(*)
               end subroutine zgtsv
#else 
               module procedure stdlib_zgtsv
#endif
          end interface gtsv



          interface gttrf
          !! GTTRF computes an LU factorization of a complex tridiagonal matrix A
          !! using elimination with partial pivoting and row interchanges.
          !! The factorization has the form
          !! A = L * U
          !! where L is a product of permutation and unit lower bidiagonal
          !! matrices and U is upper triangular with nonzeros in only the main
          !! diagonal and first two superdiagonals.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgttrf( n, dl, d, du, du2, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: d(*),dl(*),du(*)
                    complex(sp), intent(out) :: du2(*)
               end subroutine cgttrf
#else 
               module procedure stdlib_cgttrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgttrf( n, dl, d, du, du2, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: d(*),dl(*),du(*)
                    real(dp), intent(out) :: du2(*)
               end subroutine dgttrf
#else 
               module procedure stdlib_dgttrf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gttrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgttrf( n, dl, d, du, du2, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: d(*),dl(*),du(*)
                    real(sp), intent(out) :: du2(*)
               end subroutine sgttrf
#else 
               module procedure stdlib_sgttrf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gttrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgttrf( n, dl, d, du, du2, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: d(*),dl(*),du(*)
                    complex(dp), intent(out) :: du2(*)
               end subroutine zgttrf
#else 
               module procedure stdlib_zgttrf
#endif
          end interface gttrf



          interface gttrs
          !! GTTRS solves one of the systems of equations
          !! A * X = B,  A**T * X = B,  or  A**H * X = B,
          !! with a tridiagonal matrix A using the LU factorization computed
          !! by CGTTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(in) :: d(*),dl(*),du(*),du2(*)
               end subroutine cgttrs
#else 
               module procedure stdlib_cgttrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    real(dp), intent(inout) :: b(ldb,*)
                    real(dp), intent(in) :: d(*),dl(*),du(*),du2(*)
               end subroutine dgttrs
#else 
               module procedure stdlib_dgttrs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gttrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    real(sp), intent(inout) :: b(ldb,*)
                    real(sp), intent(in) :: d(*),dl(*),du(*),du2(*)
               end subroutine sgttrs
#else 
               module procedure stdlib_sgttrs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$gttrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zgttrs( trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(in) :: d(*),dl(*),du(*),du2(*)
               end subroutine zgttrs
#else 
               module procedure stdlib_zgttrs
#endif
          end interface gttrs



          interface hb2st_kernels
          !! HB2ST_KERNELS is an internal routine used by the CHETRD_HB2ST
          !! subroutine.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, &
                         lda, v, tau, ldvt, work)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: wantz
                    integer(ilp), intent(in) :: ttype,st,ed,sweep,n,nb,ib,lda,ldvt
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: v(*),tau(*),work(*)
               end subroutine chb2st_kernels
#else 
               module procedure stdlib_chb2st_kernels
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hb2st_kernels

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine  zhb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, &
                         lda, v, tau, ldvt, work)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: wantz
                    integer(ilp), intent(in) :: ttype,st,ed,sweep,n,nb,ib,lda,ldvt
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: v(*),tau(*),work(*)
               end subroutine zhb2st_kernels
#else 
               module procedure stdlib_zhb2st_kernels
#endif
          end interface hb2st_kernels



          interface hbev
          !! HBEV computes all the eigenvalues and, optionally, eigenvectors of
          !! a complex Hermitian band matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,rwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldz,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chbev
#else 
               module procedure stdlib_chbev
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hbev

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,rwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldz,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhbev
#else 
               module procedure stdlib_zhbev
#endif
          end interface hbev



          interface hbevd
          !! HBEVD computes all the eigenvalues and, optionally, eigenvectors of
          !! a complex Hermitian band matrix A.  If eigenvectors are desired, it
          !! uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,ldz,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chbevd
#else 
               module procedure stdlib_chbevd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hbevd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,ldz,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhbevd
#else 
               module procedure stdlib_zhbevd
#endif
          end interface hbevd



          interface hbgst
          !! HBGST reduces a complex Hermitian-definite banded generalized
          !! eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,
          !! such that C has the same bandwidth as A.
          !! B must have been previously factorized as S**H*S by CPBSTF, using a
          !! split Cholesky factorization. A is overwritten by C = X**H*A*X, where
          !! X = S**(-1)*Q and Q is a unitary matrix chosen to preserve the
          !! bandwidth of A.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldx,n
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
                    complex(sp), intent(in) :: bb(ldbb,*)
                    complex(sp), intent(out) :: work(*),x(ldx,*)
               end subroutine chbgst
#else 
               module procedure stdlib_chbgst
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hbgst

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldx,n
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
                    complex(dp), intent(in) :: bb(ldbb,*)
                    complex(dp), intent(out) :: work(*),x(ldx,*)
               end subroutine zhbgst
#else 
               module procedure stdlib_zhbgst
#endif
          end interface hbgst



          interface hbgv
          !! HBGV computes all the eigenvalues, and optionally, the eigenvectors
          !! of a complex generalized Hermitian-definite banded eigenproblem, of
          !! the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
          !! and banded, and B is also positive definite.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldz,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chbgv
#else 
               module procedure stdlib_chbgv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hbgv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldz,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhbgv
#else 
               module procedure stdlib_zhbgv
#endif
          end interface hbgv



          interface hbgvd
          !! HBGVD computes all the eigenvalues, and optionally, the eigenvectors
          !! of a complex generalized Hermitian-definite banded eigenproblem, of
          !! the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
          !! and banded, and B is also positive definite.  If eigenvectors are
          !! desired, it uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
                         lwork, rwork, lrwork, iwork,liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldz,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chbgvd
#else 
               module procedure stdlib_chbgvd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hbgvd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
                         lwork, rwork, lrwork, iwork,liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldz,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhbgvd
#else 
               module procedure stdlib_zhbgvd
#endif
          end interface hbgvd



          interface hbtrd
          !! HBTRD reduces a complex Hermitian band matrix A to real symmetric
          !! tridiagonal form T by a unitary similarity transformation:
          !! Q**H * A * Q = T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldq,n
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: ab(ldab,*),q(ldq,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chbtrd
#else 
               module procedure stdlib_chbtrd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hbtrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldq,n
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: ab(ldab,*),q(ldq,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhbtrd
#else 
               module procedure stdlib_zhbtrd
#endif
          end interface hbtrd



          interface hecon
          !! HECON estimates the reciprocal of the condition number of a complex
          !! Hermitian matrix A using the factorization A = U*D*U**H or
          !! A = L*D*L**H computed by CHETRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine checon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine checon
#else 
               module procedure stdlib_checon
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hecon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhecon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhecon
#else 
               module procedure stdlib_zhecon
#endif
          end interface hecon



          interface hecon_rook
          !! HECON_ROOK estimates the reciprocal of the condition number of a complex
          !! Hermitian matrix A using the factorization A = U*D*U**H or
          !! A = L*D*L**H computed by CHETRF_ROOK.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine checon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine checon_rook
#else 
               module procedure stdlib_checon_rook
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hecon_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhecon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhecon_rook
#else 
               module procedure stdlib_zhecon_rook
#endif
          end interface hecon_rook



          interface heequb
          !! HEEQUB computes row and column scalings intended to equilibrate a
          !! Hermitian matrix A (with respect to the Euclidean norm) and reduce
          !! its condition number. The scale factors S are computed by the BIN
          !! algorithm (see references) so that the scaled matrix B with elements
          !! B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
          !! the smallest possible condition number over all possible diagonal
          !! scalings.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cheequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    character, intent(in) :: uplo
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cheequb
#else 
               module procedure stdlib_cheequb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$heequb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zheequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    character, intent(in) :: uplo
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zheequb
#else 
               module procedure stdlib_zheequb
#endif
          end interface heequb



          interface heev
          !! HEEV computes all eigenvalues and, optionally, eigenvectors of a
          !! complex Hermitian matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cheev( jobz, uplo, n, a, lda, w, work, lwork, rwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cheev
#else 
               module procedure stdlib_cheev
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$heev

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zheev( jobz, uplo, n, a, lda, w, work, lwork, rwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zheev
#else 
               module procedure stdlib_zheev
#endif
          end interface heev



          interface heevd
          !! HEEVD computes all eigenvalues and, optionally, eigenvectors of a
          !! complex Hermitian matrix A.  If eigenvectors are desired, it uses a
          !! divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cheevd( jobz, uplo, n, a, lda, w, work, lwork, rwork,lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cheevd
#else 
               module procedure stdlib_cheevd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$heevd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zheevd( jobz, uplo, n, a, lda, w, work, lwork, rwork,lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zheevd
#else 
               module procedure stdlib_zheevd
#endif
          end interface heevd



          interface heevr
          !! HEEVR computes selected eigenvalues and, optionally, eigenvectors
          !! of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can
          !! be selected by specifying either a range of values or a range of
          !! indices for the desired eigenvalues.
          !! HEEVR first reduces the matrix A to tridiagonal form T with a call
          !! to CHETRD.  Then, whenever possible, HEEVR calls CSTEMR to compute
          !! the eigenspectrum using Relatively Robust Representations.  CSTEMR
          !! computes eigenvalues by the dqds algorithm, while orthogonal
          !! eigenvectors are computed from various "good" L D L^T representations
          !! (also known as Relatively Robust Representations). Gram-Schmidt
          !! orthogonalization is avoided as far as possible. More specifically,
          !! the various steps of the algorithm are as follows.
          !! For each unreduced block (submatrix) of T,
          !! (a) Compute T - sigma I  = L D L^T, so that L and D
          !! define all the wanted eigenvalues to high relative accuracy.
          !! This means that small relative changes in the entries of D and L
          !! cause only small relative changes in the eigenvalues and
          !! eigenvectors. The standard (unfactored) representation of the
          !! tridiagonal matrix T does not have this property in general.
          !! (b) Compute the eigenvalues to suitable accuracy.
          !! If the eigenvectors are desired, the algorithm attains full
          !! accuracy of the computed eigenvalues only right before
          !! the corresponding vectors have to be computed, see steps c) and d).
          !! (c) For each cluster of close eigenvalues, select a new
          !! shift close to the cluster, find a new factorization, and refine
          !! the shifted eigenvalues to suitable accuracy.
          !! (d) For each eigenvalue with a large enough relative separation compute
          !! the corresponding eigenvector by forming a rank revealing twisted
          !! factorization. Go back to (c) for any clusters that remain.
          !! The desired accuracy of the output can be specified by the input
          !! parameter ABSTOL.
          !! For more details, see CSTEMR's documentation and:
          !! - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
          !! to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
          !! Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
          !! - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
          !! Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
          !! 2004.  Also LAPACK Working Note 154.
          !! - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
          !! tridiagonal eigenvalue/eigenvector problem",
          !! Computer Science Division Technical Report No. UCB/CSD-97-971,
          !! UC Berkeley, May 1997.
          !! Note 1 : HEEVR calls CSTEMR when the full spectrum is requested
          !! on machines which conform to the ieee-754 floating point standard.
          !! HEEVR calls SSTEBZ and CSTEIN on non-ieee machines and
          !! when partial spectrum requests are made.
          !! Normal execution of CSTEMR may create NaNs and infinities and
          !! hence may abort due to a floating point exception in environments
          !! which do not handle NaNs and infinities in the ieee standard default
          !! manner.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cheevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, &
                         ldz, isuppz, work, lwork,rwork, lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,range,uplo
                    integer(ilp), intent(in) :: il,iu,lda,ldz,liwork,lrwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: abstol,vl,vu
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine cheevr
#else 
               module procedure stdlib_cheevr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$heevr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zheevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, &
                         ldz, isuppz, work, lwork,rwork, lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,range,uplo
                    integer(ilp), intent(in) :: il,iu,lda,ldz,liwork,lrwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: abstol,vl,vu
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zheevr
#else 
               module procedure stdlib_zheevr
#endif
          end interface heevr



          interface hegst
          !! HEGST reduces a complex Hermitian-definite generalized
          !! eigenproblem to standard form.
          !! If ITYPE = 1, the problem is A*x = lambda*B*x,
          !! and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
          !! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
          !! B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.
          !! B must have been previously factorized as U**H*U or L*L**H by CPOTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chegst( itype, uplo, n, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,lda,ldb,n
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine chegst
#else 
               module procedure stdlib_chegst
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hegst

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhegst( itype, uplo, n, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,lda,ldb,n
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine zhegst
#else 
               module procedure stdlib_zhegst
#endif
          end interface hegst



          interface hegv
          !! HEGV computes all the eigenvalues, and optionally, the eigenvectors
          !! of a complex generalized Hermitian-definite eigenproblem, of the form
          !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
          !! Here A and B are assumed to be Hermitian and B is also
          !! positive definite.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chegv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,lda,ldb,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chegv
#else 
               module procedure stdlib_chegv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hegv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhegv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,lda,ldb,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhegv
#else 
               module procedure stdlib_zhegv
#endif
          end interface hegv



          interface hegvd
          !! HEGVD computes all the eigenvalues, and optionally, the eigenvectors
          !! of a complex generalized Hermitian-definite eigenproblem, of the form
          !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
          !! B are assumed to be Hermitian and B is also positive definite.
          !! If eigenvectors are desired, it uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chegvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: itype,lda,ldb,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chegvd
#else 
               module procedure stdlib_chegvd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hegvd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhegvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: itype,lda,ldb,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhegvd
#else 
               module procedure stdlib_zhegvd
#endif
          end interface hegvd



          interface herfs
          !! HERFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is Hermitian indefinite, and
          !! provides error bounds and backward error estimates for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cherfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cherfs
#else 
               module procedure stdlib_cherfs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$herfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zherfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zherfs
#else 
               module procedure stdlib_zherfs
#endif
          end interface herfs



          interface hesv
          !! HESV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
          !! matrices.
          !! The diagonal pivoting method is used to factor A as
          !! A = U * D * U**H,  if UPLO = 'U', or
          !! A = L * D * L**H,  if UPLO = 'L',
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is Hermitian and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
          !! used to solve the system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chesv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chesv
#else 
               module procedure stdlib_chesv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hesv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhesv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhesv
#else 
               module procedure stdlib_zhesv
#endif
          end interface hesv



          interface hesv_aa
          !! HESV_AA computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
          !! matrices.
          !! Aasen's algorithm is used to factor A as
          !! A = U**H * T * U,  if UPLO = 'U', or
          !! A = L * T * L**H,  if UPLO = 'L',
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and T is Hermitian and tridiagonal. The factored form
          !! of A is then used to solve the system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chesv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chesv_aa
#else 
               module procedure stdlib_chesv_aa
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hesv_aa

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhesv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhesv_aa
#else 
               module procedure stdlib_zhesv_aa
#endif
          end interface hesv_aa



          interface hesv_rk
          !! HESV_RK computes the solution to a complex system of linear
          !! equations A * X = B, where A is an N-by-N Hermitian matrix
          !! and X and B are N-by-NRHS matrices.
          !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
          !! to factor A as
          !! A = P*U*D*(U**H)*(P**T),  if UPLO = 'U', or
          !! A = P*L*D*(L**H)*(P**T),  if UPLO = 'L',
          !! where U (or L) is unit upper (or lower) triangular matrix,
          !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
          !! matrix, P**T is the transpose of P, and D is Hermitian and block
          !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! CHETRF_RK is called to compute the factorization of a complex
          !! Hermitian matrix.  The factored form of A is then used to solve
          !! the system of equations A * X = B by calling BLAS3 routine CHETRS_3.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chesv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: e(*),work(*)
               end subroutine chesv_rk
#else 
               module procedure stdlib_chesv_rk
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hesv_rk

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhesv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: e(*),work(*)
               end subroutine zhesv_rk
#else 
               module procedure stdlib_zhesv_rk
#endif
          end interface hesv_rk



          interface hesv_rook
          !! HESV_ROOK computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
          !! matrices.
          !! The bounded Bunch-Kaufman ("rook") diagonal pivoting method is used
          !! to factor A as
          !! A = U * D * U**T,  if UPLO = 'U', or
          !! A = L * D * L**T,  if UPLO = 'L',
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is Hermitian and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.
          !! CHETRF_ROOK is called to compute the factorization of a complex
          !! Hermition matrix A using the bounded Bunch-Kaufman ("rook") diagonal
          !! pivoting method.
          !! The factored form of A is then used to solve the system
          !! of equations A * X = B by calling CHETRS_ROOK (uses BLAS 2).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chesv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chesv_rook
#else 
               module procedure stdlib_chesv_rook
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hesv_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhesv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhesv_rook
#else 
               module procedure stdlib_zhesv_rook
#endif
          end interface hesv_rook



          interface heswapr
          !! HESWAPR applies an elementary permutation on the rows and the columns of
          !! a hermitian matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cheswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: i1,i2,lda,n
                    complex(sp), intent(inout) :: a(lda,n)
               end subroutine cheswapr
#else 
               module procedure stdlib_cheswapr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$heswapr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zheswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: i1,i2,lda,n
                    complex(dp), intent(inout) :: a(lda,n)
               end subroutine zheswapr
#else 
               module procedure stdlib_zheswapr
#endif
          end interface heswapr



          interface hetf2_rk
          !! HETF2_RK computes the factorization of a complex Hermitian matrix A
          !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
          !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
          !! where U (or L) is unit upper (or lower) triangular matrix,
          !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
          !! matrix, P**T is the transpose of P, and D is Hermitian and block
          !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
          !! For more information see Further Details section.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*)
               end subroutine chetf2_rk
#else 
               module procedure stdlib_chetf2_rk
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hetf2_rk

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*)
               end subroutine zhetf2_rk
#else 
               module procedure stdlib_zhetf2_rk
#endif
          end interface hetf2_rk



          interface hetf2_rook
          !! HETF2_ROOK computes the factorization of a complex Hermitian matrix A
          !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
          !! A = U*D*U**H  or  A = L*D*L**H
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, U**H is the conjugate transpose of U, and D is
          !! Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine chetf2_rook
#else 
               module procedure stdlib_chetf2_rook
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hetf2_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zhetf2_rook
#else 
               module procedure stdlib_zhetf2_rook
#endif
          end interface hetf2_rook



          interface hetrd
          !! HETRD reduces a complex Hermitian matrix A to real symmetric
          !! tridiagonal form T by a unitary similarity transformation:
          !! Q**H * A * Q = T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine chetrd
#else 
               module procedure stdlib_chetrd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hetrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zhetrd
#else 
               module procedure stdlib_zhetrd
#endif
          end interface hetrd



          interface hetrd_hb2st
          !! HETRD_HB2ST reduces a complex Hermitian band matrix A to real symmetric
          !! tridiagonal form T by a unitary similarity transformation:
          !! Q**H * A * Q = T.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chetrd_hb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, &
                         lhous, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: stage1,uplo,vect
                    integer(ilp), intent(in) :: n,kd,ldab,lhous,lwork
                    integer(ilp), intent(out) :: info
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
                    complex(sp), intent(out) :: hous(*),work(*)
               end subroutine chetrd_hb2st
#else 
               module procedure stdlib_chetrd_hb2st
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hetrd_hb2st

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhetrd_hb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, &
                         lhous, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: stage1,uplo,vect
                    integer(ilp), intent(in) :: n,kd,ldab,lhous,lwork
                    integer(ilp), intent(out) :: info
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
                    complex(dp), intent(out) :: hous(*),work(*)
               end subroutine zhetrd_hb2st
#else 
               module procedure stdlib_zhetrd_hb2st
#endif
          end interface hetrd_hb2st



          interface hetrd_he2hb
          !! HETRD_HE2HB reduces a complex Hermitian matrix A to complex Hermitian
          !! band-diagonal form AB by a unitary similarity transformation:
          !! Q**H * A * Q = AB.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chetrd_he2hb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldab,lwork,n,kd
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: ab(ldab,*),tau(*),work(*)
               end subroutine chetrd_he2hb
#else 
               module procedure stdlib_chetrd_he2hb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hetrd_he2hb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhetrd_he2hb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldab,lwork,n,kd
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: ab(ldab,*),tau(*),work(*)
               end subroutine zhetrd_he2hb
#else 
               module procedure stdlib_zhetrd_he2hb
#endif
          end interface hetrd_he2hb



          interface hetrf
          !! HETRF computes the factorization of a complex Hermitian matrix A
          !! using the Bunch-Kaufman diagonal pivoting method.  The form of the
          !! factorization is
          !! A = U*D*U**H  or  A = L*D*L**H
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is Hermitian and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetrf
#else 
               module procedure stdlib_chetrf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hetrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetrf
#else 
               module procedure stdlib_zhetrf
#endif
          end interface hetrf



          interface hetrf_aa
          !! HETRF_AA computes the factorization of a complex hermitian matrix A
          !! using the Aasen's algorithm.  The form of the factorization is
          !! A = U**H*T*U  or  A = L*T*L**H
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and T is a hermitian tridiagonal matrix.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,lwork
                    integer(ilp), intent(out) :: info,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetrf_aa
#else 
               module procedure stdlib_chetrf_aa
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hetrf_aa

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,lwork
                    integer(ilp), intent(out) :: info,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetrf_aa
#else 
               module procedure stdlib_zhetrf_aa
#endif
          end interface hetrf_aa



          interface hetrf_rk
          !! HETRF_RK computes the factorization of a complex Hermitian matrix A
          !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
          !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
          !! where U (or L) is unit upper (or lower) triangular matrix,
          !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
          !! matrix, P**T is the transpose of P, and D is Hermitian and block
          !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
          !! For more information see Further Details section.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*),work(*)
               end subroutine chetrf_rk
#else 
               module procedure stdlib_chetrf_rk
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hetrf_rk

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*),work(*)
               end subroutine zhetrf_rk
#else 
               module procedure stdlib_zhetrf_rk
#endif
          end interface hetrf_rk



          interface hetrf_rook
          !! HETRF_ROOK computes the factorization of a complex Hermitian matrix A
          !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
          !! The form of the factorization is
          !! A = U*D*U**T  or  A = L*D*L**T
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is Hermitian and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetrf_rook
#else 
               module procedure stdlib_chetrf_rook
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hetrf_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetrf_rook
#else 
               module procedure stdlib_zhetrf_rook
#endif
          end interface hetrf_rook



          interface hetri
          !! HETRI computes the inverse of a complex Hermitian indefinite matrix
          !! A using the factorization A = U*D*U**H or A = L*D*L**H computed by
          !! CHETRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetri
#else 
               module procedure stdlib_chetri
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hetri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetri
#else 
               module procedure stdlib_zhetri
#endif
          end interface hetri



          interface hetri_rook
          !! HETRI_ROOK computes the inverse of a complex Hermitian indefinite matrix
          !! A using the factorization A = U*D*U**H or A = L*D*L**H computed by
          !! CHETRF_ROOK.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetri_rook
#else 
               module procedure stdlib_chetri_rook
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hetri_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetri_rook
#else 
               module procedure stdlib_zhetri_rook
#endif
          end interface hetri_rook



          interface hetrs
          !! HETRS solves a system of linear equations A*X = B with a complex
          !! Hermitian matrix A using the factorization A = U*D*U**H or
          !! A = L*D*L**H computed by CHETRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine chetrs
#else 
               module procedure stdlib_chetrs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hetrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zhetrs
#else 
               module procedure stdlib_zhetrs
#endif
          end interface hetrs



          interface hetrs2
          !! HETRS2 solves a system of linear equations A*X = B with a complex
          !! Hermitian matrix A using the factorization A = U*D*U**H or
          !! A = L*D*L**H computed by CHETRF and converted by CSYCONV.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetrs2
#else 
               module procedure stdlib_chetrs2
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hetrs2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetrs2
#else 
               module procedure stdlib_zhetrs2
#endif
          end interface hetrs2



          interface hetrs_3
          !! HETRS_3 solves a system of linear equations A * X = B with a complex
          !! Hermitian matrix A using the factorization computed
          !! by CHETRF_RK or CHETRF_BK:
          !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
          !! where U (or L) is unit upper (or lower) triangular matrix,
          !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
          !! matrix, P**T is the transpose of P, and D is Hermitian and block
          !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! This algorithm is using Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*),e(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine chetrs_3
#else 
               module procedure stdlib_chetrs_3
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hetrs_3

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*),e(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zhetrs_3
#else 
               module procedure stdlib_zhetrs_3
#endif
          end interface hetrs_3



          interface hetrs_aa
          !! HETRS_AA solves a system of linear equations A*X = B with a complex
          !! hermitian matrix A using the factorization A = U**H*T*U or
          !! A = L*T*L**H computed by CHETRF_AA.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chetrs_aa
#else 
               module procedure stdlib_chetrs_aa
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hetrs_aa

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhetrs_aa
#else 
               module procedure stdlib_zhetrs_aa
#endif
          end interface hetrs_aa



          interface hetrs_rook
          !! HETRS_ROOK solves a system of linear equations A*X = B with a complex
          !! Hermitian matrix A using the factorization A = U*D*U**H or
          !! A = L*D*L**H computed by CHETRF_ROOK.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine chetrs_rook
#else 
               module procedure stdlib_chetrs_rook
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hetrs_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zhetrs_rook
#else 
               module procedure stdlib_zhetrs_rook
#endif
          end interface hetrs_rook



          interface hfrk
          !! Level 3 BLAS like routine for C in RFP Format.
          !! HFRK performs one of the Hermitian rank--k operations
          !! C := alpha*A*A**H + beta*C,
          !! or
          !! C := alpha*A**H*A + beta*C,
          !! where alpha and beta are real scalars, C is an n--by--n Hermitian
          !! matrix and A is an n--by--k matrix in the first case and a k--by--n
          !! matrix in the second case.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,c )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: k,lda,n
                    character, intent(in) :: trans,transr,uplo
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: c(*)
               end subroutine chfrk
#else 
               module procedure stdlib_chfrk
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hfrk

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,c )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: k,lda,n
                    character, intent(in) :: trans,transr,uplo
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: c(*)
               end subroutine zhfrk
#else 
               module procedure stdlib_zhfrk
#endif
          end interface hfrk



          interface hgeqz
          !! HGEQZ computes the eigenvalues of a complex matrix pair (H,T),
          !! where H is an upper Hessenberg matrix and T is upper triangular,
          !! using the single-shift QZ method.
          !! Matrix pairs of this type are produced by the reduction to
          !! generalized upper Hessenberg form of a complex matrix pair (A,B):
          !! A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
          !! as computed by CGGHRD.
          !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
          !! also reduced to generalized Schur form,
          !! H = Q*S*Z**H,  T = Q*P*Z**H,
          !! where Q and Z are unitary matrices and S and P are upper triangular.
          !! Optionally, the unitary matrix Q from the generalized Schur
          !! factorization may be postmultiplied into an input matrix Q1, and the
          !! unitary matrix Z may be postmultiplied into an input matrix Z1.
          !! If Q1 and Z1 are the unitary matrices from CGGHRD that reduced
          !! the matrix pair (A,B) to generalized Hessenberg form, then the output
          !! matrices Q1*Q and Z1*Z are the unitary factors from the generalized
          !! Schur factorization of (A,B):
          !! A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
          !! To avoid overflow, eigenvalues of the matrix pair (H,T)
          !! (equivalently, of (A,B)) are computed as a pair of complex values
          !! (alpha,beta).  If beta is nonzero, lambda = alpha / beta is an
          !! eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)
          !! A*x = lambda*B*x
          !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
          !! alternate form of the GNEP
          !! mu*A*y = B*y.
          !! The values of alpha and beta for the i-th eigenvalue can be read
          !! directly from the generalized Schur form:  alpha = S(i,i),
          !! beta = P(i,i).
          !! Ref: C.B. Moler
          !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
          !! pp. 241--256.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alpha, beta, q, &
                         ldq, z, ldz, work, lwork,rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq,compz,job
                    integer(ilp), intent(in) :: ihi,ilo,ldh,ldq,ldt,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(out) :: alpha(*),beta(*),work(*)
                    complex(sp), intent(inout) :: h(ldh,*),q(ldq,*),t(ldt,*),z(ldz,*)
               end subroutine chgeqz
#else 
               module procedure stdlib_chgeqz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dhgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alphar, alphai, &
                         beta, q, ldq, z, ldz, work,lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq,compz,job
                    integer(ilp), intent(in) :: ihi,ilo,ldh,ldq,ldt,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(out) :: alphai(*),alphar(*),beta(*),work(*)
                    real(dp), intent(inout) :: h(ldh,*),q(ldq,*),t(ldt,*),z(ldz,*)
               end subroutine dhgeqz
#else 
               module procedure stdlib_dhgeqz
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hgeqz

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine shgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alphar, alphai, &
                         beta, q, ldq, z, ldz, work,lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq,compz,job
                    integer(ilp), intent(in) :: ihi,ilo,ldh,ldq,ldt,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(out) :: alphai(*),alphar(*),beta(*),work(*)
                    real(sp), intent(inout) :: h(ldh,*),q(ldq,*),t(ldt,*),z(ldz,*)
               end subroutine shgeqz
#else 
               module procedure stdlib_shgeqz
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hgeqz

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alpha, beta, q, &
                         ldq, z, ldz, work, lwork,rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq,compz,job
                    integer(ilp), intent(in) :: ihi,ilo,ldh,ldq,ldt,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(out) :: alpha(*),beta(*),work(*)
                    complex(dp), intent(inout) :: h(ldh,*),q(ldq,*),t(ldt,*),z(ldz,*)
               end subroutine zhgeqz
#else 
               module procedure stdlib_zhgeqz
#endif
          end interface hgeqz



          interface hpcon
          !! HPCON estimates the reciprocal of the condition number of a complex
          !! Hermitian packed matrix A using the factorization A = U*D*U**H or
          !! A = L*D*L**H computed by CHPTRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chpcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chpcon
#else 
               module procedure stdlib_chpcon
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hpcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhpcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhpcon
#else 
               module procedure stdlib_zhpcon
#endif
          end interface hpcon



          interface hpev
          !! HPEV computes all the eigenvalues and, optionally, eigenvectors of a
          !! complex Hermitian matrix in packed storage.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chpev( jobz, uplo, n, ap, w, z, ldz, work, rwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chpev
#else 
               module procedure stdlib_chpev
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hpev

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhpev( jobz, uplo, n, ap, w, z, ldz, work, rwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhpev
#else 
               module procedure stdlib_zhpev
#endif
          end interface hpev



          interface hpevd
          !! HPEVD computes all the eigenvalues and, optionally, eigenvectors of
          !! a complex Hermitian matrix A in packed storage.  If eigenvectors are
          !! desired, it uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chpevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,rwork, lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chpevd
#else 
               module procedure stdlib_chpevd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hpevd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhpevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,rwork, lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhpevd
#else 
               module procedure stdlib_zhpevd
#endif
          end interface hpevd



          interface hpgst
          !! HPGST reduces a complex Hermitian-definite generalized
          !! eigenproblem to standard form, using packed storage.
          !! If ITYPE = 1, the problem is A*x = lambda*B*x,
          !! and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
          !! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
          !! B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.
          !! B must have been previously factorized as U**H*U or L*L**H by CPPTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chpgst( itype, uplo, n, ap, bp, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,n
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(in) :: bp(*)
               end subroutine chpgst
#else 
               module procedure stdlib_chpgst
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hpgst

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhpgst( itype, uplo, n, ap, bp, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,n
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(in) :: bp(*)
               end subroutine zhpgst
#else 
               module procedure stdlib_zhpgst
#endif
          end interface hpgst



          interface hpgv
          !! HPGV computes all the eigenvalues and, optionally, the eigenvectors
          !! of a complex generalized Hermitian-definite eigenproblem, of the form
          !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
          !! Here A and B are assumed to be Hermitian, stored in packed format,
          !! and B is also positive definite.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chpgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,rwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,ldz,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ap(*),bp(*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chpgv
#else 
               module procedure stdlib_chpgv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hpgv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhpgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,rwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,ldz,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ap(*),bp(*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhpgv
#else 
               module procedure stdlib_zhpgv
#endif
          end interface hpgv



          interface hpgvd
          !! HPGVD computes all the eigenvalues and, optionally, the eigenvectors
          !! of a complex generalized Hermitian-definite eigenproblem, of the form
          !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
          !! B are assumed to be Hermitian, stored in packed format, and B is also
          !! positive definite.
          !! If eigenvectors are desired, it uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chpgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: itype,ldz,liwork,lrwork,lwork,n
                    real(sp), intent(out) :: rwork(*),w(*)
                    complex(sp), intent(inout) :: ap(*),bp(*)
                    complex(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine chpgvd
#else 
               module procedure stdlib_chpgvd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hpgvd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhpgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, rwork, &
                         lrwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: itype,ldz,liwork,lrwork,lwork,n
                    real(dp), intent(out) :: rwork(*),w(*)
                    complex(dp), intent(inout) :: ap(*),bp(*)
                    complex(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine zhpgvd
#else 
               module procedure stdlib_zhpgvd
#endif
          end interface hpgvd



          interface hprfs
          !! HPRFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is Hermitian indefinite
          !! and packed, and provides error bounds and backward error estimates
          !! for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine chprfs
#else 
               module procedure stdlib_chprfs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hprfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zhprfs
#else 
               module procedure stdlib_zhprfs
#endif
          end interface hprfs



          interface hpsv
          !! HPSV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N Hermitian matrix stored in packed format and X
          !! and B are N-by-NRHS matrices.
          !! The diagonal pivoting method is used to factor A as
          !! A = U * D * U**H,  if UPLO = 'U', or
          !! A = L * D * L**H,  if UPLO = 'L',
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, D is Hermitian and block diagonal with 1-by-1
          !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
          !! solve the system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chpsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine chpsv
#else 
               module procedure stdlib_chpsv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hpsv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhpsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine zhpsv
#else 
               module procedure stdlib_zhpsv
#endif
          end interface hpsv



          interface hptrd
          !! HPTRD reduces a complex Hermitian matrix A stored in packed form to
          !! real symmetric tridiagonal form T by a unitary similarity
          !! transformation: Q**H * A * Q = T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chptrd( uplo, n, ap, d, e, tau, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(out) :: tau(*)
               end subroutine chptrd
#else 
               module procedure stdlib_chptrd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hptrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhptrd( uplo, n, ap, d, e, tau, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(out) :: tau(*)
               end subroutine zhptrd
#else 
               module procedure stdlib_zhptrd
#endif
          end interface hptrd



          interface hptrf
          !! HPTRF computes the factorization of a complex Hermitian packed
          !! matrix A using the Bunch-Kaufman diagonal pivoting method:
          !! A = U*D*U**H  or  A = L*D*L**H
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is Hermitian and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: ap(*)
               end subroutine chptrf
#else 
               module procedure stdlib_chptrf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hptrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zhptrf
#else 
               module procedure stdlib_zhptrf
#endif
          end interface hptrf



          interface hptri
          !! HPTRI computes the inverse of a complex Hermitian indefinite matrix
          !! A in packed storage using the factorization A = U*D*U**H or
          !! A = L*D*L**H computed by CHPTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chptri
#else 
               module procedure stdlib_chptri
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hptri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhptri
#else 
               module procedure stdlib_zhptri
#endif
          end interface hptri



          interface hptrs
          !! HPTRS solves a system of linear equations A*X = B with a complex
          !! Hermitian matrix A stored in packed format using the factorization
          !! A = U*D*U**H or A = L*D*L**H computed by CHPTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine chptrs
#else 
               module procedure stdlib_chptrs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hptrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zhptrs
#else 
               module procedure stdlib_zhptrs
#endif
          end interface hptrs



          interface hsein
          !! HSEIN uses inverse iteration to find specified right and/or left
          !! eigenvectors of a complex upper Hessenberg matrix H.
          !! The right eigenvector x and the left eigenvector y of the matrix H
          !! corresponding to an eigenvalue w are defined by:
          !! H * x = w * x,     y**h * H = w * y**h
          !! where y**h denotes the conjugate transpose of the vector y.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine chsein( side, eigsrc, initv, select, n, h, ldh, w, vl,ldvl, vr, ldvr, &
                         mm, m, work, rwork, ifaill,ifailr, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: eigsrc,initv,side
                    integer(ilp), intent(out) :: info,m,ifaill(*),ifailr(*)
                    integer(ilp), intent(in) :: ldh,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(in) :: h(ldh,*)
                    complex(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*),w(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine chsein
#else 
               module procedure stdlib_chsein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dhsein( side, eigsrc, initv, select, n, h, ldh, wr, wi,vl, ldvl, vr, &
                         ldvr, mm, m, work, ifaill,ifailr, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: eigsrc,initv,side
                    integer(ilp), intent(out) :: info,m,ifaill(*),ifailr(*)
                    integer(ilp), intent(in) :: ldh,ldvl,ldvr,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(dp), intent(in) :: h(ldh,*),wi(*)
                    real(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*),wr(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dhsein
#else 
               module procedure stdlib_dhsein
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hsein

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine shsein( side, eigsrc, initv, select, n, h, ldh, wr, wi,vl, ldvl, vr, &
                         ldvr, mm, m, work, ifaill,ifailr, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: eigsrc,initv,side
                    integer(ilp), intent(out) :: info,m,ifaill(*),ifailr(*)
                    integer(ilp), intent(in) :: ldh,ldvl,ldvr,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(sp), intent(in) :: h(ldh,*),wi(*)
                    real(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*),wr(*)
                    real(sp), intent(out) :: work(*)
               end subroutine shsein
#else 
               module procedure stdlib_shsein
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hsein

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zhsein( side, eigsrc, initv, select, n, h, ldh, w, vl,ldvl, vr, ldvr, &
                         mm, m, work, rwork, ifaill,ifailr, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: eigsrc,initv,side
                    integer(ilp), intent(out) :: info,m,ifaill(*),ifailr(*)
                    integer(ilp), intent(in) :: ldh,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(in) :: h(ldh,*)
                    complex(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*),w(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zhsein
#else 
               module procedure stdlib_zhsein
#endif
          end interface hsein



          interface hseqr
          !! HSEQR computes the eigenvalues of a Hessenberg matrix H
          !! and, optionally, the matrices T and Z from the Schur decomposition
          !! H = Z T Z**H, where T is an upper triangular matrix (the
          !! Schur form), and Z is the unitary matrix of Schur vectors.
          !! Optionally Z may be postmultiplied into an input unitary
          !! matrix Q so that this routine can give the Schur factorization
          !! of a matrix A which has been reduced to the Hessenberg form H
          !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine chseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ilo,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    character, intent(in) :: compz,job
                    complex(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(sp), intent(out) :: w(*),work(*)
               end subroutine chseqr
#else 
               module procedure stdlib_chseqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dhseqr( job, compz, n, ilo, ihi, h, ldh, wr, wi, z,ldz, work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ilo,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    character, intent(in) :: compz,job
                    real(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(dp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine dhseqr
#else 
               module procedure stdlib_dhseqr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hseqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine shseqr( job, compz, n, ilo, ihi, h, ldh, wr, wi, z,ldz, work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ilo,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    character, intent(in) :: compz,job
                    real(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(sp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine shseqr
#else 
               module procedure stdlib_shseqr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$hseqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zhseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ilo,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    character, intent(in) :: compz,job
                    complex(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(dp), intent(out) :: w(*),work(*)
               end subroutine zhseqr
#else 
               module procedure stdlib_zhseqr
#endif
          end interface hseqr



          interface isnan
          !! ISNAN returns .TRUE. if its argument is NaN, and .FALSE.
          !! otherwise.  To be replaced by the Fortran 2003 intrinsic in the
          !! future.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure logical(lk) function disnan( din )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: din
               end function disnan
#else 
               module procedure stdlib_disnan
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$isnan

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure logical(lk) function sisnan( sin )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: sin
               end function sisnan
#else 
               module procedure stdlib_sisnan
#endif
          end interface isnan



          interface la_gbamv
          !! LA_GBAMV performs one of the matrix-vector operations
          !! y := alpha*abs(A)*abs(x) + beta*abs(y),
          !! or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),
          !! where alpha and beta are scalars, x and y are vectors and A is an
          !! m by n matrix.
          !! This function is primarily used in calculating error bounds.
          !! To protect against underflow during evaluation, components in
          !! the resulting vector are perturbed away from zero by (N+1)
          !! times the underflow threshold.  To prevent unnecessarily large
          !! errors for block-structure embedded in general matrices,
          !! "symbolically" zero components are not perturbed.  A zero
          !! entry is considered "symbolic" if all multiplications involved
          !! in computing that entry have at least one zero multiplicand.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,incx, beta, y, incy )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: incx,incy,ldab,m,n,kl,ku,trans
                    complex(sp), intent(in) :: ab(ldab,*),x(*)
                    real(sp), intent(inout) :: y(*)
               end subroutine cla_gbamv
#else 
               module procedure stdlib_cla_gbamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,incx, beta, y, incy )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: alpha,beta,ab(ldab,*),x(*)
                    integer(ilp), intent(in) :: incx,incy,ldab,m,n,kl,ku,trans
                    real(dp), intent(inout) :: y(*)
               end subroutine dla_gbamv
#else 
               module procedure stdlib_dla_gbamv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_gbamv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,incx, beta, y, incy )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: alpha,beta,ab(ldab,*),x(*)
                    integer(ilp), intent(in) :: incx,incy,ldab,m,n,kl,ku,trans
                    real(sp), intent(inout) :: y(*)
               end subroutine sla_gbamv
#else 
               module procedure stdlib_sla_gbamv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_gbamv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zla_gbamv( trans, m, n, kl, ku, alpha, ab, ldab, x,incx, beta, y, incy )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: incx,incy,ldab,m,n,kl,ku,trans
                    complex(dp), intent(in) :: ab(ldab,*),x(*)
                    real(dp), intent(inout) :: y(*)
               end subroutine zla_gbamv
#else 
               module procedure stdlib_zla_gbamv
#endif
          end interface la_gbamv



          interface la_gbrcond
          !! LA_GBRCOND Estimates the Skeel condition number of  op(A) * op2(C)
          !! where op2 is determined by CMODE as follows
          !! CMODE =  1    op2(C) = C
          !! CMODE =  0    op2(C) = I
          !! CMODE = -1    op2(C) = inv(C)
          !! The Skeel condition number  cond(A) = norminf( |inv(A)||A| )
          !! is computed by computing scaling factors R such that
          !! diag(R)*A*op2(C) is row equilibrated and computing the standard
          !! infinity-norm condition number.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dla_gbrcond( trans, n, kl, ku, ab, ldab,afb, ldafb, ipiv, cmode, &
                         c,info, work, iwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: n,ldab,ldafb,kl,ku,cmode,ipiv(*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: ab(ldab,*),afb(ldafb,*),c(*)
                    real(dp), intent(out) :: work(*)
               end function dla_gbrcond
#else 
               module procedure stdlib_dla_gbrcond
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_gbrcond

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function sla_gbrcond( trans, n, kl, ku, ab, ldab, afb, ldafb,ipiv, cmode, &
                         c, info, work, iwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: n,ldab,ldafb,kl,ku,cmode,ipiv(*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: ab(ldab,*),afb(ldafb,*),c(*)
                    real(sp), intent(out) :: work(*)
               end function sla_gbrcond
#else 
               module procedure stdlib_sla_gbrcond
#endif
          end interface la_gbrcond



          interface la_gbrcond_c
          !! LA_GBRCOND_C Computes the infinity norm condition number of
          !! op(A) * inv(diag(C)) where C is a REAL vector.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function cla_gbrcond_c( trans, n, kl, ku, ab, ldab, afb,ldafb, ipiv, c, &
                         capply, info, work,rwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,kl,ku,ldab,ldafb,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: ab(ldab,*),afb(ldafb,*)
                    complex(sp), intent(out) :: work(*)
                    real(sp), intent(in) :: c(*)
                    real(sp), intent(out) :: rwork(*)
               end function cla_gbrcond_c
#else 
               module procedure stdlib_cla_gbrcond_c
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_gbrcond_c

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zla_gbrcond_c( trans, n, kl, ku, ab,ldab, afb, ldafb, ipiv,c, &
                         capply, info, work,rwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,kl,ku,ldab,ldafb,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: ab(ldab,*),afb(ldafb,*)
                    complex(dp), intent(out) :: work(*)
                    real(dp), intent(in) :: c(*)
                    real(dp), intent(out) :: rwork(*)
               end function zla_gbrcond_c
#else 
               module procedure stdlib_zla_gbrcond_c
#endif
          end interface la_gbrcond_c



          interface la_gbrpvgrw
          !! LA_GBRPVGRW computes the reciprocal pivot growth factor
          !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
          !! much less than 1, the stability of the LU factorization of the
          !! (equilibrated) matrix A could be poor. This also means that the
          !! solution X, estimated condition numbers, and error bounds could be
          !! unreliable.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp) function cla_gbrpvgrw( n, kl, ku, ncols, ab, ldab, afb,ldafb )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n,kl,ku,ncols,ldab,ldafb
                    complex(sp), intent(in) :: ab(ldab,*),afb(ldafb,*)
               end function cla_gbrpvgrw
#else 
               module procedure stdlib_cla_gbrpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function dla_gbrpvgrw( n, kl, ku, ncols, ab,ldab, afb, ldafb )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n,kl,ku,ncols,ldab,ldafb
                    real(dp), intent(in) :: ab(ldab,*),afb(ldafb,*)
               end function dla_gbrpvgrw
#else 
               module procedure stdlib_dla_gbrpvgrw
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_gbrpvgrw

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp) function sla_gbrpvgrw( n, kl, ku, ncols, ab, ldab, afb,ldafb )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n,kl,ku,ncols,ldab,ldafb
                    real(sp), intent(in) :: ab(ldab,*),afb(ldafb,*)
               end function sla_gbrpvgrw
#else 
               module procedure stdlib_sla_gbrpvgrw
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_gbrpvgrw

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function zla_gbrpvgrw( n, kl, ku, ncols, ab,ldab, afb, ldafb )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n,kl,ku,ncols,ldab,ldafb
                    complex(dp), intent(in) :: ab(ldab,*),afb(ldafb,*)
               end function zla_gbrpvgrw
#else 
               module procedure stdlib_zla_gbrpvgrw
#endif
          end interface la_gbrpvgrw



          interface la_geamv
          !! LA_GEAMV performs one of the matrix-vector operations
          !! y := alpha*abs(A)*abs(x) + beta*abs(y),
          !! or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),
          !! where alpha and beta are scalars, x and y are vectors and A is an
          !! m by n matrix.
          !! This function is primarily used in calculating error bounds.
          !! To protect against underflow during evaluation, components in
          !! the resulting vector are perturbed away from zero by (N+1)
          !! times the underflow threshold.  To prevent unnecessarily large
          !! errors for block-structure embedded in general matrices,
          !! "symbolically" zero components are not perturbed.  A zero
          !! entry is considered "symbolic" if all multiplications involved
          !! in computing that entry have at least one zero multiplicand.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cla_geamv( trans, m, n, alpha, a, lda, x, incx, beta,y, incy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: incx,incy,lda,m,n,trans
                    complex(sp), intent(in) :: a(lda,*),x(*)
                    real(sp), intent(inout) :: y(*)
               end subroutine cla_geamv
#else 
               module procedure stdlib_cla_geamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dla_geamv ( trans, m, n, alpha, a, lda, x, incx, beta,y, incy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    integer(ilp), intent(in) :: incx,incy,lda,m,n,trans
                    real(dp), intent(inout) :: y(*)
               end subroutine dla_geamv
#else 
               module procedure stdlib_dla_geamv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_geamv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sla_geamv( trans, m, n, alpha, a, lda, x, incx, beta,y, incy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    integer(ilp), intent(in) :: incx,incy,lda,m,n,trans
                    real(sp), intent(inout) :: y(*)
               end subroutine sla_geamv
#else 
               module procedure stdlib_sla_geamv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_geamv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zla_geamv( trans, m, n, alpha, a, lda, x, incx, beta,y, incy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: incx,incy,lda,m,n,trans
                    complex(dp), intent(in) :: a(lda,*),x(*)
                    real(dp), intent(inout) :: y(*)
               end subroutine zla_geamv
#else 
               module procedure stdlib_zla_geamv
#endif
          end interface la_geamv



          interface la_gercond
          !! LA_GERCOND estimates the Skeel condition number of op(A) * op2(C)
          !! where op2 is determined by CMODE as follows
          !! CMODE =  1    op2(C) = C
          !! CMODE =  0    op2(C) = I
          !! CMODE = -1    op2(C) = inv(C)
          !! The Skeel condition number cond(A) = norminf( |inv(A)||A| )
          !! is computed by computing scaling factors R such that
          !! diag(R)*A*op2(C) is row equilibrated and computing the standard
          !! infinity-norm condition number.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dla_gercond( trans, n, a, lda, af,ldaf, ipiv, cmode, c,info, &
                         work, iwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: n,lda,ldaf,cmode,ipiv(*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(dp), intent(out) :: work(*)
               end function dla_gercond
#else 
               module procedure stdlib_dla_gercond
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_gercond

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function sla_gercond( trans, n, a, lda, af, ldaf, ipiv,cmode, c, info, &
                         work, iwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: n,lda,ldaf,cmode,ipiv(*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(sp), intent(out) :: work(*)
               end function sla_gercond
#else 
               module procedure stdlib_sla_gercond
#endif
          end interface la_gercond



          interface la_gercond_c
          !! LA_GERCOND_C computes the infinity norm condition number of
          !! op(A) * inv(diag(C)) where C is a REAL vector.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function cla_gercond_c( trans, n, a, lda, af, ldaf, ipiv, c,capply, info, &
                         work, rwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(sp), intent(out) :: work(*)
                    real(sp), intent(in) :: c(*)
                    real(sp), intent(out) :: rwork(*)
               end function cla_gercond_c
#else 
               module procedure stdlib_cla_gercond_c
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_gercond_c

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zla_gercond_c( trans, n, a, lda, af,ldaf, ipiv, c, capply,info, &
                         work, rwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(dp), intent(out) :: work(*)
                    real(dp), intent(in) :: c(*)
                    real(dp), intent(out) :: rwork(*)
               end function zla_gercond_c
#else 
               module procedure stdlib_zla_gercond_c
#endif
          end interface la_gercond_c



          interface la_gerpvgrw
          !! LA_GERPVGRW computes the reciprocal pivot growth factor
          !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
          !! much less than 1, the stability of the LU factorization of the
          !! (equilibrated) matrix A could be poor. This also means that the
          !! solution X, estimated condition numbers, and error bounds could be
          !! unreliable.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp) function cla_gerpvgrw( n, ncols, a, lda, af, ldaf )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n,ncols,lda,ldaf
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
               end function cla_gerpvgrw
#else 
               module procedure stdlib_cla_gerpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function dla_gerpvgrw( n, ncols, a, lda, af,ldaf )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n,ncols,lda,ldaf
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*)
               end function dla_gerpvgrw
#else 
               module procedure stdlib_dla_gerpvgrw
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_gerpvgrw

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp) function sla_gerpvgrw( n, ncols, a, lda, af, ldaf )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n,ncols,lda,ldaf
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*)
               end function sla_gerpvgrw
#else 
               module procedure stdlib_sla_gerpvgrw
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_gerpvgrw

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function zla_gerpvgrw( n, ncols, a, lda, af,ldaf )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n,ncols,lda,ldaf
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
               end function zla_gerpvgrw
#else 
               module procedure stdlib_zla_gerpvgrw
#endif
          end interface la_gerpvgrw



          interface la_heamv
          !! CLA_SYAMV  performs the matrix-vector operation
          !! y := alpha*abs(A)*abs(x) + beta*abs(y),
          !! where alpha and beta are scalars, x and y are vectors and A is an
          !! n by n symmetric matrix.
          !! This function is primarily used in calculating error bounds.
          !! To protect against underflow during evaluation, components in
          !! the resulting vector are perturbed away from zero by (N+1)
          !! times the underflow threshold.  To prevent unnecessarily large
          !! errors for block-structure embedded in general matrices,
          !! "symbolically" zero components are not perturbed.  A zero
          !! entry is considered "symbolic" if all multiplications involved
          !! in computing that entry have at least one zero multiplicand.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cla_heamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: incx,incy,lda,n,uplo
                    complex(sp), intent(in) :: a(lda,*),x(*)
                    real(sp), intent(inout) :: y(*)
               end subroutine cla_heamv
#else 
               module procedure stdlib_cla_heamv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_heamv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zla_heamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: incx,incy,lda,n,uplo
                    complex(dp), intent(in) :: a(lda,*),x(*)
                    real(dp), intent(inout) :: y(*)
               end subroutine zla_heamv
#else 
               module procedure stdlib_zla_heamv
#endif
          end interface la_heamv



          interface la_hercond_c
          !! LA_HERCOND_C computes the infinity norm condition number of
          !! op(A) * inv(diag(C)) where C is a REAL vector.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function cla_hercond_c( uplo, n, a, lda, af, ldaf, ipiv, c,capply, info, &
                         work, rwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(sp), intent(out) :: work(*)
                    real(sp), intent(in) :: c(*)
                    real(sp), intent(out) :: rwork(*)
               end function cla_hercond_c
#else 
               module procedure stdlib_cla_hercond_c
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_hercond_c

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zla_hercond_c( uplo, n, a, lda, af,ldaf, ipiv, c, capply,info, &
                         work, rwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(dp), intent(out) :: work(*)
                    real(dp), intent(in) :: c(*)
                    real(dp), intent(out) :: rwork(*)
               end function zla_hercond_c
#else 
               module procedure stdlib_zla_hercond_c
#endif
          end interface la_hercond_c



          interface la_herpvgrw
          !! LA_HERPVGRW computes the reciprocal pivot growth factor
          !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
          !! much less than 1, the stability of the LU factorization of the
          !! (equilibrated) matrix A could be poor. This also means that the
          !! solution X, estimated condition numbers, and error bounds could be
          !! unreliable.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function cla_herpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,work )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp), intent(out) :: work(*)
               end function cla_herpvgrw
#else 
               module procedure stdlib_cla_herpvgrw
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_herpvgrw

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zla_herpvgrw( uplo, n, info, a, lda, af,ldaf, ipiv, work )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp), intent(out) :: work(*)
               end function zla_herpvgrw
#else 
               module procedure stdlib_zla_herpvgrw
#endif
          end interface la_herpvgrw



          interface la_lin_berr
          !! LA_LIN_BERR computes componentwise relative backward error from
          !! the formula
          !! max(i) ( abs(R(i)) / ( abs(op(A_s))*abs(Y) + abs(B_s) )(i) )
          !! where abs(Z) is the componentwise absolute value of the matrix
          !! or vector Z.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cla_lin_berr( n, nz, nrhs, res, ayb, berr )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n,nz,nrhs
                    real(sp), intent(in) :: ayb(n,nrhs)
                    real(sp), intent(out) :: berr(nrhs)
                    complex(sp), intent(in) :: res(n,nrhs)
               end subroutine cla_lin_berr
#else 
               module procedure stdlib_cla_lin_berr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dla_lin_berr ( n, nz, nrhs, res, ayb, berr )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n,nz,nrhs
                    real(dp), intent(in) :: ayb(n,nrhs),res(n,nrhs)
                    real(dp), intent(out) :: berr(nrhs)
               end subroutine dla_lin_berr
#else 
               module procedure stdlib_dla_lin_berr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_lin_berr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sla_lin_berr( n, nz, nrhs, res, ayb, berr )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n,nz,nrhs
                    real(sp), intent(in) :: ayb(n,nrhs),res(n,nrhs)
                    real(sp), intent(out) :: berr(nrhs)
               end subroutine sla_lin_berr
#else 
               module procedure stdlib_sla_lin_berr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_lin_berr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zla_lin_berr( n, nz, nrhs, res, ayb, berr )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n,nz,nrhs
                    real(dp), intent(in) :: ayb(n,nrhs)
                    real(dp), intent(out) :: berr(nrhs)
                    complex(dp), intent(in) :: res(n,nrhs)
               end subroutine zla_lin_berr
#else 
               module procedure stdlib_zla_lin_berr
#endif
          end interface la_lin_berr



          interface la_porcond
          !! LA_PORCOND Estimates the Skeel condition number of  op(A) * op2(C)
          !! where op2 is determined by CMODE as follows
          !! CMODE =  1    op2(C) = C
          !! CMODE =  0    op2(C) = I
          !! CMODE = -1    op2(C) = inv(C)
          !! The Skeel condition number  cond(A) = norminf( |inv(A)||A| )
          !! is computed by computing scaling factors R such that
          !! diag(R)*A*op2(C) is row equilibrated and computing the standard
          !! infinity-norm condition number.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dla_porcond( uplo, n, a, lda, af, ldaf,cmode, c, info, work,&
                         iwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,ldaf,cmode
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(dp), intent(out) :: work(*)
               end function dla_porcond
#else 
               module procedure stdlib_dla_porcond
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_porcond

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function sla_porcond( uplo, n, a, lda, af, ldaf, cmode, c,info, work, &
                         iwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,ldaf,cmode
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(sp), intent(out) :: work(*)
               end function sla_porcond
#else 
               module procedure stdlib_sla_porcond
#endif
          end interface la_porcond



          interface la_porcond_c
          !! LA_PORCOND_C Computes the infinity norm condition number of
          !! op(A) * inv(diag(C)) where C is a REAL vector
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function cla_porcond_c( uplo, n, a, lda, af, ldaf, c, capply,info, work, &
                         rwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,lda,ldaf
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(sp), intent(out) :: work(*)
                    real(sp), intent(in) :: c(*)
                    real(sp), intent(out) :: rwork(*)
               end function cla_porcond_c
#else 
               module procedure stdlib_cla_porcond_c
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_porcond_c

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zla_porcond_c( uplo, n, a, lda, af,ldaf, c, capply, info,work, &
                         rwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,lda,ldaf
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(dp), intent(out) :: work(*)
                    real(dp), intent(in) :: c(*)
                    real(dp), intent(out) :: rwork(*)
               end function zla_porcond_c
#else 
               module procedure stdlib_zla_porcond_c
#endif
          end interface la_porcond_c



          interface la_porpvgrw
          !! LA_PORPVGRW computes the reciprocal pivot growth factor
          !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
          !! much less than 1, the stability of the LU factorization of the
          !! (equilibrated) matrix A could be poor. This also means that the
          !! solution X, estimated condition numbers, and error bounds could be
          !! unreliable.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function cla_porpvgrw( uplo, ncols, a, lda, af, ldaf, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: ncols,lda,ldaf
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp), intent(out) :: work(*)
               end function cla_porpvgrw
#else 
               module procedure stdlib_cla_porpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dla_porpvgrw( uplo, ncols, a, lda, af,ldaf, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: ncols,lda,ldaf
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp), intent(out) :: work(*)
               end function dla_porpvgrw
#else 
               module procedure stdlib_dla_porpvgrw
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_porpvgrw

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function sla_porpvgrw( uplo, ncols, a, lda, af, ldaf, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: ncols,lda,ldaf
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp), intent(out) :: work(*)
               end function sla_porpvgrw
#else 
               module procedure stdlib_sla_porpvgrw
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_porpvgrw

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zla_porpvgrw( uplo, ncols, a, lda, af,ldaf, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: ncols,lda,ldaf
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp), intent(out) :: work(*)
               end function zla_porpvgrw
#else 
               module procedure stdlib_zla_porpvgrw
#endif
          end interface la_porpvgrw



          interface la_syamv
          !! LA_SYAMV performs the matrix-vector operation
          !! y := alpha*abs(A)*abs(x) + beta*abs(y),
          !! where alpha and beta are scalars, x and y are vectors and A is an
          !! n by n symmetric matrix.
          !! This function is primarily used in calculating error bounds.
          !! To protect against underflow during evaluation, components in
          !! the resulting vector are perturbed away from zero by (N+1)
          !! times the underflow threshold.  To prevent unnecessarily large
          !! errors for block-structure embedded in general matrices,
          !! "symbolically" zero components are not perturbed.  A zero
          !! entry is considered "symbolic" if all multiplications involved
          !! in computing that entry have at least one zero multiplicand.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: incx,incy,lda,n,uplo
                    complex(sp), intent(in) :: a(lda,*),x(*)
                    real(sp), intent(inout) :: y(*)
               end subroutine cla_syamv
#else 
               module procedure stdlib_cla_syamv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    integer(ilp), intent(in) :: incx,incy,lda,n,uplo
                    real(dp), intent(inout) :: y(*)
               end subroutine dla_syamv
#else 
               module procedure stdlib_dla_syamv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_syamv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    integer(ilp), intent(in) :: incx,incy,lda,n,uplo
                    real(sp), intent(inout) :: y(*)
               end subroutine sla_syamv
#else 
               module procedure stdlib_sla_syamv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_syamv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: alpha,beta
                    integer(ilp), intent(in) :: incx,incy,lda,n,uplo
                    complex(dp), intent(in) :: a(lda,*),x(*)
                    real(dp), intent(inout) :: y(*)
               end subroutine zla_syamv
#else 
               module procedure stdlib_zla_syamv
#endif
          end interface la_syamv



          interface la_syrcond
          !! LA_SYRCOND estimates the Skeel condition number of  op(A) * op2(C)
          !! where op2 is determined by CMODE as follows
          !! CMODE =  1    op2(C) = C
          !! CMODE =  0    op2(C) = I
          !! CMODE = -1    op2(C) = inv(C)
          !! The Skeel condition number cond(A) = norminf( |inv(A)||A| )
          !! is computed by computing scaling factors R such that
          !! diag(R)*A*op2(C) is row equilibrated and computing the standard
          !! infinity-norm condition number.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dla_syrcond( uplo, n, a, lda, af, ldaf,ipiv, cmode, c, info, &
                         work,iwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,ldaf,cmode,ipiv(*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(dp), intent(out) :: work(*)
               end function dla_syrcond
#else 
               module procedure stdlib_dla_syrcond
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_syrcond

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function sla_syrcond( uplo, n, a, lda, af, ldaf, ipiv, cmode,c, info, &
                         work, iwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,ldaf,cmode,ipiv(*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),c(*)
                    real(sp), intent(out) :: work(*)
               end function sla_syrcond
#else 
               module procedure stdlib_sla_syrcond
#endif
          end interface la_syrcond



          interface la_syrcond_c
          !! LA_SYRCOND_C Computes the infinity norm condition number of
          !! op(A) * inv(diag(C)) where C is a REAL vector.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function cla_syrcond_c( uplo, n, a, lda, af, ldaf, ipiv, c,capply, info, &
                         work, rwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(sp), intent(out) :: work(*)
                    real(sp), intent(in) :: c(*)
                    real(sp), intent(out) :: rwork(*)
               end function cla_syrcond_c
#else 
               module procedure stdlib_cla_syrcond_c
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_syrcond_c

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zla_syrcond_c( uplo, n, a, lda, af,ldaf, ipiv, c, capply,info, &
                         work, rwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: capply
                    integer(ilp), intent(in) :: n,lda,ldaf,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    complex(dp), intent(out) :: work(*)
                    real(dp), intent(in) :: c(*)
                    real(dp), intent(out) :: rwork(*)
               end function zla_syrcond_c
#else 
               module procedure stdlib_zla_syrcond_c
#endif
          end interface la_syrcond_c



          interface la_syrpvgrw
          !! LA_SYRPVGRW computes the reciprocal pivot growth factor
          !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
          !! much less than 1, the stability of the LU factorization of the
          !! (equilibrated) matrix A could be poor. This also means that the
          !! solution X, estimated condition numbers, and error bounds could be
          !! unreliable.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function cla_syrpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,work )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp), intent(out) :: work(*)
               end function cla_syrpvgrw
#else 
               module procedure stdlib_cla_syrpvgrw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dla_syrpvgrw( uplo, n, info, a, lda, af,ldaf, ipiv, work )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp), intent(out) :: work(*)
               end function dla_syrpvgrw
#else 
               module procedure stdlib_dla_syrpvgrw
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_syrpvgrw

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function sla_syrpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,work )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(sp), intent(out) :: work(*)
               end function sla_syrpvgrw
#else 
               module procedure stdlib_sla_syrpvgrw
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_syrpvgrw

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zla_syrpvgrw( uplo, n, info, a, lda, af,ldaf, ipiv, work )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,info,lda,ldaf,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*)
                    real(dp), intent(out) :: work(*)
               end function zla_syrpvgrw
#else 
               module procedure stdlib_zla_syrpvgrw
#endif
          end interface la_syrpvgrw



          interface la_wwaddw
          !! LA_WWADDW adds a vector W into a doubled-single vector (X, Y).
          !! This works for all extant IBM's hex and binary floating point
          !! arithmetic, but not for decimal.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cla_wwaddw( n, x, y, w )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: x(*),y(*)
                    complex(sp), intent(in) :: w(*)
               end subroutine cla_wwaddw
#else 
               module procedure stdlib_cla_wwaddw
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dla_wwaddw( n, x, y, w )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: x(*),y(*)
                    real(dp), intent(in) :: w(*)
               end subroutine dla_wwaddw
#else 
               module procedure stdlib_dla_wwaddw
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_wwaddw

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sla_wwaddw( n, x, y, w )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: x(*),y(*)
                    real(sp), intent(in) :: w(*)
               end subroutine sla_wwaddw
#else 
               module procedure stdlib_sla_wwaddw
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$la_wwaddw

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zla_wwaddw( n, x, y, w )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: x(*),y(*)
                    complex(dp), intent(in) :: w(*)
               end subroutine zla_wwaddw
#else 
               module procedure stdlib_zla_wwaddw
#endif
          end interface la_wwaddw



          interface labad
          !! LABAD takes as input the values computed by DLAMCH for underflow and
          !! overflow, and returns the square root of each of these values if the
          !! log of LARGE is sufficiently large.  This subroutine is intended to
          !! identify machines with a large exponent range, such as the Crays, and
          !! redefine the underflow and overflow limits to be the square roots of
          !! the values computed by DLAMCH.  This subroutine is needed because
          !! DLAMCH does not compensate for poor arithmetic in the upper half of
          !! the exponent range, as is found on a Cray.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlabad( small, large )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(inout) :: large,small
               end subroutine dlabad
#else 
               module procedure stdlib_dlabad
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$labad

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slabad( small, large )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(inout) :: large,small
               end subroutine slabad
#else 
               module procedure stdlib_slabad
#endif
          end interface labad



          interface labrd
          !! LABRD reduces the first NB rows and columns of a complex general
          !! m by n matrix A to upper or lower real bidiagonal form by a unitary
          !! transformation Q**H * A * P, and returns the matrices X and Y which
          !! are needed to apply the transformation to the unreduced part of A.
          !! If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
          !! bidiagonal form.
          !! This is an auxiliary routine called by CGEBRD
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: lda,ldx,ldy,m,n,nb
                    real(sp), intent(out) :: d(*),e(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: taup(*),tauq(*),x(ldx,*),y(ldy,*)
               end subroutine clabrd
#else 
               module procedure stdlib_clabrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: lda,ldx,ldy,m,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*),e(*),taup(*),tauq(*),x(ldx,*),y(ldy,*)
               end subroutine dlabrd
#else 
               module procedure stdlib_dlabrd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$labrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: lda,ldx,ldy,m,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*),e(*),taup(*),tauq(*),x(ldx,*),y(ldy,*)
               end subroutine slabrd
#else 
               module procedure stdlib_slabrd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$labrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: lda,ldx,ldy,m,n,nb
                    real(dp), intent(out) :: d(*),e(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: taup(*),tauq(*),x(ldx,*),y(ldy,*)
               end subroutine zlabrd
#else 
               module procedure stdlib_zlabrd
#endif
          end interface labrd



          interface lacgv
          !! LACGV conjugates a complex vector of length N.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clacgv( n, x, incx )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,n
                    complex(sp), intent(inout) :: x(*)
               end subroutine clacgv
#else 
               module procedure stdlib_clacgv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lacgv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlacgv( n, x, incx )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,n
                    complex(dp), intent(inout) :: x(*)
               end subroutine zlacgv
#else 
               module procedure stdlib_zlacgv
#endif
          end interface lacgv



          interface lacon
          !! LACON estimates the 1-norm of a square, complex matrix A.
          !! Reverse communication is used for evaluating matrix-vector products.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine clacon( n, v, x, est, kase )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(inout) :: kase
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: est
                    complex(sp), intent(out) :: v(n)
                    complex(sp), intent(inout) :: x(n)
               end subroutine clacon
#else 
               module procedure stdlib_clacon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dlacon( n, v, x, isgn, est, kase )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(inout) :: kase
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: est,x(*)
                    integer(ilp), intent(out) :: isgn(*)
                    real(dp), intent(out) :: v(*)
               end subroutine dlacon
#else 
               module procedure stdlib_dlacon
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lacon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine slacon( n, v, x, isgn, est, kase )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(inout) :: kase
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: est,x(*)
                    integer(ilp), intent(out) :: isgn(*)
                    real(sp), intent(out) :: v(*)
               end subroutine slacon
#else 
               module procedure stdlib_slacon
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lacon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zlacon( n, v, x, est, kase )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(inout) :: kase
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: est
                    complex(dp), intent(out) :: v(n)
                    complex(dp), intent(inout) :: x(n)
               end subroutine zlacon
#else 
               module procedure stdlib_zlacon
#endif
          end interface lacon



          interface lacpy
          !! LACPY copies all or part of a two-dimensional matrix A to another
          !! matrix B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clacpy( uplo, m, n, a, lda, b, ldb )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,ldb,m,n
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: b(ldb,*)
               end subroutine clacpy
#else 
               module procedure stdlib_clacpy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlacpy( uplo, m, n, a, lda, b, ldb )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,ldb,m,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: b(ldb,*)
               end subroutine dlacpy
#else 
               module procedure stdlib_dlacpy
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lacpy

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slacpy( uplo, m, n, a, lda, b, ldb )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,ldb,m,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: b(ldb,*)
               end subroutine slacpy
#else 
               module procedure stdlib_slacpy
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lacpy

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlacpy( uplo, m, n, a, lda, b, ldb )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,ldb,m,n
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: b(ldb,*)
               end subroutine zlacpy
#else 
               module procedure stdlib_zlacpy
#endif
          end interface lacpy



          interface lacrm
          !! LACRM performs a very simple matrix-matrix multiplication:
          !! C := A * B,
          !! where A is M by N and complex; B is N by N and real;
          !! C is M by N and complex.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clacrm( m, n, a, lda, b, ldb, c, ldc, rwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: lda,ldb,ldc,m,n
                    real(sp), intent(in) :: b(ldb,*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: c(ldc,*)
               end subroutine clacrm
#else 
               module procedure stdlib_clacrm
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lacrm

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlacrm( m, n, a, lda, b, ldb, c, ldc, rwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: lda,ldb,ldc,m,n
                    real(dp), intent(in) :: b(ldb,*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: c(ldc,*)
               end subroutine zlacrm
#else 
               module procedure stdlib_zlacrm
#endif
          end interface lacrm



          interface lacrt
          !! LACRT performs the operation
          !! (  c  s )( x )  ==> ( x )
          !! ( -s  c )( y )      ( y )
          !! where c and s are complex and the vectors x and y are complex.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clacrt( n, cx, incx, cy, incy, c, s )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,incy,n
                    complex(sp), intent(in) :: c,s
                    complex(sp), intent(inout) :: cx(*),cy(*)
               end subroutine clacrt
#else 
               module procedure stdlib_clacrt
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lacrt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlacrt( n, cx, incx, cy, incy, c, s )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,incy,n
                    complex(dp), intent(in) :: c,s
                    complex(dp), intent(inout) :: cx(*),cy(*)
               end subroutine zlacrt
#else 
               module procedure stdlib_zlacrt
#endif
          end interface lacrt



          interface ladiv_f
          !! LADIV_F := X / Y, where X and Y are complex.  The computation of X / Y
          !! will not overflow on an intermediary step unless the results
          !! overflows.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure complex(sp) function cladiv( x, y )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    complex(sp), intent(in) :: x,y
               end function cladiv
#else 
               module procedure stdlib_cladiv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ladiv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure complex(dp)     function zladiv( x, y )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    complex(dp), intent(in) :: x,y
               end function zladiv
#else 
               module procedure stdlib_zladiv
#endif
          end interface ladiv_f



          interface ladiv_s
          !! LADIV_S performs complex division in  real arithmetic
          !! a + i*b
          !! p + i*q = ---------
          !! c + i*d
          !! The algorithm is due to Michael Baudin and Robert L. Smith
          !! and can be found in the paper
          !! "A Robust Complex Division in Scilab"
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dladiv( a, b, c, d, p, q )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: a,b,c,d
                    real(dp), intent(out) :: p,q
               end subroutine dladiv
#else 
               module procedure stdlib_dladiv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ladiv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sladiv( a, b, c, d, p, q )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: a,b,c,d
                    real(sp), intent(out) :: p,q
               end subroutine sladiv
#else 
               module procedure stdlib_sladiv
#endif
          end interface ladiv_s



          interface ladiv1
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dladiv1( a, b, c, d, p, q )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(inout) :: a
                    real(dp), intent(in) :: b,c,d
                    real(dp), intent(out) :: p,q
               end subroutine dladiv1
#else 
               module procedure stdlib_dladiv1
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ladiv1

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sladiv1( a, b, c, d, p, q )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(inout) :: a
                    real(sp), intent(in) :: b,c,d
                    real(sp), intent(out) :: p,q
               end subroutine sladiv1
#else 
               module procedure stdlib_sladiv1
#endif
          end interface ladiv1



          interface ladiv2
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function dladiv2( a, b, c, d, r, t )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: a,b,c,d,r,t
               end function dladiv2
#else 
               module procedure stdlib_dladiv2
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ladiv2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp) function sladiv2( a, b, c, d, r, t )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: a,b,c,d,r,t
               end function sladiv2
#else 
               module procedure stdlib_sladiv2
#endif
          end interface ladiv2



          interface laebz
          !! LAEBZ contains the iteration loops which compute and use the
          !! function N(w), which is the count of eigenvalues of a symmetric
          !! tridiagonal matrix T less than or equal to its argument  w.  It
          !! performs a choice of two types of loops:
          !! IJOB=1, followed by
          !! IJOB=2: It takes as input a list of intervals and returns a list of
          !! sufficiently small intervals whose union contains the same
          !! eigenvalues as the union of the original intervals.
          !! The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.
          !! The output interval (AB(j,1),AB(j,2)] will contain
          !! eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 <= j <= MOUT.
          !! IJOB=3: It performs a binary search in each input interval
          !! (AB(j,1),AB(j,2)] for a point  w(j)  such that
          !! N(w(j))=NVAL(j), and uses  C(j)  as the starting point of
          !! the search.  If such a w(j) is found, then on output
          !! AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output
          !! (AB(j,1),AB(j,2)] will be a small interval containing the
          !! point where N(w) jumps through NVAL(j), unless that point
          !! lies outside the initial interval.
          !! Note that the intervals are in all cases half-open intervals,
          !! i.e., of the form  (a,b] , which includes  b  but not  a .
          !! To avoid underflow, the matrix should be scaled so that its largest
          !! element is no greater than  overflow**(1/2) * underflow**(1/4)
          !! in absolute value.  To assure the most accurate computation
          !! of small eigenvalues, the matrix should be scaled to be
          !! not much smaller than that, either.
          !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
          !! Matrix", Report CS41, Computer Science Dept., Stanford
          !! University, July 21, 1966
          !! Note: the arguments are, in general, *not* checked for unreasonable
          !! values.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaebz( ijob, nitmax, n, mmax, minp, nbmin, abstol,reltol, pivmin, &
                         d, e, e2, nval, ab, c, mout,nab, work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ijob,minp,mmax,n,nbmin,nitmax
                    integer(ilp), intent(out) :: info,mout,iwork(*)
                    real(dp), intent(in) :: abstol,pivmin,reltol,d(*),e(*),e2(*)
                    integer(ilp), intent(inout) :: nab(mmax,*),nval(*)
                    real(dp), intent(inout) :: ab(mmax,*),c(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlaebz
#else 
               module procedure stdlib_dlaebz
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laebz

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaebz( ijob, nitmax, n, mmax, minp, nbmin, abstol,reltol, pivmin, &
                         d, e, e2, nval, ab, c, mout,nab, work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ijob,minp,mmax,n,nbmin,nitmax
                    integer(ilp), intent(out) :: info,mout,iwork(*)
                    real(sp), intent(in) :: abstol,pivmin,reltol,d(*),e(*),e2(*)
                    integer(ilp), intent(inout) :: nab(mmax,*),nval(*)
                    real(sp), intent(inout) :: ab(mmax,*),c(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slaebz
#else 
               module procedure stdlib_slaebz
#endif
          end interface laebz



          interface laed0
          !! Using the divide and conquer method, LAED0: computes all eigenvalues
          !! of a symmetric tridiagonal matrix which is one diagonal block of
          !! those from reducing a dense or band Hermitian matrix and
          !! corresponding eigenvectors of the dense or band matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claed0( qsiz, n, d, e, q, ldq, qstore, ldqs, rwork,iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldq,ldqs,n,qsiz
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: q(ldq,*)
                    complex(sp), intent(out) :: qstore(ldqs,*)
               end subroutine claed0
#else 
               module procedure stdlib_claed0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaed0( icompq, qsiz, n, d, e, q, ldq, qstore, ldqs,work, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: icompq,ldq,ldqs,n,qsiz
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(inout) :: d(*),e(*),q(ldq,*)
                    real(dp), intent(out) :: qstore(ldqs,*),work(*)
               end subroutine dlaed0
#else 
               module procedure stdlib_dlaed0
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laed0

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaed0( icompq, qsiz, n, d, e, q, ldq, qstore, ldqs,work, iwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: icompq,ldq,ldqs,n,qsiz
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(inout) :: d(*),e(*),q(ldq,*)
                    real(sp), intent(out) :: qstore(ldqs,*),work(*)
               end subroutine slaed0
#else 
               module procedure stdlib_slaed0
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laed0

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaed0( qsiz, n, d, e, q, ldq, qstore, ldqs, rwork,iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldq,ldqs,n,qsiz
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: q(ldq,*)
                    complex(dp), intent(out) :: qstore(ldqs,*)
               end subroutine zlaed0
#else 
               module procedure stdlib_zlaed0
#endif
          end interface laed0



          interface laed1
          !! LAED1 computes the updated eigensystem of a diagonal
          !! matrix after modification by a rank-one symmetric matrix.  This
          !! routine is used only for the eigenproblem which requires all
          !! eigenvalues and eigenvectors of a tridiagonal matrix.  DLAED7 handles
          !! the case in which eigenvalues only or eigenvalues and eigenvectors
          !! of a full symmetric matrix (which was reduced to tridiagonal form)
          !! are desired.
          !! T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
          !! where Z = Q**T*u, u is a vector of length N with ones in the
          !! CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
          !! The eigenvectors of the original matrix are stored in Q, and the
          !! eigenvalues are in D.  The algorithm consists of three stages:
          !! The first stage consists of deflating the size of the problem
          !! when there are multiple eigenvalues or if there is a zero in
          !! the Z vector.  For each such occurrence the dimension of the
          !! secular equation problem is reduced by one.  This stage is
          !! performed by the routine DLAED2.
          !! The second stage consists of calculating the updated
          !! eigenvalues. This is done by finding the roots of the secular
          !! equation via the routine DLAED4 (as called by DLAED3).
          !! This routine also calculates the eigenvectors of the current
          !! problem.
          !! The final stage consists of computing the updated eigenvectors
          !! directly using the updated eigenvalues.  The eigenvectors for
          !! the current problem are multiplied with the eigenvectors from
          !! the overall problem.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaed1( n, d, q, ldq, indxq, rho, cutpnt, work, iwork,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: cutpnt,ldq,n
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(inout) :: rho,d(*),q(ldq,*)
                    integer(ilp), intent(inout) :: indxq(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlaed1
#else 
               module procedure stdlib_dlaed1
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laed1

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaed1( n, d, q, ldq, indxq, rho, cutpnt, work, iwork,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: cutpnt,ldq,n
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(inout) :: rho,d(*),q(ldq,*)
                    integer(ilp), intent(inout) :: indxq(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slaed1
#else 
               module procedure stdlib_slaed1
#endif
          end interface laed1



          interface laed4
          !! This subroutine computes the I-th updated eigenvalue of a symmetric
          !! rank-one modification to a diagonal matrix whose elements are
          !! given in the array d, and that
          !! D(i) < D(j)  for  i < j
          !! and that RHO > 0.  This is arranged by the calling routine, and is
          !! no loss in generality.  The rank-one modified system is thus
          !! diag( D )  +  RHO * Z * Z_transpose.
          !! where we assume the Euclidean norm of Z is 1.
          !! The method consists of approximating the rational functions in the
          !! secular equation by simpler interpolating rational functions.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaed4( n, i, d, z, delta, rho, dlam, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: i,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(out) :: dlam,delta(*)
                    real(dp), intent(in) :: rho,d(*),z(*)
               end subroutine dlaed4
#else 
               module procedure stdlib_dlaed4
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laed4

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaed4( n, i, d, z, delta, rho, dlam, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: i,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(out) :: dlam,delta(*)
                    real(sp), intent(in) :: rho,d(*),z(*)
               end subroutine slaed4
#else 
               module procedure stdlib_slaed4
#endif
          end interface laed4



          interface laed5
          !! This subroutine computes the I-th eigenvalue of a symmetric rank-one
          !! modification of a 2-by-2 diagonal matrix
          !! diag( D )  +  RHO * Z * transpose(Z) .
          !! The diagonal elements in the array D are assumed to satisfy
          !! D(i) < D(j)  for  i < j .
          !! We also assume RHO > 0 and that the Euclidean norm of the vector
          !! Z is one.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaed5( i, d, z, delta, rho, dlam )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: i
                    real(dp), intent(out) :: dlam,delta(2)
                    real(dp), intent(in) :: rho,d(2),z(2)
               end subroutine dlaed5
#else 
               module procedure stdlib_dlaed5
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laed5

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaed5( i, d, z, delta, rho, dlam )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: i
                    real(sp), intent(out) :: dlam,delta(2)
                    real(sp), intent(in) :: rho,d(2),z(2)
               end subroutine slaed5
#else 
               module procedure stdlib_slaed5
#endif
          end interface laed5



          interface laed6
          !! LAED6 computes the positive or negative root (closest to the origin)
          !! of
          !! z(1)        z(2)        z(3)
          !! f(x) =   rho + --------- + ---------- + ---------
          !! d(1)-x      d(2)-x      d(3)-x
          !! It is assumed that
          !! if ORGATI = .true. the root is between d(2) and d(3);
          !! otherwise it is between d(1) and d(2)
          !! This routine will be called by DLAED4 when necessary. In most cases,
          !! the root sought is the smallest in magnitude, though it might not be
          !! in some extremely rare situations.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaed6( kniter, orgati, rho, d, z, finit, tau, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: orgati
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kniter
                    real(dp), intent(in) :: finit,rho,d(3),z(3)
                    real(dp), intent(out) :: tau
               end subroutine dlaed6
#else 
               module procedure stdlib_dlaed6
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laed6

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaed6( kniter, orgati, rho, d, z, finit, tau, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: orgati
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kniter
                    real(sp), intent(in) :: finit,rho,d(3),z(3)
                    real(sp), intent(out) :: tau
               end subroutine slaed6
#else 
               module procedure stdlib_slaed6
#endif
          end interface laed6



          interface laed7
          !! LAED7 computes the updated eigensystem of a diagonal
          !! matrix after modification by a rank-one symmetric matrix. This
          !! routine is used only for the eigenproblem which requires all
          !! eigenvalues and optionally eigenvectors of a dense or banded
          !! Hermitian matrix that has been reduced to tridiagonal form.
          !! T = Q(in) ( D(in) + RHO * Z*Z**H ) Q**H(in) = Q(out) * D(out) * Q**H(out)
          !! where Z = Q**Hu, u is a vector of length N with ones in the
          !! CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
          !! The eigenvectors of the original matrix are stored in Q, and the
          !! eigenvalues are in D.  The algorithm consists of three stages:
          !! The first stage consists of deflating the size of the problem
          !! when there are multiple eigenvalues or if there is a zero in
          !! the Z vector.  For each such occurrence the dimension of the
          !! secular equation problem is reduced by one.  This stage is
          !! performed by the routine SLAED2.
          !! The second stage consists of calculating the updated
          !! eigenvalues. This is done by finding the roots of the secular
          !! equation via the routine SLAED4 (as called by SLAED3).
          !! This routine also calculates the eigenvectors of the current
          !! problem.
          !! The final stage consists of computing the updated eigenvectors
          !! directly using the updated eigenvalues.  The eigenvectors for
          !! the current problem are multiplied with the eigenvectors from
          !! the overall problem.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claed7( n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q,ldq, rho, &
               indxq, qstore, qptr, prmptr, perm,givptr, givcol, givnum, work, rwork, iwork,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: curlvl,curpbm,cutpnt,ldq,n,qsiz,tlvls
                    integer(ilp), intent(out) :: info,indxq(*),iwork(*)
                    real(sp), intent(inout) :: rho,d(*),givnum(2,*),qstore(*)
                    integer(ilp), intent(inout) :: givcol(2,*),givptr(*),perm(*),prmptr(*),qptr(*)
                              
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: q(ldq,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine claed7
#else 
               module procedure stdlib_claed7
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaed7( icompq, n, qsiz, tlvls, curlvl, curpbm, d, q,ldq, indxq, &
               rho, cutpnt, qstore, qptr, prmptr,perm, givptr, givcol, givnum, work, iwork,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: curlvl,curpbm,cutpnt,icompq,ldq,n,qsiz,&
                              tlvls
                    integer(ilp), intent(out) :: info,indxq(*),iwork(*)
                    real(dp), intent(inout) :: rho,d(*),givnum(2,*),q(ldq,*),qstore(*)
                    integer(ilp), intent(inout) :: givcol(2,*),givptr(*),perm(*),prmptr(*),qptr(*)
                              
                    real(dp), intent(out) :: work(*)
               end subroutine dlaed7
#else 
               module procedure stdlib_dlaed7
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laed7

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaed7( icompq, n, qsiz, tlvls, curlvl, curpbm, d, q,ldq, indxq, &
               rho, cutpnt, qstore, qptr, prmptr,perm, givptr, givcol, givnum, work, iwork,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: curlvl,curpbm,cutpnt,icompq,ldq,n,qsiz,&
                              tlvls
                    integer(ilp), intent(out) :: info,indxq(*),iwork(*)
                    real(sp), intent(inout) :: rho,d(*),givnum(2,*),q(ldq,*),qstore(*)
                    integer(ilp), intent(inout) :: givcol(2,*),givptr(*),perm(*),prmptr(*),qptr(*)
                              
                    real(sp), intent(out) :: work(*)
               end subroutine slaed7
#else 
               module procedure stdlib_slaed7
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laed7

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaed7( n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q,ldq, rho, &
               indxq, qstore, qptr, prmptr, perm,givptr, givcol, givnum, work, rwork, iwork,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: curlvl,curpbm,cutpnt,ldq,n,qsiz,tlvls
                    integer(ilp), intent(out) :: info,indxq(*),iwork(*)
                    real(dp), intent(inout) :: rho,d(*),givnum(2,*),qstore(*)
                    integer(ilp), intent(inout) :: givcol(2,*),givptr(*),perm(*),prmptr(*),qptr(*)
                              
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: q(ldq,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlaed7
#else 
               module procedure stdlib_zlaed7
#endif
          end interface laed7



          interface laed8
          !! LAED8 merges the two sets of eigenvalues together into a single
          !! sorted set.  Then it tries to deflate the size of the problem.
          !! There are two ways in which deflation can occur:  when two or more
          !! eigenvalues are close together or if there is a tiny element in the
          !! Z vector.  For each such occurrence the order of the related secular
          !! equation problem is reduced by one.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claed8( k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda,q2, ldq2, w, &
                         indxp, indx, indxq, perm, givptr,givcol, givnum, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: cutpnt,ldq,ldq2,n,qsiz
                    integer(ilp), intent(out) :: givptr,info,k,givcol(2,*),indx(*),indxp(*),perm(&
                              *)
                    real(sp), intent(inout) :: rho,d(*),z(*)
                    integer(ilp), intent(inout) :: indxq(*)
                    real(sp), intent(out) :: dlamda(*),givnum(2,*),w(*)
                    complex(sp), intent(inout) :: q(ldq,*)
                    complex(sp), intent(out) :: q2(ldq2,*)
               end subroutine claed8
#else 
               module procedure stdlib_claed8
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho,cutpnt, z, &
                         dlamda, q2, ldq2, w, perm, givptr,givcol, givnum, indxp, indx, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: cutpnt,icompq,ldq,ldq2,n,qsiz
                    integer(ilp), intent(out) :: givptr,info,k,givcol(2,*),indx(*),indxp(*),perm(&
                              *)
                    real(dp), intent(inout) :: rho,d(*),q(ldq,*),z(*)
                    integer(ilp), intent(inout) :: indxq(*)
                    real(dp), intent(out) :: dlamda(*),givnum(2,*),q2(ldq2,*),w(*)
               end subroutine dlaed8
#else 
               module procedure stdlib_dlaed8
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laed8

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho,cutpnt, z, &
                         dlamda, q2, ldq2, w, perm, givptr,givcol, givnum, indxp, indx, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: cutpnt,icompq,ldq,ldq2,n,qsiz
                    integer(ilp), intent(out) :: givptr,info,k,givcol(2,*),indx(*),indxp(*),perm(&
                              *)
                    real(sp), intent(inout) :: rho,d(*),q(ldq,*),z(*)
                    integer(ilp), intent(inout) :: indxq(*)
                    real(sp), intent(out) :: dlamda(*),givnum(2,*),q2(ldq2,*),w(*)
               end subroutine slaed8
#else 
               module procedure stdlib_slaed8
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laed8

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaed8( k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda,q2, ldq2, w, &
                         indxp, indx, indxq, perm, givptr,givcol, givnum, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: cutpnt,ldq,ldq2,n,qsiz
                    integer(ilp), intent(out) :: givptr,info,k,givcol(2,*),indx(*),indxp(*),perm(&
                              *)
                    real(dp), intent(inout) :: rho,d(*),z(*)
                    integer(ilp), intent(inout) :: indxq(*)
                    real(dp), intent(out) :: dlamda(*),givnum(2,*),w(*)
                    complex(dp), intent(inout) :: q(ldq,*)
                    complex(dp), intent(out) :: q2(ldq2,*)
               end subroutine zlaed8
#else 
               module procedure stdlib_zlaed8
#endif
          end interface laed8



          interface laed9
          !! LAED9 finds the roots of the secular equation, as defined by the
          !! values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
          !! appropriate calls to DLAED4 and then stores the new matrix of
          !! eigenvectors for use in calculating the next level of Z vectors.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaed9( k, kstart, kstop, n, d, q, ldq, rho, dlamda, w,s, lds, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,kstart,kstop,ldq,lds,n
                    real(dp), intent(in) :: rho
                    real(dp), intent(out) :: d(*),q(ldq,*),s(lds,*)
                    real(dp), intent(inout) :: dlamda(*),w(*)
               end subroutine dlaed9
#else 
               module procedure stdlib_dlaed9
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laed9

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaed9( k, kstart, kstop, n, d, q, ldq, rho, dlamda, w,s, lds, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,kstart,kstop,ldq,lds,n
                    real(sp), intent(in) :: rho
                    real(sp), intent(out) :: d(*),q(ldq,*),s(lds,*)
                    real(sp), intent(inout) :: dlamda(*),w(*)
               end subroutine slaed9
#else 
               module procedure stdlib_slaed9
#endif
          end interface laed9



          interface laeda
          !! LAEDA computes the Z vector corresponding to the merge step in the
          !! CURLVLth step of the merge process with TLVLS steps for the CURPBMth
          !! problem.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, &
                         givnum, q, qptr, z, ztemp, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: curlvl,curpbm,n,tlvls,givcol(2,*),givptr(*),perm(&
                              *),prmptr(*),qptr(*)
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: givnum(2,*),q(*)
                    real(dp), intent(out) :: z(*),ztemp(*)
               end subroutine dlaeda
#else 
               module procedure stdlib_dlaeda
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laeda

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, &
                         givnum, q, qptr, z, ztemp, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: curlvl,curpbm,n,tlvls,givcol(2,*),givptr(*),perm(&
                              *),prmptr(*),qptr(*)
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: givnum(2,*),q(*)
                    real(sp), intent(out) :: z(*),ztemp(*)
               end subroutine slaeda
#else 
               module procedure stdlib_slaeda
#endif
          end interface laeda



          interface laein
          !! LAEIN uses inverse iteration to find a right or left eigenvector
          !! corresponding to the eigenvalue W of a complex upper Hessenberg
          !! matrix H.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,eps3, &
                         smlnum, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: noinit,rightv
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldh,n
                    real(sp), intent(in) :: eps3,smlnum
                    complex(sp), intent(in) :: w,h(ldh,*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(out) :: b(ldb,*)
                    complex(sp), intent(inout) :: v(*)
               end subroutine claein
#else 
               module procedure stdlib_claein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,ldb, work, &
                         eps3, smlnum, bignum, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: noinit,rightv
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldh,n
                    real(dp), intent(in) :: bignum,eps3,smlnum,wi,wr,h(ldh,*)
                    real(dp), intent(out) :: b(ldb,*),work(*)
                    real(dp), intent(inout) :: vi(*),vr(*)
               end subroutine dlaein
#else 
               module procedure stdlib_dlaein
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laein

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,ldb, work, &
                         eps3, smlnum, bignum, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: noinit,rightv
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldh,n
                    real(sp), intent(in) :: bignum,eps3,smlnum,wi,wr,h(ldh,*)
                    real(sp), intent(out) :: b(ldb,*),work(*)
                    real(sp), intent(inout) :: vi(*),vr(*)
               end subroutine slaein
#else 
               module procedure stdlib_slaein
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laein

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,eps3, &
                         smlnum, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: noinit,rightv
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldh,n
                    real(dp), intent(in) :: eps3,smlnum
                    complex(dp), intent(in) :: w,h(ldh,*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(out) :: b(ldb,*)
                    complex(dp), intent(inout) :: v(*)
               end subroutine zlaein
#else 
               module procedure stdlib_zlaein
#endif
          end interface laein



          interface laesy
          !! LAESY computes the eigendecomposition of a 2-by-2 symmetric matrix
          !! ( ( A, B );( B, C ) )
          !! provided the norm of the matrix of eigenvectors is larger than
          !! some threshold value.
          !! RT1 is the eigenvalue of larger absolute value, and RT2 of
          !! smaller absolute value.  If the eigenvectors are computed, then
          !! on return ( CS1, SN1 ) is the unit eigenvector for RT1, hence
          !! [  CS1     SN1   ] . [ A  B ] . [ CS1    -SN1   ] = [ RT1  0  ]
          !! [ -SN1     CS1   ]   [ B  C ]   [ SN1     CS1   ]   [  0  RT2 ]
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claesy( a, b, c, rt1, rt2, evscal, cs1, sn1 )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    complex(sp), intent(in) :: a,b,c
                    complex(sp), intent(out) :: cs1,evscal,rt1,rt2,sn1
               end subroutine claesy
#else 
               module procedure stdlib_claesy
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laesy

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaesy( a, b, c, rt1, rt2, evscal, cs1, sn1 )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    complex(dp), intent(in) :: a,b,c
                    complex(dp), intent(out) :: cs1,evscal,rt1,rt2,sn1
               end subroutine zlaesy
#else 
               module procedure stdlib_zlaesy
#endif
          end interface laesy



          interface laexc
          !! LAEXC swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
          !! an upper quasi-triangular matrix T by an orthogonal similarity
          !! transformation.
          !! T must be in Schur canonical form, that is, block upper triangular
          !! with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
          !! has its diagonal elements equal and its off-diagonal elements of
          !! opposite sign.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dlaexc( wantq, n, t, ldt, q, ldq, j1, n1, n2, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: wantq
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: j1,ldq,ldt,n,n1,n2
                    real(dp), intent(inout) :: q(ldq,*),t(ldt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlaexc
#else 
               module procedure stdlib_dlaexc
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laexc

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine slaexc( wantq, n, t, ldt, q, ldq, j1, n1, n2, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: wantq
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: j1,ldq,ldt,n,n1,n2
                    real(sp), intent(inout) :: q(ldq,*),t(ldt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slaexc
#else 
               module procedure stdlib_slaexc
#endif
          end interface laexc



          interface lagtf
          !! LAGTF factorizes the matrix (T - lambda*I), where T is an n by n
          !! tridiagonal matrix and lambda is a scalar, as
          !! T - lambda*I = PLU,
          !! where P is a permutation matrix, L is a unit lower tridiagonal matrix
          !! with at most one non-zero sub-diagonal elements per column and U is
          !! an upper triangular matrix with at most two non-zero super-diagonal
          !! elements per column.
          !! The factorization is obtained by Gaussian elimination with partial
          !! pivoting and implicit row scaling.
          !! The parameter LAMBDA is included in the routine so that LAGTF may
          !! be used, in conjunction with DLAGTS, to obtain eigenvectors of T by
          !! inverse iteration.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlagtf( n, a, lambda, b, c, tol, d, in, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,in(*)
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: lambda,tol
                    real(dp), intent(inout) :: a(*),b(*),c(*)
                    real(dp), intent(out) :: d(*)
               end subroutine dlagtf
#else 
               module procedure stdlib_dlagtf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lagtf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slagtf( n, a, lambda, b, c, tol, d, in, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,in(*)
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: lambda,tol
                    real(sp), intent(inout) :: a(*),b(*),c(*)
                    real(sp), intent(out) :: d(*)
               end subroutine slagtf
#else 
               module procedure stdlib_slagtf
#endif
          end interface lagtf



          interface lagtm
          !! LAGTM performs a matrix-vector product of the form
          !! B := alpha * A * X + beta * B
          !! where A is a tridiagonal matrix of order N, B and X are N by NRHS
          !! matrices, and alpha and beta are real scalars, each of which may be
          !! 0., 1., or -1.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,b, ldb )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(in) :: alpha,beta
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(in) :: d(*),dl(*),du(*),x(ldx,*)
               end subroutine clagtm
#else 
               module procedure stdlib_clagtm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,b, ldb )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(in) :: alpha,beta,d(*),dl(*),du(*),x(ldx,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dlagtm
#else 
               module procedure stdlib_dlagtm
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lagtm

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,b, ldb )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(in) :: alpha,beta,d(*),dl(*),du(*),x(ldx,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine slagtm
#else 
               module procedure stdlib_slagtm
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lagtm

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlagtm( trans, n, nrhs, alpha, dl, d, du, x, ldx, beta,b, ldb )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(in) :: alpha,beta
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(in) :: d(*),dl(*),du(*),x(ldx,*)
               end subroutine zlagtm
#else 
               module procedure stdlib_zlagtm
#endif
          end interface lagtm



          interface lagts
          !! LAGTS may be used to solve one of the systems of equations
          !! (T - lambda*I)*x = y   or   (T - lambda*I)**T*x = y,
          !! where T is an n by n tridiagonal matrix, for x, following the
          !! factorization of (T - lambda*I) as
          !! (T - lambda*I) = P*L*U ,
          !! by routine DLAGTF. The choice of equation to be solved is
          !! controlled by the argument JOB, and in each case there is an option
          !! to perturb zero or very small diagonal elements of U, this option
          !! being intended for use in applications such as inverse iteration.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlagts( job, n, a, b, c, d, in, y, tol, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: job,n,in(*)
                    real(dp), intent(inout) :: tol,y(*)
                    real(dp), intent(in) :: a(*),b(*),c(*),d(*)
               end subroutine dlagts
#else 
               module procedure stdlib_dlagts
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lagts

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slagts( job, n, a, b, c, d, in, y, tol, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: job,n,in(*)
                    real(sp), intent(inout) :: tol,y(*)
                    real(sp), intent(in) :: a(*),b(*),c(*),d(*)
               end subroutine slagts
#else 
               module procedure stdlib_slagts
#endif
          end interface lagts



          interface lahef
          !! LAHEF computes a partial factorization of a complex Hermitian
          !! matrix A using the Bunch-Kaufman diagonal pivoting method. The
          !! partial factorization has the form:
          !! A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:
          !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
          !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'
          !! ( L21  I ) (  0  A22 ) (  0      I     )
          !! where the order of D is at most NB. The actual order is returned in
          !! the argument KB, and is either NB or NB-1, or N if N <= NB.
          !! Note that U**H denotes the conjugate transpose of U.
          !! LAHEF is an auxiliary routine called by CHETRF. It uses blocked code
          !! (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
          !! A22 (if UPLO = 'L').
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clahef( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: w(ldw,*)
               end subroutine clahef
#else 
               module procedure stdlib_clahef
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lahef

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlahef( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: w(ldw,*)
               end subroutine zlahef
#else 
               module procedure stdlib_zlahef
#endif
          end interface lahef



          interface lahef_aa
          !! LAHEF_AA factorizes a panel of a complex hermitian matrix A using
          !! the Aasen's algorithm. The panel consists of a set of NB rows of A
          !! when UPLO is U, or a set of NB columns when UPLO is L.
          !! In order to factorize the panel, the Aasen's algorithm requires the
          !! last row, or column, of the previous panel. The first row, or column,
          !! of A is set to be the first row, or column, of an identity matrix,
          !! which is used to factorize the first panel.
          !! The resulting J-th row of U, or J-th column of L, is stored in the
          !! (J-1)-th row, or column, of A (without the unit diagonals), while
          !! the diagonal and subdiagonal of A are overwritten by those of T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clahef_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp), intent(out) :: ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),h(ldh,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clahef_aa
#else 
               module procedure stdlib_clahef_aa
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lahef_aa

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlahef_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp), intent(out) :: ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),h(ldh,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlahef_aa
#else 
               module procedure stdlib_zlahef_aa
#endif
          end interface lahef_aa



          interface lahef_rk
          !! LAHEF_RK computes a partial factorization of a complex Hermitian
          !! matrix A using the bounded Bunch-Kaufman (rook) diagonal
          !! pivoting method. The partial factorization has the form:
          !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
          !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
          !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L',
          !! ( L21  I ) (  0  A22 ) (  0       I    )
          !! where the order of D is at most NB. The actual order is returned in
          !! the argument KB, and is either NB or NB-1, or N if N <= NB.
          !! LAHEF_RK is an auxiliary routine called by CHETRF_RK. It uses
          !! blocked code (calling Level 3 BLAS) to update the submatrix
          !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clahef_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: w(ldw,*),e(*)
               end subroutine clahef_rk
#else 
               module procedure stdlib_clahef_rk
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lahef_rk

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlahef_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: w(ldw,*),e(*)
               end subroutine zlahef_rk
#else 
               module procedure stdlib_zlahef_rk
#endif
          end interface lahef_rk



          interface lahef_rook
          !! LAHEF_ROOK computes a partial factorization of a complex Hermitian
          !! matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting
          !! method. The partial factorization has the form:
          !! A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:
          !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
          !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'
          !! ( L21  I ) (  0  A22 ) (  0      I     )
          !! where the order of D is at most NB. The actual order is returned in
          !! the argument KB, and is either NB or NB-1, or N if N <= NB.
          !! Note that U**H denotes the conjugate transpose of U.
          !! LAHEF_ROOK is an auxiliary routine called by CHETRF_ROOK. It uses
          !! blocked code (calling Level 3 BLAS) to update the submatrix
          !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clahef_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: w(ldw,*)
               end subroutine clahef_rook
#else 
               module procedure stdlib_clahef_rook
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lahef_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlahef_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: w(ldw,*)
               end subroutine zlahef_rook
#else 
               module procedure stdlib_zlahef_rook
#endif
          end interface lahef_rook



          interface lahqr
          !! LAHQR is an auxiliary routine called by CHSEQR to update the
          !! eigenvalues and Schur decomposition already computed by CHSEQR, by
          !! dealing with the Hessenberg submatrix in rows and columns ILO to
          !! IHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(sp), intent(out) :: w(*)
               end subroutine clahqr
#else 
               module procedure stdlib_clahqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, &
                         ldz, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(dp), intent(out) :: wi(*),wr(*)
               end subroutine dlahqr
#else 
               module procedure stdlib_dlahqr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lahqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, &
                         ldz, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(sp), intent(out) :: wi(*),wr(*)
               end subroutine slahqr
#else 
               module procedure stdlib_slahqr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lahqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(dp), intent(out) :: w(*)
               end subroutine zlahqr
#else 
               module procedure stdlib_zlahqr
#endif
          end interface lahqr



          interface laic1
          !! LAIC1 applies one step of incremental condition estimation in
          !! its simplest version:
          !! Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j
          !! lower triangular matrix L, such that
          !! twonorm(L*x) = sest
          !! Then LAIC1 computes sestpr, s, c such that
          !! the vector
          !! [ s*x ]
          !! xhat = [  c  ]
          !! is an approximate singular vector of
          !! [ L      0  ]
          !! Lhat = [ w**H gamma ]
          !! in the sense that
          !! twonorm(Lhat*xhat) = sestpr.
          !! Depending on JOB, an estimate for the largest or smallest singular
          !! value is computed.
          !! Note that [s c]**H and sestpr**2 is an eigenpair of the system
          !! diag(sest*sest, 0) + [alpha  gamma] * [ conjg(alpha) ]
          !! [ conjg(gamma) ]
          !! where  alpha =  x**H*w.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claic1( job, j, x, sest, w, gamma, sestpr, s, c )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: j,job
                    real(sp), intent(in) :: sest
                    real(sp), intent(out) :: sestpr
                    complex(sp), intent(out) :: c,s
                    complex(sp), intent(in) :: gamma,w(j),x(j)
               end subroutine claic1
#else 
               module procedure stdlib_claic1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaic1( job, j, x, sest, w, gamma, sestpr, s, c )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: j,job
                    real(dp), intent(out) :: c,s,sestpr
                    real(dp), intent(in) :: gamma,sest,w(j),x(j)
               end subroutine dlaic1
#else 
               module procedure stdlib_dlaic1
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laic1

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaic1( job, j, x, sest, w, gamma, sestpr, s, c )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: j,job
                    real(sp), intent(out) :: c,s,sestpr
                    real(sp), intent(in) :: gamma,sest,w(j),x(j)
               end subroutine slaic1
#else 
               module procedure stdlib_slaic1
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laic1

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaic1( job, j, x, sest, w, gamma, sestpr, s, c )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: j,job
                    real(dp), intent(in) :: sest
                    real(dp), intent(out) :: sestpr
                    complex(dp), intent(out) :: c,s
                    complex(dp), intent(in) :: gamma,w(j),x(j)
               end subroutine zlaic1
#else 
               module procedure stdlib_zlaic1
#endif
          end interface laic1



          interface laisnan
          !! This routine is not for general use.  It exists solely to avoid
          !! over-optimization in DISNAN.
          !! LAISNAN checks for NaNs by comparing its two arguments for
          !! inequality.  NaN is the only floating-point value where NaN != NaN
          !! returns .TRUE.  To check for NaNs, pass the same variable as both
          !! arguments.
          !! A compiler must assume that the two arguments are
          !! not the same variable, and the test will not be optimized away.
          !! Interprocedural or whole-program optimization may delete this
          !! test.  The ISNAN functions will be replaced by the correct
          !! Fortran 03 intrinsic once the intrinsic is widely available.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure logical(lk) function dlaisnan( din1, din2 )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: din1,din2
               end function dlaisnan
#else 
               module procedure stdlib_dlaisnan
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laisnan

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure logical(lk) function slaisnan( sin1, sin2 )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: sin1,sin2
               end function slaisnan
#else 
               module procedure stdlib_slaisnan
#endif
          end interface laisnan



          interface lals0
          !! LALS0 applies back the multiplying factors of either the left or the
          !! right singular vector matrix of a diagonal matrix appended by a row
          !! to the right hand side matrix B in solving the least squares problem
          !! using the divide-and-conquer SVD approach.
          !! For the left singular vector matrix, three types of orthogonal
          !! matrices are involved:
          !! (1L) Givens rotations: the number of such rotations is GIVPTR; the
          !! pairs of columns/rows they were applied to are stored in GIVCOL;
          !! and the C- and S-values of these rotations are stored in GIVNUM.
          !! (2L) Permutation. The (NL+1)-st row of B is to be moved to the first
          !! row, and for J=2:N, PERM(J)-th row of B is to be moved to the
          !! J-th row.
          !! (3L) The left singular vector matrix of the remaining matrix.
          !! For the right singular vector matrix, four types of orthogonal
          !! matrices are involved:
          !! (1R) The right singular vector matrix of the remaining matrix.
          !! (2R) If SQRE = 1, one extra Givens rotation to generate the right
          !! null space.
          !! (3R) The inverse transformation of (2L).
          !! (4R) The inverse transformation of (1L).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
                         givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: givptr,icompq,k,ldb,ldbx,ldgcol,ldgnum,nl,nr,nrhs,&
                              sqre,givcol(ldgcol,*),perm(*)
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: c,s,difl(*),difr(ldgnum,*),givnum(ldgnum,*),poles(&
                              ldgnum,*),z(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(out) :: bx(ldbx,*)
               end subroutine clals0
#else 
               module procedure stdlib_clals0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
                         givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: givptr,icompq,k,ldb,ldbx,ldgcol,ldgnum,nl,nr,nrhs,&
                              sqre,givcol(ldgcol,*),perm(*)
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: c,s,difl(*),difr(ldgnum,*),givnum(ldgnum,*),poles(&
                              ldgnum,*),z(*)
                    real(dp), intent(inout) :: b(ldb,*)
                    real(dp), intent(out) :: bx(ldbx,*),work(*)
               end subroutine dlals0
#else 
               module procedure stdlib_dlals0
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lals0

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
                         givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: givptr,icompq,k,ldb,ldbx,ldgcol,ldgnum,nl,nr,nrhs,&
                              sqre,givcol(ldgcol,*),perm(*)
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: c,s,difl(*),difr(ldgnum,*),givnum(ldgnum,*),poles(&
                              ldgnum,*),z(*)
                    real(sp), intent(inout) :: b(ldb,*)
                    real(sp), intent(out) :: bx(ldbx,*),work(*)
               end subroutine slals0
#else 
               module procedure stdlib_slals0
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lals0

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
                         givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: givptr,icompq,k,ldb,ldbx,ldgcol,ldgnum,nl,nr,nrhs,&
                              sqre,givcol(ldgcol,*),perm(*)
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: c,s,difl(*),difr(ldgnum,*),givnum(ldgnum,*),poles(&
                              ldgnum,*),z(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(out) :: bx(ldbx,*)
               end subroutine zlals0
#else 
               module procedure stdlib_zlals0
#endif
          end interface lals0



          interface lalsa
          !! LALSA is an itermediate step in solving the least squares problem
          !! by computing the SVD of the coefficient matrix in compact form (The
          !! singular vectors are computed as products of simple orthorgonal
          !! matrices.).
          !! If ICOMPQ = 0, LALSA applies the inverse of the left singular vector
          !! matrix of an upper bidiagonal matrix to the right hand side; and if
          !! ICOMPQ = 1, LALSA applies the right singular vector matrix to the
          !! right hand side. The singular vector matrices were generated in
          !! compact form by LALSA.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, &
               difl, difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, rwork,iwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: icompq,ldb,ldbx,ldgcol,ldu,n,nrhs,smlsiz,givcol(&
                              ldgcol,*),givptr(*),k(*),perm(ldgcol,*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),z(ldu,*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(out) :: bx(ldbx,*)
               end subroutine clalsa
#else 
               module procedure stdlib_clalsa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, &
               difl, difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, work,iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: icompq,ldb,ldbx,ldgcol,ldu,n,nrhs,smlsiz,givcol(&
                              ldgcol,*),givptr(*),k(*),perm(ldgcol,*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(inout) :: b(ldb,*)
                    real(dp), intent(out) :: bx(ldbx,*),work(*)
                    real(dp), intent(in) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),z(ldu,*)
               end subroutine dlalsa
#else 
               module procedure stdlib_dlalsa
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lalsa

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, &
               difl, difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, work,iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: icompq,ldb,ldbx,ldgcol,ldu,n,nrhs,smlsiz,givcol(&
                              ldgcol,*),givptr(*),k(*),perm(ldgcol,*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(inout) :: b(ldb,*)
                    real(sp), intent(out) :: bx(ldbx,*),work(*)
                    real(sp), intent(in) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),z(ldu,*)
               end subroutine slalsa
#else 
               module procedure stdlib_slalsa
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lalsa

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, &
               difl, difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, rwork,iwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: icompq,ldb,ldbx,ldgcol,ldu,n,nrhs,smlsiz,givcol(&
                              ldgcol,*),givptr(*),k(*),perm(ldgcol,*)
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),z(ldu,*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(out) :: bx(ldbx,*)
               end subroutine zlalsa
#else 
               module procedure stdlib_zlalsa
#endif
          end interface lalsa



          interface lalsd
          !! LALSD uses the singular value decomposition of A to solve the least
          !! squares problem of finding X to minimize the Euclidean norm of each
          !! column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
          !! are N-by-NRHS. The solution X overwrites B.
          !! The singular values of A smaller than RCOND times the largest
          !! singular value are treated as zero in solving the least squares
          !! problem; in this case a minimum norm solution is returned.
          !! The actual singular values are returned in D in ascending order.
          !! This code makes very mild assumptions about floating point
          !! arithmetic. It will work on machines with a guard digit in
          !! add/subtract, or on those binary machines without guard digits
          !! which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
          !! It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, &
                         rwork, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,rank,iwork(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs,smlsiz
                    real(sp), intent(in) :: rcond
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clalsd
#else 
               module procedure stdlib_clalsd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, &
                         iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,rank,iwork(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs,smlsiz
                    real(dp), intent(in) :: rcond
                    real(dp), intent(inout) :: b(ldb,*),d(*),e(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlalsd
#else 
               module procedure stdlib_dlalsd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lalsd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, &
                         iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,rank,iwork(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs,smlsiz
                    real(sp), intent(in) :: rcond
                    real(sp), intent(inout) :: b(ldb,*),d(*),e(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slalsd
#else 
               module procedure stdlib_slalsd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lalsd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, &
                         rwork, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,rank,iwork(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs,smlsiz
                    real(dp), intent(in) :: rcond
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlalsd
#else 
               module procedure stdlib_zlalsd
#endif
          end interface lalsd



          interface lamrg
          !! LAMRG will create a permutation list which will merge the elements
          !! of A (which is composed of two independently sorted sets) into a
          !! single set which is sorted in ascending order.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlamrg( n1, n2, a, dtrd1, dtrd2, index )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: dtrd1,dtrd2,n1,n2
                    integer(ilp), intent(out) :: index(*)
                    real(dp), intent(in) :: a(*)
               end subroutine dlamrg
#else 
               module procedure stdlib_dlamrg
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lamrg

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slamrg( n1, n2, a, strd1, strd2, index )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n1,n2,strd1,strd2
                    integer(ilp), intent(out) :: index(*)
                    real(sp), intent(in) :: a(*)
               end subroutine slamrg
#else 
               module procedure stdlib_slamrg
#endif
          end interface lamrg



          interface lamswlq
          !! LAMSWLQ overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product of blocked
          !! elementary reflectors computed by short wide LQ
          !! factorization (CLASWLQ)
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clamswlq( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    complex(sp), intent(in) :: a(lda,*),t(ldt,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: c(ldc,*)
               end subroutine clamswlq
#else 
               module procedure stdlib_clamswlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlamswlq( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    real(dp), intent(in) :: a(lda,*),t(ldt,*)
                    real(dp), intent(out) :: work(*)
                    real(dp), intent(inout) :: c(ldc,*)
               end subroutine dlamswlq
#else 
               module procedure stdlib_dlamswlq
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lamswlq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slamswlq( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    real(sp), intent(in) :: a(lda,*),t(ldt,*)
                    real(sp), intent(out) :: work(*)
                    real(sp), intent(inout) :: c(ldc,*)
               end subroutine slamswlq
#else 
               module procedure stdlib_slamswlq
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lamswlq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlamswlq( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    complex(dp), intent(in) :: a(lda,*),t(ldt,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: c(ldc,*)
               end subroutine zlamswlq
#else 
               module procedure stdlib_zlamswlq
#endif
          end interface lamswlq



          interface lamtsqr
          !! LAMTSQR overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product
          !! of blocked elementary reflectors computed by tall skinny
          !! QR factorization (CLATSQR)
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clamtsqr( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    complex(sp), intent(in) :: a(lda,*),t(ldt,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: c(ldc,*)
               end subroutine clamtsqr
#else 
               module procedure stdlib_clamtsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlamtsqr( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    real(dp), intent(in) :: a(lda,*),t(ldt,*)
                    real(dp), intent(out) :: work(*)
                    real(dp), intent(inout) :: c(ldc,*)
               end subroutine dlamtsqr
#else 
               module procedure stdlib_dlamtsqr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lamtsqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slamtsqr( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    real(sp), intent(in) :: a(lda,*),t(ldt,*)
                    real(sp), intent(out) :: work(*)
                    real(sp), intent(inout) :: c(ldc,*)
               end subroutine slamtsqr
#else 
               module procedure stdlib_slamtsqr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lamtsqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlamtsqr( side, trans, m, n, k, mb, nb, a, lda, t,ldt, c, ldc, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,k,mb,nb,ldt,lwork,ldc
                    complex(dp), intent(in) :: a(lda,*),t(ldt,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: c(ldc,*)
               end subroutine zlamtsqr
#else 
               module procedure stdlib_zlamtsqr
#endif
          end interface lamtsqr



          interface laneg
          !! LANEG computes the Sturm count, the number of negative pivots
          !! encountered while factoring tridiagonal T - sigma I = L D L^T.
          !! This implementation works directly on the factors without forming
          !! the tridiagonal matrix T.  The Sturm count is also the number of
          !! eigenvalues of T less than sigma.
          !! This routine is called from DLARRB.
          !! The current routine does not use the PIVMIN parameter but rather
          !! requires IEEE-754 propagation of Infinities and NaNs.  This
          !! routine also has no input range restrictions but does require
          !! default exception handling such that x/0 produces Inf when x is
          !! non-zero, and Inf/Inf produces NaN.  For more information, see:
          !! Marques, Riedy, and Voemel, "Benefits of IEEE-754 Features in
          !! Modern Symmetric Tridiagonal Eigensolvers," SIAM Journal on
          !! Scientific Computing, v28, n5, 2006.  DOI 10.1137/050641624
          !! (Tech report version in LAWN 172 with the same title.)
#ifdef STDLIB_EXTERNAL_LAPACK
               pure integer(ilp) function dlaneg( n, d, lld, sigma, pivmin, r )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n,r
                    real(dp), intent(in) :: pivmin,sigma,d(*),lld(*)
               end function dlaneg
#else 
               module procedure stdlib_dlaneg
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laneg

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure integer(ilp) function slaneg( n, d, lld, sigma, pivmin, r )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n,r
                    real(sp), intent(in) :: pivmin,sigma,d(*),lld(*)
               end function slaneg
#else 
               module procedure stdlib_slaneg
#endif
          end interface laneg



          interface langb
          !! LANGB returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the element of  largest absolute value  of an
          !! n by n band matrix  A,  with kl sub-diagonals and ku super-diagonals.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clangb( norm, n, kl, ku, ab, ldab,work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: kl,ku,ldab,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end function clangb
#else 
               module procedure stdlib_clangb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlangb( norm, n, kl, ku, ab, ldab,work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: kl,ku,ldab,n
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(out) :: work(*)
               end function dlangb
#else 
               module procedure stdlib_dlangb
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$langb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slangb( norm, n, kl, ku, ab, ldab,work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: kl,ku,ldab,n
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(out) :: work(*)
               end function slangb
#else 
               module procedure stdlib_slangb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$langb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlangb( norm, n, kl, ku, ab, ldab,work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: kl,ku,ldab,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end function zlangb
#else 
               module procedure stdlib_zlangb
#endif
          end interface langb



          interface lange
          !! LANGE returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! complex matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clange( norm, m, n, a, lda, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: a(lda,*)
               end function clange
#else 
               module procedure stdlib_clange
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlange( norm, m, n, a, lda, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end function dlange
#else 
               module procedure stdlib_dlange
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lange

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slange( norm, m, n, a, lda, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end function slange
#else 
               module procedure stdlib_slange
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lange

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlange( norm, m, n, a, lda, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: a(lda,*)
               end function zlange
#else 
               module procedure stdlib_zlange
#endif
          end interface lange



          interface langt
          !! LANGT returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! complex tridiagonal matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp)             function clangt( norm, n, dl, d, du )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(in) :: d(*),dl(*),du(*)
               end function clangt
#else 
               module procedure stdlib_clangt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function dlangt( norm, n, dl, d, du )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: d(*),dl(*),du(*)
               end function dlangt
#else 
               module procedure stdlib_dlangt
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$langt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp)             function slangt( norm, n, dl, d, du )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: d(*),dl(*),du(*)
               end function slangt
#else 
               module procedure stdlib_slangt
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$langt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function zlangt( norm, n, dl, d, du )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(in) :: d(*),dl(*),du(*)
               end function zlangt
#else 
               module procedure stdlib_zlangt
#endif
          end interface langt



          interface lanhb
          !! LANHB returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the element of  largest absolute value  of an
          !! n by n hermitian band matrix A,  with k super-diagonals.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clanhb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end function clanhb
#else 
               module procedure stdlib_clanhb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lanhb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlanhb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end function zlanhb
#else 
               module procedure stdlib_zlanhb
#endif
          end interface lanhb



          interface lanhe
          !! LANHE returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! complex hermitian matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clanhe( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: a(lda,*)
               end function clanhe
#else 
               module procedure stdlib_clanhe
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lanhe

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlanhe( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: a(lda,*)
               end function zlanhe
#else 
               module procedure stdlib_zlanhe
#endif
          end interface lanhe



          interface lanhf
          !! LANHF returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! complex Hermitian matrix A in RFP format.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function clanhf( norm, transr, uplo, n, a, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,transr,uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: work(0:*)
                    complex(sp), intent(in) :: a(0:*)
               end function clanhf
#else 
               module procedure stdlib_clanhf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lanhf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlanhf( norm, transr, uplo, n, a, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,transr,uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: work(0:*)
                    complex(dp), intent(in) :: a(0:*)
               end function zlanhf
#else 
               module procedure stdlib_zlanhf
#endif
          end interface lanhf



          interface lanhp
          !! LANHP returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! complex hermitian matrix A,  supplied in packed form.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clanhp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ap(*)
               end function clanhp
#else 
               module procedure stdlib_clanhp
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lanhp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlanhp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ap(*)
               end function zlanhp
#else 
               module procedure stdlib_zlanhp
#endif
          end interface lanhp



          interface lanhs
          !! LANHS returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! Hessenberg matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clanhs( norm, n, a, lda, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: a(lda,*)
               end function clanhs
#else 
               module procedure stdlib_clanhs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlanhs( norm, n, a, lda, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end function dlanhs
#else 
               module procedure stdlib_dlanhs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lanhs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slanhs( norm, n, a, lda, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end function slanhs
#else 
               module procedure stdlib_slanhs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lanhs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlanhs( norm, n, a, lda, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: a(lda,*)
               end function zlanhs
#else 
               module procedure stdlib_zlanhs
#endif
          end interface lanhs



          interface lanht
          !! LANHT returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! complex Hermitian tridiagonal matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp)             function clanht( norm, n, d, e )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: d(*)
                    complex(sp), intent(in) :: e(*)
               end function clanht
#else 
               module procedure stdlib_clanht
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lanht

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function zlanht( norm, n, d, e )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: d(*)
                    complex(dp), intent(in) :: e(*)
               end function zlanht
#else 
               module procedure stdlib_zlanht
#endif
          end interface lanht



          interface lansb
          !! LANSB returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the element of  largest absolute value  of an
          !! n by n symmetric band matrix A,  with k super-diagonals.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clansb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end function clansb
#else 
               module procedure stdlib_clansb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlansb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(out) :: work(*)
               end function dlansb
#else 
               module procedure stdlib_dlansb
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lansb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slansb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(out) :: work(*)
               end function slansb
#else 
               module procedure stdlib_slansb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lansb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlansb( norm, uplo, n, k, ab, ldab,work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end function zlansb
#else 
               module procedure stdlib_zlansb
#endif
          end interface lansb



          interface lansf
          !! LANSF returns the value of the one norm, or the Frobenius norm, or
          !! the infinity norm, or the element of largest absolute value of a
          !! real symmetric matrix A in RFP format.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlansf( norm, transr, uplo, n, a, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,transr,uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: a(0:*)
                    real(dp), intent(out) :: work(0:*)
               end function dlansf
#else 
               module procedure stdlib_dlansf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lansf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp) function slansf( norm, transr, uplo, n, a, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,transr,uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: a(0:*)
                    real(sp), intent(out) :: work(0:*)
               end function slansf
#else 
               module procedure stdlib_slansf
#endif
          end interface lansf



          interface lansp
          !! LANSP returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! complex symmetric matrix A,  supplied in packed form.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clansp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ap(*)
               end function clansp
#else 
               module procedure stdlib_clansp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlansp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(out) :: work(*)
               end function dlansp
#else 
               module procedure stdlib_dlansp
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lansp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slansp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(out) :: work(*)
               end function slansp
#else 
               module procedure stdlib_slansp
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lansp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlansp( norm, uplo, n, ap, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ap(*)
               end function zlansp
#else 
               module procedure stdlib_zlansp
#endif
          end interface lansp



          interface lanst
          !! LANST returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! real symmetric tridiagonal matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(dp) function dlanst( norm, n, d, e )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: d(*),e(*)
               end function dlanst
#else 
               module procedure stdlib_dlanst
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lanst

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure real(sp)             function slanst( norm, n, d, e )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: d(*),e(*)
               end function slanst
#else 
               module procedure stdlib_slanst
#endif
          end interface lanst



          interface lansy
          !! LANSY returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! complex symmetric matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clansy( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: a(lda,*)
               end function clansy
#else 
               module procedure stdlib_clansy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlansy( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end function dlansy
#else 
               module procedure stdlib_dlansy
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lansy

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slansy( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end function slansy
#else 
               module procedure stdlib_slansy
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lansy

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlansy( norm, uplo, n, a, lda, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: norm,uplo
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: a(lda,*)
               end function zlansy
#else 
               module procedure stdlib_zlansy
#endif
          end interface lansy



          interface lantb
          !! LANTB returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the element of  largest absolute value  of an
          !! n by n triangular band matrix A,  with ( k + 1 ) diagonals.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clantb( norm, uplo, diag, n, k, ab,ldab, work )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end function clantb
#else 
               module procedure stdlib_clantb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlantb( norm, uplo, diag, n, k, ab,ldab, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(out) :: work(*)
               end function dlantb
#else 
               module procedure stdlib_dlantb
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lantb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slantb( norm, uplo, diag, n, k, ab,ldab, work )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(out) :: work(*)
               end function slantb
#else 
               module procedure stdlib_slantb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lantb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlantb( norm, uplo, diag, n, k, ab,ldab, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: k,ldab,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end function zlantb
#else 
               module procedure stdlib_zlantb
#endif
          end interface lantb



          interface lantp
          !! LANTP returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! triangular matrix A, supplied in packed form.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clantp( norm, uplo, diag, n, ap, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: ap(*)
               end function clantp
#else 
               module procedure stdlib_clantp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlantp( norm, uplo, diag, n, ap, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(out) :: work(*)
               end function dlantp
#else 
               module procedure stdlib_dlantp
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lantp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slantp( norm, uplo, diag, n, ap, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(out) :: work(*)
               end function slantp
#else 
               module procedure stdlib_slantp
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lantp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlantp( norm, uplo, diag, n, ap, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: ap(*)
               end function zlantp
#else 
               module procedure stdlib_zlantp
#endif
          end interface lantp



          interface lantr
          !! LANTR returns the value of the one norm,  or the Frobenius norm, or
          !! the  infinity norm,  or the  element of  largest absolute value  of a
          !! trapezoidal or triangular matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function clantr( norm, uplo, diag, m, n, a, lda,work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(in) :: a(lda,*)
               end function clantr
#else 
               module procedure stdlib_clantr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function dlantr( norm, uplo, diag, m, n, a, lda,work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end function dlantr
#else 
               module procedure stdlib_dlantr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lantr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(sp)             function slantr( norm, uplo, diag, m, n, a, lda,work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end function slantr
#else 
               module procedure stdlib_slantr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lantr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               real(dp) function zlantr( norm, uplo, diag, m, n, a, lda,work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(in) :: a(lda,*)
               end function zlantr
#else 
               module procedure stdlib_zlantr
#endif
          end interface lantr



          interface laorhr_col_getrfnp
          !! LAORHR_COL_GETRFNP computes the modified LU factorization without
          !! pivoting of a real general M-by-N matrix A. The factorization has
          !! the form:
          !! A - S = L * U,
          !! where:
          !! S is a m-by-n diagonal sign matrix with the diagonal D, so that
          !! D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
          !! as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
          !! i-1 steps of Gaussian elimination. This means that the diagonal
          !! element at each step of "modified" Gaussian elimination is
          !! at least one in absolute value (so that division-by-zero not
          !! not possible during the division by the diagonal element);
          !! L is a M-by-N lower triangular matrix with unit diagonal elements
          !! (lower trapezoidal if M > N);
          !! and U is a M-by-N upper triangular matrix
          !! (upper trapezoidal if M < N).
          !! This routine is an auxiliary routine used in the Householder
          !! reconstruction routine DORHR_COL. In DORHR_COL, this routine is
          !! applied to an M-by-N matrix A with orthonormal columns, where each
          !! element is bounded by one in absolute value. With the choice of
          !! the matrix S above, one can show that the diagonal element at each
          !! step of Gaussian elimination is the largest (in absolute value) in
          !! the column on or below the diagonal, so that no pivoting is required
          !! for numerical stability [1].
          !! For more details on the Householder reconstruction algorithm,
          !! including the modified LU factorization, see [1].
          !! This is the blocked right-looking version of the algorithm,
          !! calling Level 3 BLAS to update the submatrix. To factorize a block,
          !! this routine calls the recursive routine LAORHR_COL_GETRFNP2.
          !! [1] "Reconstructing Householder vectors from tall-skinny QR",
          !! G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
          !! E. Solomonik, J. Parallel Distrib. Comput.,
          !! vol. 85, pp. 3-31, 2015.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaorhr_col_getrfnp( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*)
               end subroutine dlaorhr_col_getrfnp
#else 
               module procedure stdlib_dlaorhr_col_getrfnp
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laorhr_col_getrfnp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaorhr_col_getrfnp( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*)
               end subroutine slaorhr_col_getrfnp
#else 
               module procedure stdlib_slaorhr_col_getrfnp
#endif
          end interface laorhr_col_getrfnp



          interface laorhr_col_getrfnp2
          !! LAORHR_COL_GETRFNP2 computes the modified LU factorization without
          !! pivoting of a real general M-by-N matrix A. The factorization has
          !! the form:
          !! A - S = L * U,
          !! where:
          !! S is a m-by-n diagonal sign matrix with the diagonal D, so that
          !! D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
          !! as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
          !! i-1 steps of Gaussian elimination. This means that the diagonal
          !! element at each step of "modified" Gaussian elimination is at
          !! least one in absolute value (so that division-by-zero not
          !! possible during the division by the diagonal element);
          !! L is a M-by-N lower triangular matrix with unit diagonal elements
          !! (lower trapezoidal if M > N);
          !! and U is a M-by-N upper triangular matrix
          !! (upper trapezoidal if M < N).
          !! This routine is an auxiliary routine used in the Householder
          !! reconstruction routine DORHR_COL. In DORHR_COL, this routine is
          !! applied to an M-by-N matrix A with orthonormal columns, where each
          !! element is bounded by one in absolute value. With the choice of
          !! the matrix S above, one can show that the diagonal element at each
          !! step of Gaussian elimination is the largest (in absolute value) in
          !! the column on or below the diagonal, so that no pivoting is required
          !! for numerical stability [1].
          !! For more details on the Householder reconstruction algorithm,
          !! including the modified LU factorization, see [1].
          !! This is the recursive version of the LU factorization algorithm.
          !! Denote A - S by B. The algorithm divides the matrix B into four
          !! submatrices:
          !! [  B11 | B12  ]  where B11 is n1 by n1,
          !! B = [ -----|----- ]        B21 is (m-n1) by n1,
          !! [  B21 | B22  ]        B12 is n1 by n2,
          !! B22 is (m-n1) by n2,
          !! with n1 = min(m,n)/2, n2 = n-n1.
          !! The subroutine calls itself to factor B11, solves for B21,
          !! solves for B12, updates B22, then calls itself to factor B22.
          !! For more details on the recursive LU algorithm, see [2].
          !! LAORHR_COL_GETRFNP2 is called to factorize a block by the blocked
          !! routine DLAORHR_COL_GETRFNP, which uses blocked code calling
          !! Level 3 BLAS to update the submatrix. However, LAORHR_COL_GETRFNP2
          !! is self-sufficient and can be used without DLAORHR_COL_GETRFNP.
          !! [1] "Reconstructing Householder vectors from tall-skinny QR",
          !! G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
          !! E. Solomonik, J. Parallel Distrib. Comput.,
          !! vol. 85, pp. 3-31, 2015.
          !! [2] "Recursion leads to automatic variable blocking for dense linear
          !! algebra algorithms", F. Gustavson, IBM J. of Res. and Dev.,
          !! vol. 41, no. 6, pp. 737-755, 1997.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine dlaorhr_col_getrfnp2( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*)
               end subroutine dlaorhr_col_getrfnp2
#else 
               module procedure stdlib_dlaorhr_col_getrfnp2
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laorhr_col_getrfnp2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine slaorhr_col_getrfnp2( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*)
               end subroutine slaorhr_col_getrfnp2
#else 
               module procedure stdlib_slaorhr_col_getrfnp2
#endif
          end interface laorhr_col_getrfnp2



          interface lapll
          !! Given two column vectors X and Y, let
          !! A = ( X Y ).
          !! The subroutine first computes the QR factorization of A = Q*R,
          !! and then computes the SVD of the 2-by-2 upper triangular matrix R.
          !! The smaller singular value of R is returned in SSMIN, which is used
          !! as the measurement of the linear dependency of the vectors X and Y.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clapll( n, x, incx, y, incy, ssmin )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,incy,n
                    real(sp), intent(out) :: ssmin
                    complex(sp), intent(inout) :: x(*),y(*)
               end subroutine clapll
#else 
               module procedure stdlib_clapll
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlapll( n, x, incx, y, incy, ssmin )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,incy,n
                    real(dp), intent(out) :: ssmin
                    real(dp), intent(inout) :: x(*),y(*)
               end subroutine dlapll
#else 
               module procedure stdlib_dlapll
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lapll

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slapll( n, x, incx, y, incy, ssmin )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,incy,n
                    real(sp), intent(out) :: ssmin
                    real(sp), intent(inout) :: x(*),y(*)
               end subroutine slapll
#else 
               module procedure stdlib_slapll
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lapll

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlapll( n, x, incx, y, incy, ssmin )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,incy,n
                    real(dp), intent(out) :: ssmin
                    complex(dp), intent(inout) :: x(*),y(*)
               end subroutine zlapll
#else 
               module procedure stdlib_zlapll
#endif
          end interface lapll



          interface lapmr
          !! LAPMR rearranges the rows of the M by N matrix X as specified
          !! by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
          !! If FORWRD = .TRUE.,  forward permutation:
          !! X(K(I),*) is moved X(I,*) for I = 1,2,...,M.
          !! If FORWRD = .FALSE., backward permutation:
          !! X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clapmr( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: forwrd
                    integer(ilp), intent(in) :: ldx,m,n
                    integer(ilp), intent(inout) :: k(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine clapmr
#else 
               module procedure stdlib_clapmr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlapmr( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: forwrd
                    integer(ilp), intent(in) :: ldx,m,n
                    integer(ilp), intent(inout) :: k(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dlapmr
#else 
               module procedure stdlib_dlapmr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lapmr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slapmr( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: forwrd
                    integer(ilp), intent(in) :: ldx,m,n
                    integer(ilp), intent(inout) :: k(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine slapmr
#else 
               module procedure stdlib_slapmr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lapmr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlapmr( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: forwrd
                    integer(ilp), intent(in) :: ldx,m,n
                    integer(ilp), intent(inout) :: k(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zlapmr
#else 
               module procedure stdlib_zlapmr
#endif
          end interface lapmr



          interface lapmt
          !! LAPMT rearranges the columns of the M by N matrix X as specified
          !! by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
          !! If FORWRD = .TRUE.,  forward permutation:
          !! X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
          !! If FORWRD = .FALSE., backward permutation:
          !! X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clapmt( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: forwrd
                    integer(ilp), intent(in) :: ldx,m,n
                    integer(ilp), intent(inout) :: k(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine clapmt
#else 
               module procedure stdlib_clapmt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlapmt( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: forwrd
                    integer(ilp), intent(in) :: ldx,m,n
                    integer(ilp), intent(inout) :: k(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dlapmt
#else 
               module procedure stdlib_dlapmt
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lapmt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slapmt( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: forwrd
                    integer(ilp), intent(in) :: ldx,m,n
                    integer(ilp), intent(inout) :: k(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine slapmt
#else 
               module procedure stdlib_slapmt
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lapmt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlapmt( forwrd, m, n, x, ldx, k )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: forwrd
                    integer(ilp), intent(in) :: ldx,m,n
                    integer(ilp), intent(inout) :: k(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zlapmt
#else 
               module procedure stdlib_zlapmt
#endif
          end interface lapmt



          interface laqgb
          !! LAQGB equilibrates a general M by N band matrix A with KL
          !! subdiagonals and KU superdiagonals using the row and scaling factors
          !! in the vectors R and C.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, equed )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine claqgb
#else 
               module procedure stdlib_claqgb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, equed )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dlaqgb
#else 
               module procedure stdlib_dlaqgb
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqgb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, equed )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(sp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine slaqgb
#else 
               module procedure stdlib_slaqgb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqgb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqgb( m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd,amax, equed )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    integer(ilp), intent(in) :: kl,ku,ldab,m,n
                    real(dp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zlaqgb
#else 
               module procedure stdlib_zlaqgb
#endif
          end interface laqgb



          interface laqge
          !! LAQGE equilibrates a general M by N matrix A using the row and
          !! column scaling factors in the vectors R and C.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine claqge
#else 
               module procedure stdlib_claqge
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dlaqge
#else 
               module procedure stdlib_dlaqge
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqge

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine slaqge
#else 
               module procedure stdlib_slaqge
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqge

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqge( m, n, a, lda, r, c, rowcnd, colcnd, amax,equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(in) :: amax,colcnd,rowcnd,c(*),r(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlaqge
#else 
               module procedure stdlib_zlaqge
#endif
          end interface laqge



          interface laqhb
          !! LAQHB equilibrates an Hermitian band matrix A using the scaling
          !! factors in the vector S.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqhb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(in) :: amax,scond
                    real(sp), intent(out) :: s(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine claqhb
#else 
               module procedure stdlib_claqhb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqhb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqhb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(in) :: amax,scond
                    real(dp), intent(out) :: s(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zlaqhb
#else 
               module procedure stdlib_zlaqhb
#endif
          end interface laqhb



          interface laqhe
          !! LAQHE equilibrates a Hermitian matrix A using the scaling factors
          !! in the vector S.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqhe( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: amax,scond,s(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine claqhe
#else 
               module procedure stdlib_claqhe
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqhe

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqhe( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: amax,scond,s(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlaqhe
#else 
               module procedure stdlib_zlaqhe
#endif
          end interface laqhe



          interface laqhp
          !! LAQHP equilibrates a Hermitian matrix A using the scaling factors
          !! in the vector S.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqhp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: amax,scond,s(*)
                    complex(sp), intent(inout) :: ap(*)
               end subroutine claqhp
#else 
               module procedure stdlib_claqhp
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqhp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqhp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: amax,scond,s(*)
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zlaqhp
#else 
               module procedure stdlib_zlaqhp
#endif
          end interface laqhp



          interface laqps
          !! LAQPS computes a step of QR factorization with column pivoting
          !! of a complex M-by-N matrix A by using Blas-3.  It tries to factorize
          !! NB columns from A starting from the row OFFSET+1, and updates all
          !! of the matrix with Blas-3 xGEMM.
          !! In some cases, due to catastrophic cancellations, it cannot
          !! factorize NB columns.  Hence, the actual number of factorized
          !! columns is returned in KB.
          !! Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,vn2, auxv, f, &
                         ldf )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: kb
                    integer(ilp), intent(in) :: lda,ldf,m,n,nb,offset
                    integer(ilp), intent(inout) :: jpvt(*)
                    real(sp), intent(inout) :: vn1(*),vn2(*)
                    complex(sp), intent(inout) :: a(lda,*),auxv(*),f(ldf,*)
                    complex(sp), intent(out) :: tau(*)
               end subroutine claqps
#else 
               module procedure stdlib_claqps
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,vn2, auxv, f, &
                         ldf )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: kb
                    integer(ilp), intent(in) :: lda,ldf,m,n,nb,offset
                    integer(ilp), intent(inout) :: jpvt(*)
                    real(dp), intent(inout) :: a(lda,*),auxv(*),f(ldf,*),vn1(*),vn2(*)
                    real(dp), intent(out) :: tau(*)
               end subroutine dlaqps
#else 
               module procedure stdlib_dlaqps
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqps

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,vn2, auxv, f, &
                         ldf )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: kb
                    integer(ilp), intent(in) :: lda,ldf,m,n,nb,offset
                    integer(ilp), intent(inout) :: jpvt(*)
                    real(sp), intent(inout) :: a(lda,*),auxv(*),f(ldf,*),vn1(*),vn2(*)
                    real(sp), intent(out) :: tau(*)
               end subroutine slaqps
#else 
               module procedure stdlib_slaqps
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqps

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqps( m, n, offset, nb, kb, a, lda, jpvt, tau, vn1,vn2, auxv, f, &
                         ldf )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: kb
                    integer(ilp), intent(in) :: lda,ldf,m,n,nb,offset
                    integer(ilp), intent(inout) :: jpvt(*)
                    real(dp), intent(inout) :: vn1(*),vn2(*)
                    complex(dp), intent(inout) :: a(lda,*),auxv(*),f(ldf,*)
                    complex(dp), intent(out) :: tau(*)
               end subroutine zlaqps
#else 
               module procedure stdlib_zlaqps
#endif
          end interface laqps



          interface laqr0
          !! LAQR0 computes the eigenvalues of a Hessenberg matrix H
          !! and, optionally, the matrices T and Z from the Schur decomposition
          !! H = Z T Z**H, where T is an upper triangular matrix (the
          !! Schur form), and Z is the unitary matrix of Schur vectors.
          !! Optionally Z may be postmultiplied into an input unitary
          !! matrix Q so that this routine can give the Schur factorization
          !! of a matrix A which has been reduced to the Hessenberg form H
          !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(sp), intent(out) :: w(*),work(*)
               end subroutine claqr0
#else 
               module procedure stdlib_claqr0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(dp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine dlaqr0
#else 
               module procedure stdlib_dlaqr0
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqr0

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine slaqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(sp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine slaqr0
#else 
               module procedure stdlib_slaqr0
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqr0

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(dp), intent(out) :: w(*),work(*)
               end subroutine zlaqr0
#else 
               module procedure stdlib_zlaqr0
#endif
          end interface laqr0



          interface laqr1
          !! Given a 2-by-2 or 3-by-3 matrix H, LAQR1: sets v to a
          !! scalar multiple of the first column of the product
          !! (*)  K = (H - s1*I)*(H - s2*I)
          !! scaling to avoid overflows and most underflows.
          !! This is useful for starting double implicit shift bulges
          !! in the QR algorithm.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqr1( n, h, ldh, s1, s2, v )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    complex(sp), intent(in) :: s1,s2,h(ldh,*)
                    integer(ilp), intent(in) :: ldh,n
                    complex(sp), intent(out) :: v(*)
               end subroutine claqr1
#else 
               module procedure stdlib_claqr1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqr1( n, h, ldh, sr1, si1, sr2, si2, v )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: si1,si2,sr1,sr2,h(ldh,*)
                    integer(ilp), intent(in) :: ldh,n
                    real(dp), intent(out) :: v(*)
               end subroutine dlaqr1
#else 
               module procedure stdlib_dlaqr1
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqr1

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqr1( n, h, ldh, sr1, si1, sr2, si2, v )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: si1,si2,sr1,sr2,h(ldh,*)
                    integer(ilp), intent(in) :: ldh,n
                    real(sp), intent(out) :: v(*)
               end subroutine slaqr1
#else 
               module procedure stdlib_slaqr1
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqr1

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqr1( n, h, ldh, s1, s2, v )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    complex(dp), intent(in) :: s1,s2,h(ldh,*)
                    integer(ilp), intent(in) :: ldh,n
                    complex(dp), intent(out) :: v(*)
               end subroutine zlaqr1
#else 
               module procedure stdlib_zlaqr1
#endif
          end interface laqr1



          interface laqr4
          !! LAQR4 implements one level of recursion for CLAQR0.
          !! It is a complete implementation of the small bulge multi-shift
          !! QR algorithm.  It may be called by CLAQR0 and, for large enough
          !! deflation window size, it may be called by CLAQR3.  This
          !! subroutine is identical to CLAQR0 except that it calls CLAQR2
          !! instead of CLAQR3.
          !! LAQR4 computes the eigenvalues of a Hessenberg matrix H
          !! and, optionally, the matrices T and Z from the Schur decomposition
          !! H = Z T Z**H, where T is an upper triangular matrix (the
          !! Schur form), and Z is the unitary matrix of Schur vectors.
          !! Optionally Z may be postmultiplied into an input unitary
          !! matrix Q so that this routine can give the Schur factorization
          !! of a matrix A which has been reduced to the Hessenberg form H
          !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(sp), intent(out) :: w(*),work(*)
               end subroutine claqr4
#else 
               module procedure stdlib_claqr4
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dlaqr4( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(dp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine dlaqr4
#else 
               module procedure stdlib_dlaqr4
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqr4

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine slaqr4( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    real(sp), intent(inout) :: h(ldh,*),z(ldz,*)
                    real(sp), intent(out) :: wi(*),work(*),wr(*)
               end subroutine slaqr4
#else 
               module procedure stdlib_slaqr4
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqr4

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, &
                         work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ihiz,ilo,iloz,ldh,ldz,lwork,n
                    integer(ilp), intent(out) :: info
                    logical(lk), intent(in) :: wantt,wantz
                    complex(dp), intent(inout) :: h(ldh,*),z(ldz,*)
                    complex(dp), intent(out) :: w(*),work(*)
               end subroutine zlaqr4
#else 
               module procedure stdlib_zlaqr4
#endif
          end interface laqr4



          interface laqr5
          !! LAQR5 called by CLAQR0 performs a
          !! single small-bulge multi-shift QR sweep.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,h, ldh, &
                         iloz, ihiz, z, ldz, v, ldv, u, ldu, nv,wv, ldwv, nh, wh, ldwh )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihiz,iloz,kacc22,kbot,ktop,ldh,ldu,ldv,ldwh,ldwv,&
                              ldz,n,nh,nshfts,nv
                    logical(lk), intent(in) :: wantt,wantz
                    complex(sp), intent(inout) :: h(ldh,*),s(*),z(ldz,*)
                    complex(sp), intent(out) :: u(ldu,*),v(ldv,*),wh(ldwh,*),wv(ldwv,*)
               end subroutine claqr5
#else 
               module procedure stdlib_claqr5
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,sr, si, h, ldh,&
                          iloz, ihiz, z, ldz, v, ldv, u,ldu, nv, wv, ldwv, nh, wh, ldwh )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihiz,iloz,kacc22,kbot,ktop,ldh,ldu,ldv,ldwh,ldwv,&
                              ldz,n,nh,nshfts,nv
                    logical(lk), intent(in) :: wantt,wantz
                    real(dp), intent(inout) :: h(ldh,*),si(*),sr(*),z(ldz,*)
                    real(dp), intent(out) :: u(ldu,*),v(ldv,*),wh(ldwh,*),wv(ldwv,*)
               end subroutine dlaqr5
#else 
               module procedure stdlib_dlaqr5
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqr5

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,sr, si, h, ldh,&
                          iloz, ihiz, z, ldz, v, ldv, u,ldu, nv, wv, ldwv, nh, wh, ldwh )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihiz,iloz,kacc22,kbot,ktop,ldh,ldu,ldv,ldwh,ldwv,&
                              ldz,n,nh,nshfts,nv
                    logical(lk), intent(in) :: wantt,wantz
                    real(sp), intent(inout) :: h(ldh,*),si(*),sr(*),z(ldz,*)
                    real(sp), intent(out) :: u(ldu,*),v(ldv,*),wh(ldwh,*),wv(ldwv,*)
               end subroutine slaqr5
#else 
               module procedure stdlib_slaqr5
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqr5

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,h, ldh, &
                         iloz, ihiz, z, ldz, v, ldv, u, ldu, nv,wv, ldwv, nh, wh, ldwh )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihiz,iloz,kacc22,kbot,ktop,ldh,ldu,ldv,ldwh,ldwv,&
                              ldz,n,nh,nshfts,nv
                    logical(lk), intent(in) :: wantt,wantz
                    complex(dp), intent(inout) :: h(ldh,*),s(*),z(ldz,*)
                    complex(dp), intent(out) :: u(ldu,*),v(ldv,*),wh(ldwh,*),wv(ldwv,*)
               end subroutine zlaqr5
#else 
               module procedure stdlib_zlaqr5
#endif
          end interface laqr5



          interface laqsb
          !! LAQSB equilibrates a symmetric band matrix A using the scaling
          !! factors in the vector S.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(in) :: amax,scond,s(*)
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine claqsb
#else 
               module procedure stdlib_claqsb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(in) :: amax,scond,s(*)
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dlaqsb
#else 
               module procedure stdlib_dlaqsb
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqsb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(in) :: amax,scond,s(*)
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine slaqsb
#else 
               module procedure stdlib_slaqsb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqsb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(in) :: amax,scond,s(*)
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zlaqsb
#else 
               module procedure stdlib_zlaqsb
#endif
          end interface laqsb



          interface laqsp
          !! LAQSP equilibrates a symmetric matrix A using the scaling factors
          !! in the vector S.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqsp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: amax,scond,s(*)
                    complex(sp), intent(inout) :: ap(*)
               end subroutine claqsp
#else 
               module procedure stdlib_claqsp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqsp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: amax,scond,s(*)
                    real(dp), intent(inout) :: ap(*)
               end subroutine dlaqsp
#else 
               module procedure stdlib_dlaqsp
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqsp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqsp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: amax,scond,s(*)
                    real(sp), intent(inout) :: ap(*)
               end subroutine slaqsp
#else 
               module procedure stdlib_slaqsp
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqsp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqsp( uplo, n, ap, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: amax,scond,s(*)
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zlaqsp
#else 
               module procedure stdlib_zlaqsp
#endif
          end interface laqsp



          interface laqsy
          !! LAQSY equilibrates a symmetric matrix A using the scaling factors
          !! in the vector S.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqsy( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: amax,scond,s(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine claqsy
#else 
               module procedure stdlib_claqsy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqsy( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: amax,scond,s(*)
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dlaqsy
#else 
               module procedure stdlib_dlaqsy
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqsy

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqsy( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: amax,scond,s(*)
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine slaqsy
#else 
               module procedure stdlib_slaqsy
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqsy

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqsy( uplo, n, a, lda, s, scond, amax, equed )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(out) :: equed
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: amax,scond,s(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlaqsy
#else 
               module procedure stdlib_zlaqsy
#endif
          end interface laqsy



          interface laqtr
          !! LAQTR solves the real quasi-triangular system
          !! op(T)*p = scale*c,               if LREAL = .TRUE.
          !! or the complex quasi-triangular systems
          !! op(T + iB)*(p+iq) = scale*(c+id),  if LREAL = .FALSE.
          !! in real arithmetic, where T is upper quasi-triangular.
          !! If LREAL = .FALSE., then the first diagonal block of T must be
          !! 1 by 1, B is the specially structured matrix
          !! B = [ b(1) b(2) ... b(n) ]
          !! [       w            ]
          !! [           w        ]
          !! [              .     ]
          !! [                 w  ]
          !! op(A) = A or A**T, A**T denotes the transpose of
          !! matrix A.
          !! On input, X = [ c ].  On output, X = [ p ].
          !! [ d ]                  [ q ]
          !! This subroutine is designed for the condition number estimation
          !! in routine DTRSNA.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dlaqtr( ltran, lreal, n, t, ldt, b, w, scale, x, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: lreal,ltran
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldt,n
                    real(dp), intent(out) :: scale,work(*)
                    real(dp), intent(in) :: w,b(*),t(ldt,*)
                    real(dp), intent(inout) :: x(*)
               end subroutine dlaqtr
#else 
               module procedure stdlib_dlaqtr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqtr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine slaqtr( ltran, lreal, n, t, ldt, b, w, scale, x, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: lreal,ltran
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldt,n
                    real(sp), intent(out) :: scale,work(*)
                    real(sp), intent(in) :: w,b(*),t(ldt,*)
                    real(sp), intent(inout) :: x(*)
               end subroutine slaqtr
#else 
               module procedure stdlib_slaqtr
#endif
          end interface laqtr



          interface laqz0
          !! LAQZ0 computes the eigenvalues of a matrix pair (H,T),
          !! where H is an upper Hessenberg matrix and T is upper triangular,
          !! using the double-shift QZ method.
          !! Matrix pairs of this type are produced by the reduction to
          !! generalized upper Hessenberg form of a matrix pair (A,B):
          !! A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
          !! as computed by CGGHRD.
          !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
          !! also reduced to generalized Schur form,
          !! H = Q*S*Z**H,  T = Q*P*Z**H,
          !! where Q and Z are unitary matrices, P and S are an upper triangular
          !! matrices.
          !! Optionally, the unitary matrix Q from the generalized Schur
          !! factorization may be postmultiplied into an input matrix Q1, and the
          !! unitary matrix Z may be postmultiplied into an input matrix Z1.
          !! If Q1 and Z1 are the unitary matrices from CGGHRD that reduced
          !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
          !! output matrices Q1*Q and Z1*Z are the unitary factors from the
          !! generalized Schur factorization of (A,B):
          !! A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
          !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
          !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
          !! complex and beta real.
          !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
          !! generalized nonsymmetric eigenvalue problem (GNEP)
          !! A*x = lambda*B*x
          !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
          !! alternate form of the GNEP
          !! mu*A*y = B*y.
          !! Eigenvalues can be read directly from the generalized Schur
          !! form:
          !! alpha = S(i,i), beta = P(i,i).
          !! Ref: C.B. Moler
          !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
          !! pp. 241--256.
          !! Ref: B. Kagstrom, D. Kressner, "Multishift Variants of the QZ
          !! Algorithm with Aggressive Early Deflation", SIAM J. Numer.
          !! Anal., 29(2006), pp. 199--227.
          !! Ref: T. Steel, D. Camps, K. Meerbergen, R. Vandebril "A multishift,
          !! multipole rational QZ method with agressive early deflation"
#ifdef STDLIB_EXTERNAL_LAPACK
               recursive subroutine claqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, &
                         alpha, beta, q, ldq, z,ldz, work, lwork, rwork, rec,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: wants,wantq,wantz
                    integer(ilp), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,rec
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    complex(sp), intent(inout) :: alpha(*),beta(*),work(*)
                    real(sp), intent(out) :: rwork(*)
               end subroutine claqz0
#else 
               module procedure stdlib_claqz0
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               recursive subroutine dlaqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, &
                         alphar, alphai, beta,q, ldq, z, ldz, work, lwork, rec,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: wants,wantq,wantz
                    integer(ilp), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,rec
                    integer(ilp), intent(out) :: info
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    real(dp), intent(inout) :: alphar(*),alphai(*),beta(*),work(*)
               end subroutine dlaqz0
#else 
               module procedure stdlib_dlaqz0
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqz0

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               recursive subroutine slaqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, &
                         alphar, alphai, beta,q, ldq, z, ldz, work, lwork, rec,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: wants,wantq,wantz
                    integer(ilp), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,rec
                    integer(ilp), intent(out) :: info
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    real(sp), intent(inout) :: alphar(*),alphai(*),beta(*),work(*)
               end subroutine slaqz0
#else 
               module procedure stdlib_slaqz0
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqz0

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               recursive subroutine zlaqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, &
                         alpha, beta, q, ldq, z,ldz, work, lwork, rwork, rec,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: wants,wantq,wantz
                    integer(ilp), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,rec
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    complex(dp), intent(inout) :: alpha(*),beta(*),work(*)
                    real(dp), intent(out) :: rwork(*)
               end subroutine zlaqz0
#else 
               module procedure stdlib_zlaqz0
#endif
          end interface laqz0



          interface laqz1
          !! LAQZ1 chases a 1x1 shift bulge in a matrix pencil down a single position
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claqz1( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, &
                         qstart, q, ldq, nz, zstart, z, ldz )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: ilq,ilz
                    integer(ilp), intent(in) :: k,lda,ldb,ldq,ldz,istartm,istopm,nq,nz,qstart,&
                              zstart,ihi
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine claqz1
#else 
               module procedure stdlib_claqz1
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqz1( a, lda, b, ldb, sr1, sr2, si, beta1, beta2,v )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: lda,ldb
                    real(dp), intent(in) :: a(lda,*),b(ldb,*),sr1,sr2,si,beta1,beta2
                    real(dp), intent(out) :: v(*)
               end subroutine dlaqz1
#else 
               module procedure stdlib_dlaqz1
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqz1

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqz1( a, lda, b, ldb, sr1, sr2, si, beta1, beta2,v )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: lda,ldb
                    real(sp), intent(in) :: a(lda,*),b(ldb,*),sr1,sr2,si,beta1,beta2
                    real(sp), intent(out) :: v(*)
               end subroutine slaqz1
#else 
               module procedure stdlib_slaqz1
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqz1

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaqz1( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, &
                         qstart, q, ldq, nz, zstart, z, ldz )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: ilq,ilz
                    integer(ilp), intent(in) :: k,lda,ldb,ldq,ldz,istartm,istopm,nq,nz,qstart,&
                              zstart,ihi
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine zlaqz1
#else 
               module procedure stdlib_zlaqz1
#endif
          end interface laqz1



          interface laqz4
          !! LAQZ4 Executes a single multishift QZ sweep
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaqz4( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, sr,&
                si, ss, a, lda, b, ldb, q,ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork,info )
                          
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: ilschur,ilq,ilz
                    integer(ilp), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,nshifts,&
                              nblock_desired,ldqc,ldzc
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*),qc(ldqc,*),zc(&
                              ldzc,*)
                    real(dp), intent(inout) :: work(*)
                    real(dp), intent(inout) :: sr(*),si(*),ss(*)
                    integer(ilp), intent(out) :: info
               end subroutine dlaqz4
#else 
               module procedure stdlib_dlaqz4
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laqz4

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaqz4( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, sr,&
                si, ss, a, lda, b, ldb, q,ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork,info )
                          
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: ilschur,ilq,ilz
                    integer(ilp), intent(in) :: n,ilo,ihi,lda,ldb,ldq,ldz,lwork,nshifts,&
                              nblock_desired,ldqc,ldzc
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*),qc(ldqc,*),zc(&
                              ldzc,*)
                    real(sp), intent(inout) :: work(*)
                    real(sp), intent(inout) :: sr(*),si(*),ss(*)
                    integer(ilp), intent(out) :: info
               end subroutine slaqz4
#else 
               module procedure stdlib_slaqz4
#endif
          end interface laqz4



          interface lar1v
          !! LAR1V computes the (scaled) r-th column of the inverse of
          !! the sumbmatrix in rows B1 through BN of the tridiagonal matrix
          !! L D L**T - sigma I. When sigma is close to an eigenvalue, the
          !! computed vector is an accurate eigenvector. Usually, r corresponds
          !! to the index where the eigenvector is largest in magnitude.
          !! The following steps accomplish this computation :
          !! (a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,
          !! (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
          !! (c) Computation of the diagonal elements of the inverse of
          !! L D L**T - sigma I by combining the above transforms, and choosing
          !! r as the index where the diagonal of the inverse is (one of the)
          !! largest in magnitude.
          !! (d) Computation of the (scaled) r-th column of the inverse using the
          !! twisted factorization obtained by combining the top part of the
          !! the stationary and the bottom part of the progressive transform.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc,&
                          negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: wantnc
                    integer(ilp), intent(in) :: b1,bn,n
                    integer(ilp), intent(out) :: negcnt,isuppz(*)
                    integer(ilp), intent(inout) :: r
                    real(sp), intent(in) :: gaptol,lambda,pivmin,d(*),l(*),ld(*),lld(*)
                    real(sp), intent(out) :: mingma,nrminv,resid,rqcorr,ztz,work(*)
                    complex(sp), intent(inout) :: z(*)
               end subroutine clar1v
#else 
               module procedure stdlib_clar1v
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc,&
                          negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: wantnc
                    integer(ilp), intent(in) :: b1,bn,n
                    integer(ilp), intent(out) :: negcnt,isuppz(*)
                    integer(ilp), intent(inout) :: r
                    real(dp), intent(in) :: gaptol,lambda,pivmin,d(*),l(*),ld(*),lld(*)
                    real(dp), intent(out) :: mingma,nrminv,resid,rqcorr,ztz,work(*)
                    real(dp), intent(inout) :: z(*)
               end subroutine dlar1v
#else 
               module procedure stdlib_dlar1v
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lar1v

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc,&
                          negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: wantnc
                    integer(ilp), intent(in) :: b1,bn,n
                    integer(ilp), intent(out) :: negcnt,isuppz(*)
                    integer(ilp), intent(inout) :: r
                    real(sp), intent(in) :: gaptol,lambda,pivmin,d(*),l(*),ld(*),lld(*)
                    real(sp), intent(out) :: mingma,nrminv,resid,rqcorr,ztz,work(*)
                    real(sp), intent(inout) :: z(*)
               end subroutine slar1v
#else 
               module procedure stdlib_slar1v
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lar1v

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc,&
                          negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: wantnc
                    integer(ilp), intent(in) :: b1,bn,n
                    integer(ilp), intent(out) :: negcnt,isuppz(*)
                    integer(ilp), intent(inout) :: r
                    real(dp), intent(in) :: gaptol,lambda,pivmin,d(*),l(*),ld(*),lld(*)
                    real(dp), intent(out) :: mingma,nrminv,resid,rqcorr,ztz,work(*)
                    complex(dp), intent(inout) :: z(*)
               end subroutine zlar1v
#else 
               module procedure stdlib_zlar1v
#endif
          end interface lar1v



          interface lar2v
          !! LAR2V applies a vector of complex plane rotations with real cosines
          !! from both sides to a sequence of 2-by-2 complex Hermitian matrices,
          !! defined by the elements of the vectors x, y and z. For i = 1,2,...,n
          !! (       x(i)  z(i) ) :=
          !! ( conjg(z(i)) y(i) )
          !! (  c(i) conjg(s(i)) ) (       x(i)  z(i) ) ( c(i) -conjg(s(i)) )
          !! ( -s(i)       c(i)  ) ( conjg(z(i)) y(i) ) ( s(i)        c(i)  )
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clar2v( n, x, y, z, incx, c, s, incc )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incc,incx,n
                    real(sp), intent(in) :: c(*)
                    complex(sp), intent(in) :: s(*)
                    complex(sp), intent(inout) :: x(*),y(*),z(*)
               end subroutine clar2v
#else 
               module procedure stdlib_clar2v
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlar2v( n, x, y, z, incx, c, s, incc )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incc,incx,n
                    real(dp), intent(in) :: c(*),s(*)
                    real(dp), intent(inout) :: x(*),y(*),z(*)
               end subroutine dlar2v
#else 
               module procedure stdlib_dlar2v
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lar2v

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slar2v( n, x, y, z, incx, c, s, incc )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incc,incx,n
                    real(sp), intent(in) :: c(*),s(*)
                    real(sp), intent(inout) :: x(*),y(*),z(*)
               end subroutine slar2v
#else 
               module procedure stdlib_slar2v
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lar2v

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlar2v( n, x, y, z, incx, c, s, incc )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incc,incx,n
                    real(dp), intent(in) :: c(*)
                    complex(dp), intent(in) :: s(*)
                    complex(dp), intent(inout) :: x(*),y(*),z(*)
               end subroutine zlar2v
#else 
               module procedure stdlib_zlar2v
#endif
          end interface lar2v



          interface larcm
          !! LARCM performs a very simple matrix-matrix multiplication:
          !! C := A * B,
          !! where A is M by M and real; B is M by N and complex;
          !! C is M by N and complex.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarcm( m, n, a, lda, b, ldb, c, ldc, rwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: lda,ldb,ldc,m,n
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(in) :: b(ldb,*)
                    complex(sp), intent(out) :: c(ldc,*)
               end subroutine clarcm
#else 
               module procedure stdlib_clarcm
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larcm

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarcm( m, n, a, lda, b, ldb, c, ldc, rwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: lda,ldb,ldc,m,n
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(in) :: b(ldb,*)
                    complex(dp), intent(out) :: c(ldc,*)
               end subroutine zlarcm
#else 
               module procedure stdlib_zlarcm
#endif
          end interface larcm



          interface larf
          !! LARF applies a complex elementary reflector H to a complex M-by-N
          !! matrix C, from either the left or the right. H is represented in the
          !! form
          !! H = I - tau * v * v**H
          !! where tau is a complex scalar and v is a complex vector.
          !! If tau = 0, then H is taken to be the unit matrix.
          !! To apply H**H (the conjugate transpose of H), supply conjg(tau) instead
          !! tau.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarf( side, m, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side
                    integer(ilp), intent(in) :: incv,ldc,m,n
                    complex(sp), intent(in) :: tau,v(*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clarf
#else 
               module procedure stdlib_clarf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarf( side, m, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side
                    integer(ilp), intent(in) :: incv,ldc,m,n
                    real(dp), intent(in) :: tau,v(*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlarf
#else 
               module procedure stdlib_dlarf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarf( side, m, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side
                    integer(ilp), intent(in) :: incv,ldc,m,n
                    real(sp), intent(in) :: tau,v(*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slarf
#else 
               module procedure stdlib_slarf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarf( side, m, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side
                    integer(ilp), intent(in) :: incv,ldc,m,n
                    complex(dp), intent(in) :: tau,v(*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlarf
#else 
               module procedure stdlib_zlarf
#endif
          end interface larf



          interface larfb
          !! LARFB applies a complex block reflector H or its transpose H**H to a
          !! complex M-by-N matrix C, from either the left or the right.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarfb( side, trans, direct, storev, m, n, k, v, ldv,t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,ldc,ldt,ldv,ldwork,m,n
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(in) :: t(ldt,*),v(ldv,*)
                    complex(sp), intent(out) :: work(ldwork,*)
               end subroutine clarfb
#else 
               module procedure stdlib_clarfb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarfb( side, trans, direct, storev, m, n, k, v, ldv,t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,ldc,ldt,ldv,ldwork,m,n
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(in) :: t(ldt,*),v(ldv,*)
                    real(dp), intent(out) :: work(ldwork,*)
               end subroutine dlarfb
#else 
               module procedure stdlib_dlarfb
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larfb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarfb( side, trans, direct, storev, m, n, k, v, ldv,t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,ldc,ldt,ldv,ldwork,m,n
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(in) :: t(ldt,*),v(ldv,*)
                    real(sp), intent(out) :: work(ldwork,*)
               end subroutine slarfb
#else 
               module procedure stdlib_slarfb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larfb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarfb( side, trans, direct, storev, m, n, k, v, ldv,t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,ldc,ldt,ldv,ldwork,m,n
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(in) :: t(ldt,*),v(ldv,*)
                    complex(dp), intent(out) :: work(ldwork,*)
               end subroutine zlarfb
#else 
               module procedure stdlib_zlarfb
#endif
          end interface larfb



          interface larfb_gett
          !! LARFB_GETT applies a complex Householder block reflector H from the
          !! left to a complex (K+M)-by-N  "triangular-pentagonal" matrix
          !! composed of two block matrices: an upper trapezoidal K-by-N matrix A
          !! stored in the array A, and a rectangular M-by-(N-K) matrix B, stored
          !! in the array B. The block reflector H is stored in a compact
          !! WY-representation, where the elementary reflectors are in the
          !! arrays A, B and T. See Further Details section.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarfb_gett( ident, m, n, k, t, ldt, a, lda, b, ldb,work, ldwork )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: ident
                    integer(ilp), intent(in) :: k,lda,ldb,ldt,ldwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(in) :: t(ldt,*)
                    complex(sp), intent(out) :: work(ldwork,*)
               end subroutine clarfb_gett
#else 
               module procedure stdlib_clarfb_gett
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarfb_gett( ident, m, n, k, t, ldt, a, lda, b, ldb,work, ldwork )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: ident
                    integer(ilp), intent(in) :: k,lda,ldb,ldt,ldwork,m,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(in) :: t(ldt,*)
                    real(dp), intent(out) :: work(ldwork,*)
               end subroutine dlarfb_gett
#else 
               module procedure stdlib_dlarfb_gett
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larfb_gett

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarfb_gett( ident, m, n, k, t, ldt, a, lda, b, ldb,work, ldwork )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: ident
                    integer(ilp), intent(in) :: k,lda,ldb,ldt,ldwork,m,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(in) :: t(ldt,*)
                    real(sp), intent(out) :: work(ldwork,*)
               end subroutine slarfb_gett
#else 
               module procedure stdlib_slarfb_gett
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larfb_gett

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarfb_gett( ident, m, n, k, t, ldt, a, lda, b, ldb,work, ldwork )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: ident
                    integer(ilp), intent(in) :: k,lda,ldb,ldt,ldwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(in) :: t(ldt,*)
                    complex(dp), intent(out) :: work(ldwork,*)
               end subroutine zlarfb_gett
#else 
               module procedure stdlib_zlarfb_gett
#endif
          end interface larfb_gett



          interface larfg
          !! LARFG generates a complex elementary reflector H of order n, such
          !! that
          !! H**H * ( alpha ) = ( beta ),   H**H * H = I.
          !! (   x   )   (   0  )
          !! where alpha and beta are scalars, with beta real, and x is an
          !! (n-1)-element complex vector. H is represented in the form
          !! H = I - tau * ( 1 ) * ( 1 v**H ) ,
          !! ( v )
          !! where tau is a complex scalar and v is a complex (n-1)-element
          !! vector. Note that H is not hermitian.
          !! If the elements of x are all zero and alpha is real, then tau = 0
          !! and H is taken to be the unit matrix.
          !! Otherwise  1 <= real(tau) <= 2  and  abs(tau-1) <= 1 .
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarfg( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,n
                    complex(sp), intent(inout) :: alpha,x(*)
                    complex(sp), intent(out) :: tau
               end subroutine clarfg
#else 
               module procedure stdlib_clarfg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarfg( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,n
                    real(dp), intent(inout) :: alpha,x(*)
                    real(dp), intent(out) :: tau
               end subroutine dlarfg
#else 
               module procedure stdlib_dlarfg
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larfg

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarfg( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,n
                    real(sp), intent(inout) :: alpha,x(*)
                    real(sp), intent(out) :: tau
               end subroutine slarfg
#else 
               module procedure stdlib_slarfg
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larfg

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarfg( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,n
                    complex(dp), intent(inout) :: alpha,x(*)
                    complex(dp), intent(out) :: tau
               end subroutine zlarfg
#else 
               module procedure stdlib_zlarfg
#endif
          end interface larfg



          interface larfgp
          !! LARFGP generates a complex elementary reflector H of order n, such
          !! that
          !! H**H * ( alpha ) = ( beta ),   H**H * H = I.
          !! (   x   )   (   0  )
          !! where alpha and beta are scalars, beta is real and non-negative, and
          !! x is an (n-1)-element complex vector.  H is represented in the form
          !! H = I - tau * ( 1 ) * ( 1 v**H ) ,
          !! ( v )
          !! where tau is a complex scalar and v is a complex (n-1)-element
          !! vector. Note that H is not hermitian.
          !! If the elements of x are all zero and alpha is real, then tau = 0
          !! and H is taken to be the unit matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine clarfgp( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,n
                    complex(sp), intent(inout) :: alpha,x(*)
                    complex(sp), intent(out) :: tau
               end subroutine clarfgp
#else 
               module procedure stdlib_clarfgp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dlarfgp( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,n
                    real(dp), intent(inout) :: alpha,x(*)
                    real(dp), intent(out) :: tau
               end subroutine dlarfgp
#else 
               module procedure stdlib_dlarfgp
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larfgp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine slarfgp( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,n
                    real(sp), intent(inout) :: alpha,x(*)
                    real(sp), intent(out) :: tau
               end subroutine slarfgp
#else 
               module procedure stdlib_slarfgp
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larfgp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zlarfgp( n, alpha, x, incx, tau )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,n
                    complex(dp), intent(inout) :: alpha,x(*)
                    complex(dp), intent(out) :: tau
               end subroutine zlarfgp
#else 
               module procedure stdlib_zlarfgp
#endif
          end interface larfgp



          interface larft
          !! LARFT forms the triangular factor T of a complex block reflector H
          !! of order n, which is defined as a product of k elementary reflectors.
          !! If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
          !! If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
          !! If STOREV = 'C', the vector which defines the elementary reflector
          !! H(i) is stored in the i-th column of the array V, and
          !! H  =  I - V * T * V**H
          !! If STOREV = 'R', the vector which defines the elementary reflector
          !! H(i) is stored in the i-th row of the array V, and
          !! H  =  I - V**H * T * V
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarft( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,storev
                    integer(ilp), intent(in) :: k,ldt,ldv,n
                    complex(sp), intent(out) :: t(ldt,*)
                    complex(sp), intent(in) :: tau(*),v(ldv,*)
               end subroutine clarft
#else 
               module procedure stdlib_clarft
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarft( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,storev
                    integer(ilp), intent(in) :: k,ldt,ldv,n
                    real(dp), intent(out) :: t(ldt,*)
                    real(dp), intent(in) :: tau(*),v(ldv,*)
               end subroutine dlarft
#else 
               module procedure stdlib_dlarft
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larft

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarft( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,storev
                    integer(ilp), intent(in) :: k,ldt,ldv,n
                    real(sp), intent(out) :: t(ldt,*)
                    real(sp), intent(in) :: tau(*),v(ldv,*)
               end subroutine slarft
#else 
               module procedure stdlib_slarft
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larft

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarft( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,storev
                    integer(ilp), intent(in) :: k,ldt,ldv,n
                    complex(dp), intent(out) :: t(ldt,*)
                    complex(dp), intent(in) :: tau(*),v(ldv,*)
               end subroutine zlarft
#else 
               module procedure stdlib_zlarft
#endif
          end interface larft



          interface larfy
          !! LARFY applies an elementary reflector, or Householder matrix, H,
          !! to an n x n Hermitian matrix C, from both the left and the right.
          !! H is represented in the form
          !! H = I - tau * v * v'
          !! where  tau  is a scalar and  v  is a vector.
          !! If  tau  is  zero, then  H  is taken to be the unit matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarfy( uplo, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incv,ldc,n
                    complex(sp), intent(in) :: tau,v(*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clarfy
#else 
               module procedure stdlib_clarfy
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarfy( uplo, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incv,ldc,n
                    real(dp), intent(in) :: tau,v(*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlarfy
#else 
               module procedure stdlib_dlarfy
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larfy

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarfy( uplo, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incv,ldc,n
                    real(sp), intent(in) :: tau,v(*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slarfy
#else 
               module procedure stdlib_slarfy
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larfy

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarfy( uplo, n, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incv,ldc,n
                    complex(dp), intent(in) :: tau,v(*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlarfy
#else 
               module procedure stdlib_zlarfy
#endif
          end interface larfy



          interface largv
          !! LARGV generates a vector of complex plane rotations with real
          !! cosines, determined by elements of the complex vectors x and y.
          !! For i = 1,2,...,n
          !! (        c(i)   s(i) ) ( x(i) ) = ( r(i) )
          !! ( -conjg(s(i))  c(i) ) ( y(i) ) = (   0  )
          !! where c(i)**2 + ABS(s(i))**2 = 1
          !! The following conventions are used (these are the same as in CLARTG,
          !! but differ from the BLAS1 routine CROTG):
          !! If y(i)=0, then c(i)=1 and s(i)=0.
          !! If x(i)=0, then c(i)=0 and s(i) is chosen so that r(i) is real.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clargv( n, x, incx, y, incy, c, incc )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incc,incx,incy,n
                    real(sp), intent(out) :: c(*)
                    complex(sp), intent(inout) :: x(*),y(*)
               end subroutine clargv
#else 
               module procedure stdlib_clargv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlargv( n, x, incx, y, incy, c, incc )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incc,incx,incy,n
                    real(dp), intent(out) :: c(*)
                    real(dp), intent(inout) :: x(*),y(*)
               end subroutine dlargv
#else 
               module procedure stdlib_dlargv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$largv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slargv( n, x, incx, y, incy, c, incc )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incc,incx,incy,n
                    real(sp), intent(out) :: c(*)
                    real(sp), intent(inout) :: x(*),y(*)
               end subroutine slargv
#else 
               module procedure stdlib_slargv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$largv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlargv( n, x, incx, y, incy, c, incc )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incc,incx,incy,n
                    real(dp), intent(out) :: c(*)
                    complex(dp), intent(inout) :: x(*),y(*)
               end subroutine zlargv
#else 
               module procedure stdlib_zlargv
#endif
          end interface largv



          interface larnv
          !! LARNV returns a vector of n random complex numbers from a uniform or
          !! normal distribution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarnv( idist, iseed, n, x )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: idist,n
                    integer(ilp), intent(inout) :: iseed(4)
                    complex(sp), intent(out) :: x(*)
               end subroutine clarnv
#else 
               module procedure stdlib_clarnv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarnv( idist, iseed, n, x )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: idist,n
                    integer(ilp), intent(inout) :: iseed(4)
                    real(dp), intent(out) :: x(*)
               end subroutine dlarnv
#else 
               module procedure stdlib_dlarnv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larnv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarnv( idist, iseed, n, x )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: idist,n
                    integer(ilp), intent(inout) :: iseed(4)
                    real(sp), intent(out) :: x(*)
               end subroutine slarnv
#else 
               module procedure stdlib_slarnv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larnv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarnv( idist, iseed, n, x )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: idist,n
                    integer(ilp), intent(inout) :: iseed(4)
                    complex(dp), intent(out) :: x(*)
               end subroutine zlarnv
#else 
               module procedure stdlib_zlarnv
#endif
          end interface larnv



          interface larra
          !! Compute the splitting points with threshold SPLTOL.
          !! LARRA sets any "small" off-diagonal elements to zero.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarra( n, d, e, e2, spltol, tnrm,nsplit, isplit, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,nsplit,isplit(*)
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: spltol,tnrm,d(*)
                    real(dp), intent(inout) :: e(*),e2(*)
               end subroutine dlarra
#else 
               module procedure stdlib_dlarra
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larra

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarra( n, d, e, e2, spltol, tnrm,nsplit, isplit, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,nsplit,isplit(*)
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: spltol,tnrm,d(*)
                    real(sp), intent(inout) :: e(*),e2(*)
               end subroutine slarra
#else 
               module procedure stdlib_slarra
#endif
          end interface larra



          interface larrb
          !! Given the relatively robust representation(RRR) L D L^T, LARRB:
          !! does "limited" bisection to refine the eigenvalues of L D L^T,
          !! W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
          !! guesses for these eigenvalues are input in W, the corresponding estimate
          !! of the error in these guesses and their gaps are input in WERR
          !! and WGAP, respectively. During bisection, intervals
          !! [left, right] are maintained by storing their mid-points and
          !! semi-widths in the arrays W and WERR respectively.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarrb( n, d, lld, ifirst, ilast, rtol1,rtol2, offset, w, wgap, &
                         werr, work, iwork,pivmin, spdiam, twist, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ifirst,ilast,n,offset,twist
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: pivmin,rtol1,rtol2,spdiam,d(*),lld(*)
                    real(dp), intent(inout) :: w(*),werr(*),wgap(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlarrb
#else 
               module procedure stdlib_dlarrb
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larrb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarrb( n, d, lld, ifirst, ilast, rtol1,rtol2, offset, w, wgap, &
                         werr, work, iwork,pivmin, spdiam, twist, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ifirst,ilast,n,offset,twist
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: pivmin,rtol1,rtol2,spdiam,d(*),lld(*)
                    real(sp), intent(inout) :: w(*),werr(*),wgap(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slarrb
#else 
               module procedure stdlib_slarrb
#endif
          end interface larrb



          interface larrc
          !! Find the number of eigenvalues of the symmetric tridiagonal matrix T
          !! that are in the interval (VL,VU] if JOBT = 'T', and of L D L^T
          !! if JOBT = 'L'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarrc( jobt, n, vl, vu, d, e, pivmin,eigcnt, lcnt, rcnt, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobt
                    integer(ilp), intent(out) :: eigcnt,info,lcnt,rcnt
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: pivmin,vl,vu,d(*),e(*)
               end subroutine dlarrc
#else 
               module procedure stdlib_dlarrc
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larrc

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarrc( jobt, n, vl, vu, d, e, pivmin,eigcnt, lcnt, rcnt, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobt
                    integer(ilp), intent(out) :: eigcnt,info,lcnt,rcnt
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: pivmin,vl,vu,d(*),e(*)
               end subroutine slarrc
#else 
               module procedure stdlib_slarrc
#endif
          end interface larrc



          interface larrd
          !! LARRD computes the eigenvalues of a symmetric tridiagonal
          !! matrix T to suitable accuracy. This is an auxiliary code to be
          !! called from DSTEMR.
          !! The user may ask for all eigenvalues, all eigenvalues
          !! in the half-open interval (VL, VU], or the IL-th through IU-th
          !! eigenvalues.
          !! To avoid overflow, the matrix must be scaled so that its
          !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
          !! accuracy, it should not be much smaller than that.
          !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
          !! Matrix", Report CS41, Computer Science Dept., Stanford
          !! University, July 21, 1966.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarrd( range, order, n, vl, vu, il, iu, gers,reltol, d, e, e2, &
               pivmin, nsplit, isplit,m, w, werr, wl, wu, iblock, indexw,work, iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: order,range
                    integer(ilp), intent(in) :: il,iu,n,nsplit,isplit(*)
                    integer(ilp), intent(out) :: info,m,iblock(*),indexw(*),iwork(*)
                    real(dp), intent(in) :: pivmin,reltol,vl,vu,d(*),e(*),e2(*),gers(*)
                    real(dp), intent(out) :: wl,wu,w(*),werr(*),work(*)
               end subroutine dlarrd
#else 
               module procedure stdlib_dlarrd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarrd( range, order, n, vl, vu, il, iu, gers,reltol, d, e, e2, &
               pivmin, nsplit, isplit,m, w, werr, wl, wu, iblock, indexw,work, iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: order,range
                    integer(ilp), intent(in) :: il,iu,n,nsplit,isplit(*)
                    integer(ilp), intent(out) :: info,m,iblock(*),indexw(*),iwork(*)
                    real(sp), intent(in) :: pivmin,reltol,vl,vu,d(*),e(*),e2(*),gers(*)
                    real(sp), intent(out) :: wl,wu,w(*),werr(*),work(*)
               end subroutine slarrd
#else 
               module procedure stdlib_slarrd
#endif
          end interface larrd



          interface larre
          !! To find the desired eigenvalues of a given real symmetric
          !! tridiagonal matrix T, LARRE: sets any "small" off-diagonal
          !! elements to zero, and for each unreduced block T_i, it finds
          !! (a) a suitable shift at one end of the block's spectrum,
          !! (b) the base representation, T_i - sigma_i I = L_i D_i L_i^T, and
          !! (c) eigenvalues of each L_i D_i L_i^T.
          !! The representations and eigenvalues found are then used by
          !! DSTEMR to compute the eigenvectors of T.
          !! The accuracy varies depending on whether bisection is used to
          !! find a few eigenvalues or the dqds algorithm (subroutine DLASQ2) to
          !! conpute all and then discard any unwanted one.
          !! As an added benefit, LARRE also outputs the n
          !! Gerschgorin intervals for the matrices L_i D_i L_i^T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarre( range, n, vl, vu, il, iu, d, e, e2,rtol1, rtol2, spltol, &
               nsplit, isplit, m,w, werr, wgap, iblock, indexw, gers, pivmin,work, iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: range
                    integer(ilp), intent(in) :: il,iu,n
                    integer(ilp), intent(out) :: info,m,nsplit,iblock(*),isplit(*),iwork(*),&
                              indexw(*)
                    real(dp), intent(out) :: pivmin,gers(*),w(*),werr(*),wgap(*),work(*)
                    real(dp), intent(in) :: rtol1,rtol2,spltol
                    real(dp), intent(inout) :: vl,vu,d(*),e(*),e2(*)
               end subroutine dlarre
#else 
               module procedure stdlib_dlarre
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larre

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarre( range, n, vl, vu, il, iu, d, e, e2,rtol1, rtol2, spltol, &
               nsplit, isplit, m,w, werr, wgap, iblock, indexw, gers, pivmin,work, iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: range
                    integer(ilp), intent(in) :: il,iu,n
                    integer(ilp), intent(out) :: info,m,nsplit,iblock(*),isplit(*),iwork(*),&
                              indexw(*)
                    real(sp), intent(out) :: pivmin,gers(*),w(*),werr(*),wgap(*),work(*)
                    real(sp), intent(in) :: rtol1,rtol2,spltol
                    real(sp), intent(inout) :: vl,vu,d(*),e(*),e2(*)
               end subroutine slarre
#else 
               module procedure stdlib_slarre
#endif
          end interface larre



          interface larrf
          !! Given the initial representation L D L^T and its cluster of close
          !! eigenvalues (in a relative measure), W( CLSTRT ), W( CLSTRT+1 ), ...
          !! W( CLEND ), LARRF: finds a new relatively robust representation
          !! L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the
          !! eigenvalues of L(+) D(+) L(+)^T is relatively isolated.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarrf( n, d, l, ld, clstrt, clend,w, wgap, werr,spdiam, clgapl, &
                         clgapr, pivmin, sigma,dplus, lplus, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: clstrt,clend,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: clgapl,clgapr,pivmin,spdiam,d(*),l(*),ld(*),w(*),werr(&
                              *)
                    real(dp), intent(out) :: sigma,dplus(*),lplus(*),work(*)
                    real(dp), intent(inout) :: wgap(*)
               end subroutine dlarrf
#else 
               module procedure stdlib_dlarrf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarrf( n, d, l, ld, clstrt, clend,w, wgap, werr,spdiam, clgapl, &
                         clgapr, pivmin, sigma,dplus, lplus, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: clstrt,clend,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: clgapl,clgapr,pivmin,spdiam,d(*),l(*),ld(*),w(*),werr(&
                              *)
                    real(sp), intent(out) :: sigma,dplus(*),lplus(*),work(*)
                    real(sp), intent(inout) :: wgap(*)
               end subroutine slarrf
#else 
               module procedure stdlib_slarrf
#endif
          end interface larrf



          interface larrj
          !! Given the initial eigenvalue approximations of T, LARRJ:
          !! does  bisection to refine the eigenvalues of T,
          !! W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
          !! guesses for these eigenvalues are input in W, the corresponding estimate
          !! of the error in these guesses in WERR. During bisection, intervals
          !! [left, right] are maintained by storing their mid-points and
          !! semi-widths in the arrays W and WERR respectively.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarrj( n, d, e2, ifirst, ilast,rtol, offset, w, werr, work, iwork,&
                         pivmin, spdiam, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ifirst,ilast,n,offset
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(in) :: pivmin,rtol,spdiam,d(*),e2(*)
                    real(dp), intent(inout) :: w(*),werr(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlarrj
#else 
               module procedure stdlib_dlarrj
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larrj

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarrj( n, d, e2, ifirst, ilast,rtol, offset, w, werr, work, iwork,&
                         pivmin, spdiam, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ifirst,ilast,n,offset
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(in) :: pivmin,rtol,spdiam,d(*),e2(*)
                    real(sp), intent(inout) :: w(*),werr(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slarrj
#else 
               module procedure stdlib_slarrj
#endif
          end interface larrj



          interface larrk
          !! LARRK computes one eigenvalue of a symmetric tridiagonal
          !! matrix T to suitable accuracy. This is an auxiliary code to be
          !! called from DSTEMR.
          !! To avoid overflow, the matrix must be scaled so that its
          !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
          !! accuracy, it should not be much smaller than that.
          !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
          !! Matrix", Report CS41, Computer Science Dept., Stanford
          !! University, July 21, 1966.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarrk( n, iw, gl, gu,d, e2, pivmin, reltol, w, werr, info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: iw,n
                    real(dp), intent(in) :: pivmin,reltol,gl,gu,d(*),e2(*)
                    real(dp), intent(out) :: w,werr
               end subroutine dlarrk
#else 
               module procedure stdlib_dlarrk
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larrk

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarrk( n, iw, gl, gu,d, e2, pivmin, reltol, w, werr, info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: iw,n
                    real(sp), intent(in) :: pivmin,reltol,gl,gu,d(*),e2(*)
                    real(sp), intent(out) :: w,werr
               end subroutine slarrk
#else 
               module procedure stdlib_slarrk
#endif
          end interface larrk



          interface larrr
          !! Perform tests to decide whether the symmetric tridiagonal matrix T
          !! warrants expensive computations which guarantee high relative accuracy
          !! in the eigenvalues.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarrr( n, d, e, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: d(*)
                    real(dp), intent(inout) :: e(*)
               end subroutine dlarrr
#else 
               module procedure stdlib_dlarrr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larrr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarrr( n, d, e, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: d(*)
                    real(sp), intent(inout) :: e(*)
               end subroutine slarrr
#else 
               module procedure stdlib_slarrr
#endif
          end interface larrr



          interface larrv
          !! LARRV computes the eigenvectors of the tridiagonal matrix
          !! T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.
          !! The input eigenvalues should have been computed by SLARRE.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: dol,dou,ldz,m,n,iblock(*),indexw(*),isplit(*)
                              
                    integer(ilp), intent(out) :: info,isuppz(*),iwork(*)
                    real(sp), intent(in) :: minrgp,pivmin,vl,vu,gers(*)
                    real(sp), intent(inout) :: rtol1,rtol2,d(*),l(*),w(*),werr(*),wgap(*)
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(out) :: z(ldz,*)
               end subroutine clarrv
#else 
               module procedure stdlib_clarrv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: dol,dou,ldz,m,n,iblock(*),indexw(*),isplit(*)
                              
                    integer(ilp), intent(out) :: info,isuppz(*),iwork(*)
                    real(dp), intent(in) :: minrgp,pivmin,vl,vu,gers(*)
                    real(dp), intent(inout) :: rtol1,rtol2,d(*),l(*),w(*),werr(*),wgap(*)
                    real(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine dlarrv
#else 
               module procedure stdlib_dlarrv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larrv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: dol,dou,ldz,m,n,iblock(*),indexw(*),isplit(*)
                              
                    integer(ilp), intent(out) :: info,isuppz(*),iwork(*)
                    real(sp), intent(in) :: minrgp,pivmin,vl,vu,gers(*)
                    real(sp), intent(inout) :: rtol1,rtol2,d(*),l(*),w(*),werr(*),wgap(*)
                    real(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine slarrv
#else 
               module procedure stdlib_slarrv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larrv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: dol,dou,ldz,m,n,iblock(*),indexw(*),isplit(*)
                              
                    integer(ilp), intent(out) :: info,isuppz(*),iwork(*)
                    real(dp), intent(in) :: minrgp,pivmin,vl,vu,gers(*)
                    real(dp), intent(inout) :: rtol1,rtol2,d(*),l(*),w(*),werr(*),wgap(*)
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(out) :: z(ldz,*)
               end subroutine zlarrv
#else 
               module procedure stdlib_zlarrv
#endif
          end interface larrv



          interface lartg
          !! LARTG generates a plane rotation so that
          !! [  C         S  ] . [ F ]  =  [ R ]
          !! [ -conjg(S)  C  ]   [ G ]     [ 0 ]
          !! where C is real and C**2 + |S|**2 = 1.
          !! The mathematical formulas used for C and S are
          !! sgn(x) = {  x / |x|,   x != 0
          !! {  1,         x = 0
          !! R = sgn(F) * sqrt(|F|**2 + |G|**2)
          !! C = |F| / sqrt(|F|**2 + |G|**2)
          !! S = sgn(F) * conjg(G) / sqrt(|F|**2 + |G|**2)
          !! When F and G are real, the formulas simplify to C = F/R and
          !! S = G/R, and the returned values of C, S, and R should be
          !! identical to those returned by LARTG.
          !! The algorithm used to compute these quantities incorporates scaling
          !! to avoid overflow or underflow in computing the square root of the
          !! sum of squares.
          !! This is a faster version of the BLAS1 routine CROTG, except for
          !! the following differences:
          !! F and G are unchanged on return.
          !! If G=0, then C=1 and S=0.
          !! If F=0, then C=0 and S is chosen so that R is real.
          !! Below, wp=>sp stands for single precision from LA_CONSTANTS module.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clartg( f, g, c, s, r )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(out) :: c
                    complex(sp), intent(in) :: f,g
                    complex(sp), intent(out) :: r,s
               end subroutine clartg
#else 
               module procedure stdlib_clartg
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlartg( f, g, c, s, r )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(out) :: c,r,s
                    real(dp), intent(in) :: f,g
               end subroutine dlartg
#else 
               module procedure stdlib_dlartg
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lartg

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slartg( f, g, c, s, r )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(out) :: c,r,s
                    real(sp), intent(in) :: f,g
               end subroutine slartg
#else 
               module procedure stdlib_slartg
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lartg

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlartg( f, g, c, s, r )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(out) :: c
                    complex(dp), intent(in) :: f,g
                    complex(dp), intent(out) :: r,s
               end subroutine zlartg
#else 
               module procedure stdlib_zlartg
#endif
          end interface lartg



          interface lartgp
          !! LARTGP generates a plane rotation so that
          !! [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
          !! [ -SN  CS  ]     [ G ]     [ 0 ]
          !! This is a slower, more accurate version of the Level 1 BLAS routine DROTG,
          !! with the following other differences:
          !! F and G are unchanged on return.
          !! If G=0, then CS=(+/-)1 and SN=0.
          !! If F=0 and (G .ne. 0), then CS=0 and SN=(+/-)1.
          !! The sign is chosen so that R >= 0.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlartgp( f, g, cs, sn, r )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(out) :: cs,r,sn
                    real(dp), intent(in) :: f,g
               end subroutine dlartgp
#else 
               module procedure stdlib_dlartgp
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lartgp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slartgp( f, g, cs, sn, r )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(out) :: cs,r,sn
                    real(sp), intent(in) :: f,g
               end subroutine slartgp
#else 
               module procedure stdlib_slartgp
#endif
          end interface lartgp



          interface lartgs
          !! LARTGS generates a plane rotation designed to introduce a bulge in
          !! Golub-Reinsch-style implicit QR iteration for the bidiagonal SVD
          !! problem. X and Y are the top-row entries, and SIGMA is the shift.
          !! The computed CS and SN define a plane rotation satisfying
          !! [  CS  SN  ]  .  [ X^2 - SIGMA ]  =  [ R ],
          !! [ -SN  CS  ]     [    X * Y    ]     [ 0 ]
          !! with R nonnegative.  If X^2 - SIGMA and X * Y are 0, then the
          !! rotation is by PI/2.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlartgs( x, y, sigma, cs, sn )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(out) :: cs,sn
                    real(dp), intent(in) :: sigma,x,y
               end subroutine dlartgs
#else 
               module procedure stdlib_dlartgs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lartgs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slartgs( x, y, sigma, cs, sn )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(out) :: cs,sn
                    real(sp), intent(in) :: sigma,x,y
               end subroutine slartgs
#else 
               module procedure stdlib_slartgs
#endif
          end interface lartgs



          interface lartv
          !! LARTV applies a vector of complex plane rotations with real cosines
          !! to elements of the complex vectors x and y. For i = 1,2,...,n
          !! ( x(i) ) := (        c(i)   s(i) ) ( x(i) )
          !! ( y(i) )    ( -conjg(s(i))  c(i) ) ( y(i) )
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clartv( n, x, incx, y, incy, c, s, incc )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incc,incx,incy,n
                    real(sp), intent(in) :: c(*)
                    complex(sp), intent(in) :: s(*)
                    complex(sp), intent(inout) :: x(*),y(*)
               end subroutine clartv
#else 
               module procedure stdlib_clartv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlartv( n, x, incx, y, incy, c, s, incc )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incc,incx,incy,n
                    real(dp), intent(in) :: c(*),s(*)
                    real(dp), intent(inout) :: x(*),y(*)
               end subroutine dlartv
#else 
               module procedure stdlib_dlartv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lartv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slartv( n, x, incx, y, incy, c, s, incc )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incc,incx,incy,n
                    real(sp), intent(in) :: c(*),s(*)
                    real(sp), intent(inout) :: x(*),y(*)
               end subroutine slartv
#else 
               module procedure stdlib_slartv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lartv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlartv( n, x, incx, y, incy, c, s, incc )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incc,incx,incy,n
                    real(dp), intent(in) :: c(*)
                    complex(dp), intent(in) :: s(*)
                    complex(dp), intent(inout) :: x(*),y(*)
               end subroutine zlartv
#else 
               module procedure stdlib_zlartv
#endif
          end interface lartv



          interface laruv
          !! LARUV returns a vector of n random real numbers from a uniform (0,1)
          !! distribution (n <= 128).
          !! This is an auxiliary routine called by DLARNV and ZLARNV.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaruv( iseed, n, x )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n
                    integer(ilp), intent(inout) :: iseed(4)
                    real(dp), intent(out) :: x(n)
               end subroutine dlaruv
#else 
               module procedure stdlib_dlaruv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laruv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaruv( iseed, n, x )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: n
                    integer(ilp), intent(inout) :: iseed(4)
                    real(sp), intent(out) :: x(n)
               end subroutine slaruv
#else 
               module procedure stdlib_slaruv
#endif
          end interface laruv



          interface larz
          !! LARZ applies a complex elementary reflector H to a complex
          !! M-by-N matrix C, from either the left or the right. H is represented
          !! in the form
          !! H = I - tau * v * v**H
          !! where tau is a complex scalar and v is a complex vector.
          !! If tau = 0, then H is taken to be the unit matrix.
          !! To apply H**H (the conjugate transpose of H), supply conjg(tau) instead
          !! tau.
          !! H is a product of k elementary reflectors as returned by CTZRZF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarz( side, m, n, l, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side
                    integer(ilp), intent(in) :: incv,l,ldc,m,n
                    complex(sp), intent(in) :: tau,v(*)
                    complex(sp), intent(inout) :: c(ldc,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clarz
#else 
               module procedure stdlib_clarz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarz( side, m, n, l, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side
                    integer(ilp), intent(in) :: incv,l,ldc,m,n
                    real(dp), intent(in) :: tau,v(*)
                    real(dp), intent(inout) :: c(ldc,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlarz
#else 
               module procedure stdlib_dlarz
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larz

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarz( side, m, n, l, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side
                    integer(ilp), intent(in) :: incv,l,ldc,m,n
                    real(sp), intent(in) :: tau,v(*)
                    real(sp), intent(inout) :: c(ldc,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slarz
#else 
               module procedure stdlib_slarz
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larz

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarz( side, m, n, l, v, incv, tau, c, ldc, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side
                    integer(ilp), intent(in) :: incv,l,ldc,m,n
                    complex(dp), intent(in) :: tau,v(*)
                    complex(dp), intent(inout) :: c(ldc,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlarz
#else 
               module procedure stdlib_zlarz
#endif
          end interface larz



          interface larzb
          !! LARZB applies a complex block reflector H or its transpose H**H
          !! to a complex distributed M-by-N  C from the left or the right.
          !! Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarzb( side, trans, direct, storev, m, n, k, l, v,ldv, t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,l,ldc,ldt,ldv,ldwork,m,n
                    complex(sp), intent(inout) :: c(ldc,*),t(ldt,*),v(ldv,*)
                    complex(sp), intent(out) :: work(ldwork,*)
               end subroutine clarzb
#else 
               module procedure stdlib_clarzb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarzb( side, trans, direct, storev, m, n, k, l, v,ldv, t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,l,ldc,ldt,ldv,ldwork,m,n
                    real(dp), intent(inout) :: c(ldc,*),t(ldt,*),v(ldv,*)
                    real(dp), intent(out) :: work(ldwork,*)
               end subroutine dlarzb
#else 
               module procedure stdlib_dlarzb
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larzb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarzb( side, trans, direct, storev, m, n, k, l, v,ldv, t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,l,ldc,ldt,ldv,ldwork,m,n
                    real(sp), intent(inout) :: c(ldc,*),t(ldt,*),v(ldv,*)
                    real(sp), intent(out) :: work(ldwork,*)
               end subroutine slarzb
#else 
               module procedure stdlib_slarzb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larzb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarzb( side, trans, direct, storev, m, n, k, l, v,ldv, t, ldt, c, &
                         ldc, work, ldwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,l,ldc,ldt,ldv,ldwork,m,n
                    complex(dp), intent(inout) :: c(ldc,*),t(ldt,*),v(ldv,*)
                    complex(dp), intent(out) :: work(ldwork,*)
               end subroutine zlarzb
#else 
               module procedure stdlib_zlarzb
#endif
          end interface larzb



          interface larzt
          !! LARZT forms the triangular factor T of a complex block reflector
          !! H of order > n, which is defined as a product of k elementary
          !! reflectors.
          !! If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
          !! If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
          !! If STOREV = 'C', the vector which defines the elementary reflector
          !! H(i) is stored in the i-th column of the array V, and
          !! H  =  I - V * T * V**H
          !! If STOREV = 'R', the vector which defines the elementary reflector
          !! H(i) is stored in the i-th row of the array V, and
          !! H  =  I - V**H * T * V
          !! Currently, only STOREV = 'R' and DIRECT = 'B' are supported.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,storev
                    integer(ilp), intent(in) :: k,ldt,ldv,n
                    complex(sp), intent(out) :: t(ldt,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(inout) :: v(ldv,*)
               end subroutine clarzt
#else 
               module procedure stdlib_clarzt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,storev
                    integer(ilp), intent(in) :: k,ldt,ldv,n
                    real(dp), intent(out) :: t(ldt,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(inout) :: v(ldv,*)
               end subroutine dlarzt
#else 
               module procedure stdlib_dlarzt
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larzt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,storev
                    integer(ilp), intent(in) :: k,ldt,ldv,n
                    real(sp), intent(out) :: t(ldt,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(inout) :: v(ldv,*)
               end subroutine slarzt
#else 
               module procedure stdlib_slarzt
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$larzt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlarzt( direct, storev, n, k, v, ldv, tau, t, ldt )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,storev
                    integer(ilp), intent(in) :: k,ldt,ldv,n
                    complex(dp), intent(out) :: t(ldt,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(inout) :: v(ldv,*)
               end subroutine zlarzt
#else 
               module procedure stdlib_zlarzt
#endif
          end interface larzt



          interface lascl
          !! LASCL multiplies the M by N complex matrix A by the real scalar
          !! CTO/CFROM.  This is done without over/underflow as long as the final
          !! result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
          !! A may be full, upper triangular, lower triangular, upper Hessenberg,
          !! or banded.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: type
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,lda,m,n
                    real(sp), intent(in) :: cfrom,cto
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine clascl
#else 
               module procedure stdlib_clascl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: type
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,lda,m,n
                    real(dp), intent(in) :: cfrom,cto
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dlascl
#else 
               module procedure stdlib_dlascl
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lascl

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: type
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,lda,m,n
                    real(sp), intent(in) :: cfrom,cto
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine slascl
#else 
               module procedure stdlib_slascl
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lascl

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlascl( type, kl, ku, cfrom, cto, m, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: type
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kl,ku,lda,m,n
                    real(dp), intent(in) :: cfrom,cto
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlascl
#else 
               module procedure stdlib_zlascl
#endif
          end interface lascl



          interface lasd0
          !! Using a divide and conquer approach, LASD0: computes the singular
          !! value decomposition (SVD) of a real upper bidiagonal N-by-M
          !! matrix B with diagonal D and offdiagonal E, where M = N + SQRE.
          !! The algorithm computes orthogonal matrices U and VT such that
          !! B = U * S * VT. The singular values S are overwritten on D.
          !! A related subroutine, DLASDA, computes only the singular values,
          !! and optionally, the singular vectors in compact form.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasd0( n, sqre, d, e, u, ldu, vt, ldvt, smlsiz, iwork,work, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu,ldvt,n,smlsiz,sqre
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine dlasd0
#else 
               module procedure stdlib_dlasd0
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasd0

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasd0( n, sqre, d, e, u, ldu, vt, ldvt, smlsiz, iwork,work, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu,ldvt,n,smlsiz,sqre
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: u(ldu,*),vt(ldvt,*),work(*)
               end subroutine slasd0
#else 
               module procedure stdlib_slasd0
#endif
          end interface lasd0



          interface lasd1
          !! LASD1 computes the SVD of an upper bidiagonal N-by-M matrix B,
          !! where N = NL + NR + 1 and M = N + SQRE. LASD1 is called from DLASD0.
          !! A related subroutine DLASD7 handles the case in which the singular
          !! values (and the singular vectors in factored form) are desired.
          !! LASD1 computes the SVD as follows:
          !! ( D1(in)    0    0       0 )
          !! B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
          !! (   0       0   D2(in)   0 )
          !! = U(out) * ( D(out) 0) * VT(out)
          !! where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
          !! with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
          !! elsewhere; and the entry b is empty if SQRE = 0.
          !! The left singular vectors of the original matrix are stored in U, and
          !! the transpose of the right singular vectors are stored in VT, and the
          !! singular values are in D.  The algorithm consists of three stages:
          !! The first stage consists of deflating the size of the problem
          !! when there are multiple singular values or when there are zeros in
          !! the Z vector.  For each such occurrence the dimension of the
          !! secular equation problem is reduced by one.  This stage is
          !! performed by the routine DLASD2.
          !! The second stage consists of calculating the updated
          !! singular values. This is done by finding the square roots of the
          !! roots of the secular equation via the routine DLASD4 (as called
          !! by DLASD3). This routine also calculates the singular vectors of
          !! the current problem.
          !! The final stage consists of computing the updated singular vectors
          !! directly using the updated singular values.  The singular vectors
          !! for the current problem are multiplied with the singular vectors
          !! from the overall problem.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasd1( nl, nr, sqre, d, alpha, beta, u, ldu, vt, ldvt,idxq, iwork,&
                          work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu,ldvt,nl,nr,sqre
                    real(dp), intent(inout) :: alpha,beta,d(*),u(ldu,*),vt(ldvt,*)
                    integer(ilp), intent(inout) :: idxq(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlasd1
#else 
               module procedure stdlib_dlasd1
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasd1

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasd1( nl, nr, sqre, d, alpha, beta, u, ldu, vt, ldvt,idxq, iwork,&
                          work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu,ldvt,nl,nr,sqre
                    real(sp), intent(inout) :: alpha,beta,d(*),u(ldu,*),vt(ldvt,*)
                    integer(ilp), intent(inout) :: idxq(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slasd1
#else 
               module procedure stdlib_slasd1
#endif
          end interface lasd1



          interface lasd4
          !! This subroutine computes the square root of the I-th updated
          !! eigenvalue of a positive symmetric rank-one modification to
          !! a positive diagonal matrix whose entries are given as the squares
          !! of the corresponding entries in the array d, and that
          !! 0 <= D(i) < D(j)  for  i < j
          !! and that RHO > 0. This is arranged by the calling routine, and is
          !! no loss in generality.  The rank-one modified system is thus
          !! diag( D ) * diag( D ) +  RHO * Z * Z_transpose.
          !! where we assume the Euclidean norm of Z is 1.
          !! The method consists of approximating the rational functions in the
          !! secular equation by simpler interpolating rational functions.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasd4( n, i, d, z, delta, rho, sigma, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: i,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: rho,d(*),z(*)
                    real(dp), intent(out) :: sigma,delta(*),work(*)
               end subroutine dlasd4
#else 
               module procedure stdlib_dlasd4
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasd4

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasd4( n, i, d, z, delta, rho, sigma, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: i,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: rho,d(*),z(*)
                    real(sp), intent(out) :: sigma,delta(*),work(*)
               end subroutine slasd4
#else 
               module procedure stdlib_slasd4
#endif
          end interface lasd4



          interface lasd5
          !! This subroutine computes the square root of the I-th eigenvalue
          !! of a positive symmetric rank-one modification of a 2-by-2 diagonal
          !! matrix
          !! diag( D ) * diag( D ) +  RHO * Z * transpose(Z) .
          !! The diagonal entries in the array D are assumed to satisfy
          !! 0 <= D(i) < D(j)  for  i < j .
          !! We also assume RHO > 0 and that the Euclidean norm of the vector
          !! Z is one.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasd5( i, d, z, delta, rho, dsigma, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: i
                    real(dp), intent(out) :: dsigma,delta(2),work(2)
                    real(dp), intent(in) :: rho,d(2),z(2)
               end subroutine dlasd5
#else 
               module procedure stdlib_dlasd5
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasd5

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasd5( i, d, z, delta, rho, dsigma, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: i
                    real(sp), intent(out) :: dsigma,delta(2),work(2)
                    real(sp), intent(in) :: rho,d(2),z(2)
               end subroutine slasd5
#else 
               module procedure stdlib_slasd5
#endif
          end interface lasd5



          interface lasd6
          !! LASD6 computes the SVD of an updated upper bidiagonal matrix B
          !! obtained by merging two smaller ones by appending a row. This
          !! routine is used only for the problem which requires all singular
          !! values and optionally singular vector matrices in factored form.
          !! B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
          !! A related subroutine, DLASD1, handles the case in which all singular
          !! values and singular vectors of the bidiagonal matrix are desired.
          !! LASD6 computes the SVD as follows:
          !! ( D1(in)    0    0       0 )
          !! B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
          !! (   0       0   D2(in)   0 )
          !! = U(out) * ( D(out) 0) * VT(out)
          !! where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
          !! with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
          !! elsewhere; and the entry b is empty if SQRE = 0.
          !! The singular values of B can be computed using D1, D2, the first
          !! components of all the right singular vectors of the lower block, and
          !! the last components of all the right singular vectors of the upper
          !! block. These components are stored and updated in VF and VL,
          !! respectively, in LASD6. Hence U and VT are not explicitly
          !! referenced.
          !! The singular values are stored in D. The algorithm consists of two
          !! stages:
          !! The first stage consists of deflating the size of the problem
          !! when there are multiple singular values or if there is a zero
          !! in the Z vector. For each such occurrence the dimension of the
          !! secular equation problem is reduced by one. This stage is
          !! performed by the routine DLASD7.
          !! The second stage consists of calculating the updated
          !! singular values. This is done by finding the roots of the
          !! secular equation via the routine DLASD4 (as called by DLASD8).
          !! This routine also updates VF and VL and computes the distances
          !! between the updated singular values and the old singular
          !! values.
          !! LASD6 is called from DLASDA.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasd6( icompq, nl, nr, sqre, d, vf, vl, alpha, beta,idxq, perm, &
               givptr, givcol, ldgcol, givnum,ldgnum, poles, difl, difr, z, k, c, s, work,iwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: givptr,info,k,givcol(ldgcol,*),iwork(*),perm(*)
                              
                    integer(ilp), intent(in) :: icompq,ldgcol,ldgnum,nl,nr,sqre
                    real(dp), intent(inout) :: alpha,beta,d(*),vf(*),vl(*)
                    real(dp), intent(out) :: c,s,difl(*),difr(*),givnum(ldgnum,*),poles(ldgnum,*),&
                              work(*),z(*)
                    integer(ilp), intent(inout) :: idxq(*)
               end subroutine dlasd6
#else 
               module procedure stdlib_dlasd6
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasd6

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasd6( icompq, nl, nr, sqre, d, vf, vl, alpha, beta,idxq, perm, &
               givptr, givcol, ldgcol, givnum,ldgnum, poles, difl, difr, z, k, c, s, work,iwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: givptr,info,k,givcol(ldgcol,*),iwork(*),perm(*)
                              
                    integer(ilp), intent(in) :: icompq,ldgcol,ldgnum,nl,nr,sqre
                    real(sp), intent(inout) :: alpha,beta,d(*),vf(*),vl(*)
                    real(sp), intent(out) :: c,s,difl(*),difr(*),givnum(ldgnum,*),poles(ldgnum,*),&
                              work(*),z(*)
                    integer(ilp), intent(inout) :: idxq(*)
               end subroutine slasd6
#else 
               module procedure stdlib_slasd6
#endif
          end interface lasd6



          interface lasd7
          !! LASD7 merges the two sets of singular values together into a single
          !! sorted set. Then it tries to deflate the size of the problem. There
          !! are two ways in which deflation can occur:  when two or more singular
          !! values are close together or if there is a tiny entry in the Z
          !! vector. For each such occurrence the order of the related
          !! secular equation problem is reduced by one.
          !! LASD7 is called from DLASD6.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasd7( icompq, nl, nr, sqre, k, d, z, zw, vf, vfw, vl,vlw, alpha, &
               beta, dsigma, idx, idxp, idxq,perm, givptr, givcol, ldgcol, givnum, ldgnum,c, s, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: givptr,info,k,givcol(ldgcol,*),idx(*),idxp(*),&
                              perm(*)
                    integer(ilp), intent(in) :: icompq,ldgcol,ldgnum,nl,nr,sqre
                    real(dp), intent(in) :: alpha,beta
                    real(dp), intent(out) :: c,s,dsigma(*),givnum(ldgnum,*),vfw(*),vlw(*),z(*),zw(&
                              *)
                    integer(ilp), intent(inout) :: idxq(*)
                    real(dp), intent(inout) :: d(*),vf(*),vl(*)
               end subroutine dlasd7
#else 
               module procedure stdlib_dlasd7
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasd7

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasd7( icompq, nl, nr, sqre, k, d, z, zw, vf, vfw, vl,vlw, alpha, &
               beta, dsigma, idx, idxp, idxq,perm, givptr, givcol, ldgcol, givnum, ldgnum,c, s, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: givptr,info,k,givcol(ldgcol,*),idx(*),idxp(*),&
                              perm(*)
                    integer(ilp), intent(in) :: icompq,ldgcol,ldgnum,nl,nr,sqre
                    real(sp), intent(in) :: alpha,beta
                    real(sp), intent(out) :: c,s,dsigma(*),givnum(ldgnum,*),vfw(*),vlw(*),z(*),zw(&
                              *)
                    integer(ilp), intent(inout) :: idxq(*)
                    real(sp), intent(inout) :: d(*),vf(*),vl(*)
               end subroutine slasd7
#else 
               module procedure stdlib_slasd7
#endif
          end interface lasd7



          interface lasd8
          !! LASD8 finds the square roots of the roots of the secular equation,
          !! as defined by the values in DSIGMA and Z. It makes the appropriate
          !! calls to DLASD4, and stores, for each  element in D, the distance
          !! to its two nearest poles (elements in DSIGMA). It also updates
          !! the arrays VF and VL, the first and last components of all the
          !! right singular vectors of the original bidiagonal matrix.
          !! LASD8 is called from DLASD6.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasd8( icompq, k, d, z, vf, vl, difl, difr, lddifr,dsigma, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: icompq,k,lddifr
                    integer(ilp), intent(out) :: info
                    real(dp), intent(out) :: d(*),difl(*),difr(lddifr,*),work(*)
                    real(dp), intent(inout) :: dsigma(*),vf(*),vl(*),z(*)
               end subroutine dlasd8
#else 
               module procedure stdlib_dlasd8
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasd8

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasd8( icompq, k, d, z, vf, vl, difl, difr, lddifr,dsigma, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: icompq,k,lddifr
                    integer(ilp), intent(out) :: info
                    real(sp), intent(out) :: d(*),difl(*),difr(lddifr,*),work(*)
                    real(sp), intent(inout) :: dsigma(*),vf(*),vl(*),z(*)
               end subroutine slasd8
#else 
               module procedure stdlib_slasd8
#endif
          end interface lasd8



          interface lasda
          !! Using a divide and conquer approach, LASDA: computes the singular
          !! value decomposition (SVD) of a real upper bidiagonal N-by-M matrix
          !! B with diagonal D and offdiagonal E, where M = N + SQRE. The
          !! algorithm computes the singular values in the SVD B = U * S * VT.
          !! The orthogonal matrices U and VT are optionally computed in
          !! compact form.
          !! A related subroutine, DLASD0, computes the singular values and
          !! the singular vectors in explicit form.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasda( icompq, smlsiz, n, sqre, d, e, u, ldu, vt, k,difl, difr, z,&
                          poles, givptr, givcol, ldgcol,perm, givnum, c, s, work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: icompq,ldgcol,ldu,n,smlsiz,sqre
                    integer(ilp), intent(out) :: info,givcol(ldgcol,*),givptr(*),iwork(*),k(*),&
                              perm(ldgcol,*)
                    real(dp), intent(out) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),work(*),z(ldu,*)
                    real(dp), intent(inout) :: d(*),e(*)
               end subroutine dlasda
#else 
               module procedure stdlib_dlasda
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasda

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasda( icompq, smlsiz, n, sqre, d, e, u, ldu, vt, k,difl, difr, z,&
                          poles, givptr, givcol, ldgcol,perm, givnum, c, s, work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: icompq,ldgcol,ldu,n,smlsiz,sqre
                    integer(ilp), intent(out) :: info,givcol(ldgcol,*),givptr(*),iwork(*),k(*),&
                              perm(ldgcol,*)
                    real(sp), intent(out) :: c(*),difl(ldu,*),difr(ldu,*),givnum(ldu,*),poles(ldu,&
                              *),s(*),u(ldu,*),vt(ldu,*),work(*),z(ldu,*)
                    real(sp), intent(inout) :: d(*),e(*)
               end subroutine slasda
#else 
               module procedure stdlib_slasda
#endif
          end interface lasda



          interface lasdq
          !! LASDQ computes the singular value decomposition (SVD) of a real
          !! (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
          !! E, accumulating the transformations if desired. Letting B denote
          !! the input bidiagonal matrix, the algorithm computes orthogonal
          !! matrices Q and P such that B = Q * S * P**T (P**T denotes the transpose
          !! of P). The singular values S are overwritten on D.
          !! The input matrix U  is changed to U  * Q  if desired.
          !! The input matrix VT is changed to P**T * VT if desired.
          !! The input matrix C  is changed to Q**T * C  if desired.
          !! See "Computing  Small Singular Values of Bidiagonal Matrices With
          !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
          !! LAPACK Working Note #3, for a detailed description of the algorithm.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasdq( uplo, sqre, n, ncvt, nru, ncc, d, e, vt, ldvt,u, ldu, c, &
                         ldc, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru,sqre
                    real(dp), intent(inout) :: c(ldc,*),d(*),e(*),u(ldu,*),vt(ldvt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlasdq
#else 
               module procedure stdlib_dlasdq
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasdq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasdq( uplo, sqre, n, ncvt, nru, ncc, d, e, vt, ldvt,u, ldu, c, &
                         ldc, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,ldu,ldvt,n,ncc,ncvt,nru,sqre
                    real(sp), intent(inout) :: c(ldc,*),d(*),e(*),u(ldu,*),vt(ldvt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slasdq
#else 
               module procedure stdlib_slasdq
#endif
          end interface lasdq



          interface laset
          !! LASET initializes a 2-D array A to BETA on the diagonal and
          !! ALPHA on the offdiagonals.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claset( uplo, m, n, alpha, beta, a, lda )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,m,n
                    complex(sp), intent(in) :: alpha,beta
                    complex(sp), intent(out) :: a(lda,*)
               end subroutine claset
#else 
               module procedure stdlib_claset
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaset( uplo, m, n, alpha, beta, a, lda )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(in) :: alpha,beta
                    real(dp), intent(out) :: a(lda,*)
               end subroutine dlaset
#else 
               module procedure stdlib_dlaset
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laset

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaset( uplo, m, n, alpha, beta, a, lda )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(in) :: alpha,beta
                    real(sp), intent(out) :: a(lda,*)
               end subroutine slaset
#else 
               module procedure stdlib_slaset
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laset

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaset( uplo, m, n, alpha, beta, a, lda )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,m,n
                    complex(dp), intent(in) :: alpha,beta
                    complex(dp), intent(out) :: a(lda,*)
               end subroutine zlaset
#else 
               module procedure stdlib_zlaset
#endif
          end interface laset



          interface lasq1
          !! LASQ1 computes the singular values of a real N-by-N bidiagonal
          !! matrix with diagonal D and off-diagonal E. The singular values
          !! are computed to high relative accuracy, in the absence of
          !! denormalization, underflow and overflow. The algorithm was first
          !! presented in
          !! "Accurate singular values and differential qd algorithms" by K. V.
          !! Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
          !! 1994,
          !! and the present implementation is described in "An implementation of
          !! the dqds Algorithm (Positive Case)", LAPACK Working Note.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasq1( n, d, e, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlasq1
#else 
               module procedure stdlib_dlasq1
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasq1

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasq1( n, d, e, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: work(*)
               end subroutine slasq1
#else 
               module procedure stdlib_slasq1
#endif
          end interface lasq1



          interface lasq4
          !! LASQ4 computes an approximation TAU to the smallest eigenvalue
          !! using values of d from the previous transform.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasq4( i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn,dn1, dn2, tau, &
                         ttype, g )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: i0,n0,n0in,pp
                    integer(ilp), intent(out) :: ttype
                    real(dp), intent(in) :: dmin,dmin1,dmin2,dn,dn1,dn2,z(*)
                    real(dp), intent(inout) :: g
                    real(dp), intent(out) :: tau
               end subroutine dlasq4
#else 
               module procedure stdlib_dlasq4
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasq4

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasq4( i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn,dn1, dn2, tau, &
                         ttype, g )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: i0,n0,n0in,pp
                    integer(ilp), intent(out) :: ttype
                    real(sp), intent(in) :: dmin,dmin1,dmin2,dn,dn1,dn2,z(*)
                    real(sp), intent(inout) :: g
                    real(sp), intent(out) :: tau
               end subroutine slasq4
#else 
               module procedure stdlib_slasq4
#endif
          end interface lasq4



          interface lasq5
          !! LASQ5 computes one dqds transform in ping-pong form, one
          !! version for IEEE machines another for non IEEE machines.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasq5( i0, n0, z, pp, tau, sigma, dmin, dmin1, dmin2,dn, dnm1, &
                         dnm2, ieee, eps )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: ieee
                    integer(ilp), intent(in) :: i0,n0,pp
                    real(dp), intent(out) :: dmin,dmin1,dmin2,dn,dnm1,dnm2
                    real(dp), intent(inout) :: tau,z(*)
                    real(dp), intent(in) :: sigma,eps
               end subroutine dlasq5
#else 
               module procedure stdlib_dlasq5
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasq5

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasq5( i0, n0, z, pp, tau, sigma, dmin, dmin1, dmin2,dn, dnm1, &
                         dnm2, ieee, eps )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: ieee
                    integer(ilp), intent(in) :: i0,n0,pp
                    real(sp), intent(out) :: dmin,dmin1,dmin2,dn,dnm1,dnm2
                    real(sp), intent(inout) :: tau,z(*)
                    real(sp), intent(in) :: sigma,eps
               end subroutine slasq5
#else 
               module procedure stdlib_slasq5
#endif
          end interface lasq5



          interface lasq6
          !! LASQ6 computes one dqd (shift equal to zero) transform in
          !! ping-pong form, with protection against underflow and overflow.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasq6( i0, n0, z, pp, dmin, dmin1, dmin2, dn,dnm1, dnm2 )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: i0,n0,pp
                    real(dp), intent(out) :: dmin,dmin1,dmin2,dn,dnm1,dnm2
                    real(dp), intent(inout) :: z(*)
               end subroutine dlasq6
#else 
               module procedure stdlib_dlasq6
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasq6

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasq6( i0, n0, z, pp, dmin, dmin1, dmin2, dn,dnm1, dnm2 )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: i0,n0,pp
                    real(sp), intent(out) :: dmin,dmin1,dmin2,dn,dnm1,dnm2
                    real(sp), intent(inout) :: z(*)
               end subroutine slasq6
#else 
               module procedure stdlib_slasq6
#endif
          end interface lasq6



          interface lasr
          !! LASR applies a sequence of real plane rotations to a complex matrix
          !! A, from either the left or the right.
          !! When SIDE = 'L', the transformation takes the form
          !! A := P*A
          !! and when SIDE = 'R', the transformation takes the form
          !! A := A*P**T
          !! where P is an orthogonal matrix consisting of a sequence of z plane
          !! rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
          !! and P**T is the transpose of P.
          !! When DIRECT = 'F' (Forward sequence), then
          !! P = P(z-1) * ... * P(2) * P(1)
          !! and when DIRECT = 'B' (Backward sequence), then
          !! P = P(1) * P(2) * ... * P(z-1)
          !! where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
          !! R(k) = (  c(k)  s(k) )
          !! = ( -s(k)  c(k) ).
          !! When PIVOT = 'V' (Variable pivot), the rotation is performed
          !! for the plane (k,k+1), i.e., P(k) has the form
          !! P(k) = (  1                                            )
          !! (       ...                                     )
          !! (              1                                )
          !! (                   c(k)  s(k)                  )
          !! (                  -s(k)  c(k)                  )
          !! (                                1              )
          !! (                                     ...       )
          !! (                                            1  )
          !! where R(k) appears as a rank-2 modification to the identity matrix in
          !! rows and columns k and k+1.
          !! When PIVOT = 'T' (Top pivot), the rotation is performed for the
          !! plane (1,k+1), so P(k) has the form
          !! P(k) = (  c(k)                    s(k)                 )
          !! (         1                                     )
          !! (              ...                              )
          !! (                     1                         )
          !! ( -s(k)                    c(k)                 )
          !! (                                 1             )
          !! (                                      ...      )
          !! (                                             1 )
          !! where R(k) appears in rows and columns 1 and k+1.
          !! Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
          !! performed for the plane (k,z), giving P(k) the form
          !! P(k) = ( 1                                             )
          !! (      ...                                      )
          !! (             1                                 )
          !! (                  c(k)                    s(k) )
          !! (                         1                     )
          !! (                              ...              )
          !! (                                     1         )
          !! (                 -s(k)                    c(k) )
          !! where R(k) appears in rows and columns k and z.  The rotations are
          !! performed without ever forming P(k) explicitly.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clasr( side, pivot, direct, m, n, c, s, a, lda )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,pivot,side
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(in) :: c(*),s(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine clasr
#else 
               module procedure stdlib_clasr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasr( side, pivot, direct, m, n, c, s, a, lda )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,pivot,side
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: c(*),s(*)
               end subroutine dlasr
#else 
               module procedure stdlib_dlasr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasr( side, pivot, direct, m, n, c, s, a, lda )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,pivot,side
                    integer(ilp), intent(in) :: lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: c(*),s(*)
               end subroutine slasr
#else 
               module procedure stdlib_slasr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlasr( side, pivot, direct, m, n, c, s, a, lda )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,pivot,side
                    integer(ilp), intent(in) :: lda,m,n
                    real(dp), intent(in) :: c(*),s(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlasr
#else 
               module procedure stdlib_zlasr
#endif
          end interface lasr



          interface lasrt
          !! Sort the numbers in D in increasing order (if ID = 'I') or
          !! in decreasing order (if ID = 'D' ).
          !! Use Quick Sort, reverting to Insertion sort on arrays of
          !! size <= 20. Dimension of STACK limits N to about 2**32.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasrt( id, n, d, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: id
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: d(*)
               end subroutine dlasrt
#else 
               module procedure stdlib_dlasrt
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasrt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasrt( id, n, d, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: id
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: d(*)
               end subroutine slasrt
#else 
               module procedure stdlib_slasrt
#endif
          end interface lasrt



          interface lassq
          !! LASSQ returns the values  scl  and  smsq  such that
          !! ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
          !! where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
          !! assumed to be non-negative.
          !! scale and sumsq must be supplied in SCALE and SUMSQ and
          !! scl and smsq are overwritten on SCALE and SUMSQ respectively.
          !! If scale * sqrt( sumsq ) > tbig then
          !! we require:   scale >= sqrt( TINY*EPS ) / sbig   on entry,
          !! and if 0 < scale * sqrt( sumsq ) < tsml then
          !! we require:   scale <= sqrt( HUGE ) / ssml       on entry,
          !! where
          !! tbig -- upper threshold for values whose square is representable;
          !! sbig -- scaling constant for big numbers; \see la_constants.f90
          !! tsml -- lower threshold for values whose square is representable;
          !! ssml -- scaling constant for small numbers; \see la_constants.f90
          !! and
          !! TINY*EPS -- tiniest representable number;
          !! HUGE     -- biggest representable number.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine classq( n, x, incx, scl, sumsq )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,n
                    real(sp), intent(inout) :: scl,sumsq
                    complex(sp), intent(in) :: x(*)
               end subroutine classq
#else 
               module procedure stdlib_classq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlassq( n, x, incx, scl, sumsq )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,n
                    real(dp), intent(inout) :: scl,sumsq
                    real(dp), intent(in) :: x(*)
               end subroutine dlassq
#else 
               module procedure stdlib_dlassq
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lassq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slassq( n, x, incx, scl, sumsq )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,n
                    real(sp), intent(inout) :: scl,sumsq
                    real(sp), intent(in) :: x(*)
               end subroutine slassq
#else 
               module procedure stdlib_slassq
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lassq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlassq( n, x, incx, scl, sumsq )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,n
                    real(dp), intent(inout) :: scl,sumsq
                    complex(dp), intent(in) :: x(*)
               end subroutine zlassq
#else 
               module procedure stdlib_zlassq
#endif
          end interface lassq



          interface laswlq
          !! LASWLQ computes a blocked Tall-Skinny LQ factorization of
          !! a complex M-by-N matrix A for M <= N:
          !! A = ( L 0 ) *  Q,
          !! where:
          !! Q is a n-by-N orthogonal matrix, stored on exit in an implicit
          !! form in the elements above the diagonal of the array A and in
          !! the elements of the array T;
          !! L is a lower-triangular M-by-M matrix stored on exit in
          !! the elements on and below the diagonal of the array A.
          !! 0 is a M-by-(N-M) zero matrix, if M < N, and is not stored.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claswlq( m, n, mb, nb, a, lda, t, ldt, work, lwork,info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,mb,nb,lwork,ldt
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*),t(ldt,*)
               end subroutine claswlq
#else 
               module procedure stdlib_claswlq
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaswlq( m, n, mb, nb, a, lda, t, ldt, work, lwork,info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,mb,nb,lwork,ldt
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*),t(ldt,*)
               end subroutine dlaswlq
#else 
               module procedure stdlib_dlaswlq
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laswlq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaswlq( m, n, mb, nb, a, lda, t, ldt, work, lwork,info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,mb,nb,lwork,ldt
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*),t(ldt,*)
               end subroutine slaswlq
#else 
               module procedure stdlib_slaswlq
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laswlq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaswlq( m, n, mb, nb, a, lda, t, ldt, work, lwork,info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,mb,nb,lwork,ldt
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*),t(ldt,*)
               end subroutine zlaswlq
#else 
               module procedure stdlib_zlaswlq
#endif
          end interface laswlq



          interface laswp
          !! LASWP performs a series of row interchanges on the matrix A.
          !! One row interchange is initiated for each of rows K1 through K2 of A.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claswp( n, a, lda, k1, k2, ipiv, incx )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,k1,k2,lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine claswp
#else 
               module procedure stdlib_claswp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlaswp( n, a, lda, k1, k2, ipiv, incx )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,k1,k2,lda,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dlaswp
#else 
               module procedure stdlib_dlaswp
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laswp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slaswp( n, a, lda, k1, k2, ipiv, incx )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,k1,k2,lda,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine slaswp
#else 
               module procedure stdlib_slaswp
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$laswp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaswp( n, a, lda, k1, k2, ipiv, incx )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,k1,k2,lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlaswp
#else 
               module procedure stdlib_zlaswp
#endif
          end interface laswp



          interface lasyf
          !! LASYF computes a partial factorization of a complex symmetric matrix
          !! A using the Bunch-Kaufman diagonal pivoting method. The partial
          !! factorization has the form:
          !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
          !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
          !! A  =  ( L11  0 ) ( D    0  ) ( L11**T L21**T )  if UPLO = 'L'
          !! ( L21  I ) ( 0   A22 ) (  0       I    )
          !! where the order of D is at most NB. The actual order is returned in
          !! the argument KB, and is either NB or NB-1, or N if N <= NB.
          !! Note that U**T denotes the transpose of U.
          !! LASYF is an auxiliary routine called by CSYTRF. It uses blocked code
          !! (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
          !! A22 (if UPLO = 'L').
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: w(ldw,*)
               end subroutine clasyf
#else 
               module procedure stdlib_clasyf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: w(ldw,*)
               end subroutine dlasyf
#else 
               module procedure stdlib_dlasyf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasyf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: w(ldw,*)
               end subroutine slasyf
#else 
               module procedure stdlib_slasyf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasyf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: w(ldw,*)
               end subroutine zlasyf
#else 
               module procedure stdlib_zlasyf
#endif
          end interface lasyf



          interface lasyf_aa
          !! DLATRF_AA factorizes a panel of a complex symmetric matrix A using
          !! the Aasen's algorithm. The panel consists of a set of NB rows of A
          !! when UPLO is U, or a set of NB columns when UPLO is L.
          !! In order to factorize the panel, the Aasen's algorithm requires the
          !! last row, or column, of the previous panel. The first row, or column,
          !! of A is set to be the first row, or column, of an identity matrix,
          !! which is used to factorize the first panel.
          !! The resulting J-th row of U, or J-th column of L, is stored in the
          !! (J-1)-th row, or column, of A (without the unit diagonals), while
          !! the diagonal and subdiagonal of A are overwritten by those of T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp), intent(out) :: ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),h(ldh,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine clasyf_aa
#else 
               module procedure stdlib_clasyf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp), intent(out) :: ipiv(*)
                    real(dp), intent(inout) :: a(lda,*),h(ldh,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dlasyf_aa
#else 
               module procedure stdlib_dlasyf_aa
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasyf_aa

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp), intent(out) :: ipiv(*)
                    real(sp), intent(inout) :: a(lda,*),h(ldh,*)
                    real(sp), intent(out) :: work(*)
               end subroutine slasyf_aa
#else 
               module procedure stdlib_slasyf_aa
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasyf_aa

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: m,nb,j1,lda,ldh
                    integer(ilp), intent(out) :: ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),h(ldh,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zlasyf_aa
#else 
               module procedure stdlib_zlasyf_aa
#endif
          end interface lasyf_aa



          interface lasyf_rk
          !! LASYF_RK computes a partial factorization of a complex symmetric
          !! matrix A using the bounded Bunch-Kaufman (rook) diagonal
          !! pivoting method. The partial factorization has the form:
          !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
          !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
          !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L',
          !! ( L21  I ) (  0  A22 ) (  0       I    )
          !! where the order of D is at most NB. The actual order is returned in
          !! the argument KB, and is either NB or NB-1, or N if N <= NB.
          !! LASYF_RK is an auxiliary routine called by CSYTRF_RK. It uses
          !! blocked code (calling Level 3 BLAS) to update the submatrix
          !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*),w(ldw,*)
               end subroutine clasyf_rk
#else 
               module procedure stdlib_clasyf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: e(*),w(ldw,*)
               end subroutine dlasyf_rk
#else 
               module procedure stdlib_dlasyf_rk
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasyf_rk

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: e(*),w(ldw,*)
               end subroutine slasyf_rk
#else 
               module procedure stdlib_slasyf_rk
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasyf_rk

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*),w(ldw,*)
               end subroutine zlasyf_rk
#else 
               module procedure stdlib_zlasyf_rk
#endif
          end interface lasyf_rk



          interface lasyf_rook
          !! LASYF_ROOK computes a partial factorization of a complex symmetric
          !! matrix A using the bounded Bunch-Kaufman ("rook") diagonal
          !! pivoting method. The partial factorization has the form:
          !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
          !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
          !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
          !! ( L21  I ) (  0  A22 ) (  0       I    )
          !! where the order of D is at most NB. The actual order is returned in
          !! the argument KB, and is either NB or NB-1, or N if N <= NB.
          !! LASYF_ROOK is an auxiliary routine called by CSYTRF_ROOK. It uses
          !! blocked code (calling Level 3 BLAS) to update the submatrix
          !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: w(ldw,*)
               end subroutine clasyf_rook
#else 
               module procedure stdlib_clasyf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: w(ldw,*)
               end subroutine dlasyf_rook
#else 
               module procedure stdlib_dlasyf_rook
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasyf_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: w(ldw,*)
               end subroutine slasyf_rook
#else 
               module procedure stdlib_slasyf_rook
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lasyf_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,kb,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: w(ldw,*)
               end subroutine zlasyf_rook
#else 
               module procedure stdlib_zlasyf_rook
#endif
          end interface lasyf_rook



          interface latbs
          !! LATBS solves one of the triangular systems
          !! A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
          !! with scaling to prevent overflow, where A is an upper or lower
          !! triangular band matrix.  Here A**T denotes the transpose of A, x and b
          !! are n-element vectors, and s is a scaling factor, usually less than
          !! or equal to 1, chosen so that the components of x will be less than
          !! the overflow threshold.  If the unscaled problem will not cause
          !! overflow, the Level 2 BLAS routine CTBSV is called.  If the matrix A
          !! is singular (A(j,j) = 0 for some j), then s is set to 0 and a
          !! non-trivial solution to A*x = 0 is returned.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,scale, cnorm,&
                          info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: scale
                    real(sp), intent(inout) :: cnorm(*)
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(inout) :: x(*)
               end subroutine clatbs
#else 
               module procedure stdlib_clatbs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,scale, cnorm,&
                          info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: scale
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(inout) :: cnorm(*),x(*)
               end subroutine dlatbs
#else 
               module procedure stdlib_dlatbs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$latbs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,scale, cnorm,&
                          info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: scale
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(inout) :: cnorm(*),x(*)
               end subroutine slatbs
#else 
               module procedure stdlib_slatbs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$latbs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlatbs( uplo, trans, diag, normin, n, kd, ab, ldab, x,scale, cnorm,&
                          info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: scale
                    real(dp), intent(inout) :: cnorm(*)
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(inout) :: x(*)
               end subroutine zlatbs
#else 
               module procedure stdlib_zlatbs
#endif
          end interface latbs



          interface latdf
          !! LATDF computes the contribution to the reciprocal Dif-estimate
          !! by solving for x in Z * x = b, where b is chosen such that the norm
          !! of x is as large as possible. It is assumed that LU decomposition
          !! of Z has been computed by CGETC2. On entry RHS = f holds the
          !! contribution from earlier solved sub-systems, and on return RHS = x.
          !! The factorization of Z returned by CGETC2 has the form
          !! Z = P * L * U * Q, where P and Q are permutation matrices. L is lower
          !! triangular with unit diagonal elements and U is upper triangular.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,jpiv )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ijob,ldz,n,ipiv(*),jpiv(*)
                    real(sp), intent(inout) :: rdscal,rdsum
                    complex(sp), intent(inout) :: rhs(*),z(ldz,*)
               end subroutine clatdf
#else 
               module procedure stdlib_clatdf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,jpiv )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ijob,ldz,n,ipiv(*),jpiv(*)
                    real(dp), intent(inout) :: rdscal,rdsum,rhs(*),z(ldz,*)
               end subroutine dlatdf
#else 
               module procedure stdlib_dlatdf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$latdf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,jpiv )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ijob,ldz,n,ipiv(*),jpiv(*)
                    real(sp), intent(inout) :: rdscal,rdsum,rhs(*),z(ldz,*)
               end subroutine slatdf
#else 
               module procedure stdlib_slatdf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$latdf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlatdf( ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv,jpiv )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ijob,ldz,n,ipiv(*),jpiv(*)
                    real(dp), intent(inout) :: rdscal,rdsum
                    complex(dp), intent(inout) :: rhs(*),z(ldz,*)
               end subroutine zlatdf
#else 
               module procedure stdlib_zlatdf
#endif
          end interface latdf



          interface latps
          !! LATPS solves one of the triangular systems
          !! A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
          !! with scaling to prevent overflow, where A is an upper or lower
          !! triangular matrix stored in packed form.  Here A**T denotes the
          !! transpose of A, A**H denotes the conjugate transpose of A, x and b
          !! are n-element vectors, and s is a scaling factor, usually less than
          !! or equal to 1, chosen so that the components of x will be less than
          !! the overflow threshold.  If the unscaled problem will not cause
          !! overflow, the Level 2 BLAS routine CTPSV is called. If the matrix A
          !! is singular (A(j,j) = 0 for some j), then s is set to 0 and a
          !! non-trivial solution to A*x = 0 is returned.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clatps( uplo, trans, diag, normin, n, ap, x, scale,cnorm, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: scale
                    real(sp), intent(inout) :: cnorm(*)
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(inout) :: x(*)
               end subroutine clatps
#else 
               module procedure stdlib_clatps
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlatps( uplo, trans, diag, normin, n, ap, x, scale,cnorm, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: scale
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(inout) :: cnorm(*),x(*)
               end subroutine dlatps
#else 
               module procedure stdlib_dlatps
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$latps

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slatps( uplo, trans, diag, normin, n, ap, x, scale,cnorm, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: scale
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(inout) :: cnorm(*),x(*)
               end subroutine slatps
#else 
               module procedure stdlib_slatps
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$latps

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlatps( uplo, trans, diag, normin, n, ap, x, scale,cnorm, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: scale
                    real(dp), intent(inout) :: cnorm(*)
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(inout) :: x(*)
               end subroutine zlatps
#else 
               module procedure stdlib_zlatps
#endif
          end interface latps



          interface latrd
          !! LATRD reduces NB rows and columns of a complex Hermitian matrix A to
          !! Hermitian tridiagonal form by a unitary similarity
          !! transformation Q**H * A * Q, and returns the matrices V and W which are
          !! needed to apply the transformation to the unreduced part of A.
          !! If UPLO = 'U', LATRD reduces the last NB rows and columns of a
          !! matrix, of which the upper triangle is supplied;
          !! if UPLO = 'L', LATRD reduces the first NB rows and columns of a
          !! matrix, of which the lower triangle is supplied.
          !! This is an auxiliary routine called by CHETRD.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(sp), intent(out) :: e(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),w(ldw,*)
               end subroutine clatrd
#else 
               module procedure stdlib_clatrd
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: e(*),tau(*),w(ldw,*)
               end subroutine dlatrd
#else 
               module procedure stdlib_dlatrd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$latrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: e(*),tau(*),w(ldw,*)
               end subroutine slatrd
#else 
               module procedure stdlib_slatrd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$latrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: lda,ldw,n,nb
                    real(dp), intent(out) :: e(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),w(ldw,*)
               end subroutine zlatrd
#else 
               module procedure stdlib_zlatrd
#endif
          end interface latrd



          interface latrs
          !! LATRS solves one of the triangular systems
          !! A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
          !! with scaling to prevent overflow.  Here A is an upper or lower
          !! triangular matrix, A**T denotes the transpose of A, A**H denotes the
          !! conjugate transpose of A, x and b are n-element vectors, and s is a
          !! scaling factor, usually less than or equal to 1, chosen so that the
          !! components of x will be less than the overflow threshold.  If the
          !! unscaled problem will not cause overflow, the Level 2 BLAS routine
          !! CTRSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
          !! then s is set to 0 and a non-trivial solution to A*x = 0 is returned.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clatrs( uplo, trans, diag, normin, n, a, lda, x, scale,cnorm, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: scale
                    real(sp), intent(inout) :: cnorm(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: x(*)
               end subroutine clatrs
#else 
               module procedure stdlib_clatrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlatrs( uplo, trans, diag, normin, n, a, lda, x, scale,cnorm, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: scale
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: cnorm(*),x(*)
               end subroutine dlatrs
#else 
               module procedure stdlib_dlatrs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$latrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slatrs( uplo, trans, diag, normin, n, a, lda, x, scale,cnorm, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: scale
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: cnorm(*),x(*)
               end subroutine slatrs
#else 
               module procedure stdlib_slatrs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$latrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlatrs( uplo, trans, diag, normin, n, a, lda, x, scale,cnorm, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,normin,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: scale
                    real(dp), intent(inout) :: cnorm(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: x(*)
               end subroutine zlatrs
#else 
               module procedure stdlib_zlatrs
#endif
          end interface latrs



          interface latrz
          !! LATRZ factors the M-by-(M+L) complex upper trapezoidal matrix
          !! [ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R  0 ) * Z by means
          !! of unitary transformations, where  Z is an (M+L)-by-(M+L) unitary
          !! matrix and, R and A1 are M-by-M upper triangular matrices.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clatrz( m, n, l, a, lda, tau, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: l,lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine clatrz
#else 
               module procedure stdlib_clatrz
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlatrz( m, n, l, a, lda, tau, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: l,lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dlatrz
#else 
               module procedure stdlib_dlatrz
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$latrz

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slatrz( m, n, l, a, lda, tau, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: l,lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine slatrz
#else 
               module procedure stdlib_slatrz
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$latrz

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlatrz( m, n, l, a, lda, tau, work )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: l,lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine zlatrz
#else 
               module procedure stdlib_zlatrz
#endif
          end interface latrz



          interface latsqr
          !! LATSQR computes a blocked Tall-Skinny QR factorization of
          !! a complex M-by-N matrix A for M >= N:
          !! A = Q * ( R ),
          !! ( 0 )
          !! where:
          !! Q is a M-by-M orthogonal matrix, stored on exit in an implicit
          !! form in the elements below the diagonal of the array A and in
          !! the elements of the array T;
          !! R is an upper-triangular N-by-N matrix, stored on exit in
          !! the elements on and above the diagonal of the array A.
          !! 0 is a (M-N)-by-N zero matrix, and is not stored.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clatsqr( m, n, mb, nb, a, lda, t, ldt, work,lwork, info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,mb,nb,ldt,lwork
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*),t(ldt,*)
               end subroutine clatsqr
#else 
               module procedure stdlib_clatsqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlatsqr( m, n, mb, nb, a, lda, t, ldt, work,lwork, info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,mb,nb,ldt,lwork
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*),t(ldt,*)
               end subroutine dlatsqr
#else 
               module procedure stdlib_dlatsqr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$latsqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slatsqr( m, n, mb, nb, a, lda, t, ldt, work,lwork, info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,mb,nb,ldt,lwork
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*),t(ldt,*)
               end subroutine slatsqr
#else 
               module procedure stdlib_slatsqr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$latsqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlatsqr( m, n, mb, nb, a, lda, t, ldt, work,lwork, info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n,mb,nb,ldt,lwork
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*),t(ldt,*)
               end subroutine zlatsqr
#else 
               module procedure stdlib_zlatsqr
#endif
          end interface latsqr



          interface launhr_col_getrfnp
          !! LAUNHR_COL_GETRFNP computes the modified LU factorization without
          !! pivoting of a complex general M-by-N matrix A. The factorization has
          !! the form:
          !! A - S = L * U,
          !! where:
          !! S is a m-by-n diagonal sign matrix with the diagonal D, so that
          !! D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
          !! as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
          !! i-1 steps of Gaussian elimination. This means that the diagonal
          !! element at each step of "modified" Gaussian elimination is
          !! at least one in absolute value (so that division-by-zero not
          !! not possible during the division by the diagonal element);
          !! L is a M-by-N lower triangular matrix with unit diagonal elements
          !! (lower trapezoidal if M > N);
          !! and U is a M-by-N upper triangular matrix
          !! (upper trapezoidal if M < N).
          !! This routine is an auxiliary routine used in the Householder
          !! reconstruction routine CUNHR_COL. In CUNHR_COL, this routine is
          !! applied to an M-by-N matrix A with orthonormal columns, where each
          !! element is bounded by one in absolute value. With the choice of
          !! the matrix S above, one can show that the diagonal element at each
          !! step of Gaussian elimination is the largest (in absolute value) in
          !! the column on or below the diagonal, so that no pivoting is required
          !! for numerical stability [1].
          !! For more details on the Householder reconstruction algorithm,
          !! including the modified LU factorization, see [1].
          !! This is the blocked right-looking version of the algorithm,
          !! calling Level 3 BLAS to update the submatrix. To factorize a block,
          !! this routine calls the recursive routine LAUNHR_COL_GETRFNP2.
          !! [1] "Reconstructing Householder vectors from tall-skinny QR",
          !! G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
          !! E. Solomonik, J. Parallel Distrib. Comput.,
          !! vol. 85, pp. 3-31, 2015.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine claunhr_col_getrfnp( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: d(*)
               end subroutine claunhr_col_getrfnp
#else 
               module procedure stdlib_claunhr_col_getrfnp
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$launhr_col_getrfnp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlaunhr_col_getrfnp( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: d(*)
               end subroutine zlaunhr_col_getrfnp
#else 
               module procedure stdlib_zlaunhr_col_getrfnp
#endif
          end interface launhr_col_getrfnp



          interface launhr_col_getrfnp2
          !! LAUNHR_COL_GETRFNP2 computes the modified LU factorization without
          !! pivoting of a complex general M-by-N matrix A. The factorization has
          !! the form:
          !! A - S = L * U,
          !! where:
          !! S is a m-by-n diagonal sign matrix with the diagonal D, so that
          !! D(i) = S(i,i), 1 <= i <= min(M,N). The diagonal D is constructed
          !! as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
          !! i-1 steps of Gaussian elimination. This means that the diagonal
          !! element at each step of "modified" Gaussian elimination is at
          !! least one in absolute value (so that division-by-zero not
          !! possible during the division by the diagonal element);
          !! L is a M-by-N lower triangular matrix with unit diagonal elements
          !! (lower trapezoidal if M > N);
          !! and U is a M-by-N upper triangular matrix
          !! (upper trapezoidal if M < N).
          !! This routine is an auxiliary routine used in the Householder
          !! reconstruction routine CUNHR_COL. In CUNHR_COL, this routine is
          !! applied to an M-by-N matrix A with orthonormal columns, where each
          !! element is bounded by one in absolute value. With the choice of
          !! the matrix S above, one can show that the diagonal element at each
          !! step of Gaussian elimination is the largest (in absolute value) in
          !! the column on or below the diagonal, so that no pivoting is required
          !! for numerical stability [1].
          !! For more details on the Householder reconstruction algorithm,
          !! including the modified LU factorization, see [1].
          !! This is the recursive version of the LU factorization algorithm.
          !! Denote A - S by B. The algorithm divides the matrix B into four
          !! submatrices:
          !! [  B11 | B12  ]  where B11 is n1 by n1,
          !! B = [ -----|----- ]        B21 is (m-n1) by n1,
          !! [  B21 | B22  ]        B12 is n1 by n2,
          !! B22 is (m-n1) by n2,
          !! with n1 = min(m,n)/2, n2 = n-n1.
          !! The subroutine calls itself to factor B11, solves for B21,
          !! solves for B12, updates B22, then calls itself to factor B22.
          !! For more details on the recursive LU algorithm, see [2].
          !! LAUNHR_COL_GETRFNP2 is called to factorize a block by the blocked
          !! routine CLAUNHR_COL_GETRFNP, which uses blocked code calling
          !! Level 3 BLAS to update the submatrix. However, LAUNHR_COL_GETRFNP2
          !! is self-sufficient and can be used without CLAUNHR_COL_GETRFNP.
          !! [1] "Reconstructing Householder vectors from tall-skinny QR",
          !! G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
          !! E. Solomonik, J. Parallel Distrib. Comput.,
          !! vol. 85, pp. 3-31, 2015.
          !! [2] "Recursion leads to automatic variable blocking for dense linear
          !! algebra algorithms", F. Gustavson, IBM J. of Res. and Dev.,
          !! vol. 41, no. 6, pp. 737-755, 1997.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine claunhr_col_getrfnp2( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: d(*)
               end subroutine claunhr_col_getrfnp2
#else 
               module procedure stdlib_claunhr_col_getrfnp2
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$launhr_col_getrfnp2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine zlaunhr_col_getrfnp2( m, n, a, lda, d, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: d(*)
               end subroutine zlaunhr_col_getrfnp2
#else 
               module procedure stdlib_zlaunhr_col_getrfnp2
#endif
          end interface launhr_col_getrfnp2



          interface lauum
          !! LAUUM computes the product U * U**H or L**H * L, where the triangular
          !! factor U or L is stored in the upper or lower triangular part of
          !! the array A.
          !! If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
          !! overwriting the factor U in A.
          !! If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
          !! overwriting the factor L in A.
          !! This is the blocked form of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine clauum( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine clauum
#else 
               module procedure stdlib_clauum
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dlauum( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dlauum
#else 
               module procedure stdlib_dlauum
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lauum

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine slauum( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine slauum
#else 
               module procedure stdlib_slauum
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$lauum

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zlauum( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zlauum
#else 
               module procedure stdlib_zlauum
#endif
          end interface lauum



          interface opgtr
          !! OPGTR generates a real orthogonal matrix Q which is defined as the
          !! product of n-1 elementary reflectors H(i) of order n, as returned by
          !! DSPTRD using packed storage:
          !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
          !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dopgtr( uplo, n, ap, tau, q, ldq, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldq,n
                    real(dp), intent(in) :: ap(*),tau(*)
                    real(dp), intent(out) :: q(ldq,*),work(*)
               end subroutine dopgtr
#else 
               module procedure stdlib_dopgtr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$opgtr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sopgtr( uplo, n, ap, tau, q, ldq, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldq,n
                    real(sp), intent(in) :: ap(*),tau(*)
                    real(sp), intent(out) :: q(ldq,*),work(*)
               end subroutine sopgtr
#else 
               module procedure stdlib_sopgtr
#endif
          end interface opgtr



          interface opmtr
          !! OPMTR overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! where Q is a real orthogonal matrix of order nq, with nq = m if
          !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !! nq-1 elementary reflectors, as returned by DSPTRD using packed
          !! storage:
          !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
          !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dopmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,m,n
                    real(dp), intent(inout) :: ap(*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dopmtr
#else 
               module procedure stdlib_dopmtr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$opmtr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sopmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,m,n
                    real(sp), intent(inout) :: ap(*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sopmtr
#else 
               module procedure stdlib_sopmtr
#endif
          end interface opmtr



          interface orbdb
          !! ORBDB simultaneously bidiagonalizes the blocks of an M-by-M
          !! partitioned orthogonal matrix X:
          !! [ B11 | B12 0  0 ]
          !! [ X11 | X12 ]   [ P1 |    ] [  0  |  0 -I  0 ] [ Q1 |    ]**T
          !! X = [-----------] = [---------] [----------------] [---------]   .
          !! [ X21 | X22 ]   [    | P2 ] [ B21 | B22 0  0 ] [    | Q2 ]
          !! [  0  |  0  0  I ]
          !! X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
          !! not the case, then X must be transposed and/or permuted. This can be
          !! done in constant time using the TRANS and SIGNS options. See DORCSD
          !! for details.)
          !! The orthogonal matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
          !! (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
          !! represented implicitly by Householder vectors.
          !! B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
          !! implicitly by angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dorbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
                         ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: signs,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldx11,ldx12,ldx21,ldx22,lwork,m,p,q
                    real(dp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),tauq2(*),&
                              work(*)
                    real(dp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(ldx22,*)
                              
               end subroutine dorbdb
#else 
               module procedure stdlib_dorbdb
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orbdb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sorbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
                         ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: signs,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldx11,ldx12,ldx21,ldx22,lwork,m,p,q
                    real(sp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),tauq2(*),&
                              work(*)
                    real(sp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(ldx22,*)
                              
               end subroutine sorbdb
#else 
               module procedure stdlib_sorbdb
#endif
          end interface orbdb



          interface orbdb1
          !! ORBDB1 simultaneously bidiagonalizes the blocks of a tall and skinny
          !! matrix X with orthonomal columns:
          !! [ B11 ]
          !! [ X11 ]   [ P1 |    ] [  0  ]
          !! [-----] = [---------] [-----] Q1**T .
          !! [ X21 ]   [    | P2 ] [ B21 ]
          !! [  0  ]
          !! X11 is P-by-Q, and X21 is (M-P)-by-Q. Q must be no larger than P,
          !! M-P, or M-Q. Routines DORBDB2, DORBDB3, and DORBDB4 handle cases in
          !! which Q is not the minimum dimension.
          !! The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !! Householder vectors.
          !! B11 and B12 are Q-by-Q bidiagonal matrices represented implicitly by
          !! angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dorbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)
                              
                    real(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorbdb1
#else 
               module procedure stdlib_dorbdb1
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orbdb1

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sorbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)
                              
                    real(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorbdb1
#else 
               module procedure stdlib_sorbdb1
#endif
          end interface orbdb1



          interface orbdb2
          !! ORBDB2 simultaneously bidiagonalizes the blocks of a tall and skinny
          !! matrix X with orthonomal columns:
          !! [ B11 ]
          !! [ X11 ]   [ P1 |    ] [  0  ]
          !! [-----] = [---------] [-----] Q1**T .
          !! [ X21 ]   [    | P2 ] [ B21 ]
          !! [  0  ]
          !! X11 is P-by-Q, and X21 is (M-P)-by-Q. P must be no larger than M-P,
          !! Q, or M-Q. Routines DORBDB1, DORBDB3, and DORBDB4 handle cases in
          !! which P is not the minimum dimension.
          !! The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !! Householder vectors.
          !! B11 and B12 are P-by-P bidiagonal matrices represented implicitly by
          !! angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dorbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)
                              
                    real(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorbdb2
#else 
               module procedure stdlib_dorbdb2
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orbdb2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sorbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)
                              
                    real(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorbdb2
#else 
               module procedure stdlib_sorbdb2
#endif
          end interface orbdb2



          interface orbdb3
          !! ORBDB3 simultaneously bidiagonalizes the blocks of a tall and skinny
          !! matrix X with orthonomal columns:
          !! [ B11 ]
          !! [ X11 ]   [ P1 |    ] [  0  ]
          !! [-----] = [---------] [-----] Q1**T .
          !! [ X21 ]   [    | P2 ] [ B21 ]
          !! [  0  ]
          !! X11 is P-by-Q, and X21 is (M-P)-by-Q. M-P must be no larger than P,
          !! Q, or M-Q. Routines DORBDB1, DORBDB2, and DORBDB4 handle cases in
          !! which M-P is not the minimum dimension.
          !! The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !! Householder vectors.
          !! B11 and B12 are (M-P)-by-(M-P) bidiagonal matrices represented
          !! implicitly by angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dorbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)
                              
                    real(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorbdb3
#else 
               module procedure stdlib_dorbdb3
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orbdb3

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sorbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*),taup1(*),taup2(*),tauq1(*),work(*)
                              
                    real(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorbdb3
#else 
               module procedure stdlib_sorbdb3
#endif
          end interface orbdb3



          interface orbdb4
          !! ORBDB4 simultaneously bidiagonalizes the blocks of a tall and skinny
          !! matrix X with orthonomal columns:
          !! [ B11 ]
          !! [ X11 ]   [ P1 |    ] [  0  ]
          !! [-----] = [---------] [-----] Q1**T .
          !! [ X21 ]   [    | P2 ] [ B21 ]
          !! [  0  ]
          !! X11 is P-by-Q, and X21 is (M-P)-by-Q. M-Q must be no larger than P,
          !! M-P, or Q. Routines DORBDB1, DORBDB2, and DORBDB3 handle cases in
          !! which M-Q is not the minimum dimension.
          !! The orthogonal matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !! Householder vectors.
          !! B11 and B12 are (M-Q)-by-(M-Q) bidiagonal matrices represented
          !! implicitly by angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dorbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, phantom, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*),phantom(*),taup1(*),taup2(*),tauq1(*)&
                              ,work(*)
                    real(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorbdb4
#else 
               module procedure stdlib_dorbdb4
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orbdb4

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sorbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, phantom, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*),phantom(*),taup1(*),taup2(*),tauq1(*)&
                              ,work(*)
                    real(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorbdb4
#else 
               module procedure stdlib_sorbdb4
#endif
          end interface orbdb4



          interface orbdb5
          !! ORBDB5 orthogonalizes the column vector
          !! X = [ X1 ]
          !! [ X2 ]
          !! with respect to the columns of
          !! Q = [ Q1 ] .
          !! [ Q2 ]
          !! The columns of Q must be orthonormal.
          !! If the projection is zero according to Kahan's "twice is enough"
          !! criterion, then some other vector from the orthogonal complement
          !! is returned. This vector is chosen in an arbitrary but deterministic
          !! way.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    real(dp), intent(out) :: work(*)
                    real(dp), intent(inout) :: x1(*),x2(*)
               end subroutine dorbdb5
#else 
               module procedure stdlib_dorbdb5
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orbdb5

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    real(sp), intent(out) :: work(*)
                    real(sp), intent(inout) :: x1(*),x2(*)
               end subroutine sorbdb5
#else 
               module procedure stdlib_sorbdb5
#endif
          end interface orbdb5



          interface orbdb6
          !! ORBDB6 orthogonalizes the column vector
          !! X = [ X1 ]
          !! [ X2 ]
          !! with respect to the columns of
          !! Q = [ Q1 ] .
          !! [ Q2 ]
          !! The columns of Q must be orthonormal.
          !! If the projection is zero according to Kahan's "twice is enough"
          !! criterion, then the zero vector is returned.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    real(dp), intent(out) :: work(*)
                    real(dp), intent(inout) :: x1(*),x2(*)
               end subroutine dorbdb6
#else 
               module procedure stdlib_dorbdb6
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orbdb6

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    real(sp), intent(out) :: work(*)
                    real(sp), intent(inout) :: x1(*),x2(*)
               end subroutine sorbdb6
#else 
               module procedure stdlib_sorbdb6
#endif
          end interface orbdb6



          interface orcsd
          !! ORCSD computes the CS decomposition of an M-by-M partitioned
          !! orthogonal matrix X:
          !! [  I  0  0 |  0  0  0 ]
          !! [  0  C  0 |  0 -S  0 ]
          !! [ X11 | X12 ]   [ U1 |    ] [  0  0  0 |  0  0 -I ] [ V1 |    ]**T
          !! X = [-----------] = [---------] [---------------------] [---------]   .
          !! [ X21 | X22 ]   [    | U2 ] [  0  0  0 |  I  0  0 ] [    | V2 ]
          !! [  0  S  0 |  0  C  0 ]
          !! [  0  0  I |  0  0  0 ]
          !! X11 is P-by-Q. The orthogonal matrices U1, U2, V1, and V2 are P-by-P,
          !! (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
          !! R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
          !! which R = MIN(P,M-P,Q,M-Q).
#ifdef STDLIB_EXTERNAL_LAPACK
               recursive subroutine dorcsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, &
               x11, ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, &
                         ldv1t, v2t,ldv2t, work, lwork, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,signs,trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,ldx11,ldx12,ldx21,ldx22,&
                              lwork,m,p,q
                    real(dp), intent(out) :: theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(&
                              ldv2t,*),work(*)
                    real(dp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(ldx22,*)
                              
               end subroutine dorcsd
#else 
               module procedure stdlib_dorcsd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orcsd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               recursive subroutine sorcsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, &
               x11, ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, &
                         ldv1t, v2t,ldv2t, work, lwork, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,signs,trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,ldx11,ldx12,ldx21,ldx22,&
                              lwork,m,p,q
                    real(sp), intent(out) :: theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(&
                              ldv2t,*),work(*)
                    real(sp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(ldx22,*)
                              
               end subroutine sorcsd
#else 
               module procedure stdlib_sorcsd
#endif
          end interface orcsd



          interface orcsd2by1
          !! ORCSD2BY1 computes the CS decomposition of an M-by-Q matrix X with
          !! orthonormal columns that has been partitioned into a 2-by-1 block
          !! structure:
          !! [  I1 0  0 ]
          !! [  0  C  0 ]
          !! [ X11 ]   [ U1 |    ] [  0  0  0 ]
          !! X = [-----] = [---------] [----------] V1**T .
          !! [ X21 ]   [    | U2 ] [  0  0  0 ]
          !! [  0  S  0 ]
          !! [  0  0  I2]
          !! X11 is P-by-Q. The orthogonal matrices U1, U2, and V1 are P-by-P,
          !! (M-P)-by-(M-P), and Q-by-Q, respectively. C and S are R-by-R
          !! nonnegative diagonal matrices satisfying C^2 + S^2 = I, in which
          !! R = MIN(P,M-P,Q,M-Q). I1 is a K1-by-K1 identity matrix and I2 is a
          !! K2-by-K2 identity matrix, where K1 = MAX(Q+P-M,0), K2 = MAX(Q-P,0).
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dorcsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta,&
                          u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobu1,jobu2,jobv1t
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,lwork,ldx11,ldx21,m,p,q
                    real(dp), intent(out) :: theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),work(*)
                              
                    real(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine dorcsd2by1
#else 
               module procedure stdlib_dorcsd2by1
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orcsd2by1

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sorcsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta,&
                          u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobu1,jobu2,jobv1t
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,lwork,ldx11,ldx21,m,p,q
                    real(sp), intent(out) :: theta(*),u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),work(*)
                              
                    real(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine sorcsd2by1
#else 
               module procedure stdlib_sorcsd2by1
#endif
          end interface orcsd2by1



          interface org2l
          !! ORG2L generates an m by n real matrix Q with orthonormal columns,
          !! which is defined as the last n columns of a product of k elementary
          !! reflectors of order m
          !! Q  =  H(k) . . . H(2) H(1)
          !! as returned by DGEQLF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorg2l( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorg2l
#else 
               module procedure stdlib_dorg2l
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$org2l

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorg2l( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorg2l
#else 
               module procedure stdlib_sorg2l
#endif
          end interface org2l



          interface org2r
          !! ORG2R generates an m by n real matrix Q with orthonormal columns,
          !! which is defined as the first n columns of a product of k elementary
          !! reflectors of order m
          !! Q  =  H(1) H(2) . . . H(k)
          !! as returned by DGEQRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorg2r( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorg2r
#else 
               module procedure stdlib_dorg2r
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$org2r

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorg2r( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorg2r
#else 
               module procedure stdlib_sorg2r
#endif
          end interface org2r



          interface orgbr
          !! ORGBR generates one of the real orthogonal matrices Q or P**T
          !! determined by DGEBRD when reducing a real matrix A to bidiagonal
          !! form: A = Q * B * P**T.  Q and P**T are defined as products of
          !! elementary reflectors H(i) or G(i) respectively.
          !! If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
          !! is of order M:
          !! if m >= k, Q = H(1) H(2) . . . H(k) and ORGBR returns the first n
          !! columns of Q, where m >= n >= k;
          !! if m < k, Q = H(1) H(2) . . . H(m-1) and ORGBR returns Q as an
          !! M-by-M matrix.
          !! If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
          !! is of order N:
          !! if k < n, P**T = G(k) . . . G(2) G(1) and ORGBR returns the first m
          !! rows of P**T, where n >= m >= k;
          !! if k >= n, P**T = G(n-1) . . . G(2) G(1) and ORGBR returns P**T as
          !! an N-by-N matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorgbr( vect, m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgbr
#else 
               module procedure stdlib_dorgbr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orgbr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorgbr( vect, m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgbr
#else 
               module procedure stdlib_sorgbr
#endif
          end interface orgbr



          interface orghr
          !! ORGHR generates a real orthogonal matrix Q which is defined as the
          !! product of IHI-ILO elementary reflectors of order N, as returned by
          !! DGEHRD:
          !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorghr
#else 
               module procedure stdlib_dorghr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orghr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorghr
#else 
               module procedure stdlib_sorghr
#endif
          end interface orghr



          interface orglq
          !! ORGLQ generates an M-by-N real matrix Q with orthonormal rows,
          !! which is defined as the first M rows of a product of K elementary
          !! reflectors of order N
          !! Q  =  H(k) . . . H(2) H(1)
          !! as returned by DGELQF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorglq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorglq
#else 
               module procedure stdlib_dorglq
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orglq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorglq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorglq
#else 
               module procedure stdlib_sorglq
#endif
          end interface orglq



          interface orgql
          !! ORGQL generates an M-by-N real matrix Q with orthonormal columns,
          !! which is defined as the last N columns of a product of K elementary
          !! reflectors of order M
          !! Q  =  H(k) . . . H(2) H(1)
          !! as returned by DGEQLF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorgql( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgql
#else 
               module procedure stdlib_dorgql
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orgql

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorgql( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgql
#else 
               module procedure stdlib_sorgql
#endif
          end interface orgql



          interface orgqr
          !! ORGQR generates an M-by-N real matrix Q with orthonormal columns,
          !! which is defined as the first N columns of a product of K elementary
          !! reflectors of order M
          !! Q  =  H(1) H(2) . . . H(k)
          !! as returned by DGEQRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorgqr( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgqr
#else 
               module procedure stdlib_dorgqr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orgqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorgqr( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgqr
#else 
               module procedure stdlib_sorgqr
#endif
          end interface orgqr



          interface orgrq
          !! ORGRQ generates an M-by-N real matrix Q with orthonormal rows,
          !! which is defined as the last M rows of a product of K elementary
          !! reflectors of order N
          !! Q  =  H(1) H(2) . . . H(k)
          !! as returned by DGERQF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorgrq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgrq
#else 
               module procedure stdlib_dorgrq
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orgrq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorgrq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgrq
#else 
               module procedure stdlib_sorgrq
#endif
          end interface orgrq



          interface orgtr
          !! ORGTR generates a real orthogonal matrix Q which is defined as the
          !! product of n-1 elementary reflectors of order N, as returned by
          !! DSYTRD:
          !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
          !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorgtr( uplo, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgtr
#else 
               module procedure stdlib_dorgtr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orgtr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorgtr( uplo, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgtr
#else 
               module procedure stdlib_sorgtr
#endif
          end interface orgtr



          interface orgtsqr
          !! ORGTSQR generates an M-by-N real matrix Q_out with orthonormal columns,
          !! which are the first N columns of a product of real orthogonal
          !! matrices of order M which are returned by DLATSQR
          !! Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).
          !! See the documentation for DLATSQR.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorgtsqr( m, n, mb, nb, a, lda, t, ldt, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: t(ldt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgtsqr
#else 
               module procedure stdlib_dorgtsqr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orgtsqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorgtsqr( m, n, mb, nb, a, lda, t, ldt, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: t(ldt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgtsqr
#else 
               module procedure stdlib_sorgtsqr
#endif
          end interface orgtsqr



          interface orgtsqr_row
          !! ORGTSQR_ROW generates an M-by-N real matrix Q_out with
          !! orthonormal columns from the output of DLATSQR. These N orthonormal
          !! columns are the first N columns of a product of complex unitary
          !! matrices Q(k)_in of order M, which are returned by DLATSQR in
          !! a special format.
          !! Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).
          !! The input matrices Q(k)_in are stored in row and column blocks in A.
          !! See the documentation of DLATSQR for more details on the format of
          !! Q(k)_in, where each Q(k)_in is represented by block Householder
          !! transformations. This routine calls an auxiliary routine DLARFB_GETT,
          !! where the computation is performed on each individual block. The
          !! algorithm first sweeps NB-sized column blocks from the right to left
          !! starting in the bottom row block and continues to the top row block
          !! (hence _ROW in the routine name). This sweep is in reverse order of
          !! the order in which DLATSQR generates the output blocks.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorgtsqr_row( m, n, mb, nb, a, lda, t, ldt, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: t(ldt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorgtsqr_row
#else 
               module procedure stdlib_dorgtsqr_row
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orgtsqr_row

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorgtsqr_row( m, n, mb, nb, a, lda, t, ldt, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: t(ldt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorgtsqr_row
#else 
               module procedure stdlib_sorgtsqr_row
#endif
          end interface orgtsqr_row



          interface orhr_col
          !! ORHR_COL takes an M-by-N real matrix Q_in with orthonormal columns
          !! as input, stored in A, and performs Householder Reconstruction (HR),
          !! i.e. reconstructs Householder vectors V(i) implicitly representing
          !! another M-by-N matrix Q_out, with the property that Q_in = Q_out*S,
          !! where S is an N-by-N diagonal matrix with diagonal entries
          !! equal to +1 or -1. The Householder vectors (columns V(i) of V) are
          !! stored in A on output, and the diagonal entries of S are stored in D.
          !! Block reflectors are also returned in T
          !! (same output format as DGEQRT).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorhr_col( m, n, nb, a, lda, t, ldt, d, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,nb
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*),t(ldt,*)
               end subroutine dorhr_col
#else 
               module procedure stdlib_dorhr_col
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orhr_col

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorhr_col( m, n, nb, a, lda, t, ldt, d, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,nb
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*),t(ldt,*)
               end subroutine sorhr_col
#else 
               module procedure stdlib_sorhr_col
#endif
          end interface orhr_col



          interface orm2l
          !! ORM2L overwrites the general real m by n matrix C with
          !! Q * C  if SIDE = 'L' and TRANS = 'N', or
          !! Q**T * C  if SIDE = 'L' and TRANS = 'T', or
          !! C * Q  if SIDE = 'R' and TRANS = 'N', or
          !! C * Q**T if SIDE = 'R' and TRANS = 'T',
          !! where Q is a real orthogonal matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(k) . . . H(2) H(1)
          !! as returned by DGEQLF. Q is of order m if SIDE = 'L' and of order n
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorm2l( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorm2l
#else 
               module procedure stdlib_dorm2l
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orm2l

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorm2l( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorm2l
#else 
               module procedure stdlib_sorm2l
#endif
          end interface orm2l



          interface orm2r
          !! ORM2R overwrites the general real m by n matrix C with
          !! Q * C  if SIDE = 'L' and TRANS = 'N', or
          !! Q**T* C  if SIDE = 'L' and TRANS = 'T', or
          !! C * Q  if SIDE = 'R' and TRANS = 'N', or
          !! C * Q**T if SIDE = 'R' and TRANS = 'T',
          !! where Q is a real orthogonal matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(1) H(2) . . . H(k)
          !! as returned by DGEQRF. Q is of order m if SIDE = 'L' and of order n
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dorm2r( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dorm2r
#else 
               module procedure stdlib_dorm2r
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$orm2r

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sorm2r( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sorm2r
#else 
               module procedure stdlib_sorm2r
#endif
          end interface orm2r



          interface ormbr
          !! If VECT = 'Q', ORMBR: overwrites the general real M-by-N matrix C
          !! with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! If VECT = 'P', ORMBR overwrites the general real M-by-N matrix C
          !! with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      P * C          C * P
          !! TRANS = 'T':      P**T * C       C * P**T
          !! Here Q and P**T are the orthogonal matrices determined by DGEBRD when
          !! reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and
          !! P**T are defined as products of elementary reflectors H(i) and G(i)
          !! respectively.
          !! Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
          !! order of the orthogonal matrix Q or P**T that is applied.
          !! If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
          !! if nq >= k, Q = H(1) H(2) . . . H(k);
          !! if nq < k, Q = H(1) H(2) . . . H(nq-1).
          !! If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
          !! if k < nq, P = G(1) G(2) . . . G(k);
          !! if k >= nq, P = G(1) G(2) . . . G(nq-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dormbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormbr
#else 
               module procedure stdlib_dormbr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ormbr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sormbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormbr
#else 
               module procedure stdlib_sormbr
#endif
          end interface ormbr



          interface ormhr
          !! ORMHR overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! where Q is a real orthogonal matrix of order nq, with nq = m if
          !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !! IHI-ILO elementary reflectors, as returned by DGEHRD:
          !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(in) :: ihi,ilo,lda,ldc,lwork,m,n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormhr
#else 
               module procedure stdlib_dormhr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ormhr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(in) :: ihi,ilo,lda,ldc,lwork,m,n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormhr
#else 
               module procedure stdlib_sormhr
#endif
          end interface ormhr



          interface ormlq
          !! ORMLQ overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! where Q is a real orthogonal matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(k) . . . H(2) H(1)
          !! as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dormlq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormlq
#else 
               module procedure stdlib_dormlq
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ormlq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sormlq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormlq
#else 
               module procedure stdlib_sormlq
#endif
          end interface ormlq



          interface ormql
          !! ORMQL overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! where Q is a real orthogonal matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(k) . . . H(2) H(1)
          !! as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dormql( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormql
#else 
               module procedure stdlib_dormql
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ormql

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sormql( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormql
#else 
               module procedure stdlib_sormql
#endif
          end interface ormql



          interface ormqr
          !! ORMQR overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! where Q is a real orthogonal matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(1) H(2) . . . H(k)
          !! as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dormqr( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormqr
#else 
               module procedure stdlib_dormqr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ormqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sormqr( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormqr
#else 
               module procedure stdlib_sormqr
#endif
          end interface ormqr



          interface ormrq
          !! ORMRQ overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! where Q is a real orthogonal matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(1) H(2) . . . H(k)
          !! as returned by DGERQF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dormrq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormrq
#else 
               module procedure stdlib_dormrq
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ormrq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sormrq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormrq
#else 
               module procedure stdlib_sormrq
#endif
          end interface ormrq



          interface ormrz
          !! ORMRZ overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! where Q is a real orthogonal matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(1) H(2) . . . H(k)
          !! as returned by DTZRZF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dormrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,l,lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormrz
#else 
               module procedure stdlib_dormrz
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ormrz

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sormrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,l,lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormrz
#else 
               module procedure stdlib_sormrz
#endif
          end interface ormrz



          interface ormtr
          !! ORMTR overwrites the general real M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'T':      Q**T * C       C * Q**T
          !! where Q is a real orthogonal matrix of order nq, with nq = m if
          !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !! nq-1 elementary reflectors, as returned by DSYTRD:
          !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
          !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dormtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldc,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(dp), intent(in) :: tau(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dormtr
#else 
               module procedure stdlib_dormtr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ormtr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sormtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldc,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    real(sp), intent(in) :: tau(*)
                    real(sp), intent(out) :: work(*)
               end subroutine sormtr
#else 
               module procedure stdlib_sormtr
#endif
          end interface ormtr



          interface pbcon
          !! PBCON estimates the reciprocal of the condition number (in the
          !! 1-norm) of a complex Hermitian positive definite band matrix using
          !! the Cholesky factorization A = U**H*U or A = L*L**H computed by
          !! CPBTRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,rwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cpbcon
#else 
               module procedure stdlib_cpbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(in) :: anorm,ab(ldab,*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dpbcon
#else 
               module procedure stdlib_dpbcon
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pbcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(in) :: anorm,ab(ldab,*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine spbcon
#else 
               module procedure stdlib_spbcon
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pbcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpbcon( uplo, n, kd, ab, ldab, anorm, rcond, work,rwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zpbcon
#else 
               module procedure stdlib_zpbcon
#endif
          end interface pbcon



          interface pbequ
          !! PBEQU computes row and column scalings intended to equilibrate a
          !! Hermitian positive definite band matrix A and reduce its condition
          !! number (with respect to the two-norm).  S contains the scale factors,
          !! S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
          !! elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
          !! choice of S puts the condition number of B within a factor N of the
          !! smallest possible condition number over all possible diagonal
          !! scalings.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    complex(sp), intent(in) :: ab(ldab,*)
               end subroutine cpbequ
#else 
               module procedure stdlib_cpbequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    real(dp), intent(in) :: ab(ldab,*)
               end subroutine dpbequ
#else 
               module procedure stdlib_dpbequ
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pbequ

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    real(sp), intent(in) :: ab(ldab,*)
               end subroutine spbequ
#else 
               module procedure stdlib_spbequ
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pbequ

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpbequ( uplo, n, kd, ab, ldab, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    complex(dp), intent(in) :: ab(ldab,*)
               end subroutine zpbequ
#else 
               module procedure stdlib_zpbequ
#endif
          end interface pbequ



          interface pbrfs
          !! PBRFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is Hermitian positive definite
          !! and banded, and provides error bounds and backward error estimates
          !! for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,ldb, x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldafb,ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cpbrfs
#else 
               module procedure stdlib_cpbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,ldb, x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,ldafb,ldb,ldx,n,nrhs
                    real(dp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dpbrfs
#else 
               module procedure stdlib_dpbrfs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pbrfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,ldb, x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,ldafb,ldb,ldx,n,nrhs
                    real(sp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine spbrfs
#else 
               module procedure stdlib_spbrfs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pbrfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpbrfs( uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b,ldb, x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldafb,ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*),afb(ldafb,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zpbrfs
#else 
               module procedure stdlib_zpbrfs
#endif
          end interface pbrfs



          interface pbstf
          !! PBSTF computes a split Cholesky factorization of a complex
          !! Hermitian positive definite band matrix A.
          !! This routine is designed to be used in conjunction with CHBGST.
          !! The factorization has the form  A = S**H*S  where S is a band matrix
          !! of the same bandwidth as A and the following structure:
          !! S = ( U    )
          !! ( M  L )
          !! where U is upper triangular of order m = (n+kd)/2, and L is lower
          !! triangular of order n-m.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpbstf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine cpbstf
#else 
               module procedure stdlib_cpbstf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpbstf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dpbstf
#else 
               module procedure stdlib_dpbstf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pbstf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spbstf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine spbstf
#else 
               module procedure stdlib_spbstf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pbstf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpbstf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zpbstf
#else 
               module procedure stdlib_zpbstf
#endif
          end interface pbstf



          interface pbsv
          !! PBSV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N Hermitian positive definite band matrix and X
          !! and B are N-by-NRHS matrices.
          !! The Cholesky decomposition is used to factor A as
          !! A = U**H * U,  if UPLO = 'U', or
          !! A = L * L**H,  if UPLO = 'L',
          !! where U is an upper triangular band matrix, and L is a lower
          !! triangular band matrix, with the same number of superdiagonals or
          !! subdiagonals as A.  The factored form of A is then used to solve the
          !! system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(sp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine cpbsv
#else 
               module procedure stdlib_cpbsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(dp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine dpbsv
#else 
               module procedure stdlib_dpbsv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pbsv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(sp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine spbsv
#else 
               module procedure stdlib_spbsv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pbsv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(dp), intent(inout) :: ab(ldab,*),b(ldb,*)
               end subroutine zpbsv
#else 
               module procedure stdlib_zpbsv
#endif
          end interface pbsv



          interface pbtrf
          !! PBTRF computes the Cholesky factorization of a complex Hermitian
          !! positive definite band matrix A.
          !! The factorization has the form
          !! A = U**H * U,  if UPLO = 'U', or
          !! A = L  * L**H,  if UPLO = 'L',
          !! where U is an upper triangular matrix and L is lower triangular.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpbtrf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    complex(sp), intent(inout) :: ab(ldab,*)
               end subroutine cpbtrf
#else 
               module procedure stdlib_cpbtrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpbtrf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dpbtrf
#else 
               module procedure stdlib_dpbtrf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pbtrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spbtrf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine spbtrf
#else 
               module procedure stdlib_spbtrf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pbtrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpbtrf( uplo, n, kd, ab, ldab, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    complex(dp), intent(inout) :: ab(ldab,*)
               end subroutine zpbtrf
#else 
               module procedure stdlib_zpbtrf
#endif
          end interface pbtrf



          interface pbtrs
          !! PBTRS solves a system of linear equations A*X = B with a Hermitian
          !! positive definite band matrix A using the Cholesky factorization
          !! A = U**H*U or A = L*L**H computed by CPBTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cpbtrs
#else 
               module procedure stdlib_cpbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dpbtrs
#else 
               module procedure stdlib_dpbtrs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pbtrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine spbtrs
#else 
               module procedure stdlib_spbtrs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pbtrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zpbtrs
#else 
               module procedure stdlib_zpbtrs
#endif
          end interface pbtrs



          interface pftrf
          !! PFTRF computes the Cholesky factorization of a complex Hermitian
          !! positive definite matrix A.
          !! The factorization has the form
          !! A = U**H * U,  if UPLO = 'U', or
          !! A = L  * L**H,  if UPLO = 'L',
          !! where U is an upper triangular matrix and L is lower triangular.
          !! This is the block version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpftrf( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(in) :: n
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(inout) :: a(0:*)
               end subroutine cpftrf
#else 
               module procedure stdlib_cpftrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpftrf( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(in) :: n
                    integer(ilp), intent(out) :: info
                    real(dp), intent(inout) :: a(0:*)
               end subroutine dpftrf
#else 
               module procedure stdlib_dpftrf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pftrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spftrf( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(in) :: n
                    integer(ilp), intent(out) :: info
                    real(sp), intent(inout) :: a(0:*)
               end subroutine spftrf
#else 
               module procedure stdlib_spftrf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pftrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpftrf( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(in) :: n
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(inout) :: a(0:*)
               end subroutine zpftrf
#else 
               module procedure stdlib_zpftrf
#endif
          end interface pftrf



          interface pftri
          !! PFTRI computes the inverse of a complex Hermitian positive definite
          !! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
          !! computed by CPFTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpftri( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: a(0:*)
               end subroutine cpftri
#else 
               module procedure stdlib_cpftri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpftri( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: a(0:*)
               end subroutine dpftri
#else 
               module procedure stdlib_dpftri
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pftri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spftri( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: a(0:*)
               end subroutine spftri
#else 
               module procedure stdlib_spftri
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pftri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpftri( transr, uplo, n, a, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: a(0:*)
               end subroutine zpftri
#else 
               module procedure stdlib_zpftri
#endif
          end interface pftri



          interface pftrs
          !! PFTRS solves a system of linear equations A*X = B with a Hermitian
          !! positive definite matrix A using the Cholesky factorization
          !! A = U**H*U or A = L*L**H computed by CPFTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpftrs( transr, uplo, n, nrhs, a, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(in) :: a(0:*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cpftrs
#else 
               module procedure stdlib_cpftrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpftrs( transr, uplo, n, nrhs, a, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(in) :: a(0:*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dpftrs
#else 
               module procedure stdlib_dpftrs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pftrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spftrs( transr, uplo, n, nrhs, a, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(in) :: a(0:*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine spftrs
#else 
               module procedure stdlib_spftrs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pftrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpftrs( transr, uplo, n, nrhs, a, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(in) :: a(0:*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zpftrs
#else 
               module procedure stdlib_zpftrs
#endif
          end interface pftrs



          interface pocon
          !! POCON estimates the reciprocal of the condition number (in the
          !! 1-norm) of a complex Hermitian positive definite matrix using the
          !! Cholesky factorization A = U**H*U or A = L*L**H computed by CPOTRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpocon( uplo, n, a, lda, anorm, rcond, work, rwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cpocon
#else 
               module procedure stdlib_cpocon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpocon( uplo, n, a, lda, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,work(*)
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dpocon
#else 
               module procedure stdlib_dpocon
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pocon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spocon( uplo, n, a, lda, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,work(*)
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine spocon
#else 
               module procedure stdlib_spocon
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pocon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpocon( uplo, n, a, lda, anorm, rcond, work, rwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zpocon
#else 
               module procedure stdlib_zpocon
#endif
          end interface pocon



          interface poequ
          !! POEQU computes row and column scalings intended to equilibrate a
          !! Hermitian positive definite matrix A and reduce its condition number
          !! (with respect to the two-norm).  S contains the scale factors,
          !! S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
          !! elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
          !! choice of S puts the condition number of B within a factor N of the
          !! smallest possible condition number over all possible diagonal
          !! scalings.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpoequ( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    complex(sp), intent(in) :: a(lda,*)
               end subroutine cpoequ
#else 
               module procedure stdlib_cpoequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpoequ( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dpoequ
#else 
               module procedure stdlib_dpoequ
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$poequ

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spoequ( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    real(sp), intent(in) :: a(lda,*)
               end subroutine spoequ
#else 
               module procedure stdlib_spoequ
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$poequ

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpoequ( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    complex(dp), intent(in) :: a(lda,*)
               end subroutine zpoequ
#else 
               module procedure stdlib_zpoequ
#endif
          end interface poequ



          interface poequb
          !! POEQUB computes row and column scalings intended to equilibrate a
          !! Hermitian positive definite matrix A and reduce its condition number
          !! (with respect to the two-norm).  S contains the scale factors,
          !! S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
          !! elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
          !! choice of S puts the condition number of B within a factor N of the
          !! smallest possible condition number over all possible diagonal
          !! scalings.
          !! This routine differs from CPOEQU by restricting the scaling factors
          !! to a power of the radix.  Barring over- and underflow, scaling by
          !! these factors introduces no additional rounding errors.  However, the
          !! scaled diagonal entries are no longer approximately 1 but lie
          !! between sqrt(radix) and 1/sqrt(radix).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpoequb( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    complex(sp), intent(in) :: a(lda,*)
               end subroutine cpoequb
#else 
               module procedure stdlib_cpoequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpoequb( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dpoequb
#else 
               module procedure stdlib_dpoequb
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$poequb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spoequb( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    real(sp), intent(in) :: a(lda,*)
               end subroutine spoequb
#else 
               module procedure stdlib_spoequb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$poequb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpoequb( n, a, lda, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    complex(dp), intent(in) :: a(lda,*)
               end subroutine zpoequb
#else 
               module procedure stdlib_zpoequb
#endif
          end interface poequb



          interface porfs
          !! PORFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is Hermitian positive definite,
          !! and provides error bounds and backward error estimates for the
          !! solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,ldx, ferr, berr,&
                          work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cporfs
#else 
               module procedure stdlib_cporfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,ldx, ferr, berr,&
                          work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dporfs
#else 
               module procedure stdlib_dporfs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$porfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,ldx, ferr, berr,&
                          work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine sporfs
#else 
               module procedure stdlib_sporfs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$porfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zporfs( uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x,ldx, ferr, berr,&
                          work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zporfs
#else 
               module procedure stdlib_zporfs
#endif
          end interface porfs



          interface posv
          !! POSV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N Hermitian positive definite matrix and X and B
          !! are N-by-NRHS matrices.
          !! The Cholesky decomposition is used to factor A as
          !! A = U**H* U,  if UPLO = 'U', or
          !! A = L * L**H,  if UPLO = 'L',
          !! where U is an upper triangular matrix and  L is a lower triangular
          !! matrix.  The factored form of A is then used to solve the system of
          !! equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cposv( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine cposv
#else 
               module procedure stdlib_cposv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dposv( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine dposv
#else 
               module procedure stdlib_dposv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$posv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sposv( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine sposv
#else 
               module procedure stdlib_sposv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$posv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zposv( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
               end subroutine zposv
#else 
               module procedure stdlib_zposv
#endif
          end interface posv



          interface potrf
          !! POTRF computes the Cholesky factorization of a complex Hermitian
          !! positive definite matrix A.
          !! The factorization has the form
          !! A = U**H * U,  if UPLO = 'U', or
          !! A = L  * L**H,  if UPLO = 'L',
          !! where U is an upper triangular matrix and L is lower triangular.
          !! This is the block version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpotrf( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cpotrf
#else 
               module procedure stdlib_cpotrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpotrf( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dpotrf
#else 
               module procedure stdlib_dpotrf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$potrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spotrf( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine spotrf
#else 
               module procedure stdlib_spotrf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$potrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpotrf( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zpotrf
#else 
               module procedure stdlib_zpotrf
#endif
          end interface potrf



          interface potrf2
          !! POTRF2 computes the Cholesky factorization of a Hermitian
          !! positive definite matrix A using the recursive algorithm.
          !! The factorization has the form
          !! A = U**H * U,  if UPLO = 'U', or
          !! A = L  * L**H,  if UPLO = 'L',
          !! where U is an upper triangular matrix and L is lower triangular.
          !! This is the recursive version of the algorithm. It divides
          !! the matrix into four submatrices:
          !! [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2
          !! A = [ -----|----- ]  with n1 = n/2
          !! [  A21 | A22  ]       n2 = n-n1
          !! The subroutine calls itself to factor A11. Update and scale A21
          !! or A12, update A22 then calls itself to factor A22.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine cpotrf2( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cpotrf2
#else 
               module procedure stdlib_cpotrf2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine dpotrf2( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dpotrf2
#else 
               module procedure stdlib_dpotrf2
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$potrf2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine spotrf2( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine spotrf2
#else 
               module procedure stdlib_spotrf2
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$potrf2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure recursive subroutine zpotrf2( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zpotrf2
#else 
               module procedure stdlib_zpotrf2
#endif
          end interface potrf2



          interface potri
          !! POTRI computes the inverse of a complex Hermitian positive definite
          !! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
          !! computed by CPOTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpotri( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine cpotri
#else 
               module procedure stdlib_cpotri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpotri( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dpotri
#else 
               module procedure stdlib_dpotri
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$potri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spotri( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine spotri
#else 
               module procedure stdlib_spotri
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$potri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpotri( uplo, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zpotri
#else 
               module procedure stdlib_zpotri
#endif
          end interface potri



          interface potrs
          !! POTRS solves a system of linear equations A*X = B with a Hermitian
          !! positive definite matrix A using the Cholesky factorization
          !! A = U**H*U or A = L*L**H computed by CPOTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cpotrs
#else 
               module procedure stdlib_cpotrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dpotrs
#else 
               module procedure stdlib_dpotrs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$potrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spotrs( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine spotrs
#else 
               module procedure stdlib_spotrs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$potrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zpotrs
#else 
               module procedure stdlib_zpotrs
#endif
          end interface potrs



          interface ppcon
          !! PPCON estimates the reciprocal of the condition number (in the
          !! 1-norm) of a complex Hermitian positive definite packed matrix using
          !! the Cholesky factorization A = U**H*U or A = L*L**H computed by
          !! CPPTRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cppcon( uplo, n, ap, anorm, rcond, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cppcon
#else 
               module procedure stdlib_cppcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dppcon( uplo, n, ap, anorm, rcond, work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: anorm,ap(*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dppcon
#else 
               module procedure stdlib_dppcon
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ppcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sppcon( uplo, n, ap, anorm, rcond, work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: anorm,ap(*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine sppcon
#else 
               module procedure stdlib_sppcon
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ppcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zppcon( uplo, n, ap, anorm, rcond, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zppcon
#else 
               module procedure stdlib_zppcon
#endif
          end interface ppcon



          interface ppequ
          !! PPEQU computes row and column scalings intended to equilibrate a
          !! Hermitian positive definite matrix A in packed storage and reduce
          !! its condition number (with respect to the two-norm).  S contains the
          !! scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
          !! B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
          !! This choice of S puts the condition number of B within a factor N of
          !! the smallest possible condition number over all possible diagonal
          !! scalings.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cppequ( uplo, n, ap, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: amax,scond,s(*)
                    complex(sp), intent(in) :: ap(*)
               end subroutine cppequ
#else 
               module procedure stdlib_cppequ
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dppequ( uplo, n, ap, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: amax,scond,s(*)
                    real(dp), intent(in) :: ap(*)
               end subroutine dppequ
#else 
               module procedure stdlib_dppequ
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ppequ

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sppequ( uplo, n, ap, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: amax,scond,s(*)
                    real(sp), intent(in) :: ap(*)
               end subroutine sppequ
#else 
               module procedure stdlib_sppequ
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ppequ

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zppequ( uplo, n, ap, s, scond, amax, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: amax,scond,s(*)
                    complex(dp), intent(in) :: ap(*)
               end subroutine zppequ
#else 
               module procedure stdlib_zppequ
#endif
          end interface ppequ



          interface pprfs
          !! PPRFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is Hermitian positive definite
          !! and packed, and provides error bounds and backward error estimates
          !! for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,berr, work, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cpprfs
#else 
               module procedure stdlib_cpprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,berr, work, &
                         iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dpprfs
#else 
               module procedure stdlib_dpprfs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pprfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,berr, work, &
                         iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine spprfs
#else 
               module procedure stdlib_spprfs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pprfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpprfs( uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr,berr, work, &
                         rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zpprfs
#else 
               module procedure stdlib_zpprfs
#endif
          end interface pprfs



          interface ppsv
          !! PPSV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N Hermitian positive definite matrix stored in
          !! packed format and X and B are N-by-NRHS matrices.
          !! The Cholesky decomposition is used to factor A as
          !! A = U**H * U,  if UPLO = 'U', or
          !! A = L * L**H,  if UPLO = 'L',
          !! where U is an upper triangular matrix and L is a lower triangular
          !! matrix.  The factored form of A is then used to solve the system of
          !! equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cppsv( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine cppsv
#else 
               module procedure stdlib_cppsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dppsv( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine dppsv
#else 
               module procedure stdlib_dppsv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ppsv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sppsv( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine sppsv
#else 
               module procedure stdlib_sppsv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ppsv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zppsv( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine zppsv
#else 
               module procedure stdlib_zppsv
#endif
          end interface ppsv



          interface pptrf
          !! PPTRF computes the Cholesky factorization of a complex Hermitian
          !! positive definite matrix A stored in packed format.
          !! The factorization has the form
          !! A = U**H * U,  if UPLO = 'U', or
          !! A = L  * L**H,  if UPLO = 'L',
          !! where U is an upper triangular matrix and L is lower triangular.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpptrf( uplo, n, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: ap(*)
               end subroutine cpptrf
#else 
               module procedure stdlib_cpptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpptrf( uplo, n, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: ap(*)
               end subroutine dpptrf
#else 
               module procedure stdlib_dpptrf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pptrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spptrf( uplo, n, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: ap(*)
               end subroutine spptrf
#else 
               module procedure stdlib_spptrf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pptrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpptrf( uplo, n, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zpptrf
#else 
               module procedure stdlib_zpptrf
#endif
          end interface pptrf



          interface pptri
          !! PPTRI computes the inverse of a complex Hermitian positive definite
          !! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
          !! computed by CPPTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpptri( uplo, n, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: ap(*)
               end subroutine cpptri
#else 
               module procedure stdlib_cpptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpptri( uplo, n, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: ap(*)
               end subroutine dpptri
#else 
               module procedure stdlib_dpptri
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pptri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spptri( uplo, n, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: ap(*)
               end subroutine spptri
#else 
               module procedure stdlib_spptri
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pptri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpptri( uplo, n, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zpptri
#else 
               module procedure stdlib_zpptri
#endif
          end interface pptri



          interface pptrs
          !! PPTRS solves a system of linear equations A*X = B with a Hermitian
          !! positive definite matrix A in packed storage using the Cholesky
          !! factorization A = U**H*U or A = L*L**H computed by CPPTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpptrs( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine cpptrs
#else 
               module procedure stdlib_cpptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpptrs( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dpptrs
#else 
               module procedure stdlib_dpptrs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pptrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spptrs( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine spptrs
#else 
               module procedure stdlib_spptrs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pptrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpptrs( uplo, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zpptrs
#else 
               module procedure stdlib_zpptrs
#endif
          end interface pptrs



          interface pstrf
          !! PSTRF computes the Cholesky factorization with complete
          !! pivoting of a complex Hermitian positive semidefinite matrix A.
          !! The factorization has the form
          !! P**T * A * P = U**H * U ,  if UPLO = 'U',
          !! P**T * A * P = L  * L**H,  if UPLO = 'L',
          !! where U is an upper triangular matrix and L is lower triangular, and
          !! P is stored as vector PIV.
          !! This algorithm does not attempt to check that A is positive
          !! semidefinite. This version of the algorithm calls level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpstrf( uplo, n, a, lda, piv, rank, tol, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: tol
                    integer(ilp), intent(out) :: info,rank,piv(n)
                    integer(ilp), intent(in) :: lda,n
                    character, intent(in) :: uplo
                    complex(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(2*n)
               end subroutine cpstrf
#else 
               module procedure stdlib_cpstrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpstrf( uplo, n, a, lda, piv, rank, tol, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: tol
                    integer(ilp), intent(out) :: info,rank,piv(n)
                    integer(ilp), intent(in) :: lda,n
                    character, intent(in) :: uplo
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(2*n)
               end subroutine dpstrf
#else 
               module procedure stdlib_dpstrf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pstrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spstrf( uplo, n, a, lda, piv, rank, tol, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: tol
                    integer(ilp), intent(out) :: info,rank,piv(n)
                    integer(ilp), intent(in) :: lda,n
                    character, intent(in) :: uplo
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(2*n)
               end subroutine spstrf
#else 
               module procedure stdlib_spstrf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pstrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpstrf( uplo, n, a, lda, piv, rank, tol, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: tol
                    integer(ilp), intent(out) :: info,rank,piv(n)
                    integer(ilp), intent(in) :: lda,n
                    character, intent(in) :: uplo
                    complex(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(2*n)
               end subroutine zpstrf
#else 
               module procedure stdlib_zpstrf
#endif
          end interface pstrf



          interface ptcon
          !! PTCON computes the reciprocal of the condition number (in the
          !! 1-norm) of a complex Hermitian positive definite tridiagonal matrix
          !! using the factorization A = L*D*L**H or A = U**H*D*U computed by
          !! CPTTRF.
          !! Norm(inv(A)) is computed by a direct method, and the reciprocal of
          !! the condition number is computed as
          !! RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cptcon( n, d, e, anorm, rcond, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: anorm,d(*)
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: e(*)
               end subroutine cptcon
#else 
               module procedure stdlib_cptcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dptcon( n, d, e, anorm, rcond, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: anorm,d(*),e(*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dptcon
#else 
               module procedure stdlib_dptcon
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ptcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sptcon( n, d, e, anorm, rcond, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: anorm,d(*),e(*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine sptcon
#else 
               module procedure stdlib_sptcon
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ptcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zptcon( n, d, e, anorm, rcond, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: anorm,d(*)
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: e(*)
               end subroutine zptcon
#else 
               module procedure stdlib_zptcon
#endif
          end interface ptcon



          interface pteqr
          !! PTEQR computes all eigenvalues and, optionally, eigenvectors of a
          !! symmetric positive definite tridiagonal matrix by first factoring the
          !! matrix using SPTTRF and then calling CBDSQR to compute the singular
          !! values of the bidiagonal factor.
          !! This routine computes the eigenvalues of the positive definite
          !! tridiagonal matrix to high relative accuracy.  This means that if the
          !! eigenvalues range over many orders of magnitude in size, then the
          !! small eigenvalues and corresponding eigenvectors will be computed
          !! more accurately than, for example, with the standard QR method.
          !! The eigenvectors of a full or band positive definite Hermitian matrix
          !! can also be found if CHETRD, CHPTRD, or CHBTRD has been used to
          !! reduce this matrix to tridiagonal form.  (The reduction to
          !! tridiagonal form, however, may preclude the possibility of obtaining
          !! high relative accuracy in the small eigenvalues of the original
          !! matrix, if these eigenvalues range over many orders of magnitude.)
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: z(ldz,*)
               end subroutine cpteqr
#else 
               module procedure stdlib_cpteqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(dp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dpteqr
#else 
               module procedure stdlib_dpteqr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pteqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(sp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(sp), intent(out) :: work(*)
               end subroutine spteqr
#else 
               module procedure stdlib_spteqr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pteqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: z(ldz,*)
               end subroutine zpteqr
#else 
               module procedure stdlib_zpteqr
#endif
          end interface pteqr



          interface ptrfs
          !! PTRFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is Hermitian positive definite
          !! and tridiagonal, and provides error bounds and backward error
          !! estimates for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cptrfs( uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    real(sp), intent(in) :: d(*),df(*)
                    complex(sp), intent(in) :: b(ldb,*),e(*),ef(*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine cptrfs
#else 
               module procedure stdlib_cptrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dptrfs( n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr,berr, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(in) :: b(ldb,*),d(*),df(*),e(*),ef(*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dptrfs
#else 
               module procedure stdlib_dptrfs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ptrfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sptrfs( n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr,berr, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(in) :: b(ldb,*),d(*),df(*),e(*),ef(*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine sptrfs
#else 
               module procedure stdlib_sptrfs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ptrfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zptrfs( uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    real(dp), intent(in) :: d(*),df(*)
                    complex(dp), intent(in) :: b(ldb,*),e(*),ef(*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zptrfs
#else 
               module procedure stdlib_zptrfs
#endif
          end interface ptrfs



          interface ptsv
          !! PTSV computes the solution to a complex system of linear equations
          !! A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal
          !! matrix, and X and B are N-by-NRHS matrices.
          !! A is factored as A = L*D*L**H, and the factored form of A is then
          !! used to solve the system of equations.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cptsv( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: d(*)
                    complex(sp), intent(inout) :: b(ldb,*),e(*)
               end subroutine cptsv
#else 
               module procedure stdlib_cptsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dptsv( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: b(ldb,*),d(*),e(*)
               end subroutine dptsv
#else 
               module procedure stdlib_dptsv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ptsv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sptsv( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: b(ldb,*),d(*),e(*)
               end subroutine sptsv
#else 
               module procedure stdlib_sptsv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ptsv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zptsv( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: d(*)
                    complex(dp), intent(inout) :: b(ldb,*),e(*)
               end subroutine zptsv
#else 
               module procedure stdlib_zptsv
#endif
          end interface ptsv



          interface pttrf
          !! PTTRF computes the L*D*L**H factorization of a complex Hermitian
          !! positive definite tridiagonal matrix A.  The factorization may also
          !! be regarded as having the form A = U**H *D*U.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpttrf( n, d, e, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: d(*)
                    complex(sp), intent(inout) :: e(*)
               end subroutine cpttrf
#else 
               module procedure stdlib_cpttrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpttrf( n, d, e, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: d(*),e(*)
               end subroutine dpttrf
#else 
               module procedure stdlib_dpttrf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pttrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spttrf( n, d, e, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: d(*),e(*)
               end subroutine spttrf
#else 
               module procedure stdlib_spttrf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pttrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpttrf( n, d, e, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: d(*)
                    complex(dp), intent(inout) :: e(*)
               end subroutine zpttrf
#else 
               module procedure stdlib_zpttrf
#endif
          end interface pttrf



          interface pttrs
          !! PTTRS solves a tridiagonal system of the form
          !! A * X = B
          !! using the factorization A = U**H*D*U or A = L*D*L**H computed by CPTTRF.
          !! D is a diagonal matrix specified in the vector D, U (or L) is a unit
          !! bidiagonal matrix whose superdiagonal (subdiagonal) is specified in
          !! the vector E, and X and B are N by NRHS matrices.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cpttrs( uplo, n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(in) :: d(*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(in) :: e(*)
               end subroutine cpttrs
#else 
               module procedure stdlib_cpttrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dpttrs( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: b(ldb,*)
                    real(dp), intent(in) :: d(*),e(*)
               end subroutine dpttrs
#else 
               module procedure stdlib_dpttrs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pttrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine spttrs( n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: b(ldb,*)
                    real(sp), intent(in) :: d(*),e(*)
               end subroutine spttrs
#else 
               module procedure stdlib_spttrs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$pttrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zpttrs( uplo, n, nrhs, d, e, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(in) :: d(*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(in) :: e(*)
               end subroutine zpttrs
#else 
               module procedure stdlib_zpttrs
#endif
          end interface pttrs



          interface rot
          !! ROT applies a plane rotation, where the cos (C) is real and the
          !! sin (S) is complex, and the vectors CX and CY are complex.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine crot( n, cx, incx, cy, incy, c, s )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,incy,n
                    real(sp), intent(in) :: c
                    complex(sp), intent(in) :: s
                    complex(sp), intent(inout) :: cx(*),cy(*)
               end subroutine crot
#else 
               module procedure stdlib_crot
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$rot

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zrot( n, cx, incx, cy, incy, c, s )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,incy,n
                    real(dp), intent(in) :: c
                    complex(dp), intent(in) :: s
                    complex(dp), intent(inout) :: cx(*),cy(*)
               end subroutine zrot
#else 
               module procedure stdlib_zrot
#endif
          end interface rot



          interface rscl
          !! RSCL multiplies an n-element real vector x by the real scalar 1/a.
          !! This is done without overflow or underflow as long as
          !! the final result x/a does not overflow or underflow.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine drscl( n, sa, sx, incx )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,n
                    real(dp), intent(in) :: sa
                    real(dp), intent(inout) :: sx(*)
               end subroutine drscl
#else 
               module procedure stdlib_drscl
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$rscl

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine srscl( n, sa, sx, incx )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx,n
                    real(sp), intent(in) :: sa
                    real(sp), intent(inout) :: sx(*)
               end subroutine srscl
#else 
               module procedure stdlib_srscl
#endif
          end interface rscl



          interface sb2st_kernels
          !! SB2ST_KERNELS is an internal routine used by the DSYTRD_SB2ST
          !! subroutine.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine  dsb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, &
                         lda, v, tau, ldvt, work)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: wantz
                    integer(ilp), intent(in) :: ttype,st,ed,sweep,n,nb,ib,lda,ldvt
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: v(*),tau(*),work(*)
               end subroutine dsb2st_kernels
#else 
               module procedure stdlib_dsb2st_kernels
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sb2st_kernels

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine  ssb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, &
                         lda, v, tau, ldvt, work)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    logical(lk), intent(in) :: wantz
                    integer(ilp), intent(in) :: ttype,st,ed,sweep,n,nb,ib,lda,ldvt
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: v(*),tau(*),work(*)
               end subroutine ssb2st_kernels
#else 
               module procedure stdlib_ssb2st_kernels
#endif
          end interface sb2st_kernels



          interface sbev
          !! SBEV computes all the eigenvalues and, optionally, eigenvectors of
          !! a real symmetric band matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldz,n
                    real(dp), intent(inout) :: ab(ldab,*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsbev
#else 
               module procedure stdlib_dsbev
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sbev

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldz,n
                    real(sp), intent(inout) :: ab(ldab,*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssbev
#else 
               module procedure stdlib_ssbev
#endif
          end interface sbev



          interface sbevd
          !! SBEVD computes all the eigenvalues and, optionally, eigenvectors of
          !! a real symmetric band matrix A. If eigenvectors are desired, it uses
          !! a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,ldz,liwork,lwork,n
                    real(dp), intent(inout) :: ab(ldab,*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsbevd
#else 
               module procedure stdlib_dsbevd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sbevd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,ldz,liwork,lwork,n
                    real(sp), intent(inout) :: ab(ldab,*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssbevd
#else 
               module procedure stdlib_ssbevd
#endif
          end interface sbevd



          interface sbgst
          !! SBGST reduces a real symmetric-definite banded generalized
          !! eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,
          !! such that C has the same bandwidth as A.
          !! B must have been previously factorized as S**T*S by DPBSTF, using a
          !! split Cholesky factorization. A is overwritten by C = X**T*A*X, where
          !! X = S**(-1)*Q and Q is an orthogonal matrix chosen to preserve the
          !! bandwidth of A.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldx,n
                    real(dp), intent(inout) :: ab(ldab,*)
                    real(dp), intent(in) :: bb(ldbb,*)
                    real(dp), intent(out) :: work(*),x(ldx,*)
               end subroutine dsbgst
#else 
               module procedure stdlib_dsbgst
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sbgst

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldx,n
                    real(sp), intent(inout) :: ab(ldab,*)
                    real(sp), intent(in) :: bb(ldbb,*)
                    real(sp), intent(out) :: work(*),x(ldx,*)
               end subroutine ssbgst
#else 
               module procedure stdlib_ssbgst
#endif
          end interface sbgst



          interface sbgv
          !! SBGV computes all the eigenvalues, and optionally, the eigenvectors
          !! of a real generalized symmetric-definite banded eigenproblem, of
          !! the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
          !! and banded, and B is also positive definite.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldz,n
                    real(dp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsbgv
#else 
               module procedure stdlib_dsbgv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sbgv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldz,n
                    real(sp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssbgv
#else 
               module procedure stdlib_ssbgv
#endif
          end interface sbgv



          interface sbgvd
          !! SBGVD computes all the eigenvalues, and optionally, the eigenvectors
          !! of a real generalized symmetric-definite banded eigenproblem, of the
          !! form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric and
          !! banded, and B is also positive definite.  If eigenvectors are
          !! desired, it uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
                         lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldz,liwork,lwork,n
                    real(dp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsbgvd
#else 
               module procedure stdlib_dsbgvd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sbgvd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
                         lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ka,kb,ldab,ldbb,ldz,liwork,lwork,n
                    real(sp), intent(inout) :: ab(ldab,*),bb(ldbb,*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssbgvd
#else 
               module procedure stdlib_ssbgvd
#endif
          end interface sbgvd



          interface sbtrd
          !! SBTRD reduces a real symmetric band matrix A to symmetric
          !! tridiagonal form T by an orthogonal similarity transformation:
          !! Q**T * A * Q = T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldq,n
                    real(dp), intent(inout) :: ab(ldab,*),q(ldq,*)
                    real(dp), intent(out) :: d(*),e(*),work(*)
               end subroutine dsbtrd
#else 
               module procedure stdlib_dsbtrd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sbtrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldq,n
                    real(sp), intent(inout) :: ab(ldab,*),q(ldq,*)
                    real(sp), intent(out) :: d(*),e(*),work(*)
               end subroutine ssbtrd
#else 
               module procedure stdlib_ssbtrd
#endif
          end interface sbtrd



          interface sfrk
          !! Level 3 BLAS like routine for C in RFP Format.
          !! SFRK performs one of the symmetric rank--k operations
          !! C := alpha*A*A**T + beta*C,
          !! or
          !! C := alpha*A**T*A + beta*C,
          !! where alpha and beta are real scalars, C is an n--by--n symmetric
          !! matrix and A is an n--by--k matrix in the first case and a k--by--n
          !! matrix in the second case.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,c )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(dp), intent(in) :: alpha,beta,a(lda,*)
                    integer(ilp), intent(in) :: k,lda,n
                    character, intent(in) :: trans,transr,uplo
                    real(dp), intent(inout) :: c(*)
               end subroutine dsfrk
#else 
               module procedure stdlib_dsfrk
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sfrk

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssfrk( transr, uplo, trans, n, k, alpha, a, lda, beta,c )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    real(sp), intent(in) :: alpha,beta,a(lda,*)
                    integer(ilp), intent(in) :: k,lda,n
                    character, intent(in) :: trans,transr,uplo
                    real(sp), intent(inout) :: c(*)
               end subroutine ssfrk
#else 
               module procedure stdlib_ssfrk
#endif
          end interface sfrk



          interface spcon
          !! SPCON estimates the reciprocal of the condition number (in the
          !! 1-norm) of a complex symmetric packed matrix A using the
          !! factorization A = U*D*U**T or A = L*D*L**T computed by CSPTRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cspcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cspcon
#else 
               module procedure stdlib_cspcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dspcon( uplo, n, ap, ipiv, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(dp), intent(in) :: anorm,ap(*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dspcon
#else 
               module procedure stdlib_dspcon
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$spcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sspcon( uplo, n, ap, ipiv, anorm, rcond, work, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(sp), intent(in) :: anorm,ap(*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine sspcon
#else 
               module procedure stdlib_sspcon
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$spcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zspcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zspcon
#else 
               module procedure stdlib_zspcon
#endif
          end interface spcon



          interface spev
          !! SPEV computes all the eigenvalues and, optionally, eigenvectors of a
          !! real symmetric matrix A in packed storage.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dspev( jobz, uplo, n, ap, w, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(dp), intent(inout) :: ap(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dspev
#else 
               module procedure stdlib_dspev
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$spev

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sspev( jobz, uplo, n, ap, w, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(sp), intent(inout) :: ap(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sspev
#else 
               module procedure stdlib_sspev
#endif
          end interface spev



          interface spevd
          !! SPEVD computes all the eigenvalues and, optionally, eigenvectors
          !! of a real symmetric matrix A in packed storage. If eigenvectors are
          !! desired, it uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dspevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,iwork, liwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lwork,n
                    real(dp), intent(inout) :: ap(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dspevd
#else 
               module procedure stdlib_dspevd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$spevd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sspevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,iwork, liwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lwork,n
                    real(sp), intent(inout) :: ap(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sspevd
#else 
               module procedure stdlib_sspevd
#endif
          end interface spevd



          interface spgst
          !! SPGST reduces a real symmetric-definite generalized eigenproblem
          !! to standard form, using packed storage.
          !! If ITYPE = 1, the problem is A*x = lambda*B*x,
          !! and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)
          !! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
          !! B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.
          !! B must have been previously factorized as U**T*U or L*L**T by DPPTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dspgst( itype, uplo, n, ap, bp, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,n
                    real(dp), intent(inout) :: ap(*)
                    real(dp), intent(in) :: bp(*)
               end subroutine dspgst
#else 
               module procedure stdlib_dspgst
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$spgst

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sspgst( itype, uplo, n, ap, bp, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,n
                    real(sp), intent(inout) :: ap(*)
                    real(sp), intent(in) :: bp(*)
               end subroutine sspgst
#else 
               module procedure stdlib_sspgst
#endif
          end interface spgst



          interface spgv
          !! SPGV computes all the eigenvalues and, optionally, the eigenvectors
          !! of a real generalized symmetric-definite eigenproblem, of the form
          !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
          !! Here A and B are assumed to be symmetric, stored in packed format,
          !! and B is also positive definite.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dspgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,ldz,n
                    real(dp), intent(inout) :: ap(*),bp(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dspgv
#else 
               module procedure stdlib_dspgv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$spgv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sspgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,ldz,n
                    real(sp), intent(inout) :: ap(*),bp(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sspgv
#else 
               module procedure stdlib_sspgv
#endif
          end interface spgv



          interface spgvd
          !! SPGVD computes all the eigenvalues, and optionally, the eigenvectors
          !! of a real generalized symmetric-definite eigenproblem, of the form
          !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
          !! B are assumed to be symmetric, stored in packed format, and B is also
          !! positive definite.
          !! If eigenvectors are desired, it uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dspgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: itype,ldz,liwork,lwork,n
                    real(dp), intent(inout) :: ap(*),bp(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dspgvd
#else 
               module procedure stdlib_dspgvd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$spgvd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine sspgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: itype,ldz,liwork,lwork,n
                    real(sp), intent(inout) :: ap(*),bp(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sspgvd
#else 
               module procedure stdlib_sspgvd
#endif
          end interface spgvd



          interface spmv
          !! SPMV performs the matrix-vector operation
          !! y := alpha*A*x + beta*y,
          !! where alpha and beta are scalars, x and y are n element vectors and
          !! A is an n by n symmetric matrix, supplied in packed form.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cspmv( uplo, n, alpha, ap, x, incx, beta, y, incy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incx,incy,n
                    complex(sp), intent(in) :: alpha,beta,ap(*),x(*)
                    complex(sp), intent(inout) :: y(*)
               end subroutine cspmv
#else 
               module procedure stdlib_cspmv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$spmv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zspmv( uplo, n, alpha, ap, x, incx, beta, y, incy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incx,incy,n
                    complex(dp), intent(in) :: alpha,beta,ap(*),x(*)
                    complex(dp), intent(inout) :: y(*)
               end subroutine zspmv
#else 
               module procedure stdlib_zspmv
#endif
          end interface spmv



          interface spr
          !! SPR performs the symmetric rank 1 operation
          !! A := alpha*x*x**H + A,
          !! where alpha is a complex scalar, x is an n element vector and A is an
          !! n by n symmetric matrix, supplied in packed form.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cspr( uplo, n, alpha, x, incx, ap )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incx,n
                    complex(sp), intent(in) :: alpha,x(*)
                    complex(sp), intent(inout) :: ap(*)
               end subroutine cspr
#else 
               module procedure stdlib_cspr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$spr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zspr( uplo, n, alpha, x, incx, ap )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incx,n
                    complex(dp), intent(in) :: alpha,x(*)
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zspr
#else 
               module procedure stdlib_zspr
#endif
          end interface spr



          interface sprfs
          !! SPRFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is symmetric indefinite
          !! and packed, and provides error bounds and backward error estimates
          !! for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine csprfs
#else 
               module procedure stdlib_csprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dsprfs
#else 
               module procedure stdlib_dsprfs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sprfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine ssprfs
#else 
               module procedure stdlib_ssprfs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sprfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: afp(*),ap(*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zsprfs
#else 
               module procedure stdlib_zsprfs
#endif
          end interface sprfs



          interface spsv
          !! SPSV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N symmetric matrix stored in packed format and X
          !! and B are N-by-NRHS matrices.
          !! The diagonal pivoting method is used to factor A as
          !! A = U * D * U**T,  if UPLO = 'U', or
          !! A = L * D * L**T,  if UPLO = 'L',
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, D is symmetric and block diagonal with 1-by-1
          !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
          !! solve the system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine cspsv
#else 
               module procedure stdlib_cspsv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine dspsv
#else 
               module procedure stdlib_dspsv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$spsv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine sspsv
#else 
               module procedure stdlib_sspsv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$spsv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(inout) :: ap(*),b(ldb,*)
               end subroutine zspsv
#else 
               module procedure stdlib_zspsv
#endif
          end interface spsv



          interface sptrd
          !! SPTRD reduces a real symmetric matrix A stored in packed form to
          !! symmetric tridiagonal form T by an orthogonal similarity
          !! transformation: Q**T * A * Q = T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsptrd( uplo, n, ap, d, e, tau, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: ap(*)
                    real(dp), intent(out) :: d(*),e(*),tau(*)
               end subroutine dsptrd
#else 
               module procedure stdlib_dsptrd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sptrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssptrd( uplo, n, ap, d, e, tau, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: ap(*)
                    real(sp), intent(out) :: d(*),e(*),tau(*)
               end subroutine ssptrd
#else 
               module procedure stdlib_ssptrd
#endif
          end interface sptrd



          interface sptrf
          !! SPTRF computes the factorization of a complex symmetric matrix A
          !! stored in packed format using the Bunch-Kaufman diagonal pivoting
          !! method:
          !! A = U*D*U**T  or  A = L*D*L**T
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is symmetric and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: ap(*)
               end subroutine csptrf
#else 
               module procedure stdlib_csptrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: ap(*)
               end subroutine dsptrf
#else 
               module procedure stdlib_dsptrf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sptrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: ap(*)
               end subroutine ssptrf
#else 
               module procedure stdlib_ssptrf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sptrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsptrf( uplo, n, ap, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: ap(*)
               end subroutine zsptrf
#else 
               module procedure stdlib_zsptrf
#endif
          end interface sptrf



          interface sptri
          !! SPTRI computes the inverse of a complex symmetric indefinite matrix
          !! A in packed storage using the factorization A = U*D*U**T or
          !! A = L*D*L**T computed by CSPTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    complex(sp), intent(inout) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csptri
#else 
               module procedure stdlib_csptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(dp), intent(inout) :: ap(*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsptri
#else 
               module procedure stdlib_dsptri
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sptri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    real(sp), intent(inout) :: ap(*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssptri
#else 
               module procedure stdlib_ssptri
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sptri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsptri( uplo, n, ap, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,ipiv(*)
                    complex(dp), intent(inout) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsptri
#else 
               module procedure stdlib_zsptri
#endif
          end interface sptri



          interface sptrs
          !! SPTRS solves a system of linear equations A*X = B with a complex
          !! symmetric matrix A stored in packed format using the factorization
          !! A = U*D*U**T or A = L*D*L**T computed by CSPTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine csptrs
#else 
               module procedure stdlib_csptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dsptrs
#else 
               module procedure stdlib_dsptrs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sptrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine ssptrs
#else 
               module procedure stdlib_ssptrs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sptrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zsptrs
#else 
               module procedure stdlib_zsptrs
#endif
          end interface sptrs



          interface stebz
          !! STEBZ computes the eigenvalues of a symmetric tridiagonal
          !! matrix T.  The user may ask for all eigenvalues, all eigenvalues
          !! in the half-open interval (VL, VU], or the IL-th through IU-th
          !! eigenvalues.
          !! To avoid overflow, the matrix must be scaled so that its
          !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
          !! accuracy, it should not be much smaller than that.
          !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
          !! Matrix", Report CS41, Computer Science Dept., Stanford
          !! University, July 21, 1966.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dstebz( range, order, n, vl, vu, il, iu, abstol, d, e,m, nsplit, w,&
                          iblock, isplit, work, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: order,range
                    integer(ilp), intent(in) :: il,iu,n
                    integer(ilp), intent(out) :: info,m,nsplit,iblock(*),isplit(*),iwork(*)
                              
                    real(dp), intent(in) :: abstol,vl,vu,d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*)
               end subroutine dstebz
#else 
               module procedure stdlib_dstebz
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$stebz

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sstebz( range, order, n, vl, vu, il, iu, abstol, d, e,m, nsplit, w,&
                          iblock, isplit, work, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: order,range
                    integer(ilp), intent(in) :: il,iu,n
                    integer(ilp), intent(out) :: info,m,nsplit,iblock(*),isplit(*),iwork(*)
                              
                    real(sp), intent(in) :: abstol,vl,vu,d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*)
               end subroutine sstebz
#else 
               module procedure stdlib_sstebz
#endif
          end interface stebz



          interface stedc
          !! STEDC computes all eigenvalues and, optionally, eigenvectors of a
          !! symmetric tridiagonal matrix using the divide and conquer method.
          !! The eigenvectors of a full or band complex Hermitian matrix can also
          !! be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
          !! matrix to tridiagonal form.
          !! This code makes very mild assumptions about floating point
          !! arithmetic. It will work on machines with a guard digit in
          !! add/subtract, or on those binary machines without guard digits
          !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
          !! It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.  See SLAED3 for details.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cstedc( compz, n, d, e, z, ldz, work, lwork, rwork,lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lrwork,lwork,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: z(ldz,*)
               end subroutine cstedc
#else 
               module procedure stdlib_cstedc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dstedc( compz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lwork,n
                    real(dp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dstedc
#else 
               module procedure stdlib_dstedc
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$stedc

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sstedc( compz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lwork,n
                    real(sp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(sp), intent(out) :: work(*)
               end subroutine sstedc
#else 
               module procedure stdlib_sstedc
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$stedc

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zstedc( compz, n, d, e, z, ldz, work, lwork, rwork,lrwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lrwork,lwork,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: z(ldz,*)
               end subroutine zstedc
#else 
               module procedure stdlib_zstedc
#endif
          end interface stedc



          interface stegr
          !! STEGR computes selected eigenvalues and, optionally, eigenvectors
          !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
          !! a well defined set of pairwise different real eigenvalues, the corresponding
          !! real eigenvectors are pairwise orthogonal.
          !! The spectrum may be computed either completely or partially by specifying
          !! either an interval (VL,VU] or a range of indices IL:IU for the desired
          !! eigenvalues.
          !! STEGR is a compatibility wrapper around the improved CSTEMR routine.
          !! See SSTEMR for further details.
          !! One important change is that the ABSTOL parameter no longer provides any
          !! benefit and hence is no longer used.
          !! Note : STEGR and CSTEMR work only on machines which follow
          !! IEEE-754 floating-point standard in their handling of infinities and
          !! NaNs.  Normal execution may create these exceptiona values and hence
          !! may abort due to a floating point exception in environments which
          !! do not conform to the IEEE-754 standard.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,range
                    integer(ilp), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: abstol,vl,vu
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*)
                    complex(sp), intent(out) :: z(ldz,*)
               end subroutine cstegr
#else 
               module procedure stdlib_cstegr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,range
                    integer(ilp), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: abstol,vl,vu
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dstegr
#else 
               module procedure stdlib_dstegr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$stegr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,range
                    integer(ilp), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: abstol,vl,vu
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sstegr
#else 
               module procedure stdlib_sstegr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$stegr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,range
                    integer(ilp), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: abstol,vl,vu
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*)
                    complex(dp), intent(out) :: z(ldz,*)
               end subroutine zstegr
#else 
               module procedure stdlib_zstegr
#endif
          end interface stegr



          interface stein
          !! STEIN computes the eigenvectors of a real symmetric tridiagonal
          !! matrix T corresponding to specified eigenvalues, using inverse
          !! iteration.
          !! The maximum number of iterations allowed for each eigenvector is
          !! specified by an internal parameter MAXITS (currently set to 5).
          !! Although the eigenvectors are real, they are stored in a complex
          !! array, which may be passed to CUNMTR or CUPMTR for back
          !! transformation to the eigenvectors of a complex Hermitian matrix
          !! which was reduced to tridiagonal form.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ifail(*),iwork(*)
                    integer(ilp), intent(in) :: ldz,m,n,iblock(*),isplit(*)
                    real(sp), intent(in) :: d(*),e(*),w(*)
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(out) :: z(ldz,*)
               end subroutine cstein
#else 
               module procedure stdlib_cstein
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ifail(*),iwork(*)
                    integer(ilp), intent(in) :: ldz,m,n,iblock(*),isplit(*)
                    real(dp), intent(in) :: d(*),e(*),w(*)
                    real(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine dstein
#else 
               module procedure stdlib_dstein
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$stein

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ifail(*),iwork(*)
                    integer(ilp), intent(in) :: ldz,m,n,iblock(*),isplit(*)
                    real(sp), intent(in) :: d(*),e(*),w(*)
                    real(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine sstein
#else 
               module procedure stdlib_sstein
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$stein

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info,ifail(*),iwork(*)
                    integer(ilp), intent(in) :: ldz,m,n,iblock(*),isplit(*)
                    real(dp), intent(in) :: d(*),e(*),w(*)
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(out) :: z(ldz,*)
               end subroutine zstein
#else 
               module procedure stdlib_zstein
#endif
          end interface stein



          interface stemr
          !! STEMR computes selected eigenvalues and, optionally, eigenvectors
          !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
          !! a well defined set of pairwise different real eigenvalues, the corresponding
          !! real eigenvectors are pairwise orthogonal.
          !! The spectrum may be computed either completely or partially by specifying
          !! either an interval (VL,VU] or a range of indices IL:IU for the desired
          !! eigenvalues.
          !! Depending on the number of desired eigenvalues, these are computed either
          !! by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
          !! computed by the use of various suitable L D L^T factorizations near clusters
          !! of close eigenvalues (referred to as RRRs, Relatively Robust
          !! Representations). An informal sketch of the algorithm follows.
          !! For each unreduced block (submatrix) of T,
          !! (a) Compute T - sigma I  = L D L^T, so that L and D
          !! define all the wanted eigenvalues to high relative accuracy.
          !! This means that small relative changes in the entries of D and L
          !! cause only small relative changes in the eigenvalues and
          !! eigenvectors. The standard (unfactored) representation of the
          !! tridiagonal matrix T does not have this property in general.
          !! (b) Compute the eigenvalues to suitable accuracy.
          !! If the eigenvectors are desired, the algorithm attains full
          !! accuracy of the computed eigenvalues only right before
          !! the corresponding vectors have to be computed, see steps c) and d).
          !! (c) For each cluster of close eigenvalues, select a new
          !! shift close to the cluster, find a new factorization, and refine
          !! the shifted eigenvalues to suitable accuracy.
          !! (d) For each eigenvalue with a large enough relative separation compute
          !! the corresponding eigenvector by forming a rank revealing twisted
          !! factorization. Go back to (c) for any clusters that remain.
          !! For more details, see:
          !! - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
          !! to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
          !! Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
          !! - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
          !! Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
          !! 2004.  Also LAPACK Working Note 154.
          !! - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
          !! tridiagonal eigenvalue/eigenvector problem",
          !! Computer Science Division Technical Report No. UCB/CSD-97-971,
          !! UC Berkeley, May 1997.
          !! Further Details
          !! 1.STEMR works only on machines which follow IEEE-754
          !! floating-point standard in their handling of infinities and NaNs.
          !! This permits the use of efficient inner loops avoiding a check for
          !! zero divisors.
          !! 2. LAPACK routines can be used to reduce a complex Hermitean matrix to
          !! real symmetric tridiagonal form.
          !! (Any complex Hermitean tridiagonal matrix has real values on its diagonal
          !! and potentially complex numbers on its off-diagonals. By applying a
          !! similarity transform with an appropriate diagonal matrix
          !! diag(1,e^{i \phy_1}, ... , e^{i \phy_{n-1}}), the complex Hermitean
          !! matrix can be transformed into a real symmetric matrix and complex
          !! arithmetic can be entirely avoided.)
          !! While the eigenvectors of the real symmetric tridiagonal matrix are real,
          !! the eigenvectors of original complex Hermitean matrix have complex entries
          !! in general.
          !! Since LAPACK drivers overwrite the matrix data with the eigenvectors,
          !! STEMR accepts complex workspace to facilitate interoperability
          !! with CUNMTR or CUPMTR.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
                         isuppz, tryrac, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,range
                    logical(lk), intent(inout) :: tryrac
                    integer(ilp), intent(in) :: il,iu,ldz,nzc,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: vl,vu
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*)
                    complex(sp), intent(out) :: z(ldz,*)
               end subroutine cstemr
#else 
               module procedure stdlib_cstemr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
                         isuppz, tryrac, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,range
                    logical(lk), intent(inout) :: tryrac
                    integer(ilp), intent(in) :: il,iu,ldz,nzc,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: vl,vu
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dstemr
#else 
               module procedure stdlib_dstemr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$stemr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
                         isuppz, tryrac, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,range
                    logical(lk), intent(inout) :: tryrac
                    integer(ilp), intent(in) :: il,iu,ldz,nzc,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: vl,vu
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sstemr
#else 
               module procedure stdlib_sstemr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$stemr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
                         isuppz, tryrac, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,range
                    logical(lk), intent(inout) :: tryrac
                    integer(ilp), intent(in) :: il,iu,ldz,nzc,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: vl,vu
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*)
                    complex(dp), intent(out) :: z(ldz,*)
               end subroutine zstemr
#else 
               module procedure stdlib_zstemr
#endif
          end interface stemr



          interface steqr
          !! STEQR computes all eigenvalues and, optionally, eigenvectors of a
          !! symmetric tridiagonal matrix using the implicit QL or QR method.
          !! The eigenvectors of a full or band complex Hermitian matrix can also
          !! be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
          !! matrix to tridiagonal form.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: z(ldz,*)
               end subroutine csteqr
#else 
               module procedure stdlib_csteqr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(dp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsteqr
#else 
               module procedure stdlib_dsteqr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$steqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(sp), intent(inout) :: d(*),e(*),z(ldz,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssteqr
#else 
               module procedure stdlib_ssteqr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$steqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsteqr( compz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: z(ldz,*)
               end subroutine zsteqr
#else 
               module procedure stdlib_zsteqr
#endif
          end interface steqr



          interface sterf
          !! STERF computes all eigenvalues of a symmetric tridiagonal matrix
          !! using the Pal-Walker-Kahan variant of the QL or QR algorithm.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsterf( n, d, e, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: d(*),e(*)
               end subroutine dsterf
#else 
               module procedure stdlib_dsterf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sterf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssterf( n, d, e, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: d(*),e(*)
               end subroutine ssterf
#else 
               module procedure stdlib_ssterf
#endif
          end interface sterf



          interface stev
          !! STEV computes all eigenvalues and, optionally, eigenvectors of a
          !! real symmetric tridiagonal matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dstev( jobz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine dstev
#else 
               module procedure stdlib_dstev
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$stev

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sstev( jobz, n, d, e, z, ldz, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldz,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine sstev
#else 
               module procedure stdlib_sstev
#endif
          end interface stev



          interface stevd
          !! STEVD computes all eigenvalues and, optionally, eigenvectors of a
          !! real symmetric tridiagonal matrix. If eigenvectors are desired, it
          !! uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dstevd( jobz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lwork,n
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: work(*),z(ldz,*)
               end subroutine dstevd
#else 
               module procedure stdlib_dstevd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$stevd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sstevd( jobz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldz,liwork,lwork,n
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: work(*),z(ldz,*)
               end subroutine sstevd
#else 
               module procedure stdlib_sstevd
#endif
          end interface stevd



          interface stevr
          !! STEVR computes selected eigenvalues and, optionally, eigenvectors
          !! of a real symmetric tridiagonal matrix T.  Eigenvalues and
          !! eigenvectors can be selected by specifying either a range of values
          !! or a range of indices for the desired eigenvalues.
          !! Whenever possible, STEVR calls DSTEMR to compute the
          !! eigenspectrum using Relatively Robust Representations.  DSTEMR
          !! computes eigenvalues by the dqds algorithm, while orthogonal
          !! eigenvectors are computed from various "good" L D L^T representations
          !! (also known as Relatively Robust Representations). Gram-Schmidt
          !! orthogonalization is avoided as far as possible. More specifically,
          !! the various steps of the algorithm are as follows. For the i-th
          !! unreduced block of T,
          !! (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
          !! is a relatively robust representation,
          !! (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
          !! relative accuracy by the dqds algorithm,
          !! (c) If there is a cluster of close eigenvalues, "choose" sigma_i
          !! close to the cluster, and go to step (a),
          !! (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
          !! compute the corresponding eigenvector by forming a
          !! rank-revealing twisted factorization.
          !! The desired accuracy of the output can be specified by the input
          !! parameter ABSTOL.
          !! For more details, see "A new O(n^2) algorithm for the symmetric
          !! tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
          !! Computer Science Division Technical Report No. UCB//CSD-97-971,
          !! UC Berkeley, May 1997.
          !! Note 1 : STEVR calls DSTEMR when the full spectrum is requested
          !! on machines which conform to the ieee-754 floating point standard.
          !! STEVR calls DSTEBZ and DSTEIN on non-ieee machines and
          !! when partial spectrum requests are made.
          !! Normal execution of DSTEMR may create NaNs and infinities and
          !! hence may abort due to a floating point exception in environments
          !! which do not handle NaNs and infinities in the ieee standard default
          !! manner.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dstevr( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,range
                    integer(ilp), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: abstol,vl,vu
                    real(dp), intent(inout) :: d(*),e(*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dstevr
#else 
               module procedure stdlib_dstevr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$stevr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine sstevr( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
                         isuppz, work, lwork, iwork,liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,range
                    integer(ilp), intent(in) :: il,iu,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: abstol,vl,vu
                    real(sp), intent(inout) :: d(*),e(*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine sstevr
#else 
               module procedure stdlib_sstevr
#endif
          end interface stevr



          interface sycon
          !! SYCON estimates the reciprocal of the condition number (in the
          !! 1-norm) of a complex symmetric matrix A using the factorization
          !! A = U*D*U**T or A = L*D*L**T computed by CSYTRF.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csycon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csycon
#else 
               module procedure stdlib_csycon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsycon( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm,a(lda,*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dsycon
#else 
               module procedure stdlib_dsycon
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sycon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssycon( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm,a(lda,*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine ssycon
#else 
               module procedure stdlib_ssycon
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sycon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsycon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsycon
#else 
               module procedure stdlib_zsycon
#endif
          end interface sycon



          interface sycon_rook
          !! SYCON_ROOK estimates the reciprocal of the condition number (in the
          !! 1-norm) of a complex symmetric matrix A using the factorization
          !! A = U*D*U**T or A = L*D*L**T computed by CSYTRF_ROOK.
          !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
          !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm
                    real(sp), intent(out) :: rcond
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csycon_rook
#else 
               module procedure stdlib_csycon_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm,a(lda,*)
                    real(dp), intent(out) :: rcond,work(*)
               end subroutine dsycon_rook
#else 
               module procedure stdlib_dsycon_rook
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sycon_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(in) :: anorm,a(lda,*)
                    real(sp), intent(out) :: rcond,work(*)
               end subroutine ssycon_rook
#else 
               module procedure stdlib_ssycon_rook
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sycon_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(in) :: anorm
                    real(dp), intent(out) :: rcond
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsycon_rook
#else 
               module procedure stdlib_zsycon_rook
#endif
          end interface sycon_rook



          interface syconv
          !! SYCONV convert A given by TRF into L and D and vice-versa.
          !! Get Non-diag elements of D (returned in workspace) and
          !! apply or reverse permutation done in TRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csyconv( uplo, way, n, a, lda, ipiv, e, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*)
               end subroutine csyconv
#else 
               module procedure stdlib_csyconv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsyconv( uplo, way, n, a, lda, ipiv, e, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: e(*)
               end subroutine dsyconv
#else 
               module procedure stdlib_dsyconv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$syconv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssyconv( uplo, way, n, a, lda, ipiv, e, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: e(*)
               end subroutine ssyconv
#else 
               module procedure stdlib_ssyconv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$syconv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsyconv( uplo, way, n, a, lda, ipiv, e, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*)
               end subroutine zsyconv
#else 
               module procedure stdlib_zsyconv
#endif
          end interface syconv



          interface syconvf
          !! If parameter WAY = 'C':
          !! SYCONVF converts the factorization output format used in
          !! CSYTRF provided on entry in parameter A into the factorization
          !! output format used in CSYTRF_RK (or CSYTRF_BK) that is stored
          !! on exit in parameters A and E. It also converts in place details of
          !! the intechanges stored in IPIV from the format used in CSYTRF into
          !! the format used in CSYTRF_RK (or CSYTRF_BK).
          !! If parameter WAY = 'R':
          !! SYCONVF performs the conversion in reverse direction, i.e.
          !! converts the factorization output format used in CSYTRF_RK
          !! (or CSYTRF_BK) provided on entry in parameters A and E into
          !! the factorization output format used in CSYTRF that is stored
          !! on exit in parameter A. It also converts in place details of
          !! the intechanges stored in IPIV from the format used in CSYTRF_RK
          !! (or CSYTRF_BK) into the format used in CSYTRF.
          !! SYCONVF can also convert in Hermitian matrix case, i.e. between
          !! formats used in CHETRF and CHETRF_RK (or CHETRF_BK).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csyconvf( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    integer(ilp), intent(inout) :: ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),e(*)
               end subroutine csyconvf
#else 
               module procedure stdlib_csyconvf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsyconvf( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    integer(ilp), intent(inout) :: ipiv(*)
                    real(dp), intent(inout) :: a(lda,*),e(*)
               end subroutine dsyconvf
#else 
               module procedure stdlib_dsyconvf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$syconvf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssyconvf( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    integer(ilp), intent(inout) :: ipiv(*)
                    real(sp), intent(inout) :: a(lda,*),e(*)
               end subroutine ssyconvf
#else 
               module procedure stdlib_ssyconvf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$syconvf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsyconvf( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    integer(ilp), intent(inout) :: ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),e(*)
               end subroutine zsyconvf
#else 
               module procedure stdlib_zsyconvf
#endif
          end interface syconvf



          interface syconvf_rook
          !! If parameter WAY = 'C':
          !! SYCONVF_ROOK converts the factorization output format used in
          !! CSYTRF_ROOK provided on entry in parameter A into the factorization
          !! output format used in CSYTRF_RK (or CSYTRF_BK) that is stored
          !! on exit in parameters A and E. IPIV format for CSYTRF_ROOK and
          !! CSYTRF_RK (or CSYTRF_BK) is the same and is not converted.
          !! If parameter WAY = 'R':
          !! SYCONVF_ROOK performs the conversion in reverse direction, i.e.
          !! converts the factorization output format used in CSYTRF_RK
          !! (or CSYTRF_BK) provided on entry in parameters A and E into
          !! the factorization output format used in CSYTRF_ROOK that is stored
          !! on exit in parameter A. IPIV format for CSYTRF_ROOK and
          !! CSYTRF_RK (or CSYTRF_BK) is the same and is not converted.
          !! SYCONVF_ROOK can also convert in Hermitian matrix case, i.e. between
          !! formats used in CHETRF_ROOK and CHETRF_RK (or CHETRF_BK).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),e(*)
               end subroutine csyconvf_rook
#else 
               module procedure stdlib_csyconvf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*),e(*)
               end subroutine dsyconvf_rook
#else 
               module procedure stdlib_dsyconvf_rook
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$syconvf_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*),e(*)
               end subroutine ssyconvf_rook
#else 
               module procedure stdlib_ssyconvf_rook
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$syconvf_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo,way
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),e(*)
               end subroutine zsyconvf_rook
#else 
               module procedure stdlib_zsyconvf_rook
#endif
          end interface syconvf_rook



          interface syequb
          !! SYEQUB computes row and column scalings intended to equilibrate a
          !! symmetric matrix A (with respect to the Euclidean norm) and reduce
          !! its condition number. The scale factors S are computed by the BIN
          !! algorithm (see references) so that the scaled matrix B with elements
          !! B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
          !! the smallest possible condition number over all possible diagonal
          !! scalings.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csyequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*)
                    character, intent(in) :: uplo
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csyequb
#else 
               module procedure stdlib_csyequb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsyequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*),work(*)
                    character, intent(in) :: uplo
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dsyequb
#else 
               module procedure stdlib_dsyequb
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$syequb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssyequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: amax,scond,s(*),work(*)
                    character, intent(in) :: uplo
                    real(sp), intent(in) :: a(lda,*)
               end subroutine ssyequb
#else 
               module procedure stdlib_ssyequb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$syequb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsyequb( uplo, n, a, lda, s, scond, amax, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: amax,scond,s(*)
                    character, intent(in) :: uplo
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsyequb
#else 
               module procedure stdlib_zsyequb
#endif
          end interface syequb



          interface syev
          !! SYEV computes all eigenvalues and, optionally, eigenvectors of a
          !! real symmetric matrix A.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsyev( jobz, uplo, n, a, lda, w, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: w(*),work(*)
               end subroutine dsyev
#else 
               module procedure stdlib_dsyev
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$syev

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssyev( jobz, uplo, n, a, lda, w, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: w(*),work(*)
               end subroutine ssyev
#else 
               module procedure stdlib_ssyev
#endif
          end interface syev



          interface syevd
          !! SYEVD computes all eigenvalues and, optionally, eigenvectors of a
          !! real symmetric matrix A. If eigenvectors are desired, it uses a
          !! divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
          !! Because of large use of BLAS of level 3, SYEVD needs N**2 more
          !! workspace than DSYEVX.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsyevd( jobz, uplo, n, a, lda, w, work, lwork, iwork,liwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,liwork,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: w(*),work(*)
               end subroutine dsyevd
#else 
               module procedure stdlib_dsyevd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$syevd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssyevd( jobz, uplo, n, a, lda, w, work, lwork, iwork,liwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,liwork,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: w(*),work(*)
               end subroutine ssyevd
#else 
               module procedure stdlib_ssyevd
#endif
          end interface syevd



          interface syevr
          !! SYEVR computes selected eigenvalues and, optionally, eigenvectors
          !! of a real symmetric matrix A.  Eigenvalues and eigenvectors can be
          !! selected by specifying either a range of values or a range of
          !! indices for the desired eigenvalues.
          !! SYEVR first reduces the matrix A to tridiagonal form T with a call
          !! to DSYTRD.  Then, whenever possible, SYEVR calls DSTEMR to compute
          !! the eigenspectrum using Relatively Robust Representations.  DSTEMR
          !! computes eigenvalues by the dqds algorithm, while orthogonal
          !! eigenvectors are computed from various "good" L D L^T representations
          !! (also known as Relatively Robust Representations). Gram-Schmidt
          !! orthogonalization is avoided as far as possible. More specifically,
          !! the various steps of the algorithm are as follows.
          !! For each unreduced block (submatrix) of T,
          !! (a) Compute T - sigma I  = L D L^T, so that L and D
          !! define all the wanted eigenvalues to high relative accuracy.
          !! This means that small relative changes in the entries of D and L
          !! cause only small relative changes in the eigenvalues and
          !! eigenvectors. The standard (unfactored) representation of the
          !! tridiagonal matrix T does not have this property in general.
          !! (b) Compute the eigenvalues to suitable accuracy.
          !! If the eigenvectors are desired, the algorithm attains full
          !! accuracy of the computed eigenvalues only right before
          !! the corresponding vectors have to be computed, see steps c) and d).
          !! (c) For each cluster of close eigenvalues, select a new
          !! shift close to the cluster, find a new factorization, and refine
          !! the shifted eigenvalues to suitable accuracy.
          !! (d) For each eigenvalue with a large enough relative separation compute
          !! the corresponding eigenvector by forming a rank revealing twisted
          !! factorization. Go back to (c) for any clusters that remain.
          !! The desired accuracy of the output can be specified by the input
          !! parameter ABSTOL.
          !! For more details, see DSTEMR's documentation and:
          !! - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
          !! to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
          !! Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
          !! - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
          !! Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
          !! 2004.  Also LAPACK Working Note 154.
          !! - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
          !! tridiagonal eigenvalue/eigenvector problem",
          !! Computer Science Division Technical Report No. UCB/CSD-97-971,
          !! UC Berkeley, May 1997.
          !! Note 1 : SYEVR calls DSTEMR when the full spectrum is requested
          !! on machines which conform to the ieee-754 floating point standard.
          !! SYEVR calls DSTEBZ and DSTEIN on non-ieee machines and
          !! when partial spectrum requests are made.
          !! Normal execution of DSTEMR may create NaNs and infinities and
          !! hence may abort due to a floating point exception in environments
          !! which do not handle NaNs and infinities in the ieee standard default
          !! manner.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsyevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, &
                         ldz, isuppz, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,range,uplo
                    integer(ilp), intent(in) :: il,iu,lda,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(dp), intent(in) :: abstol,vl,vu
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine dsyevr
#else 
               module procedure stdlib_dsyevr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$syevr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssyevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, &
                         ldz, isuppz, work, lwork,iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,range,uplo
                    integer(ilp), intent(in) :: il,iu,lda,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,isuppz(*),iwork(*)
                    real(sp), intent(in) :: abstol,vl,vu
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: w(*),work(*),z(ldz,*)
               end subroutine ssyevr
#else 
               module procedure stdlib_ssyevr
#endif
          end interface syevr



          interface sygst
          !! SYGST reduces a real symmetric-definite generalized eigenproblem
          !! to standard form.
          !! If ITYPE = 1, the problem is A*x = lambda*B*x,
          !! and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)
          !! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
          !! B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.
          !! B must have been previously factorized as U**T*U or L*L**T by DPOTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsygst( itype, uplo, n, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,lda,ldb,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(in) :: b(ldb,*)
               end subroutine dsygst
#else 
               module procedure stdlib_dsygst
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sygst

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssygst( itype, uplo, n, a, lda, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,lda,ldb,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(in) :: b(ldb,*)
               end subroutine ssygst
#else 
               module procedure stdlib_ssygst
#endif
          end interface sygst



          interface sygv
          !! SYGV computes all the eigenvalues, and optionally, the eigenvectors
          !! of a real generalized symmetric-definite eigenproblem, of the form
          !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
          !! Here A and B are assumed to be symmetric and B is also
          !! positive definite.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsygv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,lda,ldb,lwork,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: w(*),work(*)
               end subroutine dsygv
#else 
               module procedure stdlib_dsygv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sygv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssygv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: itype,lda,ldb,lwork,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: w(*),work(*)
               end subroutine ssygv
#else 
               module procedure stdlib_ssygv
#endif
          end interface sygv



          interface sygvd
          !! SYGVD computes all the eigenvalues, and optionally, the eigenvectors
          !! of a real generalized symmetric-definite eigenproblem, of the form
          !! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
          !! B are assumed to be symmetric and B is also positive definite.
          !! If eigenvectors are desired, it uses a divide and conquer algorithm.
          !! The divide and conquer algorithm makes very mild assumptions about
          !! floating point arithmetic. It will work on machines with a guard
          !! digit in add/subtract, or on those binary machines without guard
          !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
          !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
          !! without guard digits, but we know of none.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsygvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: itype,lda,ldb,liwork,lwork,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: w(*),work(*)
               end subroutine dsygvd
#else 
               module procedure stdlib_dsygvd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sygvd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssygvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, iwork, &
                         liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobz,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: itype,lda,ldb,liwork,lwork,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: w(*),work(*)
               end subroutine ssygvd
#else 
               module procedure stdlib_ssygvd
#endif
          end interface sygvd



          interface symv
          !! SYMV performs the matrix-vector  operation
          !! y := alpha*A*x + beta*y,
          !! where alpha and beta are scalars, x and y are n element vectors and
          !! A is an n by n symmetric matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csymv( uplo, n, alpha, a, lda, x, incx, beta, y, incy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incx,incy,lda,n
                    complex(sp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    complex(sp), intent(inout) :: y(*)
               end subroutine csymv
#else 
               module procedure stdlib_csymv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$symv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsymv( uplo, n, alpha, a, lda, x, incx, beta, y, incy )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incx,incy,lda,n
                    complex(dp), intent(in) :: alpha,beta,a(lda,*),x(*)
                    complex(dp), intent(inout) :: y(*)
               end subroutine zsymv
#else 
               module procedure stdlib_zsymv
#endif
          end interface symv



          interface syr
          !! SYR performs the symmetric rank 1 operation
          !! A := alpha*x*x**H + A,
          !! where alpha is a complex scalar, x is an n element vector and A is an
          !! n by n symmetric matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csyr( uplo, n, alpha, x, incx, a, lda )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incx,lda,n
                    complex(sp), intent(in) :: alpha,x(*)
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine csyr
#else 
               module procedure stdlib_csyr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$syr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsyr( uplo, n, alpha, x, incx, a, lda )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: incx,lda,n
                    complex(dp), intent(in) :: alpha,x(*)
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zsyr
#else 
               module procedure stdlib_zsyr
#endif
          end interface syr



          interface syrfs
          !! SYRFS improves the computed solution to a system of linear
          !! equations when the coefficient matrix is symmetric indefinite, and
          !! provides error bounds and backward error estimates for the solution.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x(ldx,*)
               end subroutine csyrfs
#else 
               module procedure stdlib_csyrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
                    real(dp), intent(inout) :: x(ldx,*)
               end subroutine dsyrfs
#else 
               module procedure stdlib_dsyrfs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$syrfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
                    real(sp), intent(inout) :: x(ldx,*)
               end subroutine ssyrfs
#else 
               module procedure stdlib_ssyrfs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$syrfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr,&
                          berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldaf,ldb,ldx,n,nrhs,ipiv(*)
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: a(lda,*),af(ldaf,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x(ldx,*)
               end subroutine zsyrfs
#else 
               module procedure stdlib_zsyrfs
#endif
          end interface syrfs



          interface sysv
          !! SYSV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
          !! matrices.
          !! The diagonal pivoting method is used to factor A as
          !! A = U * D * U**T,  if UPLO = 'U', or
          !! A = L * D * L**T,  if UPLO = 'L',
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is symmetric and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
          !! used to solve the system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csysv
#else 
               module procedure stdlib_csysv
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsysv
#else 
               module procedure stdlib_dsysv
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sysv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssysv
#else 
               module procedure stdlib_ssysv
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sysv

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsysv
#else 
               module procedure stdlib_zsysv
#endif
          end interface sysv



          interface sysv_aa
          !! CSYSV computes the solution to a complex system of linear equations
          !! A * X = B,
          !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
          !! matrices.
          !! Aasen's algorithm is used to factor A as
          !! A = U**T * T * U,  if UPLO = 'U', or
          !! A = L * T * L**T,  if UPLO = 'L',
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and T is symmetric tridiagonal. The factored
          !! form of A is then used to solve the system of equations A * X = B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csysv_aa
#else 
               module procedure stdlib_csysv_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsysv_aa
#else 
               module procedure stdlib_dsysv_aa
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sysv_aa

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssysv_aa
#else 
               module procedure stdlib_ssysv_aa
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sysv_aa

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsysv_aa
#else 
               module procedure stdlib_zsysv_aa
#endif
          end interface sysv_aa



          interface sysv_rk
          !! SYSV_RK computes the solution to a complex system of linear
          !! equations A * X = B, where A is an N-by-N symmetric matrix
          !! and X and B are N-by-NRHS matrices.
          !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
          !! to factor A as
          !! A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
          !! A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
          !! where U (or L) is unit upper (or lower) triangular matrix,
          !! U**T (or L**T) is the transpose of U (or L), P is a permutation
          !! matrix, P**T is the transpose of P, and D is symmetric and block
          !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! CSYTRF_RK is called to compute the factorization of a complex
          !! symmetric matrix.  The factored form of A is then used to solve
          !! the system of equations A * X = B by calling BLAS3 routine CSYTRS_3.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: e(*),work(*)
               end subroutine csysv_rk
#else 
               module procedure stdlib_csysv_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,work, lwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: e(*),work(*)
               end subroutine dsysv_rk
#else 
               module procedure stdlib_dsysv_rk
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sysv_rk

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,work, lwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: e(*),work(*)
               end subroutine ssysv_rk
#else 
               module procedure stdlib_ssysv_rk
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sysv_rk

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: e(*),work(*)
               end subroutine zsysv_rk
#else 
               module procedure stdlib_zsysv_rk
#endif
          end interface sysv_rk



          interface sysv_rook
          !! SYSV_ROOK computes the solution to a complex system of linear
          !! equations
          !! A * X = B,
          !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
          !! matrices.
          !! The diagonal pivoting method is used to factor A as
          !! A = U * D * U**T,  if UPLO = 'U', or
          !! A = L * D * L**T,  if UPLO = 'L',
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is symmetric and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.
          !! CSYTRF_ROOK is called to compute the factorization of a complex
          !! symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
          !! pivoting method.
          !! The factored form of A is then used to solve the system
          !! of equations A * X = B by calling CSYTRS_ROOK.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csysv_rook
#else 
               module procedure stdlib_csysv_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsysv_rook
#else 
               module procedure stdlib_dsysv_rook
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sysv_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssysv_rook
#else 
               module procedure stdlib_ssysv_rook
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sysv_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,ldb,lwork,n,nrhs
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsysv_rook
#else 
               module procedure stdlib_zsysv_rook
#endif
          end interface sysv_rook



          interface syswapr
          !! SYSWAPR applies an elementary permutation on the rows and the columns of
          !! a symmetric matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csyswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: i1,i2,lda,n
                    complex(sp), intent(inout) :: a(lda,n)
               end subroutine csyswapr
#else 
               module procedure stdlib_csyswapr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsyswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: i1,i2,lda,n
                    real(dp), intent(inout) :: a(lda,n)
               end subroutine dsyswapr
#else 
               module procedure stdlib_dsyswapr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$syswapr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssyswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: i1,i2,lda,n
                    real(sp), intent(inout) :: a(lda,n)
               end subroutine ssyswapr
#else 
               module procedure stdlib_ssyswapr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$syswapr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsyswapr( uplo, n, a, lda, i1, i2)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: i1,i2,lda,n
                    complex(dp), intent(inout) :: a(lda,n)
               end subroutine zsyswapr
#else 
               module procedure stdlib_zsyswapr
#endif
          end interface syswapr



          interface sytf2_rk
          !! SYTF2_RK computes the factorization of a complex symmetric matrix A
          !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
          !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
          !! where U (or L) is unit upper (or lower) triangular matrix,
          !! U**T (or L**T) is the transpose of U (or L), P is a permutation
          !! matrix, P**T is the transpose of P, and D is symmetric and block
          !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
          !! For more information see Further Details section.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*)
               end subroutine csytf2_rk
#else 
               module procedure stdlib_csytf2_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: e(*)
               end subroutine dsytf2_rk
#else 
               module procedure stdlib_dsytf2_rk
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytf2_rk

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: e(*)
               end subroutine ssytf2_rk
#else 
               module procedure stdlib_ssytf2_rk
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytf2_rk

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytf2_rk( uplo, n, a, lda, e, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*)
               end subroutine zsytf2_rk
#else 
               module procedure stdlib_zsytf2_rk
#endif
          end interface sytf2_rk



          interface sytf2_rook
          !! SYTF2_ROOK computes the factorization of a complex symmetric matrix A
          !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
          !! A = U*D*U**T  or  A = L*D*L**T
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, U**T is the transpose of U, and D is symmetric and
          !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine csytf2_rook
#else 
               module procedure stdlib_csytf2_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dsytf2_rook
#else 
               module procedure stdlib_dsytf2_rook
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytf2_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine ssytf2_rook
#else 
               module procedure stdlib_ssytf2_rook
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytf2_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytf2_rook( uplo, n, a, lda, ipiv, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine zsytf2_rook
#else 
               module procedure stdlib_zsytf2_rook
#endif
          end interface sytf2_rook



          interface sytrd
          !! SYTRD reduces a real symmetric matrix A to real symmetric
          !! tridiagonal form T by an orthogonal similarity transformation:
          !! Q**T * A * Q = T.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: d(*),e(*),tau(*),work(*)
               end subroutine dsytrd
#else 
               module procedure stdlib_dsytrd
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: d(*),e(*),tau(*),work(*)
               end subroutine ssytrd
#else 
               module procedure stdlib_ssytrd
#endif
          end interface sytrd



          interface sytrd_sb2st
          !! SYTRD_SB2ST reduces a real symmetric band matrix A to real symmetric
          !! tridiagonal form T by a orthogonal similarity transformation:
          !! Q**T * A * Q = T.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsytrd_sb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, &
                         lhous, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: stage1,uplo,vect
                    integer(ilp), intent(in) :: n,kd,ldab,lhous,lwork
                    integer(ilp), intent(out) :: info
                    real(dp), intent(out) :: d(*),e(*),hous(*),work(*)
                    real(dp), intent(inout) :: ab(ldab,*)
               end subroutine dsytrd_sb2st
#else 
               module procedure stdlib_dsytrd_sb2st
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrd_sb2st

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssytrd_sb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, &
                         lhous, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: stage1,uplo,vect
                    integer(ilp), intent(in) :: n,kd,ldab,lhous,lwork
                    integer(ilp), intent(out) :: info
                    real(sp), intent(out) :: d(*),e(*),hous(*),work(*)
                    real(sp), intent(inout) :: ab(ldab,*)
               end subroutine ssytrd_sb2st
#else 
               module procedure stdlib_ssytrd_sb2st
#endif
          end interface sytrd_sb2st



          interface sytrd_sy2sb
          !! SYTRD_SY2SB reduces a real symmetric matrix A to real symmetric
          !! band-diagonal form AB by a orthogonal similarity transformation:
          !! Q**T * A * Q = AB.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dsytrd_sy2sb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldab,lwork,n,kd
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: ab(ldab,*),tau(*),work(*)
               end subroutine dsytrd_sy2sb
#else 
               module procedure stdlib_dsytrd_sy2sb
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrd_sy2sb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ssytrd_sy2sb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info &
                         )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldab,lwork,n,kd
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: ab(ldab,*),tau(*),work(*)
               end subroutine ssytrd_sy2sb
#else 
               module procedure stdlib_ssytrd_sy2sb
#endif
          end interface sytrd_sy2sb



          interface sytrf
          !! SYTRF computes the factorization of a complex symmetric matrix A
          !! using the Bunch-Kaufman diagonal pivoting method.  The form of the
          !! factorization is
          !! A = U*D*U**T  or  A = L*D*L**T
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is symmetric and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytrf
#else 
               module procedure stdlib_csytrf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytrf
#else 
               module procedure stdlib_dsytrf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytrf
#else 
               module procedure stdlib_ssytrf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrf( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytrf
#else 
               module procedure stdlib_zsytrf
#endif
          end interface sytrf



          interface sytrf_aa
          !! SYTRF_AA computes the factorization of a complex symmetric matrix A
          !! using the Aasen's algorithm.  The form of the factorization is
          !! A = U**T*T*U  or  A = L*T*L**T
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and T is a complex symmetric tridiagonal matrix.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,lwork
                    integer(ilp), intent(out) :: info,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytrf_aa
#else 
               module procedure stdlib_csytrf_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,lwork
                    integer(ilp), intent(out) :: info,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytrf_aa
#else 
               module procedure stdlib_dsytrf_aa
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrf_aa

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,lwork
                    integer(ilp), intent(out) :: info,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytrf_aa
#else 
               module procedure stdlib_ssytrf_aa
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrf_aa

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,lda,lwork
                    integer(ilp), intent(out) :: info,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytrf_aa
#else 
               module procedure stdlib_zsytrf_aa
#endif
          end interface sytrf_aa



          interface sytrf_rk
          !! SYTRF_RK computes the factorization of a complex symmetric matrix A
          !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
          !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
          !! where U (or L) is unit upper (or lower) triangular matrix,
          !! U**T (or L**T) is the transpose of U (or L), P is a permutation
          !! matrix, P**T is the transpose of P, and D is symmetric and block
          !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
          !! For more information see Further Details section.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: e(*),work(*)
               end subroutine csytrf_rk
#else 
               module procedure stdlib_csytrf_rk
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: e(*),work(*)
               end subroutine dsytrf_rk
#else 
               module procedure stdlib_dsytrf_rk
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrf_rk

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: e(*),work(*)
               end subroutine ssytrf_rk
#else 
               module procedure stdlib_ssytrf_rk
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrf_rk

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: e(*),work(*)
               end subroutine zsytrf_rk
#else 
               module procedure stdlib_zsytrf_rk
#endif
          end interface sytrf_rk



          interface sytrf_rook
          !! SYTRF_ROOK computes the factorization of a complex symmetric matrix A
          !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
          !! The form of the factorization is
          !! A = U*D*U**T  or  A = L*D*L**T
          !! where U (or L) is a product of permutation and unit upper (lower)
          !! triangular matrices, and D is symmetric and block diagonal with
          !! 1-by-1 and 2-by-2 diagonal blocks.
          !! This is the blocked version of the algorithm, calling Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytrf_rook
#else 
               module procedure stdlib_csytrf_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytrf_rook
#else 
               module procedure stdlib_dsytrf_rook
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrf_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytrf_rook
#else 
               module procedure stdlib_ssytrf_rook
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrf_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info,ipiv(*)
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytrf_rook
#else 
               module procedure stdlib_zsytrf_rook
#endif
          end interface sytrf_rook



          interface sytri
          !! SYTRI computes the inverse of a complex symmetric indefinite matrix
          !! A using the factorization A = U*D*U**T or A = L*D*L**T computed by
          !! CSYTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytri
#else 
               module procedure stdlib_csytri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytri
#else 
               module procedure stdlib_dsytri
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytri
#else 
               module procedure stdlib_ssytri
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytri( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytri
#else 
               module procedure stdlib_zsytri
#endif
          end interface sytri



          interface sytri_rook
          !! SYTRI_ROOK computes the inverse of a complex symmetric
          !! matrix A using the factorization A = U*D*U**T or A = L*D*L**T
          !! computed by CSYTRF_ROOK.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytri_rook
#else 
               module procedure stdlib_csytri_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytri_rook
#else 
               module procedure stdlib_dsytri_rook
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytri_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytri_rook
#else 
               module procedure stdlib_ssytri_rook
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytri_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytri_rook( uplo, n, a, lda, ipiv, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytri_rook
#else 
               module procedure stdlib_zsytri_rook
#endif
          end interface sytri_rook



          interface sytrs
          !! SYTRS solves a system of linear equations A*X = B with a complex
          !! symmetric matrix A using the factorization A = U*D*U**T or
          !! A = L*D*L**T computed by CSYTRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine csytrs
#else 
               module procedure stdlib_csytrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dsytrs
#else 
               module procedure stdlib_dsytrs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine ssytrs
#else 
               module procedure stdlib_ssytrs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zsytrs
#else 
               module procedure stdlib_zsytrs
#endif
          end interface sytrs



          interface sytrs2
          !! SYTRS2 solves a system of linear equations A*X = B with a complex
          !! symmetric matrix A using the factorization A = U*D*U**T or
          !! A = L*D*L**T computed by CSYTRF and converted by CSYCONV.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytrs2
#else 
               module procedure stdlib_csytrs2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytrs2
#else 
               module procedure stdlib_dsytrs2
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrs2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytrs2
#else 
               module procedure stdlib_ssytrs2
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrs2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytrs2
#else 
               module procedure stdlib_zsytrs2
#endif
          end interface sytrs2



          interface sytrs_3
          !! SYTRS_3 solves a system of linear equations A * X = B with a complex
          !! symmetric matrix A using the factorization computed
          !! by CSYTRF_RK or CSYTRF_BK:
          !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
          !! where U (or L) is unit upper (or lower) triangular matrix,
          !! U**T (or L**T) is the transpose of U (or L), P is a permutation
          !! matrix, P**T is the transpose of P, and D is symmetric and block
          !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
          !! This algorithm is using Level 3 BLAS.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*),e(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine csytrs_3
#else 
               module procedure stdlib_csytrs_3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*),e(*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dsytrs_3
#else 
               module procedure stdlib_dsytrs_3
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrs_3

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*),e(*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine ssytrs_3
#else 
               module procedure stdlib_ssytrs_3
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrs_3

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*),e(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zsytrs_3
#else 
               module procedure stdlib_zsytrs_3
#endif
          end interface sytrs_3



          interface sytrs_aa
          !! SYTRS_AA solves a system of linear equations A*X = B with a complex
          !! symmetric matrix A using the factorization A = U**T*T*U or
          !! A = L*T*L**T computed by CSYTRF_AA.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine csytrs_aa
#else 
               module procedure stdlib_csytrs_aa
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp), intent(out) :: info
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dsytrs_aa
#else 
               module procedure stdlib_dsytrs_aa
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrs_aa

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp), intent(out) :: info
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine ssytrs_aa
#else 
               module procedure stdlib_ssytrs_aa
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrs_aa

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(in) :: n,nrhs,lda,ldb,lwork,ipiv(*)
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zsytrs_aa
#else 
               module procedure stdlib_zsytrs_aa
#endif
          end interface sytrs_aa



          interface sytrs_rook
          !! SYTRS_ROOK solves a system of linear equations A*X = B with
          !! a complex symmetric matrix A using the factorization A = U*D*U**T or
          !! A = L*D*L**T computed by CSYTRF_ROOK.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine csytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine csytrs_rook
#else 
               module procedure stdlib_csytrs_rook
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dsytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dsytrs_rook
#else 
               module procedure stdlib_dsytrs_rook
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrs_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ssytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine ssytrs_rook
#else 
               module procedure stdlib_ssytrs_rook
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$sytrs_rook

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zsytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs,ipiv(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine zsytrs_rook
#else 
               module procedure stdlib_zsytrs_rook
#endif
          end interface sytrs_rook



          interface tbcon
          !! TBCON estimates the reciprocal of the condition number of a
          !! triangular band matrix A, in either the 1-norm or the infinity-norm.
          !! The norm of A is computed and an estimate is obtained for
          !! norm(inv(A)), then the reciprocal of the condition number is
          !! computed as
          !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ctbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,rwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctbcon
#else 
               module procedure stdlib_ctbcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dtbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: rcond,work(*)
                    real(dp), intent(in) :: ab(ldab,*)
               end subroutine dtbcon
#else 
               module procedure stdlib_dtbcon
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tbcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine stbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,iwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(sp), intent(out) :: rcond,work(*)
                    real(sp), intent(in) :: ab(ldab,*)
               end subroutine stbcon
#else 
               module procedure stdlib_stbcon
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tbcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ztbcon( norm, uplo, diag, n, kd, ab, ldab, rcond, work,rwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,n
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztbcon
#else 
               module procedure stdlib_ztbcon
#endif
          end interface tbcon



          interface tbrfs
          !! TBRFS provides error bounds and backward error estimates for the
          !! solution to a system of linear equations with a triangular band
          !! coefficient matrix.
          !! The solution matrix X must be computed by CTBTRS or some other
          !! means before entering this routine.  TBRFS does not do iterative
          !! refinement because doing so cannot improve the backward error.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: ab(ldab,*),b(ldb,*),x(ldx,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctbrfs
#else 
               module procedure stdlib_ctbrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,ldb,ldx,n,nrhs
                    real(dp), intent(in) :: ab(ldab,*),b(ldb,*),x(ldx,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine dtbrfs
#else 
               module procedure stdlib_dtbrfs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tbrfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, x, ldx, &
                         ferr, berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: kd,ldab,ldb,ldx,n,nrhs
                    real(sp), intent(in) :: ab(ldab,*),b(ldb,*),x(ldx,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine stbrfs
#else 
               module procedure stdlib_stbrfs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tbrfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztbrfs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, x, ldx, &
                         ferr, berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: ab(ldab,*),b(ldb,*),x(ldx,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztbrfs
#else 
               module procedure stdlib_ztbrfs
#endif
          end interface tbrfs



          interface tbtrs
          !! TBTRS solves a triangular system of the form
          !! A * X = B,  A**T * X = B,  or  A**H * X = B,
          !! where A is a triangular band matrix of order N, and B is an
          !! N-by-NRHS matrix.  A check is made to verify that A is nonsingular.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(sp), intent(in) :: ab(ldab,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine ctbtrs
#else 
               module procedure stdlib_ctbtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(dp), intent(in) :: ab(ldab,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dtbtrs
#else 
               module procedure stdlib_dtbtrs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tbtrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    real(sp), intent(in) :: ab(ldab,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine stbtrs
#else 
               module procedure stdlib_stbtrs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tbtrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztbtrs( uplo, trans, diag, n, kd, nrhs, ab, ldab, b,ldb, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: kd,ldab,ldb,n,nrhs
                    complex(dp), intent(in) :: ab(ldab,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine ztbtrs
#else 
               module procedure stdlib_ztbtrs
#endif
          end interface tbtrs



          interface tfsm
          !! Level 3 BLAS like routine for A in RFP Format.
          !! TFSM solves the matrix equation
          !! op( A )*X = alpha*B  or  X*op( A ) = alpha*B
          !! where alpha is a scalar, X and B are m by n matrices, A is a unit, or
          !! non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
          !! op( A ) = A   or   op( A ) = A**H.
          !! A is in Rectangular Full Packed (RFP) Format.
          !! The matrix X is overwritten on B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctfsm( transr, side, uplo, trans, diag, m, n, alpha, a,b, ldb )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,diag,side,trans,uplo
                    integer(ilp), intent(in) :: ldb,m,n
                    complex(sp), intent(in) :: alpha,a(0:*)
                    complex(sp), intent(inout) :: b(0:ldb-1,0:*)
               end subroutine ctfsm
#else 
               module procedure stdlib_ctfsm
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtfsm( transr, side, uplo, trans, diag, m, n, alpha, a,b, ldb )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,diag,side,trans,uplo
                    integer(ilp), intent(in) :: ldb,m,n
                    real(dp), intent(in) :: alpha,a(0:*)
                    real(dp), intent(inout) :: b(0:ldb-1,0:*)
               end subroutine dtfsm
#else 
               module procedure stdlib_dtfsm
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tfsm

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stfsm( transr, side, uplo, trans, diag, m, n, alpha, a,b, ldb )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,diag,side,trans,uplo
                    integer(ilp), intent(in) :: ldb,m,n
                    real(sp), intent(in) :: alpha,a(0:*)
                    real(sp), intent(inout) :: b(0:ldb-1,0:*)
               end subroutine stfsm
#else 
               module procedure stdlib_stfsm
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tfsm

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztfsm( transr, side, uplo, trans, diag, m, n, alpha, a,b, ldb )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,diag,side,trans,uplo
                    integer(ilp), intent(in) :: ldb,m,n
                    complex(dp), intent(in) :: alpha,a(0:*)
                    complex(dp), intent(inout) :: b(0:ldb-1,0:*)
               end subroutine ztfsm
#else 
               module procedure stdlib_ztfsm
#endif
          end interface tfsm



          interface tftri
          !! TFTRI computes the inverse of a triangular matrix A stored in RFP
          !! format.
          !! This is a Level 3 BLAS version of the algorithm.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctftri( transr, uplo, diag, n, a, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo,diag
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: a(0:*)
               end subroutine ctftri
#else 
               module procedure stdlib_ctftri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtftri( transr, uplo, diag, n, a, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo,diag
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: a(0:*)
               end subroutine dtftri
#else 
               module procedure stdlib_dtftri
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tftri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stftri( transr, uplo, diag, n, a, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo,diag
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: a(0:*)
               end subroutine stftri
#else 
               module procedure stdlib_stftri
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tftri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztftri( transr, uplo, diag, n, a, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo,diag
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: a(0:*)
               end subroutine ztftri
#else 
               module procedure stdlib_ztftri
#endif
          end interface tftri



          interface tfttp
          !! TFTTP copies a triangular matrix A from rectangular full packed
          !! format (TF) to standard packed format (TP).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctfttp( transr, uplo, n, arf, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(out) :: ap(0:*)
                    complex(sp), intent(in) :: arf(0:*)
               end subroutine ctfttp
#else 
               module procedure stdlib_ctfttp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtfttp( transr, uplo, n, arf, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: ap(0:*)
                    real(dp), intent(in) :: arf(0:*)
               end subroutine dtfttp
#else 
               module procedure stdlib_dtfttp
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tfttp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stfttp( transr, uplo, n, arf, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: ap(0:*)
                    real(sp), intent(in) :: arf(0:*)
               end subroutine stfttp
#else 
               module procedure stdlib_stfttp
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tfttp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztfttp( transr, uplo, n, arf, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(out) :: ap(0:*)
                    complex(dp), intent(in) :: arf(0:*)
               end subroutine ztfttp
#else 
               module procedure stdlib_ztfttp
#endif
          end interface tfttp



          interface tfttr
          !! TFTTR copies a triangular matrix A from rectangular full packed
          !! format (TF) to standard full format (TR).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctfttr( transr, uplo, n, arf, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    complex(sp), intent(out) :: a(0:lda-1,0:*)
                    complex(sp), intent(in) :: arf(0:*)
               end subroutine ctfttr
#else 
               module procedure stdlib_ctfttr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtfttr( transr, uplo, n, arf, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    real(dp), intent(out) :: a(0:lda-1,0:*)
                    real(dp), intent(in) :: arf(0:*)
               end subroutine dtfttr
#else 
               module procedure stdlib_dtfttr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tfttr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stfttr( transr, uplo, n, arf, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    real(sp), intent(out) :: a(0:lda-1,0:*)
                    real(sp), intent(in) :: arf(0:*)
               end subroutine stfttr
#else 
               module procedure stdlib_stfttr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tfttr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztfttr( transr, uplo, n, arf, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    complex(dp), intent(out) :: a(0:lda-1,0:*)
                    complex(dp), intent(in) :: arf(0:*)
               end subroutine ztfttr
#else 
               module procedure stdlib_ztfttr
#endif
          end interface tfttr



          interface tgevc
          !! TGEVC computes some or all of the right and/or left eigenvectors of
          !! a pair of complex matrices (S,P), where S and P are upper triangular.
          !! Matrix pairs of this type are produced by the generalized Schur
          !! factorization of a complex matrix pair (A,B):
          !! A = Q*S*Z**H,  B = Q*P*Z**H
          !! as computed by CGGHRD + CHGEQZ.
          !! The right eigenvector x and the left eigenvector y of (S,P)
          !! corresponding to an eigenvalue w are defined by:
          !! S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
          !! where y**H denotes the conjugate tranpose of y.
          !! The eigenvalues are not input to this routine, but are computed
          !! directly from the diagonal elements of S and P.
          !! This routine returns the matrices X and/or Y of right and left
          !! eigenvectors of (S,P), or the products Z*X and/or Q*Y,
          !! where Z and Q are input matrices.
          !! If Q and Z are the unitary factors from the generalized Schur
          !! factorization of a matrix pair (A,B), then Z*X and Q*Y
          !! are the matrices of right and left eigenvectors of (A,B).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr,&
                          mm, m, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldp,lds,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(in) :: p(ldp,*),s(lds,*)
                    complex(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctgevc
#else 
               module procedure stdlib_ctgevc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr,&
                          mm, m, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldp,lds,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(in) :: p(ldp,*),s(lds,*)
                    real(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtgevc
#else 
               module procedure stdlib_dtgevc
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tgevc

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr,&
                          mm, m, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldp,lds,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(in) :: p(ldp,*),s(lds,*)
                    real(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(sp), intent(out) :: work(*)
               end subroutine stgevc
#else 
               module procedure stdlib_stgevc
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tgevc

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr,&
                          mm, m, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldp,lds,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(in) :: p(ldp,*),s(lds,*)
                    complex(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztgevc
#else 
               module procedure stdlib_ztgevc
#endif
          end interface tgevc



          interface tgexc
          !! TGEXC reorders the generalized Schur decomposition of a complex
          !! matrix pair (A,B), using an unitary equivalence transformation
          !! (A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with
          !! row index IFST is moved to row ILST.
          !! (A, B) must be in generalized Schur canonical form, that is, A and
          !! B are both upper triangular.
          !! Optionally, the matrices Q and Z of generalized Schur vectors are
          !! updated.
          !! Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
          !! Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst,&
                          info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: wantq,wantz
                    integer(ilp), intent(in) :: ifst,lda,ldb,ldq,ldz,n
                    integer(ilp), intent(inout) :: ilst
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine ctgexc
#else 
               module procedure stdlib_ctgexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst,&
                          work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: wantq,wantz
                    integer(ilp), intent(inout) :: ifst,ilst
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldq,ldz,lwork,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtgexc
#else 
               module procedure stdlib_dtgexc
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tgexc

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst,&
                          work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: wantq,wantz
                    integer(ilp), intent(inout) :: ifst,ilst
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldq,ldz,lwork,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    real(sp), intent(out) :: work(*)
               end subroutine stgexc
#else 
               module procedure stdlib_stgexc
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tgexc

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst,&
                          info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: wantq,wantz
                    integer(ilp), intent(in) :: ifst,lda,ldb,ldq,ldz,n
                    integer(ilp), intent(inout) :: ilst
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine ztgexc
#else 
               module procedure stdlib_ztgexc
#endif
          end interface tgexc



          interface tgsen
          !! TGSEN reorders the generalized Schur decomposition of a complex
          !! matrix pair (A, B) (in terms of an unitary equivalence trans-
          !! formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues
          !! appears in the leading diagonal blocks of the pair (A,B). The leading
          !! columns of Q and Z form unitary bases of the corresponding left and
          !! right eigenspaces (deflating subspaces). (A, B) must be in
          !! generalized Schur canonical form, that is, A and B are both upper
          !! triangular.
          !! TGSEN also computes the generalized eigenvalues
          !! w(j)= ALPHA(j) / BETA(j)
          !! of the reordered matrix pair (A, B).
          !! Optionally, the routine computes estimates of reciprocal condition
          !! numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
          !! (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
          !! between the matrix pairs (A11, B11) and (A22,B22) that correspond to
          !! the selected cluster and the eigenvalues outside the cluster, resp.,
          !! and norms of "projections" onto left and right eigenspaces w.r.t.
          !! the selected cluster in the (1,1)-block.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alpha, beta, &
                         q, ldq, z, ldz, m, pl, pr, dif,work, lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: wantq,wantz,select(*)
                    integer(ilp), intent(in) :: ijob,lda,ldb,ldq,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    real(sp), intent(out) :: pl,pr,dif(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    complex(sp), intent(out) :: alpha(*),beta(*),work(*)
               end subroutine ctgsen
#else 
               module procedure stdlib_ctgsen
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alphar, &
               alphai, beta, q, ldq, z, ldz, m, pl,pr, dif, work, lwork, iwork, liwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: wantq,wantz,select(*)
                    integer(ilp), intent(in) :: ijob,lda,ldb,ldq,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    real(dp), intent(out) :: pl,pr,alphai(*),alphar(*),beta(*),dif(*),work(*)
                              
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine dtgsen
#else 
               module procedure stdlib_dtgsen
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tgsen

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alphar, &
               alphai, beta, q, ldq, z, ldz, m, pl,pr, dif, work, lwork, iwork, liwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: wantq,wantz,select(*)
                    integer(ilp), intent(in) :: ijob,lda,ldb,ldq,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    real(sp), intent(out) :: pl,pr,alphai(*),alphar(*),beta(*),dif(*),work(*)
                              
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
               end subroutine stgsen
#else 
               module procedure stdlib_stgsen
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tgsen

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alpha, beta, &
                         q, ldq, z, ldz, m, pl, pr, dif,work, lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    logical(lk), intent(in) :: wantq,wantz,select(*)
                    integer(ilp), intent(in) :: ijob,lda,ldb,ldq,ldz,liwork,lwork,n
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    real(dp), intent(out) :: pl,pr,dif(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),z(ldz,*)
                    complex(dp), intent(out) :: alpha(*),beta(*),work(*)
               end subroutine ztgsen
#else 
               module procedure stdlib_ztgsen
#endif
          end interface tgsen



          interface tgsja
          !! TGSJA computes the generalized singular value decomposition (GSVD)
          !! of two complex upper triangular (or trapezoidal) matrices A and B.
          !! On entry, it is assumed that matrices A and B have the following
          !! forms, which may be obtained by the preprocessing subroutine CGGSVP
          !! from a general M-by-N matrix A and P-by-N matrix B:
          !! N-K-L  K    L
          !! A =    K ( 0    A12  A13 ) if M-K-L >= 0;
          !! L ( 0     0   A23 )
          !! M-K-L ( 0     0    0  )
          !! N-K-L  K    L
          !! A =  K ( 0    A12  A13 ) if M-K-L < 0;
          !! M-K ( 0     0   A23 )
          !! N-K-L  K    L
          !! B =  L ( 0     0   B13 )
          !! P-L ( 0     0    0  )
          !! where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
          !! upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
          !! otherwise A23 is (M-K)-by-L upper trapezoidal.
          !! On exit,
          !! U**H *A*Q = D1*( 0 R ),    V**H *B*Q = D2*( 0 R ),
          !! where U, V and Q are unitary matrices.
          !! R is a nonsingular upper triangular matrix, and D1
          !! and D2 are ``diagonal'' matrices, which are of the following
          !! structures:
          !! If M-K-L >= 0,
          !! K  L
          !! D1 =     K ( I  0 )
          !! L ( 0  C )
          !! M-K-L ( 0  0 )
          !! K  L
          !! D2 = L   ( 0  S )
          !! P-L ( 0  0 )
          !! N-K-L  K    L
          !! ( 0 R ) = K (  0   R11  R12 ) K
          !! L (  0    0   R22 ) L
          !! where
          !! C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
          !! S = diag( BETA(K+1),  ... , BETA(K+L) ),
          !! C**2 + S**2 = I.
          !! R is stored in A(1:K+L,N-K-L+1:N) on exit.
          !! If M-K-L < 0,
          !! K M-K K+L-M
          !! D1 =   K ( I  0    0   )
          !! M-K ( 0  C    0   )
          !! K M-K K+L-M
          !! D2 =   M-K ( 0  S    0   )
          !! K+L-M ( 0  0    I   )
          !! P-L ( 0  0    0   )
          !! N-K-L  K   M-K  K+L-M
          !! ( 0 R ) =    K ( 0    R11  R12  R13  )
          !! M-K ( 0     0   R22  R23  )
          !! K+L-M ( 0     0    0   R33  )
          !! where
          !! C = diag( ALPHA(K+1), ... , ALPHA(M) ),
          !! S = diag( BETA(K+1),  ... , BETA(M) ),
          !! C**2 + S**2 = I.
          !! R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
          !! (  0  R22 R23 )
          !! in B(M-K+1:L,N+M-K-L+1:N) on exit.
          !! The computation of the unitary transformation matrices U, V or Q
          !! is optional.  These matrices may either be formed explicitly, or they
          !! may be postmultiplied into input matrices U1, V1, or Q1.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb,&
                          alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobq,jobu,jobv
                    integer(ilp), intent(out) :: info,ncycle
                    integer(ilp), intent(in) :: k,l,lda,ldb,ldq,ldu,ldv,m,n,p
                    real(sp), intent(in) :: tola,tolb
                    real(sp), intent(out) :: alpha(*),beta(*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),u(ldu,*),v(ldv,*)
                              
                    complex(sp), intent(out) :: work(*)
               end subroutine ctgsja
#else 
               module procedure stdlib_ctgsja
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb,&
                          alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobq,jobu,jobv
                    integer(ilp), intent(out) :: info,ncycle
                    integer(ilp), intent(in) :: k,l,lda,ldb,ldq,ldu,ldv,m,n,p
                    real(dp), intent(in) :: tola,tolb
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),u(ldu,*),v(ldv,*)
                              
                    real(dp), intent(out) :: alpha(*),beta(*),work(*)
               end subroutine dtgsja
#else 
               module procedure stdlib_dtgsja
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tgsja

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb,&
                          alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobq,jobu,jobv
                    integer(ilp), intent(out) :: info,ncycle
                    integer(ilp), intent(in) :: k,l,lda,ldb,ldq,ldu,ldv,m,n,p
                    real(sp), intent(in) :: tola,tolb
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),u(ldu,*),v(ldv,*)
                              
                    real(sp), intent(out) :: alpha(*),beta(*),work(*)
               end subroutine stgsja
#else 
               module procedure stdlib_stgsja
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tgsja

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb,&
                          alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobq,jobu,jobv
                    integer(ilp), intent(out) :: info,ncycle
                    integer(ilp), intent(in) :: k,l,lda,ldb,ldq,ldu,ldv,m,n,p
                    real(dp), intent(in) :: tola,tolb
                    real(dp), intent(out) :: alpha(*),beta(*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*),q(ldq,*),u(ldu,*),v(ldv,*)
                              
                    complex(dp), intent(out) :: work(*)
               end subroutine ztgsja
#else 
               module procedure stdlib_ztgsja
#endif
          end interface tgsja



          interface tgsna
          !! TGSNA estimates reciprocal condition numbers for specified
          !! eigenvalues and/or eigenvectors of a matrix pair (A, B).
          !! (A, B) must be in generalized Schur canonical form, that is, A and
          !! B are both upper triangular.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                         s, dif, mm, m, work, lwork,iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,job
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: dif(*),s(*)
                    complex(sp), intent(in) :: a(lda,*),b(ldb,*),vl(ldvl,*),vr(ldvr,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctgsna
#else 
               module procedure stdlib_ctgsna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                         s, dif, mm, m, work, lwork,iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,job
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(in) :: a(lda,*),b(ldb,*),vl(ldvl,*),vr(ldvr,*)
                    real(dp), intent(out) :: dif(*),s(*),work(*)
               end subroutine dtgsna
#else 
               module procedure stdlib_dtgsna
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tgsna

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                         s, dif, mm, m, work, lwork,iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,job
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(in) :: a(lda,*),b(ldb,*),vl(ldvl,*),vr(ldvr,*)
                    real(sp), intent(out) :: dif(*),s(*),work(*)
               end subroutine stgsna
#else 
               module procedure stdlib_stgsna
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tgsna

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                         s, dif, mm, m, work, lwork,iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,job
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: dif(*),s(*)
                    complex(dp), intent(in) :: a(lda,*),b(ldb,*),vl(ldvl,*),vr(ldvr,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztgsna
#else 
               module procedure stdlib_ztgsna
#endif
          end interface tgsna



          interface tgsyl
          !! TGSYL solves the generalized Sylvester equation:
          !! A * R - L * B = scale * C            (1)
          !! D * R - L * E = scale * F
          !! where R and L are unknown m-by-n matrices, (A, D), (B, E) and
          !! (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
          !! respectively, with complex entries. A, B, D and E are upper
          !! triangular (i.e., (A,D) and (B,E) in generalized Schur form).
          !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
          !! is an output scaling factor chosen to avoid overflow.
          !! In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
          !! is defined as
          !! Z = [ kron(In, A)  -kron(B**H, Im) ]        (2)
          !! [ kron(In, D)  -kron(E**H, Im) ],
          !! Here Ix is the identity matrix of size x and X**H is the conjugate
          !! transpose of X. Kron(X, Y) is the Kronecker product between the
          !! matrices X and Y.
          !! If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b
          !! is solved for, which is equivalent to solve for R and L in
          !! A**H * R + D**H * L = scale * C           (3)
          !! R * B**H + L * E**H = scale * -F
          !! This case (TRANS = 'C') is used to compute an one-norm-based estimate
          !! of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
          !! and (B,E), using CLACON.
          !! If IJOB >= 1, TGSYL computes a Frobenius norm-based estimate of
          !! Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
          !! reciprocal of the smallest singular value of Z.
          !! This is a level-3 BLAS algorithm.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, &
                         f, ldf, scale, dif, work, lwork,iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: ijob,lda,ldb,ldc,ldd,lde,ldf,lwork,m,n
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(out) :: dif,scale
                    complex(sp), intent(in) :: a(lda,*),b(ldb,*),d(ldd,*),e(lde,*)
                    complex(sp), intent(inout) :: c(ldc,*),f(ldf,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctgsyl
#else 
               module procedure stdlib_ctgsyl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, &
                         f, ldf, scale, dif, work, lwork,iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: ijob,lda,ldb,ldc,ldd,lde,ldf,lwork,m,n
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(out) :: dif,scale,work(*)
                    real(dp), intent(in) :: a(lda,*),b(ldb,*),d(ldd,*),e(lde,*)
                    real(dp), intent(inout) :: c(ldc,*),f(ldf,*)
               end subroutine dtgsyl
#else 
               module procedure stdlib_dtgsyl
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tgsyl

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, &
                         f, ldf, scale, dif, work, lwork,iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: ijob,lda,ldb,ldc,ldd,lde,ldf,lwork,m,n
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(sp), intent(out) :: dif,scale,work(*)
                    real(sp), intent(in) :: a(lda,*),b(ldb,*),d(ldd,*),e(lde,*)
                    real(sp), intent(inout) :: c(ldc,*),f(ldf,*)
               end subroutine stgsyl
#else 
               module procedure stdlib_stgsyl
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tgsyl

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, &
                         f, ldf, scale, dif, work, lwork,iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trans
                    integer(ilp), intent(in) :: ijob,lda,ldb,ldc,ldd,lde,ldf,lwork,m,n
                    integer(ilp), intent(out) :: info,iwork(*)
                    real(dp), intent(out) :: dif,scale
                    complex(dp), intent(in) :: a(lda,*),b(ldb,*),d(ldd,*),e(lde,*)
                    complex(dp), intent(inout) :: c(ldc,*),f(ldf,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztgsyl
#else 
               module procedure stdlib_ztgsyl
#endif
          end interface tgsyl



          interface tpcon
          !! TPCON estimates the reciprocal of the condition number of a packed
          !! triangular matrix A, in either the 1-norm or the infinity-norm.
          !! The norm of A is computed and an estimate is obtained for
          !! norm(inv(A)), then the reciprocal of the condition number is
          !! computed as
          !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ctpcon( norm, uplo, diag, n, ap, rcond, work, rwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctpcon
#else 
               module procedure stdlib_ctpcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dtpcon( norm, uplo, diag, n, ap, rcond, work, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: rcond,work(*)
                    real(dp), intent(in) :: ap(*)
               end subroutine dtpcon
#else 
               module procedure stdlib_dtpcon
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tpcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine stpcon( norm, uplo, diag, n, ap, rcond, work, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: n
                    real(sp), intent(out) :: rcond,work(*)
                    real(sp), intent(in) :: ap(*)
               end subroutine stpcon
#else 
               module procedure stdlib_stpcon
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tpcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ztpcon( norm, uplo, diag, n, ap, rcond, work, rwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztpcon
#else 
               module procedure stdlib_ztpcon
#endif
          end interface tpcon



          interface tplqt
          !! TPLQT computes a blocked LQ factorization of a complex
          !! "triangular-pentagonal" matrix C, which is composed of a
          !! triangular block A and pentagonal block B, using the compact
          !! WY representation for Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctplqt( m, n, l, mb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l,mb
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine ctplqt
#else 
               module procedure stdlib_ctplqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtplqt( m, n, l, mb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l,mb
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine dtplqt
#else 
               module procedure stdlib_dtplqt
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tplqt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stplqt( m, n, l, mb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l,mb
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine stplqt
#else 
               module procedure stdlib_stplqt
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tplqt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztplqt( m, n, l, mb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l,mb
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine ztplqt
#else 
               module procedure stdlib_ztplqt
#endif
          end interface tplqt



          interface tplqt2
          !! TPLQT2 computes a LQ a factorization of a complex "triangular-pentagonal"
          !! matrix C, which is composed of a triangular block A and pentagonal block B,
          !! using the compact WY representation for Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctplqt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: t(ldt,*)
               end subroutine ctplqt2
#else 
               module procedure stdlib_ctplqt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtplqt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: t(ldt,*)
               end subroutine dtplqt2
#else 
               module procedure stdlib_dtplqt2
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tplqt2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stplqt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: t(ldt,*)
               end subroutine stplqt2
#else 
               module procedure stdlib_stplqt2
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tplqt2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztplqt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: t(ldt,*)
               end subroutine ztplqt2
#else 
               module procedure stdlib_ztplqt2
#endif
          end interface tplqt2



          interface tpmlqt
          !! TPMLQT applies a complex unitary matrix Q obtained from a
          !! "triangular-pentagonal" complex block reflector H to a general
          !! complex matrix C, which consists of two blocks A and B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctpmlqt( side, trans, m, n, k, l, mb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,lda,ldb,m,n,l,mb,ldt
                    complex(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctpmlqt
#else 
               module procedure stdlib_ctpmlqt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtpmlqt( side, trans, m, n, k, l, mb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,lda,ldb,m,n,l,mb,ldt
                    real(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtpmlqt
#else 
               module procedure stdlib_dtpmlqt
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tpmlqt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stpmlqt( side, trans, m, n, k, l, mb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,lda,ldb,m,n,l,mb,ldt
                    real(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine stpmlqt
#else 
               module procedure stdlib_stpmlqt
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tpmlqt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztpmlqt( side, trans, m, n, k, l, mb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,lda,ldb,m,n,l,mb,ldt
                    complex(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztpmlqt
#else 
               module procedure stdlib_ztpmlqt
#endif
          end interface tpmlqt



          interface tpmqrt
          !! TPMQRT applies a complex orthogonal matrix Q obtained from a
          !! "triangular-pentagonal" complex block reflector H to a general
          !! complex matrix C, which consists of two blocks A and B.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,lda,ldb,m,n,l,nb,ldt
                    complex(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctpmqrt
#else 
               module procedure stdlib_ctpmqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,lda,ldb,m,n,l,nb,ldt
                    real(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtpmqrt
#else 
               module procedure stdlib_dtpmqrt
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tpmqrt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,lda,ldb,m,n,l,nb,ldt
                    real(sp), intent(in) :: v(ldv,*),t(ldt,*)
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: work(*)
               end subroutine stpmqrt
#else 
               module procedure stdlib_stpmqrt
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tpmqrt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztpmqrt( side, trans, m, n, k, l, nb, v, ldv, t, ldt,a, lda, b, &
                         ldb, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,ldv,lda,ldb,m,n,l,nb,ldt
                    complex(dp), intent(in) :: v(ldv,*),t(ldt,*)
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztpmqrt
#else 
               module procedure stdlib_ztpmqrt
#endif
          end interface tpmqrt



          interface tpqrt
          !! TPQRT computes a blocked QR factorization of a complex
          !! "triangular-pentagonal" matrix C, which is composed of a
          !! triangular block A and pentagonal block B, using the compact
          !! WY representation for Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l,nb
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine ctpqrt
#else 
               module procedure stdlib_ctpqrt
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l,nb
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine dtpqrt
#else 
               module procedure stdlib_dtpqrt
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tpqrt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l,nb
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: t(ldt,*),work(*)
               end subroutine stpqrt
#else 
               module procedure stdlib_stpqrt
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tpqrt

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztpqrt( m, n, l, nb, a, lda, b, ldb, t, ldt, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l,nb
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: t(ldt,*),work(*)
               end subroutine ztpqrt
#else 
               module procedure stdlib_ztpqrt
#endif
          end interface tpqrt



          interface tpqrt2
          !! TPQRT2 computes a QR factorization of a complex "triangular-pentagonal"
          !! matrix C, which is composed of a triangular block A and pentagonal block B,
          !! using the compact WY representation for Q.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(out) :: t(ldt,*)
               end subroutine ctpqrt2
#else 
               module procedure stdlib_ctpqrt2
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(out) :: t(ldt,*)
               end subroutine dtpqrt2
#else 
               module procedure stdlib_dtpqrt2
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tpqrt2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(out) :: t(ldt,*)
               end subroutine stpqrt2
#else 
               module procedure stdlib_stpqrt2
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tpqrt2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztpqrt2( m, n, l, a, lda, b, ldb, t, ldt, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldt,n,m,l
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(out) :: t(ldt,*)
               end subroutine ztpqrt2
#else 
               module procedure stdlib_ztpqrt2
#endif
          end interface tpqrt2



          interface tprfb
          !! TPRFB applies a complex "triangular-pentagonal" block reflector H or its
          !! conjugate transpose H**H to a complex matrix C, which is composed of two
          !! blocks A and B, either from the left or right.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctprfb( side, trans, direct, storev, m, n, k, l,v, ldv, t, ldt, a, &
                         lda, b, ldb, work, ldwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,l,lda,ldb,ldt,ldv,ldwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(in) :: t(ldt,*),v(ldv,*)
                    complex(sp), intent(out) :: work(ldwork,*)
               end subroutine ctprfb
#else 
               module procedure stdlib_ctprfb
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtprfb( side, trans, direct, storev, m, n, k, l,v, ldv, t, ldt, a, &
                         lda, b, ldb, work, ldwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,l,lda,ldb,ldt,ldv,ldwork,m,n
                    real(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(dp), intent(in) :: t(ldt,*),v(ldv,*)
                    real(dp), intent(out) :: work(ldwork,*)
               end subroutine dtprfb
#else 
               module procedure stdlib_dtprfb
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tprfb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stprfb( side, trans, direct, storev, m, n, k, l,v, ldv, t, ldt, a, &
                         lda, b, ldb, work, ldwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,l,lda,ldb,ldt,ldv,ldwork,m,n
                    real(sp), intent(inout) :: a(lda,*),b(ldb,*)
                    real(sp), intent(in) :: t(ldt,*),v(ldv,*)
                    real(sp), intent(out) :: work(ldwork,*)
               end subroutine stprfb
#else 
               module procedure stdlib_stprfb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tprfb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztprfb( side, trans, direct, storev, m, n, k, l,v, ldv, t, ldt, a, &
                         lda, b, ldb, work, ldwork )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: direct,side,storev,trans
                    integer(ilp), intent(in) :: k,l,lda,ldb,ldt,ldv,ldwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(in) :: t(ldt,*),v(ldv,*)
                    complex(dp), intent(out) :: work(ldwork,*)
               end subroutine ztprfb
#else 
               module procedure stdlib_ztprfb
#endif
          end interface tprfb



          interface tprfs
          !! TPRFS provides error bounds and backward error estimates for the
          !! solution to a system of linear equations with a triangular packed
          !! coefficient matrix.
          !! The solution matrix X must be computed by CTPTRS or some other
          !! means before entering this routine.  TPRFS does not do iterative
          !! refinement because doing so cannot improve the backward error.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: ap(*),b(ldb,*),x(ldx,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctprfs
#else 
               module procedure stdlib_ctprfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,ferr, berr, &
                         work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(in) :: ap(*),b(ldb,*),x(ldx,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine dtprfs
#else 
               module procedure stdlib_dtprfs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tprfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,ferr, berr, &
                         work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(sp), intent(in) :: ap(*),b(ldb,*),x(ldx,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine stprfs
#else 
               module procedure stdlib_stprfs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tprfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztprfs( uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx,ferr, berr, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: ap(*),b(ldb,*),x(ldx,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztprfs
#else 
               module procedure stdlib_ztprfs
#endif
          end interface tprfs



          interface tptri
          !! TPTRI computes the inverse of a complex upper or lower triangular
          !! matrix A stored in packed format.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctptri( uplo, diag, n, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(inout) :: ap(*)
               end subroutine ctptri
#else 
               module procedure stdlib_ctptri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtptri( uplo, diag, n, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(inout) :: ap(*)
               end subroutine dtptri
#else 
               module procedure stdlib_dtptri
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tptri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stptri( uplo, diag, n, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(inout) :: ap(*)
               end subroutine stptri
#else 
               module procedure stdlib_stptri
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tptri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztptri( uplo, diag, n, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(inout) :: ap(*)
               end subroutine ztptri
#else 
               module procedure stdlib_ztptri
#endif
          end interface tptri



          interface tptrs
          !! TPTRS solves a triangular system of the form
          !! A * X = B,  A**T * X = B,  or  A**H * X = B,
          !! where A is a triangular matrix of order N stored in packed format,
          !! and B is an N-by-NRHS matrix.  A check is made to verify that A is
          !! nonsingular.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(sp), intent(in) :: ap(*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine ctptrs
#else 
               module procedure stdlib_ctptrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(dp), intent(in) :: ap(*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dtptrs
#else 
               module procedure stdlib_dtptrs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tptrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    real(sp), intent(in) :: ap(*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine stptrs
#else 
               module procedure stdlib_stptrs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tptrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztptrs( uplo, trans, diag, n, nrhs, ap, b, ldb, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldb,n,nrhs
                    complex(dp), intent(in) :: ap(*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine ztptrs
#else 
               module procedure stdlib_ztptrs
#endif
          end interface tptrs



          interface tpttf
          !! TPTTF copies a triangular matrix A from standard packed format (TP)
          !! to rectangular full packed format (TF).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctpttf( transr, uplo, n, ap, arf, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(sp), intent(in) :: ap(0:*)
                    complex(sp), intent(out) :: arf(0:*)
               end subroutine ctpttf
#else 
               module procedure stdlib_ctpttf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtpttf( transr, uplo, n, ap, arf, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(dp), intent(in) :: ap(0:*)
                    real(dp), intent(out) :: arf(0:*)
               end subroutine dtpttf
#else 
               module procedure stdlib_dtpttf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tpttf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stpttf( transr, uplo, n, ap, arf, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    real(sp), intent(in) :: ap(0:*)
                    real(sp), intent(out) :: arf(0:*)
               end subroutine stpttf
#else 
               module procedure stdlib_stpttf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tpttf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztpttf( transr, uplo, n, ap, arf, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n
                    complex(dp), intent(in) :: ap(0:*)
                    complex(dp), intent(out) :: arf(0:*)
               end subroutine ztpttf
#else 
               module procedure stdlib_ztpttf
#endif
          end interface tpttf



          interface tpttr
          !! TPTTR copies a triangular matrix A from standard packed format (TP)
          !! to standard full format (TR).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctpttr( uplo, n, ap, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    complex(sp), intent(out) :: a(lda,*)
                    complex(sp), intent(in) :: ap(*)
               end subroutine ctpttr
#else 
               module procedure stdlib_ctpttr
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtpttr( uplo, n, ap, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    real(dp), intent(out) :: a(lda,*)
                    real(dp), intent(in) :: ap(*)
               end subroutine dtpttr
#else 
               module procedure stdlib_dtpttr
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tpttr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stpttr( uplo, n, ap, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    real(sp), intent(out) :: a(lda,*)
                    real(sp), intent(in) :: ap(*)
               end subroutine stpttr
#else 
               module procedure stdlib_stpttr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tpttr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztpttr( uplo, n, ap, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    complex(dp), intent(out) :: a(lda,*)
                    complex(dp), intent(in) :: ap(*)
               end subroutine ztpttr
#else 
               module procedure stdlib_ztpttr
#endif
          end interface tpttr



          interface trcon
          !! TRCON estimates the reciprocal of the condition number of a
          !! triangular matrix A, in either the 1-norm or the infinity-norm.
          !! The norm of A is computed and an estimate is obtained for
          !! norm(inv(A)), then the reciprocal of the condition number is
          !! computed as
          !! RCOND = 1 / ( norm(A) * norm(inv(A)) ).
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ctrcon( norm, uplo, diag, n, a, lda, rcond, work,rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: rcond,rwork(*)
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctrcon
#else 
               module procedure stdlib_ctrcon
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dtrcon( norm, uplo, diag, n, a, lda, rcond, work,iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: rcond,work(*)
                    real(dp), intent(in) :: a(lda,*)
               end subroutine dtrcon
#else 
               module procedure stdlib_dtrcon
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine strcon( norm, uplo, diag, n, a, lda, rcond, work,iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(out) :: rcond,work(*)
                    real(sp), intent(in) :: a(lda,*)
               end subroutine strcon
#else 
               module procedure stdlib_strcon
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trcon

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ztrcon( norm, uplo, diag, n, a, lda, rcond, work,rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,norm,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(out) :: rcond,rwork(*)
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztrcon
#else 
               module procedure stdlib_ztrcon
#endif
          end interface trcon



          interface trevc
          !! TREVC computes some or all of the right and/or left eigenvectors of
          !! a complex upper triangular matrix T.
          !! Matrices of this type are produced by the Schur factorization of
          !! a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.
          !! The right eigenvector x and the left eigenvector y of T corresponding
          !! to an eigenvalue w are defined by:
          !! T*x = w*x,     (y**H)*T = w*(y**H)
          !! where y**H denotes the conjugate transpose of the vector y.
          !! The eigenvalues are not input to this routine, but are read directly
          !! from the diagonal of T.
          !! This routine returns the matrices X and/or Y of right and left
          !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
          !! input matrix.  If Q is the unitary factor that reduces a matrix A to
          !! Schur form T, then Q*X and Q*Y are the matrices of right and left
          !! eigenvectors of A.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctrevc
#else 
               module procedure stdlib_ctrevc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
                         work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(dp), intent(in) :: t(ldt,*)
                    real(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtrevc
#else 
               module procedure stdlib_dtrevc
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trevc

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine strevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
                         work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(sp), intent(in) :: t(ldt,*)
                    real(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(sp), intent(out) :: work(*)
               end subroutine strevc
#else 
               module procedure stdlib_strevc
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trevc

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
                         work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztrevc
#else 
               module procedure stdlib_ztrevc
#endif
          end interface trevc



          interface trevc3
          !! TREVC3 computes some or all of the right and/or left eigenvectors of
          !! a complex upper triangular matrix T.
          !! Matrices of this type are produced by the Schur factorization of
          !! a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.
          !! The right eigenvector x and the left eigenvector y of T corresponding
          !! to an eigenvalue w are defined by:
          !! T*x = w*x,     (y**H)*T = w*(y**H)
          !! where y**H denotes the conjugate transpose of the vector y.
          !! The eigenvalues are not input to this routine, but are read directly
          !! from the diagonal of T.
          !! This routine returns the matrices X and/or Y of right and left
          !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
          !! input matrix. If Q is the unitary factor that reduces a matrix A to
          !! Schur form T, then Q*X and Q*Y are the matrices of right and left
          !! eigenvectors of A.
          !! This uses a Level 3 BLAS version of the back transformation.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrevc3( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m,&
                          work, lwork, rwork, lrwork, info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,lwork,lrwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: rwork(*)
                    complex(sp), intent(inout) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctrevc3
#else 
               module procedure stdlib_ctrevc3
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtrevc3( side, howmny, select, n, t, ldt, vl, ldvl,vr, ldvr, mm, m,&
                          work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(dp), intent(in) :: t(ldt,*)
                    real(dp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtrevc3
#else 
               module procedure stdlib_dtrevc3
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trevc3

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine strevc3( side, howmny, select, n, t, ldt, vl, ldvl,vr, ldvr, mm, m,&
                          work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,lwork,mm,n
                    logical(lk), intent(inout) :: select(*)
                    real(sp), intent(in) :: t(ldt,*)
                    real(sp), intent(inout) :: vl(ldvl,*),vr(ldvr,*)
                    real(sp), intent(out) :: work(*)
               end subroutine strevc3
#else 
               module procedure stdlib_strevc3
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trevc3

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrevc3( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m,&
                          work, lwork, rwork, lrwork, info)
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,side
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,lwork,lrwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: rwork(*)
                    complex(dp), intent(inout) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztrevc3
#else 
               module procedure stdlib_ztrevc3
#endif
          end interface trevc3



          interface trexc
          !! TREXC reorders the Schur factorization of a complex matrix
          !! A = Q*T*Q**H, so that the diagonal element of T with row index IFST
          !! is moved to row ILST.
          !! The Schur form T is reordered by a unitary similarity transformation
          !! Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
          !! postmultplying it with Z.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq
                    integer(ilp), intent(in) :: ifst,ilst,ldq,ldt,n
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(inout) :: q(ldq,*),t(ldt,*)
               end subroutine ctrexc
#else 
               module procedure stdlib_ctrexc
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dtrexc( compq, n, t, ldt, q, ldq, ifst, ilst, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq
                    integer(ilp), intent(inout) :: ifst,ilst
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldq,ldt,n
                    real(dp), intent(inout) :: q(ldq,*),t(ldt,*)
                    real(dp), intent(out) :: work(*)
               end subroutine dtrexc
#else 
               module procedure stdlib_dtrexc
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trexc

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine strexc( compq, n, t, ldt, q, ldq, ifst, ilst, work,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq
                    integer(ilp), intent(inout) :: ifst,ilst
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldq,ldt,n
                    real(sp), intent(inout) :: q(ldq,*),t(ldt,*)
                    real(sp), intent(out) :: work(*)
               end subroutine strexc
#else 
               module procedure stdlib_strexc
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trexc

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq
                    integer(ilp), intent(in) :: ifst,ilst,ldq,ldt,n
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(inout) :: q(ldq,*),t(ldt,*)
               end subroutine ztrexc
#else 
               module procedure stdlib_ztrexc
#endif
          end interface trexc



          interface trrfs
          !! TRRFS provides error bounds and backward error estimates for the
          !! solution to a system of linear equations with a triangular
          !! coefficient matrix.
          !! The solution matrix X must be computed by CTRTRS or some other
          !! means before entering this routine.  TRRFS does not do iterative
          !! refinement because doing so cannot improve the backward error.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,ldx, ferr, &
                         berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldx,n,nrhs
                    real(sp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(sp), intent(in) :: a(lda,*),b(ldb,*),x(ldx,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine ctrrfs
#else 
               module procedure stdlib_ctrrfs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtrrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,ldx, ferr, &
                         berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,ldx,n,nrhs
                    real(dp), intent(in) :: a(lda,*),b(ldb,*),x(ldx,*)
                    real(dp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine dtrrfs
#else 
               module procedure stdlib_dtrrfs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trrfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine strrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,ldx, ferr, &
                         berr, work, iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: lda,ldb,ldx,n,nrhs
                    real(sp), intent(in) :: a(lda,*),b(ldb,*),x(ldx,*)
                    real(sp), intent(out) :: berr(*),ferr(*),work(*)
               end subroutine strrfs
#else 
               module procedure stdlib_strrfs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trrfs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrrfs( uplo, trans, diag, n, nrhs, a, lda, b, ldb, x,ldx, ferr, &
                         berr, work, rwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,ldx,n,nrhs
                    real(dp), intent(out) :: berr(*),ferr(*),rwork(*)
                    complex(dp), intent(in) :: a(lda,*),b(ldb,*),x(ldx,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine ztrrfs
#else 
               module procedure stdlib_ztrrfs
#endif
          end interface trrfs



          interface trsen
          !! TRSEN reorders the Schur factorization of a complex matrix
          !! A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in
          !! the leading positions on the diagonal of the upper triangular matrix
          !! T, and the leading columns of Q form an orthonormal basis of the
          !! corresponding right invariant subspace.
          !! Optionally the routine computes the reciprocal condition numbers of
          !! the cluster of eigenvalues and/or the invariant subspace.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ctrsen( job, compq, select, n, t, ldt, q, ldq, w, m, s,sep, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq,job
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldq,ldt,lwork,n
                    real(sp), intent(out) :: s,sep
                    logical(lk), intent(in) :: select(*)
                    complex(sp), intent(inout) :: q(ldq,*),t(ldt,*)
                    complex(sp), intent(out) :: w(*),work(*)
               end subroutine ctrsen
#else 
               module procedure stdlib_ctrsen
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dtrsen( job, compq, select, n, t, ldt, q, ldq, wr, wi,m, s, sep, work, &
                         lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq,job
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    integer(ilp), intent(in) :: ldq,ldt,liwork,lwork,n
                    real(dp), intent(out) :: s,sep,wi(*),work(*),wr(*)
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(inout) :: q(ldq,*),t(ldt,*)
               end subroutine dtrsen
#else 
               module procedure stdlib_dtrsen
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trsen

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine strsen( job, compq, select, n, t, ldt, q, ldq, wr, wi,m, s, sep, work, &
                         lwork, iwork, liwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq,job
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    integer(ilp), intent(in) :: ldq,ldt,liwork,lwork,n
                    real(sp), intent(out) :: s,sep,wi(*),work(*),wr(*)
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(inout) :: q(ldq,*),t(ldt,*)
               end subroutine strsen
#else 
               module procedure stdlib_strsen
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trsen

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ztrsen( job, compq, select, n, t, ldt, q, ldq, w, m, s,sep, work, lwork,&
                          info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: compq,job
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldq,ldt,lwork,n
                    real(dp), intent(out) :: s,sep
                    logical(lk), intent(in) :: select(*)
                    complex(dp), intent(inout) :: q(ldq,*),t(ldt,*)
                    complex(dp), intent(out) :: w(*),work(*)
               end subroutine ztrsen
#else 
               module procedure stdlib_ztrsen
#endif
          end interface trsen



          interface trsna
          !! TRSNA estimates reciprocal condition numbers for specified
          !! eigenvalues and/or right eigenvectors of a complex upper triangular
          !! matrix T (or of any matrix Q*T*Q**H with Q unitary).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, &
                         mm, m, work, ldwork, rwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,job
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,ldwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: rwork(*),s(*),sep(*)
                    complex(sp), intent(in) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(sp), intent(out) :: work(ldwork,*)
               end subroutine ctrsna
#else 
               module procedure stdlib_ctrsna
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dtrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm, &
                         m, work, ldwork, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,job
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,ldwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: s(*),sep(*),work(ldwork,*)
                    real(dp), intent(in) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
               end subroutine dtrsna
#else 
               module procedure stdlib_dtrsna
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trsna

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine strsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm, &
                         m, work, ldwork, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,job
                    integer(ilp), intent(out) :: info,m,iwork(*)
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,ldwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(sp), intent(out) :: s(*),sep(*),work(ldwork,*)
                    real(sp), intent(in) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
               end subroutine strsna
#else 
               module procedure stdlib_strsna
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trsna

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, &
                         mm, m, work, ldwork, rwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: howmny,job
                    integer(ilp), intent(out) :: info,m
                    integer(ilp), intent(in) :: ldt,ldvl,ldvr,ldwork,mm,n
                    logical(lk), intent(in) :: select(*)
                    real(dp), intent(out) :: rwork(*),s(*),sep(*)
                    complex(dp), intent(in) :: t(ldt,*),vl(ldvl,*),vr(ldvr,*)
                    complex(dp), intent(out) :: work(ldwork,*)
               end subroutine ztrsna
#else 
               module procedure stdlib_ztrsna
#endif
          end interface trsna



          interface trsyl
          !! TRSYL solves the complex Sylvester matrix equation:
          !! op(A)*X + X*op(B) = scale*C or
          !! op(A)*X - X*op(B) = scale*C,
          !! where op(A) = A or A**H, and A and B are both upper triangular. A is
          !! M-by-M and B is N-by-N; the right hand side C and the solution X are
          !! M-by-N; and scale is an output scale factor, set <= 1 to avoid
          !! overflow in X.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ctrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trana,tranb
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: isgn,lda,ldb,ldc,m,n
                    real(sp), intent(out) :: scale
                    complex(sp), intent(in) :: a(lda,*),b(ldb,*)
                    complex(sp), intent(inout) :: c(ldc,*)
               end subroutine ctrsyl
#else 
               module procedure stdlib_ctrsyl
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine dtrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trana,tranb
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: isgn,lda,ldb,ldc,m,n
                    real(dp), intent(out) :: scale
                    real(dp), intent(in) :: a(lda,*),b(ldb,*)
                    real(dp), intent(inout) :: c(ldc,*)
               end subroutine dtrsyl
#else 
               module procedure stdlib_dtrsyl
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trsyl

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine strsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trana,tranb
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: isgn,lda,ldb,ldc,m,n
                    real(sp), intent(out) :: scale
                    real(sp), intent(in) :: a(lda,*),b(ldb,*)
                    real(sp), intent(inout) :: c(ldc,*)
               end subroutine strsyl
#else 
               module procedure stdlib_strsyl
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trsyl

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine ztrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: trana,tranb
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: isgn,lda,ldb,ldc,m,n
                    real(dp), intent(out) :: scale
                    complex(dp), intent(in) :: a(lda,*),b(ldb,*)
                    complex(dp), intent(inout) :: c(ldc,*)
               end subroutine ztrsyl
#else 
               module procedure stdlib_ztrsyl
#endif
          end interface trsyl



          interface trtri
          !! TRTRI computes the inverse of a complex upper or lower triangular
          !! matrix A.
          !! This is the Level 3 BLAS version of the algorithm.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrtri( uplo, diag, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(sp), intent(inout) :: a(lda,*)
               end subroutine ctrtri
#else 
               module procedure stdlib_ctrtri
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtrtri( uplo, diag, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(dp), intent(inout) :: a(lda,*)
               end subroutine dtrtri
#else 
               module procedure stdlib_dtrtri
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trtri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine strtri( uplo, diag, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    real(sp), intent(inout) :: a(lda,*)
               end subroutine strtri
#else 
               module procedure stdlib_strtri
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trtri

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrtri( uplo, diag, n, a, lda, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,n
                    complex(dp), intent(inout) :: a(lda,*)
               end subroutine ztrtri
#else 
               module procedure stdlib_ztrtri
#endif
          end interface trtri



          interface trtrs
          !! TRTRS solves a triangular system of the form
          !! A * X = B,  A**T * X = B,  or  A**H * X = B,
          !! where A is a triangular matrix of order N, and B is an N-by-NRHS
          !! matrix.  A check is made to verify that A is nonsingular.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(inout) :: b(ldb,*)
               end subroutine ctrtrs
#else 
               module procedure stdlib_ctrtrs
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtrtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(inout) :: b(ldb,*)
               end subroutine dtrtrs
#else 
               module procedure stdlib_dtrtrs
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trtrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine strtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(inout) :: b(ldb,*)
               end subroutine strtrs
#else 
               module procedure stdlib_strtrs
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trtrs

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrtrs( uplo, trans, diag, n, nrhs, a, lda, b, ldb,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: diag,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldb,n,nrhs
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(inout) :: b(ldb,*)
               end subroutine ztrtrs
#else 
               module procedure stdlib_ztrtrs
#endif
          end interface trtrs



          interface trttf
          !! TRTTF copies a triangular matrix A from standard full format (TR)
          !! to rectangular full packed format (TF) .
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrttf( transr, uplo, n, a, lda, arf, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    complex(sp), intent(in) :: a(0:lda-1,0:*)
                    complex(sp), intent(out) :: arf(0:*)
               end subroutine ctrttf
#else 
               module procedure stdlib_ctrttf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtrttf( transr, uplo, n, a, lda, arf, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    real(dp), intent(in) :: a(0:lda-1,0:*)
                    real(dp), intent(out) :: arf(0:*)
               end subroutine dtrttf
#else 
               module procedure stdlib_dtrttf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trttf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine strttf( transr, uplo, n, a, lda, arf, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    real(sp), intent(in) :: a(0:lda-1,0:*)
                    real(sp), intent(out) :: arf(0:*)
               end subroutine strttf
#else 
               module procedure stdlib_strttf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trttf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrttf( transr, uplo, n, a, lda, arf, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: transr,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    complex(dp), intent(in) :: a(0:lda-1,0:*)
                    complex(dp), intent(out) :: arf(0:*)
               end subroutine ztrttf
#else 
               module procedure stdlib_ztrttf
#endif
          end interface trttf



          interface trttp
          !! TRTTP copies a triangular matrix A from full format (TR) to standard
          !! packed format (TP).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctrttp( uplo, n, a, lda, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    complex(sp), intent(in) :: a(lda,*)
                    complex(sp), intent(out) :: ap(*)
               end subroutine ctrttp
#else 
               module procedure stdlib_ctrttp
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtrttp( uplo, n, a, lda, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    real(dp), intent(in) :: a(lda,*)
                    real(dp), intent(out) :: ap(*)
               end subroutine dtrttp
#else 
               module procedure stdlib_dtrttp
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trttp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine strttp( uplo, n, a, lda, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    real(sp), intent(in) :: a(lda,*)
                    real(sp), intent(out) :: ap(*)
               end subroutine strttp
#else 
               module procedure stdlib_strttp
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$trttp

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztrttp( uplo, n, a, lda, ap, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: n,lda
                    complex(dp), intent(in) :: a(lda,*)
                    complex(dp), intent(out) :: ap(*)
               end subroutine ztrttp
#else 
               module procedure stdlib_ztrttp
#endif
          end interface trttp



          interface tzrzf
          !! TZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
          !! to upper triangular form by means of unitary transformations.
          !! The upper trapezoidal matrix A is factored as
          !! A = ( R  0 ) * Z,
          !! where Z is an N-by-N unitary matrix and R is an M-by-M upper
          !! triangular matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ctzrzf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: tau(*),work(*)
               end subroutine ctzrzf
#else 
               module procedure stdlib_ctzrzf
#endif
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine dtzrzf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(dp), intent(inout) :: a(lda,*)
                    real(dp), intent(out) :: tau(*),work(*)
               end subroutine dtzrzf
#else 
               module procedure stdlib_dtzrzf
#endif
#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tzrzf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine stzrzf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    real(sp), intent(inout) :: a(lda,*)
                    real(sp), intent(out) :: tau(*),work(*)
               end subroutine stzrzf
#else 
               module procedure stdlib_stzrzf
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$tzrzf

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine ztzrzf( m, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: tau(*),work(*)
               end subroutine ztzrzf
#else 
               module procedure stdlib_ztzrzf
#endif
          end interface tzrzf



          interface unbdb
          !! UNBDB simultaneously bidiagonalizes the blocks of an M-by-M
          !! partitioned unitary matrix X:
          !! [ B11 | B12 0  0 ]
          !! [ X11 | X12 ]   [ P1 |    ] [  0  |  0 -I  0 ] [ Q1 |    ]**H
          !! X = [-----------] = [---------] [----------------] [---------]   .
          !! [ X21 | X22 ]   [    | P2 ] [ B21 | B22 0  0 ] [    | Q2 ]
          !! [  0  |  0  0  I ]
          !! X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
          !! not the case, then X must be transposed and/or permuted. This can be
          !! done in constant time using the TRANS and SIGNS options. See CUNCSD
          !! for details.)
          !! The unitary matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
          !! (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
          !! represented implicitly by Householder vectors.
          !! B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
          !! implicitly by angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cunbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
                         ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: signs,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldx11,ldx12,ldx21,ldx22,lwork,m,p,q
                    real(sp), intent(out) :: phi(*),theta(*)
                    complex(sp), intent(out) :: taup1(*),taup2(*),tauq1(*),tauq2(*),work(*)
                              
                    complex(sp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(&
                              ldx22,*)
               end subroutine cunbdb
#else 
               module procedure stdlib_cunbdb
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unbdb

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zunbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
                         ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: signs,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldx11,ldx12,ldx21,ldx22,lwork,m,p,q
                    real(dp), intent(out) :: phi(*),theta(*)
                    complex(dp), intent(out) :: taup1(*),taup2(*),tauq1(*),tauq2(*),work(*)
                              
                    complex(dp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(&
                              ldx22,*)
               end subroutine zunbdb
#else 
               module procedure stdlib_zunbdb
#endif
          end interface unbdb



          interface unbdb1
          !! UNBDB1 simultaneously bidiagonalizes the blocks of a tall and skinny
          !! matrix X with orthonomal columns:
          !! [ B11 ]
          !! [ X11 ]   [ P1 |    ] [  0  ]
          !! [-----] = [---------] [-----] Q1**T .
          !! [ X21 ]   [    | P2 ] [ B21 ]
          !! [  0  ]
          !! X11 is P-by-Q, and X21 is (M-P)-by-Q. Q must be no larger than P,
          !! M-P, or M-Q. Routines CUNBDB2, CUNBDB3, and CUNBDB4 handle cases in
          !! which Q is not the minimum dimension.
          !! The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !! Householder vectors.
          !! B11 and B12 are Q-by-Q bidiagonal matrices represented implicitly by
          !! angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cunbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*)
                    complex(sp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cunbdb1
#else 
               module procedure stdlib_cunbdb1
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unbdb1

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zunbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*)
                    complex(dp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zunbdb1
#else 
               module procedure stdlib_zunbdb1
#endif
          end interface unbdb1



          interface unbdb2
          !! UNBDB2 simultaneously bidiagonalizes the blocks of a tall and skinny
          !! matrix X with orthonomal columns:
          !! [ B11 ]
          !! [ X11 ]   [ P1 |    ] [  0  ]
          !! [-----] = [---------] [-----] Q1**T .
          !! [ X21 ]   [    | P2 ] [ B21 ]
          !! [  0  ]
          !! X11 is P-by-Q, and X21 is (M-P)-by-Q. P must be no larger than M-P,
          !! Q, or M-Q. Routines CUNBDB1, CUNBDB3, and CUNBDB4 handle cases in
          !! which P is not the minimum dimension.
          !! The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !! Householder vectors.
          !! B11 and B12 are P-by-P bidiagonal matrices represented implicitly by
          !! angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cunbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*)
                    complex(sp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cunbdb2
#else 
               module procedure stdlib_cunbdb2
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unbdb2

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zunbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*)
                    complex(dp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zunbdb2
#else 
               module procedure stdlib_zunbdb2
#endif
          end interface unbdb2



          interface unbdb3
          !! UNBDB3 simultaneously bidiagonalizes the blocks of a tall and skinny
          !! matrix X with orthonomal columns:
          !! [ B11 ]
          !! [ X11 ]   [ P1 |    ] [  0  ]
          !! [-----] = [---------] [-----] Q1**T .
          !! [ X21 ]   [    | P2 ] [ B21 ]
          !! [  0  ]
          !! X11 is P-by-Q, and X21 is (M-P)-by-Q. M-P must be no larger than P,
          !! Q, or M-Q. Routines CUNBDB1, CUNBDB2, and CUNBDB4 handle cases in
          !! which M-P is not the minimum dimension.
          !! The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !! Householder vectors.
          !! B11 and B12 are (M-P)-by-(M-P) bidiagonal matrices represented
          !! implicitly by angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cunbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*)
                    complex(sp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cunbdb3
#else 
               module procedure stdlib_cunbdb3
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unbdb3

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zunbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*)
                    complex(dp), intent(out) :: taup1(*),taup2(*),tauq1(*),work(*)
                    complex(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zunbdb3
#else 
               module procedure stdlib_zunbdb3
#endif
          end interface unbdb3



          interface unbdb4
          !! UNBDB4 simultaneously bidiagonalizes the blocks of a tall and skinny
          !! matrix X with orthonomal columns:
          !! [ B11 ]
          !! [ X11 ]   [ P1 |    ] [  0  ]
          !! [-----] = [---------] [-----] Q1**T .
          !! [ X21 ]   [    | P2 ] [ B21 ]
          !! [  0  ]
          !! X11 is P-by-Q, and X21 is (M-P)-by-Q. M-Q must be no larger than P,
          !! M-P, or Q. Routines CUNBDB1, CUNBDB2, and CUNBDB3 handle cases in
          !! which M-Q is not the minimum dimension.
          !! The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
          !! and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
          !! Householder vectors.
          !! B11 and B12 are (M-Q)-by-(M-Q) bidiagonal matrices represented
          !! implicitly by angles THETA, PHI.
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cunbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, phantom, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(sp), intent(out) :: phi(*),theta(*)
                    complex(sp), intent(out) :: phantom(*),taup1(*),taup2(*),tauq1(*),work(*)
                              
                    complex(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cunbdb4
#else 
               module procedure stdlib_cunbdb4
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unbdb4

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zunbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, &
                         tauq1, phantom, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lwork,m,p,q,ldx11,ldx21
                    real(dp), intent(out) :: phi(*),theta(*)
                    complex(dp), intent(out) :: phantom(*),taup1(*),taup2(*),tauq1(*),work(*)
                              
                    complex(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zunbdb4
#else 
               module procedure stdlib_zunbdb4
#endif
          end interface unbdb4



          interface unbdb5
          !! UNBDB5 orthogonalizes the column vector
          !! X = [ X1 ]
          !! [ X2 ]
          !! with respect to the columns of
          !! Q = [ Q1 ] .
          !! [ Q2 ]
          !! The columns of Q must be orthonormal.
          !! If the projection is zero according to Kahan's "twice is enough"
          !! criterion, then some other vector from the orthogonal complement
          !! is returned. This vector is chosen in an arbitrary but deterministic
          !! way.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x1(*),x2(*)
               end subroutine cunbdb5
#else 
               module procedure stdlib_cunbdb5
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unbdb5

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x1(*),x2(*)
               end subroutine zunbdb5
#else 
               module procedure stdlib_zunbdb5
#endif
          end interface unbdb5



          interface unbdb6
          !! UNBDB6 orthogonalizes the column vector
          !! X = [ X1 ]
          !! [ X2 ]
          !! with respect to the columns of
          !! Q = [ Q1 ] .
          !! [ Q2 ]
          !! The columns of Q must be orthonormal.
          !! If the projection is zero according to Kahan's "twice is enough"
          !! criterion, then the zero vector is returned.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    complex(sp), intent(out) :: work(*)
                    complex(sp), intent(inout) :: x1(*),x2(*)
               end subroutine cunbdb6
#else 
               module procedure stdlib_cunbdb6
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unbdb6

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: incx1,incx2,ldq1,ldq2,lwork,m1,m2,n
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(in) :: q1(ldq1,*),q2(ldq2,*)
                    complex(dp), intent(out) :: work(*)
                    complex(dp), intent(inout) :: x1(*),x2(*)
               end subroutine zunbdb6
#else 
               module procedure stdlib_zunbdb6
#endif
          end interface unbdb6



          interface uncsd
          !! UNCSD computes the CS decomposition of an M-by-M partitioned
          !! unitary matrix X:
          !! [  I  0  0 |  0  0  0 ]
          !! [  0  C  0 |  0 -S  0 ]
          !! [ X11 | X12 ]   [ U1 |    ] [  0  0  0 |  0  0 -I ] [ V1 |    ]**H
          !! X = [-----------] = [---------] [---------------------] [---------]   .
          !! [ X21 | X22 ]   [    | U2 ] [  0  0  0 |  I  0  0 ] [    | V2 ]
          !! [  0  S  0 |  0  C  0 ]
          !! [  0  0  I |  0  0  0 ]
          !! X11 is P-by-Q. The unitary matrices U1, U2, V1, and V2 are P-by-P,
          !! (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
          !! R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
          !! which R = MIN(P,M-P,Q,M-Q).
#ifdef STDLIB_EXTERNAL_LAPACK
               recursive subroutine cuncsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, &
               x11, ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, &
                         ldv1t, v2t,ldv2t, work, lwork, rwork, lrwork,iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,signs,trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,ldx11,ldx12,ldx21,ldx22,&
                              lrwork,lwork,m,p,q
                    real(sp), intent(out) :: theta(*),rwork(*)
                    complex(sp), intent(out) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*),&
                              work(*)
                    complex(sp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(&
                              ldx22,*)
               end subroutine cuncsd
#else 
               module procedure stdlib_cuncsd
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$uncsd

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               recursive subroutine zuncsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, &
               x11, ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, &
                         ldv1t, v2t,ldv2t, work, lwork, rwork, lrwork,iwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobu1,jobu2,jobv1t,jobv2t,signs,trans
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,ldv2t,ldx11,ldx12,ldx21,ldx22,&
                              lrwork,lwork,m,p,q
                    real(dp), intent(out) :: theta(*),rwork(*)
                    complex(dp), intent(out) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),v2t(ldv2t,*),&
                              work(*)
                    complex(dp), intent(inout) :: x11(ldx11,*),x12(ldx12,*),x21(ldx21,*),x22(&
                              ldx22,*)
               end subroutine zuncsd
#else 
               module procedure stdlib_zuncsd
#endif
          end interface uncsd



          interface uncsd2by1
          !! UNCSD2BY1 computes the CS decomposition of an M-by-Q matrix X with
          !! orthonormal columns that has been partitioned into a 2-by-1 block
          !! structure:
          !! [  I1 0  0 ]
          !! [  0  C  0 ]
          !! [ X11 ]   [ U1 |    ] [  0  0  0 ]
          !! X = [-----] = [---------] [----------] V1**T .
          !! [ X21 ]   [    | U2 ] [  0  0  0 ]
          !! [  0  S  0 ]
          !! [  0  0  I2]
          !! X11 is P-by-Q. The unitary matrices U1, U2, and V1 are P-by-P,
          !! (M-P)-by-(M-P), and Q-by-Q, respectively. C and S are R-by-R
          !! nonnegative diagonal matrices satisfying C^2 + S^2 = I, in which
          !! R = MIN(P,M-P,Q,M-Q). I1 is a K1-by-K1 identity matrix and I2 is a
          !! K2-by-K2 identity matrix, where K1 = MAX(Q+P-M,0), K2 = MAX(Q-P,0).
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine cuncsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta,&
                          u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, rwork, lrwork, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobu1,jobu2,jobv1t
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,lwork,ldx11,ldx21,m,p,q,&
                              lrwork
                    real(sp), intent(out) :: rwork(*),theta(*)
                    complex(sp), intent(out) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),work(*)
                    complex(sp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine cuncsd2by1
#else 
               module procedure stdlib_cuncsd2by1
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$uncsd2by1

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               subroutine zuncsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta,&
                          u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, rwork, lrwork, iwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: jobu1,jobu2,jobv1t
                    integer(ilp), intent(out) :: info,iwork(*)
                    integer(ilp), intent(in) :: ldu1,ldu2,ldv1t,lwork,ldx11,ldx21,m,p,q,&
                              lrwork
                    real(dp), intent(out) :: rwork(*),theta(*)
                    complex(dp), intent(out) :: u1(ldu1,*),u2(ldu2,*),v1t(ldv1t,*),work(*)
                    complex(dp), intent(inout) :: x11(ldx11,*),x21(ldx21,*)
               end subroutine zuncsd2by1
#else 
               module procedure stdlib_zuncsd2by1
#endif
          end interface uncsd2by1



          interface ung2l
          !! UNG2L generates an m by n complex matrix Q with orthonormal columns,
          !! which is defined as the last n columns of a product of k elementary
          !! reflectors of order m
          !! Q  =  H(k) . . . H(2) H(1)
          !! as returned by CGEQLF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cung2l( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cung2l
#else 
               module procedure stdlib_cung2l
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ung2l

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zung2l( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zung2l
#else 
               module procedure stdlib_zung2l
#endif
          end interface ung2l



          interface ung2r
          !! UNG2R generates an m by n complex matrix Q with orthonormal columns,
          !! which is defined as the first n columns of a product of k elementary
          !! reflectors of order m
          !! Q  =  H(1) H(2) . . . H(k)
          !! as returned by CGEQRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cung2r( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cung2r
#else 
               module procedure stdlib_cung2r
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ung2r

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zung2r( m, n, k, a, lda, tau, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zung2r
#else 
               module procedure stdlib_zung2r
#endif
          end interface ung2r



          interface ungbr
          !! UNGBR generates one of the complex unitary matrices Q or P**H
          !! determined by CGEBRD when reducing a complex matrix A to bidiagonal
          !! form: A = Q * B * P**H.  Q and P**H are defined as products of
          !! elementary reflectors H(i) or G(i) respectively.
          !! If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
          !! is of order M:
          !! if m >= k, Q = H(1) H(2) . . . H(k) and UNGBR returns the first n
          !! columns of Q, where m >= n >= k;
          !! if m < k, Q = H(1) H(2) . . . H(m-1) and UNGBR returns Q as an
          !! M-by-M matrix.
          !! If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
          !! is of order N:
          !! if k < n, P**H = G(k) . . . G(2) G(1) and UNGBR returns the first m
          !! rows of P**H, where n >= m >= k;
          !! if k >= n, P**H = G(n-1) . . . G(2) G(1) and UNGBR returns P**H as
          !! an N-by-N matrix.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cungbr( vect, m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungbr
#else 
               module procedure stdlib_cungbr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ungbr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zungbr( vect, m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungbr
#else 
               module procedure stdlib_zungbr
#endif
          end interface ungbr



          interface unghr
          !! UNGHR generates a complex unitary matrix Q which is defined as the
          !! product of IHI-ILO elementary reflectors of order N, as returned by
          !! CGEHRD:
          !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunghr
#else 
               module procedure stdlib_cunghr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unghr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(in) :: ihi,ilo,lda,lwork,n
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunghr
#else 
               module procedure stdlib_zunghr
#endif
          end interface unghr



          interface unglq
          !! UNGLQ generates an M-by-N complex matrix Q with orthonormal rows,
          !! which is defined as the first M rows of a product of K elementary
          !! reflectors of order N
          !! Q  =  H(k)**H . . . H(2)**H H(1)**H
          !! as returned by CGELQF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunglq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunglq
#else 
               module procedure stdlib_cunglq
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unglq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunglq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunglq
#else 
               module procedure stdlib_zunglq
#endif
          end interface unglq



          interface ungql
          !! UNGQL generates an M-by-N complex matrix Q with orthonormal columns,
          !! which is defined as the last N columns of a product of K elementary
          !! reflectors of order M
          !! Q  =  H(k) . . . H(2) H(1)
          !! as returned by CGEQLF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cungql( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungql
#else 
               module procedure stdlib_cungql
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ungql

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zungql( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungql
#else 
               module procedure stdlib_zungql
#endif
          end interface ungql



          interface ungqr
          !! UNGQR generates an M-by-N complex matrix Q with orthonormal columns,
          !! which is defined as the first N columns of a product of K elementary
          !! reflectors of order M
          !! Q  =  H(1) H(2) . . . H(k)
          !! as returned by CGEQRF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cungqr( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungqr
#else 
               module procedure stdlib_cungqr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ungqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zungqr( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungqr
#else 
               module procedure stdlib_zungqr
#endif
          end interface ungqr



          interface ungrq
          !! UNGRQ generates an M-by-N complex matrix Q with orthonormal rows,
          !! which is defined as the last M rows of a product of K elementary
          !! reflectors of order N
          !! Q  =  H(1)**H H(2)**H . . . H(k)**H
          !! as returned by CGERQF.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cungrq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungrq
#else 
               module procedure stdlib_cungrq
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ungrq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zungrq( m, n, k, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungrq
#else 
               module procedure stdlib_zungrq
#endif
          end interface ungrq



          interface ungtr
          !! UNGTR generates a complex unitary matrix Q which is defined as the
          !! product of n-1 elementary reflectors of order N, as returned by
          !! CHETRD:
          !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
          !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cungtr( uplo, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungtr
#else 
               module procedure stdlib_cungtr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ungtr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zungtr( uplo, n, a, lda, tau, work, lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,lwork,n
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungtr
#else 
               module procedure stdlib_zungtr
#endif
          end interface ungtr



          interface ungtsqr
          !! UNGTSQR generates an M-by-N complex matrix Q_out with orthonormal
          !! columns, which are the first N columns of a product of comlpex unitary
          !! matrices of order M which are returned by CLATSQR
          !! Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).
          !! See the documentation for CLATSQR.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cungtsqr( m, n, mb, nb, a, lda, t, ldt, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: t(ldt,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungtsqr
#else 
               module procedure stdlib_cungtsqr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ungtsqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zungtsqr( m, n, mb, nb, a, lda, t, ldt, work, lwork,info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: t(ldt,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungtsqr
#else 
               module procedure stdlib_zungtsqr
#endif
          end interface ungtsqr



          interface ungtsqr_row
          !! UNGTSQR_ROW generates an M-by-N complex matrix Q_out with
          !! orthonormal columns from the output of CLATSQR. These N orthonormal
          !! columns are the first N columns of a product of complex unitary
          !! matrices Q(k)_in of order M, which are returned by CLATSQR in
          !! a special format.
          !! Q_out = first_N_columns_of( Q(1)_in * Q(2)_in * ... * Q(k)_in ).
          !! The input matrices Q(k)_in are stored in row and column blocks in A.
          !! See the documentation of CLATSQR for more details on the format of
          !! Q(k)_in, where each Q(k)_in is represented by block Householder
          !! transformations. This routine calls an auxiliary routine CLARFB_GETT,
          !! where the computation is performed on each individual block. The
          !! algorithm first sweeps NB-sized column blocks from the right to left
          !! starting in the bottom row block and continues to the top row block
          !! (hence _ROW in the routine name). This sweep is in reverse order of
          !! the order in which CLATSQR generates the output blocks.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cungtsqr_row( m, n, mb, nb, a, lda, t, ldt, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(in) :: t(ldt,*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cungtsqr_row
#else 
               module procedure stdlib_cungtsqr_row
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$ungtsqr_row

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zungtsqr_row( m, n, mb, nb, a, lda, t, ldt, work,lwork, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,lwork,m,n,mb,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(in) :: t(ldt,*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zungtsqr_row
#else 
               module procedure stdlib_zungtsqr_row
#endif
          end interface ungtsqr_row



          interface unhr_col
          !! UNHR_COL takes an M-by-N complex matrix Q_in with orthonormal columns
          !! as input, stored in A, and performs Householder Reconstruction (HR),
          !! i.e. reconstructs Householder vectors V(i) implicitly representing
          !! another M-by-N matrix Q_out, with the property that Q_in = Q_out*S,
          !! where S is an N-by-N diagonal matrix with diagonal entries
          !! equal to +1 or -1. The Householder vectors (columns V(i) of V) are
          !! stored in A on output, and the diagonal entries of S are stored in D.
          !! Block reflectors are also returned in T
          !! (same output format as CGEQRT).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunhr_col( m, n, nb, a, lda, t, ldt, d, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,nb
                    complex(sp), intent(inout) :: a(lda,*)
                    complex(sp), intent(out) :: d(*),t(ldt,*)
               end subroutine cunhr_col
#else 
               module procedure stdlib_cunhr_col
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unhr_col

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunhr_col( m, n, nb, a, lda, t, ldt, d, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldt,m,n,nb
                    complex(dp), intent(inout) :: a(lda,*)
                    complex(dp), intent(out) :: d(*),t(ldt,*)
               end subroutine zunhr_col
#else 
               module procedure stdlib_zunhr_col
#endif
          end interface unhr_col



          interface unm2l
          !! UNM2L overwrites the general complex m-by-n matrix C with
          !! Q * C  if SIDE = 'L' and TRANS = 'N', or
          !! Q**H* C  if SIDE = 'L' and TRANS = 'C', or
          !! C * Q  if SIDE = 'R' and TRANS = 'N', or
          !! C * Q**H if SIDE = 'R' and TRANS = 'C',
          !! where Q is a complex unitary matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(k) . . . H(2) H(1)
          !! as returned by CGEQLF. Q is of order m if SIDE = 'L' and of order n
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunm2l( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunm2l
#else 
               module procedure stdlib_cunm2l
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unm2l

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunm2l( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunm2l
#else 
               module procedure stdlib_zunm2l
#endif
          end interface unm2l



          interface unm2r
          !! UNM2R overwrites the general complex m-by-n matrix C with
          !! Q * C  if SIDE = 'L' and TRANS = 'N', or
          !! Q**H* C  if SIDE = 'L' and TRANS = 'C', or
          !! C * Q  if SIDE = 'R' and TRANS = 'N', or
          !! C * Q**H if SIDE = 'R' and TRANS = 'C',
          !! where Q is a complex unitary matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(1) H(2) . . . H(k)
          !! as returned by CGEQRF. Q is of order m if SIDE = 'L' and of order n
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunm2r( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunm2r
#else 
               module procedure stdlib_cunm2r
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unm2r

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunm2r( side, trans, m, n, k, a, lda, tau, c, ldc,work, info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunm2r
#else 
               module procedure stdlib_zunm2r
#endif
          end interface unm2r



          interface unmbr
          !! If VECT = 'Q', UNMBR: overwrites the general complex M-by-N matrix C
          !! with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! If VECT = 'P', UNMBR overwrites the general complex M-by-N matrix C
          !! with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      P * C          C * P
          !! TRANS = 'C':      P**H * C       C * P**H
          !! Here Q and P**H are the unitary matrices determined by CGEBRD when
          !! reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
          !! and P**H are defined as products of elementary reflectors H(i) and
          !! G(i) respectively.
          !! Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
          !! order of the unitary matrix Q or P**H that is applied.
          !! If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
          !! if nq >= k, Q = H(1) H(2) . . . H(k);
          !! if nq < k, Q = H(1) H(2) . . . H(nq-1).
          !! If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
          !! if k < nq, P = G(1) G(2) . . . G(k);
          !! if k >= nq, P = G(1) G(2) . . . G(nq-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunmbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmbr
#else 
               module procedure stdlib_cunmbr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unmbr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunmbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans,vect
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmbr
#else 
               module procedure stdlib_zunmbr
#endif
          end interface unmbr



          interface unmhr
          !! UNMHR overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix of order nq, with nq = m if
          !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !! IHI-ILO elementary reflectors, as returned by CGEHRD:
          !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(in) :: ihi,ilo,lda,ldc,lwork,m,n
                    integer(ilp), intent(out) :: info
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmhr
#else 
               module procedure stdlib_cunmhr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unmhr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, &
                         lwork, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(in) :: ihi,ilo,lda,ldc,lwork,m,n
                    integer(ilp), intent(out) :: info
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmhr
#else 
               module procedure stdlib_zunmhr
#endif
          end interface unmhr



          interface unmlq
          !! UNMLQ overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(k)**H . . . H(2)**H H(1)**H
          !! as returned by CGELQF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunmlq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmlq
#else 
               module procedure stdlib_cunmlq
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unmlq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunmlq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmlq
#else 
               module procedure stdlib_zunmlq
#endif
          end interface unmlq



          interface unmql
          !! UNMQL overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(k) . . . H(2) H(1)
          !! as returned by CGEQLF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunmql( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmql
#else 
               module procedure stdlib_cunmql
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unmql

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunmql( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmql
#else 
               module procedure stdlib_zunmql
#endif
          end interface unmql



          interface unmqr
          !! UNMQR overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(1) H(2) . . . H(k)
          !! as returned by CGEQRF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunmqr( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmqr
#else 
               module procedure stdlib_cunmqr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unmqr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunmqr( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmqr
#else 
               module procedure stdlib_zunmqr
#endif
          end interface unmqr



          interface unmrq
          !! UNMRQ overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(1)**H H(2)**H . . . H(k)**H
          !! as returned by CGERQF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunmrq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmrq
#else 
               module procedure stdlib_cunmrq
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unmrq

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunmrq( side, trans, m, n, k, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmrq
#else 
               module procedure stdlib_zunmrq
#endif
          end interface unmrq



          interface unmrz
          !! UNMRZ overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix defined as the product of k
          !! elementary reflectors
          !! Q = H(1) H(2) . . . H(k)
          !! as returned by CTZRZF. Q is of order M if SIDE = 'L' and of order N
          !! if SIDE = 'R'.
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunmrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,l,lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmrz
#else 
               module procedure stdlib_cunmrz
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unmrz

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunmrz( side, trans, m, n, k, l, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: k,l,lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmrz
#else 
               module procedure stdlib_zunmrz
#endif
          end interface unmrz



          interface unmtr
          !! UNMTR overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix of order nq, with nq = m if
          !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !! nq-1 elementary reflectors, as returned by CHETRD:
          !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
          !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cunmtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldc,lwork,m,n
                    complex(sp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cunmtr
#else 
               module procedure stdlib_cunmtr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$unmtr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zunmtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
                         info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: lda,ldc,lwork,m,n
                    complex(dp), intent(inout) :: a(lda,*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zunmtr
#else 
               module procedure stdlib_zunmtr
#endif
          end interface unmtr



          interface upgtr
          !! UPGTR generates a complex unitary matrix Q which is defined as the
          !! product of n-1 elementary reflectors H(i) of order n, as returned by
          !! CHPTRD using packed storage:
          !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
          !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cupgtr( uplo, n, ap, tau, q, ldq, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldq,n
                    complex(sp), intent(in) :: ap(*),tau(*)
                    complex(sp), intent(out) :: q(ldq,*),work(*)
               end subroutine cupgtr
#else 
               module procedure stdlib_cupgtr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$upgtr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zupgtr( uplo, n, ap, tau, q, ldq, work, info )
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldq,n
                    complex(dp), intent(in) :: ap(*),tau(*)
                    complex(dp), intent(out) :: q(ldq,*),work(*)
               end subroutine zupgtr
#else 
               module procedure stdlib_zupgtr
#endif
          end interface upgtr



          interface upmtr
          !! UPMTR overwrites the general complex M-by-N matrix C with
          !! SIDE = 'L'     SIDE = 'R'
          !! TRANS = 'N':      Q * C          C * Q
          !! TRANS = 'C':      Q**H * C       C * Q**H
          !! where Q is a complex unitary matrix of order nq, with nq = m if
          !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
          !! nq-1 elementary reflectors, as returned by CHPTRD using packed
          !! storage:
          !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
          !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine cupmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,m,n
                    complex(sp), intent(inout) :: ap(*),c(ldc,*)
                    complex(sp), intent(in) :: tau(*)
                    complex(sp), intent(out) :: work(*)
               end subroutine cupmtr
#else 
               module procedure stdlib_cupmtr
#endif
#:for rk,rt,ri in CMPLX_KINDS_TYPES
#:if not rk in ["sp","dp"]
               module procedure stdlib_${ri}$upmtr

#:endif
#:endfor
#ifdef STDLIB_EXTERNAL_LAPACK
               pure subroutine zupmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
                         
                    import sp,dp,qp,ilp,lk 
                    implicit none(type,external) 
                    character, intent(in) :: side,trans,uplo
                    integer(ilp), intent(out) :: info
                    integer(ilp), intent(in) :: ldc,m,n
                    complex(dp), intent(inout) :: ap(*),c(ldc,*)
                    complex(dp), intent(in) :: tau(*)
                    complex(dp), intent(out) :: work(*)
               end subroutine zupmtr
#else 
               module procedure stdlib_zupmtr
#endif
          end interface upmtr





end module stdlib_linalg_lapack
