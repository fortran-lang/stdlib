submodule (stdlib_experimental_stats) stdlib_experimental_stats_mean

#:set VERSION90 = defined('VERSION90')
#:set REALKINDS = ["sp", "dp", "qp"]
#:set INTKINDS = ["int8", "int16", "int32", "int64"]
#:set REALTYPES = ["real({})".format(k) for k in REALKINDS]
#:set INTTYPES = ["integer({})".format(k) for k in INTKINDS]
#:set iktr = list(zip(range(len(REALKINDS)), REALKINDS, REALTYPES))
#:set ikti = list(zip(range(len(INTKINDS)), INTKINDS, INTTYPES))

use stdlib_experimental_error, only: error_stop
implicit none

contains

#:for i1, k1, t1 in iktr
module function mean_1_${k1}$_${k1}$(x) result(res)
    ${t1}$, intent(in) :: x(:)
    ${t1}$ :: res

    integer :: i1

    res = 0.0_${k1}$
    do i1 = 1, size(x)
        res = res + x(i1)
    end do
    res = res / real(size(x), ${k1}$)

end function mean_1_${k1}$_${k1}$
#:endfor

#:for i1, k1, t1 in ikti
module function mean_1_${k1}$_dp(x) result(res)
    ${t1}$, intent(in) :: x(:)
    real(dp) :: res

    integer :: i1

    res = 0.0_dp
    do i1 = 1, size(x)
        res = res + real(x(i1), dp)
    end do
    res = res / real(size(x), dp)

end function mean_1_${k1}$_dp
#:endfor


#:for i1, k1, t1 in iktr
module function mean_2_all_${k1}$_${k1}$(x) result(res)
    ${t1}$, intent(in) :: x(:,:)
    ${t1}$ :: res

    integer :: i1, i2

    res = 0.0_${k1}$
    do i2 = 1, size(x, 2)
      do i1 = 1, size(x, 1)
        res = res + x(i1, i2)
      end do
    end do
    res = res / real(size(x), ${k1}$)

end function mean_2_all_${k1}$_${k1}$
#:endfor

#:for i1, k1, t1 in ikti
module function mean_2_all_${k1}$_dp(x) result(res)
    ${t1}$, intent(in) :: x(:,:)
    real(dp) :: res

    integer :: i1, i2

    res = 0.0_dp
    do i2 = 1, size(x, 2)
      do i1 = 1, size(x, 1)
        res = res + real(x(i1, i2), dp)
      end do
    end do
    res = res / real(size(x), dp)

end function mean_2_all_${k1}$_dp
#:endfor

#:for i1, k1, t1 in iktr
module function mean_2_${k1}$_${k1}$(x, dim) result(res)
    ${t1}$, intent(in) :: x(:,:)
    integer, intent(in) :: dim
    ${t1}$ :: res(size(x)/size(x, dim))

    integer :: i1, i2

    res = 0.0_${k1}$

    select case(dim)
     case(1)
       do i2 = 1, size(x, 2)
         do i1 = 1, size(x, 1)
           res(i2) = res(i2) + x(i1, i2)
         end do
       end do
     case(2)
       do i2 = 1, size(x, 2)
         do i1 = 1, size(x, 1)
           res(i1) = res(i1) + x(i1, i2)
         end do
       end do
     case default
       call error_stop("ERROR (mean): wrong dimension")
    end select

    res = res / real(size(x, dim), ${k1}$)

end function mean_2_${k1}$_${k1}$
#:endfor

#:for i1, k1, t1 in ikti
module function mean_2_${k1}$_dp(x, dim) result(res)
    ${t1}$, intent(in) :: x(:,:)
    integer, intent(in) :: dim
    real(dp) :: res(size(x)/size(x, dim))

    integer :: i1, i2

    res = 0.0_dp

    select case(dim)
     case(1)
       do i2 = 1, size(x, 2)
         do i1 = 1, size(x, 1)
           res(i2) = res(i2) + real(x(i1, i2), dp)
         end do
       end do
     case(2)
       do i2 = 1, size(x, 2)
         do i1 = 1, size(x, 1)
           res(i1) = res(i1) + real(x(i1, i2), dp)
         end do
       end do
     case default
       call error_stop("ERROR (mean): wrong dimension")
    end select

    res = res / real(size(x, dim), dp)

end function mean_2_${k1}$_dp
#:endfor


#:def ranksuffix(rank)
#{if rank > 0}#(${":" + ",:" * (rank - 1)}$)#{endif}#
#:enddef

!As proposed by @arady
#:def varsuffix(rank)
${str(rank)}$
#:enddef

#:def varlist(varname, startlist, endlist)
#:if startlist > 0
${",".join([varname + varsuffix(i) for i in range(startlist, endlist + 1)])}$
#:endif
#:enddef

#:def varlistskip(varname, rank, dim)
#:if rank > 0
${varlist(varname,1,dim-1)}$#{if dim -1 > 0 and dim < rank}#,#{endif}#${varlist(varname,dim+1,rank)}$
#:endif
#:enddef

#:if VERSION90
#:set ranks = range(3,8)
#:else
#:set ranks = range(3,16)
#:endif

#:for i1, k1, t1 in iktr
#:for rank in ranks
module function mean_${rank}$_all_${k1}$_${k1}$(x) result(res)
    ${t1}$, intent(in) :: x${ranksuffix(rank)}$
    ${t1}$ :: res

    integer :: ${varlist("i",1,rank)}$

    res = 0.0_${k1}$

#:for fj in range(rank,0,-1)
    ${"  "* (rank - fj)}$do i${varsuffix(fj)}$ = 1, size(x, ${fj}$)
#:endfor
    ${"  "* (rank)}$res = res + x(${varlist("i",1,rank)}$)
#:for fj in range(rank,0,-1)
    ${"  "* (fj-1)}$end do
#:endfor

    res = res / real(size(x), ${k1}$)

end function mean_${rank}$_all_${k1}$_${k1}$
#:endfor
#:endfor

#:for i1, k1, t1 in ikti
#:for rank in ranks
module function mean_${rank}$_all_${k1}$_dp(x) result(res)
    ${t1}$, intent(in) :: x${ranksuffix(rank)}$
    real(dp) :: res

    integer :: ${varlist("i",1,rank)}$

    res = 0.0_dp

#:for fj in range(rank,0,-1)
    ${"  "* (rank - fj)}$do i${varsuffix(fj)}$ = 1, size(x, ${fj}$)
#:endfor
    ${"  "* (rank)}$res = res + real(x(${varlist("i",1,rank)}$), dp)
#:for fj in range(rank,0,-1)
    ${"  "* (fj-1)}$end do
#:endfor

    res = res / real(size(x), dp)

end function mean_${rank}$_all_${k1}$_dp
#:endfor
#:endfor

#:for i1, k1, t1 in iktr
#:for rank in ranks
module function mean_${rank}$_${k1}$_${k1}$(x, dim) result(res)
    ${t1}$, intent(in) :: x${ranksuffix(rank)}$
    integer, intent(in) :: dim
    ${t1}$ :: res( &
#:for imerge in range(1,rank-1)
                  merge(size(x,${imerge}$),size(x,${imerge + 1}$),mask = ${imerge}$ < dim ), &
#:endfor
                  merge(size(x,${rank-1}$),size(x,${rank}$),mask = ${rank-1}$ < dim ) )

    integer :: ${varlist("i",1,rank)}$

    res = 0.0_${k1}$

    select case(dim)
#:for fi in range(1,rank+1)
     case(${fi}$)
#:for fj in range(rank,0,-1)
       ${"  "* (rank - fj)}$do i${varsuffix(fj)}$ = 1, size(x, ${fj}$)
#:endfor
       ${"  "* (rank)}$res(${varlistskip("i", rank, fi)}$) = res(${varlistskip("i", rank, fi)}$) + x(${varlist("i",1,rank)}$)
#:for fj in range(rank,0,-1)
       ${"  "* (fj-1)}$end do
#:endfor
#:endfor
     case default
       call error_stop("ERROR (mean): wrong dimension")
    end select

    res = res / real(size(x, dim), ${k1}$)

end function mean_${rank}$_${k1}$_${k1}$
#:endfor
#:endfor

#:for i1, k1, t1 in ikti
#:for rank in ranks
module function mean_${rank}$_${k1}$_dp(x, dim) result(res)
    ${t1}$, intent(in) :: x${ranksuffix(rank)}$
    integer, intent(in) :: dim
    real(dp) :: res( &
#:for imerge in range(1,rank-1)
                  merge(size(x,${imerge}$),size(x,${imerge + 1}$),mask = ${imerge}$ < dim ), &
#:endfor
                  merge(size(x,${rank-1}$),size(x,${rank}$),mask = ${rank-1}$ < dim ) )

    integer :: ${varlist("i",1,rank)}$

    res = 0.0_dp

    select case(dim)
#:for fi in range(1,rank+1)
     case(${fi}$)
#:for fj in range(rank,0,-1)
       ${"  "* (rank - fj)}$do i${varsuffix(fj)}$ = 1, size(x, ${fj}$)
#:endfor
       ${"  "* (rank)}$res(${varlistskip("i", rank, fi)}$) = res(${varlistskip("i", rank, fi)}$) + real(x(${varlist("i",1,rank)}$), dp)
#:for fj in range(rank,0,-1)
       ${"  "* (fj-1)}$end do
#:endfor
#:endfor
     case default
       call error_stop("ERROR (mean): wrong dimension")
    end select

    res = res / real(size(x, dim), dp)

end function mean_${rank}$_${k1}$_dp
#:endfor
#:endfor

end submodule
