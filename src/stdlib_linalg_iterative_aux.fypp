#:include "common.fypp"
#:set R_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES, REAL_SUFFIX))
#:set MATRIX_TYPES = ["dense", "CSR"]
#:set RANKS = range(1, 2+1)

submodule(stdlib_linalg_iterative_solvers) stdlib_linalg_iterative_aux
    use stdlib_kinds
    use stdlib_sparse
    use stdlib_constants
    use stdlib_linalg_iterative_solvers
    use stdlib_constants
    implicit none

    integer, parameter :: ilp = int32

contains

    #:for k, t, s in R_KINDS_TYPES
    module subroutine solve_forward_triangular_dense_${s}$(L,b,x)
        ${t}$, intent(in) :: L(:,:)
        ${t}$, intent(in) :: b(:)
        ${t}$, intent(inout) :: x(:)

        integer(ilp) :: i, j, m

        x = zero_${s}$
        do j = 1, size(L,dim=2)
            x(j) = x(j) + b(j)
            do i = j+1, size(L,dim=1)
                x(i) = x(i) - L(i,j)*x(j)
            end do
        end do
    end subroutine

    module subroutine solve_backward_triangular_dense_${s}$(Lt,b,x)
        ${t}$, intent(in) :: Lt(:,:)
        ${t}$, intent(in) :: b(:)
        ${t}$, intent(inout) :: x(:)

        integer(ilp) :: i, j, m

        do j = size(Lt,dim=2), 1, -1
            x(j) = b(j)
            do i = 1, j-1
                x(i) = x(i) - Lt(j,i)*x(j)
            end do
        end do
    end subroutine

    #:endfor    

    #:for k, t, s in R_KINDS_TYPES
    module subroutine solve_forward_triangular_csr_${s}$(L,b,x)
        type(CSR_${s}$_type), intent(in) :: L
        ${t}$, intent(in) :: b(:)
        ${t}$, intent(inout) :: x(:)
        ${t}$ :: aux
    
        integer(ilp) :: i, j, m
        select case (L%storage)
        case(sparse_full)
            do i = 1, L%nrows
                aux = zero_${s}$
                do m = L%rowptr(i), L%rowptr(i+1)-1
                    j = L%col(m)
                    if(j>i) cycle !> skip upper part of the matrix
                    aux = aux + L%data(m)*x(j)
                end do
                x(i) = b(i) - aux
            end do
        case(sparse_lower)
            do i = 1, L%nrows
                aux = zero_${s}$
                do m = L%rowptr(i), L%rowptr(i+1)-2
                    j = L%col(m)
                    aux = aux + L%data(m)*x(j)
                end do
                x(i) = b(i) - aux
            end do
        case(sparse_upper) !> treates as lower triangular (thus transpose)
            do i = 1, L%nrows
                x(i) = b(i)
                do m = L%rowptr(i)+1, L%rowptr(i+1)-1
                    j = L%col(m)
                    x(j) = x(j) - L%data(m)*x(i)
                end do
            end do
        end select
    end subroutine
    
    module subroutine solve_backward_triangular_csr_${s}$(Lt,b,x)
        type(CSR_${s}$_type), intent(in) :: Lt
        ${t}$, intent(in) :: b(:)
        ${t}$, intent(inout) :: x(:)
        ${t}$ :: aux
        ${t}$ :: baux(size(x))
    
        integer(ilp) :: i, j, m
    
        baux = zero_${s}$
        select case (Lt%storage)
        case(sparse_full)
            do i = Lt%nrows, 1, -1
                x(i) = b(i) - baux(i)
                do m = Lt%rowptr(i), Lt%rowptr(i+1)-1
                    j = Lt%col(m)
                    if(j<i) cycle !> skip lower part of the matrix
                    baux(j) = baux(j) + Lt%data(m)*x(i)
                end do
            end do
        case(sparse_lower)
            do i = Lt%nrows, 1, -1
                x(i) = b(i) - baux(i)
                do m = Lt%rowptr(i), Lt%rowptr(i+1)-2
                    j = Lt%col(m)
                    baux(j) = baux(j) + Lt%data(m)*x(i)
                end do
            end do
        case(sparse_upper) 
            do i = Lt%nrows, 1, -1
                x(i) = b(i)
                do m = Lt%rowptr(i)+1, Lt%rowptr(i+1)-1
                    j = Lt%col(m)
                    x(i) = x(i) - Lt%data(m)*x(j)
                end do
            end do
        end select
    end subroutine

    #:endfor
    

    !==============================================================
    ! Factorization for preconditioners
    !==============================================================
    #:for k, t, s in R_KINDS_TYPES
    module subroutine factorize_ssor_dense_${s}$(A, w, L, D)
        ${t}$, intent(in) :: A(:,:)
        ${t}$, intent(in) :: w
        ${t}$, intent(inout) :: L(:,:)
        ${t}$, intent(inout) :: D(:)
        
        integer(ilp) :: i, j, n
        ${t}$ :: inv_w
    
        n = size(A,dim=1)
        inv_w = 1._${s}$ / w
        do j = 1, n 
            D(j) = A(j,j) * (2._${s}$-w)*inv_w
            do i = 1, j-1 
                L(i,j) = 0._${s}$
            end do
            L(j,j) = L(j,j) * inv_w
            do i = j+1, n 
                L(i,j) = A(i,j) 
            end do
        end do

    end subroutine

    #:endfor

    #:for k, t, s in R_KINDS_TYPES
    module subroutine factorize_ssor_csr_${s}$(A, w, L, D)
        type(CSR_${s}$_type), intent(in) :: A
        ${t}$, intent(in) :: w
        type(CSR_${s}$_type), intent(inout) :: L
        ${t}$, intent(inout) :: D(:)
        
        integer(ilp) :: i, j, n
        ${t}$ :: inv_w
        
        inv_w = 1._${s}$ / w
        L%data = A%data
        select case(A%storage)
        case(sparse_lower)
            do i = 1, A%nrows
                D(i) = A%data( A%rowptr(i+1)-1 ) * (2._${s}$-w)*inv_w
                L%data( A%rowptr(i+1)-1 ) = L%data( A%rowptr(i+1)-1 ) * inv_w
            end do
        case(sparse_upper)
            do i = 1, A%nrows
                D(i) = A%data( A%rowptr(i) ) * (2._${s}$-w)*inv_w
                L%data( A%rowptr(i) ) = L%data( A%rowptr(i) ) * inv_w
            end do
        case(sparse_full)
            do i = 1, A%nrows
                do j = A%rowptr(i), A%rowptr(i+1)-1
                    if( A%col(j) == i ) then
                        D(i) = A%data(j) * (2._${s}$-w)*inv_w
                        L%data(j) = L%data(j) * inv_w
                        exit
                    end if
                end do
            end do
        end select

    end subroutine

    #:endfor

    !> Bunch-Kaufman factorization of a symmetric positive definite matrix A.
    !> The matrix A is assumed to be symmetric and positive definite.
    #:for k, t, s in R_KINDS_TYPES
    module subroutine factorize_ldlt_dense_${s}$(A, L, D)
        ${t}$, intent(in) :: A(:,:)
        ${t}$, intent(inout) :: L(:,:)
        ${t}$, intent(inout) :: D(:)
        
        ${t}$:: auxsum
        integer(ilp) :: i, j, k, n
    
        ! Initialize L to zero
        n = size(A,dim=1)
        L = zero_${s}$

        do i = 1, n
            ! Compute D(i)
            auxsum = A(i, i)
            do k = 1, i - 1
                auxsum = auxsum - (L(i, k) ** 2) * D(k)
            end do
            D(i) = auxsum
    
            ! Check for positive definiteness
            if (D(i) <= zero_${s}$ ) D(i) = one_${s}$
    
            ! Set unit diagonal
            L(i, i) = one_${s}$
    
            ! Compute L(j, i) for j = i+1 to n
            do j = i + 1, n
                auxsum = A(j, i)
                do k = 1, i - 1
                    auxsum = auxsum - L(j, k) * L(i, k) * D(k)
                end do
                L(j, i) = auxsum / D(i)
            end do
        end do
    end subroutine

    #:endfor

    #:for k, t, s in R_KINDS_TYPES
    module subroutine factorize_ldlt_csr_${s}$(A, L, D)
        type(CSR_${s}$_type), intent(in) :: A
        type(CSR_${s}$_type), intent(inout) :: L
        ${t}$, intent(inout) :: D(:)
        
        ${t}$:: aux_diag, nondiag
        integer(ilp) :: i, j, k, m, n, p, q, r, ad1, ad2

        D = zero_${s}$
        L%data = zero_${s}$

        select case(A%storage)
        case(sparse_lower)
            do i = 1, A%nrows
                ad1 = A%rowptr(i)
                ad2 = A%rowptr(i+1)-1
                L%data(ad2) = one_${s}$
                aux_diag = zero_${s}$
                do m = ad1, ad2-1 
                    j = A%col(m)
                    nondiag = A%data(m)
                    q = ad1
                    do p = A%rowptr(j), A%rowptr(j+1)-2 
                        k = A%col(p) 
                        do r = q, m-1 
                            n = A%col(r) 
                            if( k == n ) then 
                                nondiag = nondiag - L%data(r)*L%data(p)*D(k)  ! Aij - Lik Ljk Dk
                                q = r + 1 
                            end if
                        end do
                    end do 
                    L%data(m) = nondiag / D(j) ! Lij = (Aij - Lik Ljk Dk)/Dj
                    aux_diag = aux_diag + (L%data(m) * nondiag) 
                end do        
                D(i) = A%data(ad2) - aux_diag ! Dj = Ajj - Ljk^2 Dk
                if (D(i) <= zero_${s}$)  D(i)= one_${s}$ 
            end do
        end select
    end subroutine

    #:endfor

end submodule stdlib_linalg_iterative_aux