#:include "common.fypp"
#! Note: PCA is limited to single (sp) and double (dp) precision because external
#! optimized BLAS/LAPACK libraries (OpenBLAS, MKL) only support these precisions.
#:set PCA_KINDS_TYPES = [("sp", "real(sp)"), ("dp", "real(dp)")]
submodule (stdlib_stats) stdlib_stats_pca
  use stdlib_kinds, only: sp, dp
  use stdlib_error, only: error_stop
  use stdlib_optval, only: optval
  use stdlib_linalg, only: svd, eigh
  use stdlib_linalg_constants, only: ilp
  use stdlib_linalg_blas, only: gemm
  use stdlib_linalg_state, only: linalg_state_type, LINALG_ERROR
  use stdlib_sorting, only: sort_index
  implicit none

contains

  #:for k1, t1 in PCA_KINDS_TYPES
    module subroutine pca_${k1}$(x, components, singular_values, x_mean, &
                                method, overwrite_x, err)
      ${t1}$, intent(inout), target :: x(:,:)
      ${t1}$, intent(out) :: components(:,:)
      real(${k1}$), intent(out) :: singular_values(:)
      ${t1}$, intent(out), optional :: x_mean(:)
      character(*), intent(in), optional :: method
      logical, intent(in), optional :: overwrite_x
      type(linalg_state_type), intent(out), optional :: err

      type(linalg_state_type) :: err0
      integer(ilp) :: n, p, i, k, m, n_s
      ${t1}$, allocatable :: mu(:)
      character(16) :: method_
      
      n = size(x, 1, kind=ilp)
      p = size(x, 2, kind=ilp)
      k = size(components, 1, kind=ilp)
      
      method_ = optval(method, "svd")
      
      ! 1. Calculate and optionally return mean
      allocate(mu(p))
      mu = mean(x, dim=1)
      if (present(x_mean)) x_mean = mu

      if (method_ == "svd") then
         ! 2. Center data and call SVD with temporaries for robustness
         block
            ${t1}$, allocatable :: s_tmp(:), vt_tmp(:,:)
            n_s = min(n, p)
            allocate(s_tmp(n_s), vt_tmp(n_s, p))

            if (optval(overwrite_x, .false.)) then
               do i = 1, n
                  x(i, :) = x(i, :) - mu
               end do
               call svd(x, s_tmp, vt=vt_tmp, overwrite_a=.true., full_matrices=.false., err=err0)
            else
               block
                  ${t1}$, allocatable :: x_centered(:,:)
                  allocate(x_centered(n, p))
                  do i = 1, n
                     x_centered(i, :) = x(i, :) - mu
                  end do
                  call svd(x_centered, s_tmp, vt=vt_tmp, overwrite_a=.true., full_matrices=.false., err=err0)
               end block
            end if

            if (err0%ok()) then
               m = min(size(components, 1, kind=ilp), n_s)
               components(:m, :) = vt_tmp(:m, :)
               m = min(size(singular_values, 1, kind=ilp), n_s)
               singular_values(:m) = s_tmp(:m)
            end if
         end block
      else if (method_ == "eig" .or. method_ == "cov") then
         ! 3. Eigendecomposition of covariance matrix
         block
            ${t1}$, allocatable :: c(:,:), vectors(:,:)
            real(${k1}$), allocatable :: lambda(:), lambda_copy(:)
            integer(ilp), allocatable :: idx(:)

            allocate(lambda(p), lambda_copy(p), idx(p), vectors(p, p))
            c = cov(x, dim=1)
            call eigh(c, lambda, vectors=vectors, err=err0)
            
            if (err0%ok()) then
               ! Sort eigenvalues in descending order using stdlib_sorting
               ! sort_index sorts in ascending order, so we negate values
               lambda_copy = -lambda
               call sort_index(lambda_copy, idx)
               
               ! Assign sorted results
               m = min(size(components, 1, kind=ilp), p)
               do i = 1, m
                  components(i, :) = vectors(:, idx(i))
                  if (lambda(idx(i)) > 0.0_${k1}$) then
                     singular_values(i) = sqrt(lambda(idx(i)) * real(n-1, ${k1}$))
                  else
                     singular_values(i) = 0.0_${k1}$
                  end if
               end do
            end if
         end block
      else
         err0 = linalg_state_type("pca", LINALG_ERROR, "Unknown method: "//method_)
      end if
      
      ! Handle error state: return error or stop if err not present
      call err0%handle(err)
      
    end subroutine pca_${k1}$
  #:endfor


  #:for k1, t1 in PCA_KINDS_TYPES
    module subroutine pca_transform_${k1}$(x, components, x_mean, x_transformed)
      ${t1}$, intent(in) :: x(:,:)
      ${t1}$, intent(in) :: components(:,:)
      ${t1}$, intent(in), optional :: x_mean(:)
      ${t1}$, intent(out) :: x_transformed(:,:)

      integer(ilp) :: i, n, p, nc
      ${t1}$, allocatable :: x_centered(:,:)
      ${t1}$, parameter :: alpha = 1.0_${k1}$, beta = 0.0_${k1}$
      
      n = size(x, 1, kind=ilp)
      p = size(x, 2, kind=ilp)
      nc = size(components, 1, kind=ilp)
      
      allocate(x_centered(n, p))
      if (present(x_mean)) then
         do i = 1, n
            x_centered(i, :) = x(i, :) - x_mean
         end do
      else
         x_centered = x
      end if
      
      ! x_transformed = x_centered * components^T using GEMM
      ! GEMM: C = alpha * op(A) * op(B) + beta * C
      ! x_transformed(n, nc) = x_centered(n, p) * components(nc, p)^T
      call gemm('N', 'T', n, nc, p, alpha, x_centered, n, components, nc, beta, x_transformed, n)
    end subroutine pca_transform_${k1}$
  #:endfor


  #:for k1, t1 in PCA_KINDS_TYPES
    module subroutine pca_inverse_transform_${k1}$(x_reduced, components, x_mean, x_reconstructed)
      ${t1}$, intent(in) :: x_reduced(:,:)
      ${t1}$, intent(in) :: components(:,:)
      ${t1}$, intent(in), optional :: x_mean(:)
      ${t1}$, intent(out) :: x_reconstructed(:,:)

      integer(ilp) :: i, n, nc, p
      ${t1}$, parameter :: alpha = 1.0_${k1}$, beta = 0.0_${k1}$
      
      n = size(x_reduced, 1, kind=ilp)
      nc = size(x_reduced, 2, kind=ilp)
      p = size(components, 2, kind=ilp)
      
      ! x_reconstructed = x_reduced * components using GEMM
      ! GEMM: C = alpha * op(A) * op(B) + beta * C
      ! x_reconstructed(n, p) = x_reduced(n, nc) * components(nc, p)
      call gemm('N', 'N', n, p, nc, alpha, x_reduced, n, components, nc, beta, x_reconstructed, n)
      
      if (present(x_mean)) then
         do i = 1, n
            x_reconstructed(i, :) = x_reconstructed(i, :) + x_mean
         end do
      end if
    end subroutine pca_inverse_transform_${k1}$
  #:endfor

end submodule stdlib_stats_pca
