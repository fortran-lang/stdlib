#:include "common.fypp"
#! Note: PCA is limited to single (sp) and double (dp) precision because external
#! optimized BLAS/LAPACK libraries (OpenBLAS, MKL) only support these precisions.
#:set PCA_KINDS_TYPES = [("sp", "real(sp)"), ("dp", "real(dp)")]
submodule (stdlib_stats) stdlib_stats_pca
  use stdlib_kinds, only: sp, dp
  use stdlib_error, only: error_stop
  use stdlib_optval, only: optval
  use stdlib_linalg, only: svd, eigh
  use stdlib_linalg_constants, only: ilp
  use stdlib_linalg_blas, only: gemm, syrk
  use stdlib_linalg_state, only: linalg_state_type, LINALG_ERROR
  use stdlib_sorting, only: sort_index
  implicit none

contains

  ! Helper subroutine: Centers data in-place by subtracting the mean from each row
  #:for k1, t1 in PCA_KINDS_TYPES
    pure subroutine center_data_${k1}$(x, mu)
      ${t1}$, intent(inout) :: x(:,:)
      ${t1}$, intent(in) :: mu(:)
      integer(ilp) :: i, n
      n = size(x, 1, kind=ilp)
      do i = 1, n
         x(i, :) = x(i, :) - mu
      end do
    end subroutine center_data_${k1}$
  #:endfor

  ! SVD-based PCA driver: computes principal components via SVD of centered data
  #:for k1, t1 in PCA_KINDS_TYPES
    subroutine pca_svd_driver_${k1}$(x_centered, n, p, components, singular_values, err)
      ${t1}$, intent(inout) :: x_centered(:,:)
      integer(ilp), intent(in) :: n, p
      ${t1}$, intent(out) :: components(:,:)
      real(${k1}$), intent(out) :: singular_values(:)
      type(linalg_state_type), intent(out) :: err

      integer(ilp) :: n_s, m
      ${t1}$, allocatable :: s_tmp(:), vt_tmp(:,:)

      n_s = min(n, p)
      allocate(s_tmp(n_s), vt_tmp(n_s, p))

      call svd(x_centered, s_tmp, vt=vt_tmp, overwrite_a=.true., full_matrices=.false., err=err)

      if (err%ok()) then
         m = min(size(components, 1, kind=ilp), n_s)
         components(:m, :) = vt_tmp(:m, :)
         m = min(size(singular_values, 1, kind=ilp), n_s)
         singular_values(:m) = s_tmp(:m)
      end if
    end subroutine pca_svd_driver_${k1}$
  #:endfor

  ! Eigendecomposition-based PCA driver: computes principal components via covariance matrix
  #:for k1, t1 in PCA_KINDS_TYPES
    subroutine pca_eigh_driver_${k1}$(x_centered, n, p, components, singular_values, err)
      ${t1}$, intent(in) :: x_centered(:,:)
      integer(ilp), intent(in) :: n, p
      ${t1}$, intent(out) :: components(:,:)
      real(${k1}$), intent(out) :: singular_values(:)
      type(linalg_state_type), intent(out) :: err

      integer(ilp) :: i, j, m
      integer(ilp), allocatable :: idx(:)
      ${t1}$ :: alpha, beta
      real(${k1}$) :: scale_factor
      real(${k1}$), allocatable :: lambda(:), lambda_copy(:)
      ${t1}$, allocatable :: c(:,:), vectors(:,:)

      allocate(c(p, p), lambda(p), lambda_copy(p), idx(p), vectors(p, p))

      ! Compute covariance matrix using BLAS syrk: C = (1/(n-1)) * X^T * X
      scale_factor = 1.0_${k1}$ / real(max(n-1, 1), ${k1}$)
      alpha = real(scale_factor, ${k1}$)
      beta = 0.0_${k1}$
      c = 0.0_${k1}$
      call syrk('U', 'T', p, n, alpha, x_centered, n, beta, c, p)
      ! Fill lower triangle from upper triangle (syrk only fills upper)
      do j = 1, p-1
         do i = j+1, p
            c(i, j) = c(j, i)
         end do
      end do

      call eigh(c, lambda, vectors=vectors, err=err)

      if (err%ok()) then
         ! Sort eigenvalues in descending order
         lambda_copy = -lambda
         call sort_index(lambda_copy, idx)

         ! Assign sorted results with safety bounds checks
         m = min(size(components, 1, kind=ilp), p)
         m = min(m, size(singular_values, 1, kind=ilp))
         do i = 1, m
            components(i, :) = vectors(:, idx(i))
            if (lambda(idx(i)) > 0.0_${k1}$) then
               singular_values(i) = sqrt(lambda(idx(i)) * real(n-1, ${k1}$))
            else
               singular_values(i) = 0.0_${k1}$
            end if
         end do
      end if
    end subroutine pca_eigh_driver_${k1}$
  #:endfor

  #:for k1, t1 in PCA_KINDS_TYPES
    module subroutine pca_${k1}$(x, components, singular_values, x_mean, &
                                method, overwrite_x, err)
      ${t1}$, intent(inout), target :: x(:,:)
      ${t1}$, intent(out) :: components(:,:)
      real(${k1}$), intent(out) :: singular_values(:)
      ${t1}$, intent(out), optional :: x_mean(:)
      character(*), intent(in), optional :: method
      logical, intent(in), optional :: overwrite_x
      type(linalg_state_type), intent(out), optional :: err

      type(linalg_state_type) :: err0
      integer(ilp) :: n, p
      ${t1}$, allocatable :: mu(:), x_centered(:,:)
      character(16) :: method_

      n = size(x, 1, kind=ilp)
      p = size(x, 2, kind=ilp)
      method_ = adjustl(optval(method, "svd"))

      ! Calculate mean along dimension 1 (column means)
      allocate(mu(p))
      mu = sum(x, dim=1) / real(n, ${k1}$)
      if (present(x_mean)) x_mean = mu

      ! Method dispatch using trimmed string for robustness
      select case (trim(method_))
      case ("svd")
         if (optval(overwrite_x, .false.)) then
            call center_data_${k1}$(x, mu)
            call pca_svd_driver_${k1}$(x, n, p, components, singular_values, err0)
         else
            allocate(x_centered(n, p))
            x_centered = x
            call center_data_${k1}$(x_centered, mu)
            call pca_svd_driver_${k1}$(x_centered, n, p, components, singular_values, err0)
         end if

      case ("eig", "cov")
         allocate(x_centered(n, p))
         x_centered = x
         call center_data_${k1}$(x_centered, mu)
         call pca_eigh_driver_${k1}$(x_centered, n, p, components, singular_values, err0)

      case default
         err0 = linalg_state_type("pca", LINALG_ERROR, "Unknown method: "//trim(method_))
      end select

      ! Handle error state
      call err0%handle(err)

    end subroutine pca_${k1}$
  #:endfor


  #:for k1, t1 in PCA_KINDS_TYPES
    module subroutine pca_transform_${k1}$(x, components, x_mean, x_transformed)
      ${t1}$, intent(in) :: x(:,:)
      ${t1}$, intent(in) :: components(:,:)
      ${t1}$, intent(in), optional :: x_mean(:)
      ${t1}$, intent(out) :: x_transformed(:,:)

      integer(ilp) :: n, p, nc
      ${t1}$ :: alpha, beta
      ${t1}$, allocatable :: x_centered(:,:)
      
      n = size(x, 1, kind=ilp)
      p = size(x, 2, kind=ilp)
      nc = size(components, 1, kind=ilp)
      
      allocate(x_centered(n, p))
      x_centered = x
      if (present(x_mean)) call center_data_${k1}$(x_centered, x_mean)
      
      ! x_transformed = x_centered * components^T using GEMM
      alpha = 1.0_${k1}$
      beta = 0.0_${k1}$
      call gemm('N', 'T', n, nc, p, alpha, x_centered, n, components, nc, beta, x_transformed, n)
    end subroutine pca_transform_${k1}$
  #:endfor


  #:for k1, t1 in PCA_KINDS_TYPES
    module subroutine pca_inverse_transform_${k1}$(x_reduced, components, x_mean, x_reconstructed)
      ${t1}$, intent(in) :: x_reduced(:,:)
      ${t1}$, intent(in) :: components(:,:)
      ${t1}$, intent(in), optional :: x_mean(:)
      ${t1}$, intent(out) :: x_reconstructed(:,:)

      integer(ilp) :: i, n, nc, p
      ${t1}$ :: alpha, beta
      
      n = size(x_reduced, 1, kind=ilp)
      nc = size(x_reduced, 2, kind=ilp)
      p = size(components, 2, kind=ilp)
      
      ! x_reconstructed = x_reduced * components using GEMM
      alpha = 1.0_${k1}$
      beta = 0.0_${k1}$
      call gemm('N', 'N', n, p, nc, alpha, x_reduced, n, components, nc, beta, x_reconstructed, n)
      
      if (present(x_mean)) then
         do i = 1, n
            x_reconstructed(i, :) = x_reconstructed(i, :) + x_mean
         end do
      end if
    end subroutine pca_inverse_transform_${k1}$
  #:endfor

end submodule stdlib_stats_pca
