#:include "common.fypp"
#:set R_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES, REAL_SUFFIX))
#:set C_KINDS_TYPES = list(zip(CMPLX_KINDS, CMPLX_TYPES, CMPLX_SUFFIX))
#:set MATRIX_TYPES = ["dense", "CSR"]
#:set RANKS = range(1, 2+1)

submodule(stdlib_linalg_iterative_solvers) stdlib_linalg_iterative_cg
    use stdlib_kinds
    use stdlib_sparse
    use stdlib_constants
    use stdlib_intrinsics, only: dot_product => stdlib_dot_product
    use stdlib_linalg_iterative_solvers
    implicit none

contains

    #:for k, t, s in R_KINDS_TYPES
    module subroutine solve_cg_generic_${s}$(A,b,x,tol,maxiter,workspace)
        class(linop_${s}$), intent(in) :: A
        ${t}$, intent(in) :: b(:), tol
        ${t}$, intent(inout) :: x(:)
        integer, intent(in) :: maxiter
        type(cg_workspace_${s}$), intent(inout) :: workspace
        !-------------------------
        integer :: iter
        ${t}$ :: rtr, rtrold, alpha, beta, norm0_sq
        !-------------------------
        associate(  p => workspace%p, &
                    r => workspace%r, &
                    Ap => workspace%Ap)
            x = zero_${s}$
            rtr = A%inner_product(r, r)
            norm0_sq = A%inner_product(b, b)
            p = b
            beta = zero_${s}$
            iter = 1
            do while( rtr > tol**2 * norm0_sq .and. iter < maxiter)
                p = r + beta * p
                call A%matvec(p,Ap) 
                alpha = rtr / A%inner_product(p, Ap)
                x = x + alpha * p
                r = r - alpha * Ap
                rtrold = rtr
                rtr = A%inner_product(r, r)
                beta = rtr / rtrold
                iter = iter + 1
            end do
        end associate
    end subroutine
    #:endfor

    #:for matrix in MATRIX_TYPES
    #:for k, t, s in R_KINDS_TYPES
    module subroutine solve_cg_${matrix}$_${s}$(A,b,x,tol,maxiter,workspace)
        #:if matrix == "dense"
        ${t}$, intent(in) :: A(:,:)
        #:else 
        type(${matrix}$_${s}$_type), intent(in) :: A
        #:endif
        ${t}$, intent(in) :: b(:), tol
        ${t}$, intent(inout) :: x(:)
        integer, intent(in), optional :: maxiter
        type(cg_workspace_${s}$), optional, intent(inout), target :: workspace
        !-------------------------
        type(linop_${s}$) :: op
        type(cg_workspace_${s}$), pointer :: workspace_
        integer :: n, maxiter_
        !-------------------------
        n = size(b)
        op%matvec => default_matvec
        op%inner_product => default_dot

        maxiter_ = n
        if(present(maxiter)) maxiter_ = maxiter
        if(present(workspace)) then
            workspace_ => workspace
        else
            allocate( workspace_%r(n), &
                      workspace_%p(n), &
                      workspace_%Ap(n))
            
        end if
        call solve_cg_generic(op,b,x,tol,maxiter_,workspace_)
        contains
        
        subroutine default_matvec(x,y)
            ${t}$, intent(in)  :: x(:)
            ${t}$, intent(inout) :: y(:)
            #:if matrix == "dense"
            y = matmul(A,x)
            #:else 
            call spmv( A , x, y )
            #:endif
        end subroutine
        pure ${t}$ function default_dot(x,y) result(r)
            ${t}$, intent(in) :: x(:)
            ${t}$, intent(in) :: y(:)
            r = dot_product(x,y)
        end function
    end subroutine

    #:endfor
    #:endfor

end submodule stdlib_linalg_iterative_cg