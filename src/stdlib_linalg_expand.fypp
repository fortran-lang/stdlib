#:include "common.fypp"
#:set ALL_KINDS_TYPES = REAL_KINDS_TYPES + INT_KINDS_TYPES + CMPLX_KINDS_TYPES &
    & + LOG_KINDS_TYPES + STRING_KINDS_TYPES
submodule(stdlib_linalg) stdlib_linalg_expand

contains

    !> `ones` creates a vector, filled completely with `1` `integer` type values.
    pure module function ones_1_default(dim) result(result)
        integer, intent(in) :: dim
        integer, allocatable :: result(:)

        allocate(result(dim))
        result = 1

    end function ones_1_default

    !> `ones` creates a matrix, filled completely with `1` `integer` type values.
    pure module function ones_2_default(dim1, dim2) result(result)
        integer, intent(in) :: dim1, dim2
        integer, allocatable :: result(:, :)

        allocate(result(dim1, dim2))
        result = 1

    end function ones_2_default

    !> `zeros` creates a vector, filled completely with `0` `integer` type values.
    pure module function zeros_1_default(dim) result(result)
        integer, intent(in) :: dim
        integer, allocatable :: result(:)

        allocate(result(dim))
        result = 0

    end function zeros_1_default

    !> `zeros` creates a matrix, filled completely with `0` `integer` type values.
    pure module function zeros_2_default(dim1, dim2) result(result)
        integer, intent(in) :: dim1, dim2
        integer, allocatable :: result(:, :)

        allocate(result(dim1, dim2))
        result = 0

    end function zeros_2_default

    #:for k1, t1 in ALL_KINDS_TYPES
    !> `expand` creates a vector, filled completely with `value` `${t1}$` type values.
    pure module function expand_1_${t1[0]}$_${k1}$(value, dim) result(result)
        
        ${t1}$, intent(in) :: value
        integer, intent(in) :: dim
        ${t1}$, allocatable :: result(:)

        allocate(result(dim))
        result = value
        
    end function expand_1_${t1[0]}$_${k1}$

    !> `expand` creates a matrix, filled completely with `value` `${t1}$` type values.
    pure module function expand_2_${t1[0]}$_${k1}$(value, dim1, dim2) result(result)
        
        ${t1}$, intent(in) :: value
        integer, intent(in) :: dim1, dim2
        ${t1}$, allocatable :: result(:, :)

        allocate(result(dim1, dim2))
        result = value
        
    end function expand_2_${t1[0]}$_${k1}$
    #:endfor

end submodule stdlib_linalg_expand
