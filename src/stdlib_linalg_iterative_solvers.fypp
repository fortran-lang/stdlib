#:include "common.fypp"
#:set R_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES, REAL_SUFFIX))
#:set C_KINDS_TYPES = list(zip(CMPLX_KINDS, CMPLX_TYPES, CMPLX_SUFFIX))
#:set MATRIX_TYPES = ["dense", "CSR"]
#:set RANKS = range(1, 2+1)

module stdlib_linalg_iterative_solvers
    use stdlib_kinds
    use stdlib_sparse
    implicit none
    private 

    !> brief workspace size for the iterative solvers
    !> details The size of the workspace is defined by the number of vectors used in the iterative solver.
    enum, bind(c)
        enumerator :: size_wksp_cg = 3
        enumerator :: size_wksp_pccg = 4
    end enum
    public :: size_wksp_cg, size_wksp_pccg

    !> linear operator class for the iterative solvers
    #:for k, t, s in R_KINDS_TYPES
    type, public :: linop_${s}$
        procedure(vector_sub_${s}$), nopass, pointer    :: apply => null()
        procedure(reduction_sub_${s}$), nopass, pointer :: inner_product => default_dot_${s}$
    end type
    #:endfor

    #:for k, t, s in R_KINDS_TYPES
    type, public :: solver_workspace_${s}$
        ${t}$, allocatable :: tmp(:,:)
        procedure(logger_sub_${s}$), pointer, nopass :: callback => null()
    end type 

    #:endfor

    abstract interface
        #:for k, t, s in R_KINDS_TYPES
        subroutine vector_sub_${s}$(x,y,alpha,beta)
            import :: ${k}$
            ${t}$, intent(in)  :: x(:)
            ${t}$, intent(inout) :: y(:)
            ${t}$, intent(in) :: alpha
            ${t}$, intent(in) :: beta
        end subroutine
        pure ${t}$ function reduction_sub_${s}$(x,y) result(r)
            import :: ${k}$
            ${t}$, intent(in) :: x(:)
            ${t}$, intent(in) :: y(:)
        end function
        subroutine logger_sub_${s}$(x,norm_sq,iter)
            import :: ${k}$
            ${t}$, intent(in) :: x(:)
            ${t}$, intent(in) :: norm_sq
            integer, intent(in) :: iter
        end subroutine
        #:endfor
    end interface

    interface solve_cg_kernel
        #:for k, t, s in R_KINDS_TYPES
        module subroutine solve_cg_kernel_${s}$(A,b,x,tol,maxiter,workspace)
            class(linop_${s}$), intent(in) :: A
            ${t}$, intent(in) :: b(:)
            ${t}$, intent(inout) :: x(:)
            ${t}$, intent(in) :: tol
            integer, intent(in) :: maxiter
            type(solver_workspace_${s}$), intent(inout) :: workspace
        end subroutine
        #:endfor
    end interface
    public :: solve_cg_kernel

    interface solve_cg
        #:for matrix in MATRIX_TYPES
        #:for k, t, s in R_KINDS_TYPES
        module subroutine solve_cg_${matrix}$_${s}$(A,b,x,di,tol,maxiter,restart,workspace)
            #:if matrix == "dense"
            ${t}$, intent(in) :: A(:,:)
            #:else 
            type(${matrix}$_${s}$_type), intent(in) :: A
            #:endif
            ${t}$, intent(in) :: b(:)
            ${t}$, intent(inout) :: x(:)
            ${t}$, intent(in), optional :: tol
            logical(1), intent(in), optional, target  :: di(:)
            integer, intent(in), optional :: maxiter
            logical, intent(in), optional :: restart
            type(solver_workspace_${s}$), optional, intent(inout), target :: workspace
        end subroutine
        #:endfor
        #:endfor
    end interface
    public :: solve_cg

    interface solve_pccg_kernel
        #:for k, t, s in R_KINDS_TYPES
        module subroutine solve_pccg_kernel_${s}$(A,M,b,x,tol,maxiter,workspace)
            class(linop_${s}$), intent(in) :: A
            class(linop_${s}$), intent(in) :: M !> preconditionner
            ${t}$, intent(in) :: b(:)
            ${t}$, intent(inout) :: x(:)
            ${t}$, intent(in) :: tol
            integer, intent(in) :: maxiter
            type(solver_workspace_${s}$), intent(inout) :: workspace
        end subroutine
        #:endfor
    end interface
    public :: solve_pccg_kernel

    interface solve_pccg
        #:for matrix in MATRIX_TYPES
        #:for k, t, s in R_KINDS_TYPES
        module subroutine solve_pccg_${matrix}$_${s}$(A,b,x,di,tol,maxiter,restart,precond,M,workspace)
            #:if matrix == "dense"
            ${t}$, intent(in) :: A(:,:)
            #:else 
            type(${matrix}$_${s}$_type), intent(in) :: A
            #:endif
            ${t}$, intent(in) :: b(:)
            ${t}$, intent(inout) :: x(:)
            ${t}$, intent(in), optional :: tol
            logical(1), intent(in), optional, target  :: di(:)
            integer, intent(in), optional  :: maxiter
            logical, intent(in), optional :: restart
            integer, intent(in), optional  :: precond !> preconditionner method flag
            class(linop_${s}$), optional , intent(in), target :: M !> preconditionner
            type(solver_workspace_${s}$), optional, intent(inout), target :: workspace
        end subroutine
        #:endfor
        #:endfor
    end interface
    public :: solve_pccg 

    interface solve_forward_triangular
        !> Solve the system L x = b, where L is a strictly lower triangular matrix (diagonal assumed = 1).
        #:for k, t, s in R_KINDS_TYPES
        module subroutine solve_forward_triangular_dense_${s}$(L,b,x)
            ${t}$, intent(in) :: L(:,:)
            ${t}$, intent(in) :: b(:)
            ${t}$, intent(inout) :: x(:)
        end subroutine
        module subroutine solve_forward_triangular_csr_${s}$(L,b,x)
            type(CSR_${s}$_type), intent(in) :: L
            ${t}$, intent(in) :: b(:)
            ${t}$, intent(inout) :: x(:)
        end subroutine
        #:endfor    
    end interface
    public :: solve_forward_triangular
 

    interface solve_backward_triangular
        !> Solve the system U x = b, where U is a strictly upper triangular matrix (diagonal assumed = 1).
        #:for k, t, s in R_KINDS_TYPES
        module subroutine solve_backward_triangular_dense_${s}$(Lt,b,x)
            ${t}$, intent(in) :: Lt(:,:)
            ${t}$, intent(in) :: b(:)
            ${t}$, intent(inout) :: x(:)
        end subroutine
        module subroutine solve_backward_triangular_csr_${s}$(Lt,b,x)
            type(CSR_${s}$_type), intent(in) :: Lt
            ${t}$, intent(in) :: b(:)
            ${t}$, intent(inout) :: x(:)
        end subroutine
        #:endfor    
    end interface
    public :: solve_backward_triangular

    interface ldlt
        #:for k, t, s in R_KINDS_TYPES
        module subroutine ldlt_dense_${s}$(A, L, D)
            ${t}$, intent(in) :: A(:,:)
            ${t}$, intent(inout) :: L(:,:)
            ${t}$, intent(inout) :: D(:)
        end subroutine
        module subroutine ldlt_csr_${s}$(A, L, D)
            type(CSR_${s}$_type), intent(in) :: A
            type(CSR_${s}$_type), intent(inout) :: L
            ${t}$, intent(inout) :: D(:)
        end subroutine
        #:endfor    
    end interface
    public :: ldlt

    interface ssor
        #:for k, t, s in R_KINDS_TYPES
        module subroutine ssor_dense_${s}$(A, w, L, D)
            ${t}$, intent(in) :: A(:,:)
            ${t}$, intent(in) :: w
            ${t}$, intent(inout) :: L(:,:)
            ${t}$, intent(inout) :: D(:)
        end subroutine
        module subroutine ssor_csr_${s}$(A, w, L, D)
            type(CSR_${s}$_type), intent(in) :: A
            ${t}$, intent(in) :: w
            type(CSR_${s}$_type), intent(inout) :: L
            ${t}$, intent(inout) :: D(:)
        end subroutine
        #:endfor    
    end interface
    public :: ssor


contains

    !------------------------------------------------------------------
    ! defaults
    !------------------------------------------------------------------
    #:for k, t, s in R_KINDS_TYPES
    pure ${t}$ function default_dot_${s}$(x,y) result(r)
        use stdlib_intrinsics, only: stdlib_dot_product
        ${t}$, intent(in) :: x(:)
        ${t}$, intent(in) :: y(:)
        r = stdlib_dot_product(x,y)
    end function

    #:endfor
    
end module stdlib_linalg_iterative_solvers
