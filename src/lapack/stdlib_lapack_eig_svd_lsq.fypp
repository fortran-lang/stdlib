#:include "common.fypp" 
module stdlib_lapack_eig_svd_lsq
  use stdlib_linalg_constants
  use stdlib_linalg_lapack_aux
  use stdlib_linalg_blas
  use stdlib_lapack_base
  use stdlib_lapack_orthogonal_factors
  use stdlib_lapack_solve
  implicit none

interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, m, n
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: d(*), e(*), taup(*), tauq(*), work(*)
     end subroutine stdlib${ii}$_sgebrd

     pure module subroutine stdlib${ii}$_dgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, m, n
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: d(*), e(*), taup(*), tauq(*), work(*)
     end subroutine stdlib${ii}$_dgebrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$gebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, m, n
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: d(*), e(*), taup(*), tauq(*), work(*)
     end subroutine stdlib${ii}$_${ri}$gebrd

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, m, n
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: taup(*), tauq(*), work(*)
     end subroutine stdlib${ii}$_cgebrd

     pure module subroutine stdlib${ii}$_zgebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, m, n
           real(dp), intent(out) :: d(*), e(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: taup(*), tauq(*), work(*)
     end subroutine stdlib${ii}$_zgebrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$gebrd( m, n, a, lda, d, e, tauq, taup, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, m, n
           real(${ck}$), intent(out) :: d(*), e(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: taup(*), tauq(*), work(*)
     end subroutine stdlib${ii}$_${ci}$gebrd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sgebd2( m, n, a, lda, d, e, tauq, taup, work, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, m, n
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: d(*), e(*), taup(*), tauq(*), work(*)
     end subroutine stdlib${ii}$_sgebd2

     pure module subroutine stdlib${ii}$_dgebd2( m, n, a, lda, d, e, tauq, taup, work, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, m, n
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: d(*), e(*), taup(*), tauq(*), work(*)
     end subroutine stdlib${ii}$_dgebd2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$gebd2( m, n, a, lda, d, e, tauq, taup, work, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, m, n
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: d(*), e(*), taup(*), tauq(*), work(*)
     end subroutine stdlib${ii}$_${ri}$gebd2

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cgebd2( m, n, a, lda, d, e, tauq, taup, work, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, m, n
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: taup(*), tauq(*), work(*)
     end subroutine stdlib${ii}$_cgebd2

     pure module subroutine stdlib${ii}$_zgebd2( m, n, a, lda, d, e, tauq, taup, work, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, m, n
           real(dp), intent(out) :: d(*), e(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: taup(*), tauq(*), work(*)
     end subroutine stdlib${ii}$_zgebd2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$gebd2( m, n, a, lda, d, e, tauq, taup, work, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, m, n
           real(${ck}$), intent(out) :: d(*), e(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: taup(*), tauq(*), work(*)
     end subroutine stdlib${ii}$_${ci}$gebd2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, c, &
               ldc, work, info )
           character, intent(in) :: vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kl, ku, ldab, ldc, ldpt, ldq, m, n, ncc
           real(sp), intent(inout) :: ab(ldab,*), c(ldc,*)
           real(sp), intent(out) :: d(*), e(*), pt(ldpt,*), q(ldq,*), work(*)
     end subroutine stdlib${ii}$_sgbbrd

     pure module subroutine stdlib${ii}$_dgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, c, &
               ldc, work, info )
           character, intent(in) :: vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kl, ku, ldab, ldc, ldpt, ldq, m, n, ncc
           real(dp), intent(inout) :: ab(ldab,*), c(ldc,*)
           real(dp), intent(out) :: d(*), e(*), pt(ldpt,*), q(ldq,*), work(*)
     end subroutine stdlib${ii}$_dgbbrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$gbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, c, &
               ldc, work, info )
           character, intent(in) :: vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kl, ku, ldab, ldc, ldpt, ldq, m, n, ncc
           real(${rk}$), intent(inout) :: ab(ldab,*), c(ldc,*)
           real(${rk}$), intent(out) :: d(*), e(*), pt(ldpt,*), q(ldq,*), work(*)
     end subroutine stdlib${ii}$_${ri}$gbbrd

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, c, &
               ldc, work, rwork, info )
           character, intent(in) :: vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kl, ku, ldab, ldc, ldpt, ldq, m, n, ncc
           real(sp), intent(out) :: d(*), e(*), rwork(*)
           complex(sp), intent(inout) :: ab(ldab,*), c(ldc,*)
           complex(sp), intent(out) :: pt(ldpt,*), q(ldq,*), work(*)
     end subroutine stdlib${ii}$_cgbbrd

     pure module subroutine stdlib${ii}$_zgbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, c, &
               ldc, work, rwork, info )
           character, intent(in) :: vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kl, ku, ldab, ldc, ldpt, ldq, m, n, ncc
           real(dp), intent(out) :: d(*), e(*), rwork(*)
           complex(dp), intent(inout) :: ab(ldab,*), c(ldc,*)
           complex(dp), intent(out) :: pt(ldpt,*), q(ldq,*), work(*)
     end subroutine stdlib${ii}$_zgbbrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$gbbrd( vect, m, n, ncc, kl, ku, ab, ldab, d, e, q,ldq, pt, ldpt, c, &
               ldc, work, rwork, info )
           character, intent(in) :: vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kl, ku, ldab, ldc, ldpt, ldq, m, n, ncc
           real(${ck}$), intent(out) :: d(*), e(*), rwork(*)
           complex(${ck}$), intent(inout) :: ab(ldab,*), c(ldc,*)
           complex(${ck}$), intent(out) :: pt(ldpt,*), q(ldq,*), work(*)
     end subroutine stdlib${ii}$_${ci}$gbbrd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
               nsweep, work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, m, mv, n, nsweep
           real(sp), intent(in) :: eps, sfmin, tol
           character, intent(in) :: jobv
           real(sp), intent(inout) :: a(lda,*), sva(n), d(n), v(ldv,*)
           real(sp), intent(out) :: work(lwork)
     end subroutine stdlib${ii}$_sgsvj0

     pure module subroutine stdlib${ii}$_dgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
               nsweep, work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, m, mv, n, nsweep
           real(dp), intent(in) :: eps, sfmin, tol
           character, intent(in) :: jobv
           real(dp), intent(inout) :: a(lda,*), sva(n), d(n), v(ldv,*)
           real(dp), intent(out) :: work(lwork)
     end subroutine stdlib${ii}$_dgsvj0

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$gsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
               nsweep, work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, m, mv, n, nsweep
           real(${rk}$), intent(in) :: eps, sfmin, tol
           character, intent(in) :: jobv
           real(${rk}$), intent(inout) :: a(lda,*), sva(n), d(n), v(ldv,*)
           real(${rk}$), intent(out) :: work(lwork)
     end subroutine stdlib${ii}$_${ri}$gsvj0

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
               nsweep, work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, m, mv, n, nsweep
           real(sp), intent(in) :: eps, sfmin, tol
           character, intent(in) :: jobv
           complex(sp), intent(inout) :: a(lda,*), d(n), v(ldv,*)
           complex(sp), intent(out) :: work(lwork)
           real(sp), intent(inout) :: sva(n)
     end subroutine stdlib${ii}$_cgsvj0

     pure module subroutine stdlib${ii}$_zgsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
               nsweep, work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, m, mv, n, nsweep
           real(dp), intent(in) :: eps, sfmin, tol
           character, intent(in) :: jobv
           complex(dp), intent(inout) :: a(lda,*), d(n), v(ldv,*)
           complex(dp), intent(out) :: work(lwork)
           real(dp), intent(inout) :: sva(n)
     end subroutine stdlib${ii}$_zgsvj0

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$gsvj0( jobv, m, n, a, lda, d, sva, mv, v, ldv, eps,sfmin, tol, &
               nsweep, work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, m, mv, n, nsweep
           real(${ck}$), intent(in) :: eps, sfmin, tol
           character, intent(in) :: jobv
           complex(${ck}$), intent(inout) :: a(lda,*), d(n), v(ldv,*)
           complex(${ck}$), intent(out) :: work(lwork)
           real(${ck}$), intent(inout) :: sva(n)
     end subroutine stdlib${ii}$_${ci}$gsvj0

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol, &
               nsweep, work, lwork, info )
           real(sp), intent(in) :: eps, sfmin, tol
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, m, mv, n, n1, nsweep
           character, intent(in) :: jobv
           real(sp), intent(inout) :: a(lda,*), d(n), sva(n), v(ldv,*)
           real(sp), intent(out) :: work(lwork)
     end subroutine stdlib${ii}$_sgsvj1

     pure module subroutine stdlib${ii}$_dgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol, &
               nsweep, work, lwork, info )
           real(dp), intent(in) :: eps, sfmin, tol
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, m, mv, n, n1, nsweep
           character, intent(in) :: jobv
           real(dp), intent(inout) :: a(lda,*), d(n), sva(n), v(ldv,*)
           real(dp), intent(out) :: work(lwork)
     end subroutine stdlib${ii}$_dgsvj1

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$gsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol, &
               nsweep, work, lwork, info )
           real(${rk}$), intent(in) :: eps, sfmin, tol
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, m, mv, n, n1, nsweep
           character, intent(in) :: jobv
           real(${rk}$), intent(inout) :: a(lda,*), d(n), sva(n), v(ldv,*)
           real(${rk}$), intent(out) :: work(lwork)
     end subroutine stdlib${ii}$_${ri}$gsvj1

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol, &
               nsweep, work, lwork, info )
           real(sp), intent(in) :: eps, sfmin, tol
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, m, mv, n, n1, nsweep
           character, intent(in) :: jobv
           complex(sp), intent(inout) :: a(lda,*), d(n), v(ldv,*)
           complex(sp), intent(out) :: work(lwork)
           real(sp), intent(inout) :: sva(n)
     end subroutine stdlib${ii}$_cgsvj1

     pure module subroutine stdlib${ii}$_zgsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol, &
               nsweep, work, lwork, info )
           real(dp), intent(in) :: eps, sfmin, tol
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, m, mv, n, n1, nsweep
           character, intent(in) :: jobv
           complex(dp), intent(inout) :: a(lda,*), d(n), v(ldv,*)
           complex(dp), intent(out) :: work(lwork)
           real(dp), intent(inout) :: sva(n)
     end subroutine stdlib${ii}$_zgsvj1

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$gsvj1( jobv, m, n, n1, a, lda, d, sva, mv, v, ldv,eps, sfmin, tol, &
               nsweep, work, lwork, info )
           real(${ck}$), intent(in) :: eps, sfmin, tol
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, m, mv, n, n1, nsweep
           character, intent(in) :: jobv
           complex(${ck}$), intent(inout) :: a(lda,*), d(n), v(ldv,*)
           complex(${ck}$), intent(out) :: work(lwork)
           real(${ck}$), intent(inout) :: sva(n)
     end subroutine stdlib${ii}$_${ci}$gsvj1

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_stgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb, &
               alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
           character, intent(in) :: jobq, jobu, jobv
           integer(${ik}$), intent(out) :: info, ncycle
           integer(${ik}$), intent(in) :: k, l, lda, ldb, ldq, ldu, ldv, m, n, p
           real(sp), intent(in) :: tola, tolb
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), u(ldu,*), v(ldv,*)
           real(sp), intent(out) :: alpha(*), beta(*), work(*)
     end subroutine stdlib${ii}$_stgsja

     pure module subroutine stdlib${ii}$_dtgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb, &
               alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
           character, intent(in) :: jobq, jobu, jobv
           integer(${ik}$), intent(out) :: info, ncycle
           integer(${ik}$), intent(in) :: k, l, lda, ldb, ldq, ldu, ldv, m, n, p
           real(dp), intent(in) :: tola, tolb
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), u(ldu,*), v(ldv,*)
           real(dp), intent(out) :: alpha(*), beta(*), work(*)
     end subroutine stdlib${ii}$_dtgsja

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$tgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb, &
               alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
           character, intent(in) :: jobq, jobu, jobv
           integer(${ik}$), intent(out) :: info, ncycle
           integer(${ik}$), intent(in) :: k, l, lda, ldb, ldq, ldu, ldv, m, n, p
           real(${rk}$), intent(in) :: tola, tolb
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), u(ldu,*), v(ldv,*)
           real(${rk}$), intent(out) :: alpha(*), beta(*), work(*)
     end subroutine stdlib${ii}$_${ri}$tgsja

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_ctgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb, &
               alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
           character, intent(in) :: jobq, jobu, jobv
           integer(${ik}$), intent(out) :: info, ncycle
           integer(${ik}$), intent(in) :: k, l, lda, ldb, ldq, ldu, ldv, m, n, p
           real(sp), intent(in) :: tola, tolb
           real(sp), intent(out) :: alpha(*), beta(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), u(ldu,*), v(ldv,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_ctgsja

     pure module subroutine stdlib${ii}$_ztgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb, &
               alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
           character, intent(in) :: jobq, jobu, jobv
           integer(${ik}$), intent(out) :: info, ncycle
           integer(${ik}$), intent(in) :: k, l, lda, ldb, ldq, ldu, ldv, m, n, p
           real(dp), intent(in) :: tola, tolb
           real(dp), intent(out) :: alpha(*), beta(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), u(ldu,*), v(ldv,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_ztgsja

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$tgsja( jobu, jobv, jobq, m, p, n, k, l, a, lda, b,ldb, tola, tolb, &
               alpha, beta, u, ldu, v, ldv,q, ldq, work, ncycle, info )
           character, intent(in) :: jobq, jobu, jobv
           integer(${ik}$), intent(out) :: info, ncycle
           integer(${ik}$), intent(in) :: k, l, lda, ldb, ldq, ldu, ldv, m, n, p
           real(${ck}$), intent(in) :: tola, tolb
           real(${ck}$), intent(out) :: alpha(*), beta(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), u(ldu,*), v(ldv,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$tgsja

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_cungbr( vect, m, n, k, a, lda, tau, work, lwork, info )
           character, intent(in) :: vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, lda, lwork, m, n
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_cungbr

     pure module subroutine stdlib${ii}$_zungbr( vect, m, n, k, a, lda, tau, work, lwork, info )
           character, intent(in) :: vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, lda, lwork, m, n
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(in) :: tau(*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zungbr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$ungbr( vect, m, n, k, a, lda, tau, work, lwork, info )
           character, intent(in) :: vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, lda, lwork, m, n
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(in) :: tau(*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$ungbr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sorgbr( vect, m, n, k, a, lda, tau, work, lwork, info )
           character, intent(in) :: vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, lda, lwork, m, n
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(in) :: tau(*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_sorgbr

     pure module subroutine stdlib${ii}$_dorgbr( vect, m, n, k, a, lda, tau, work, lwork, info )
           character, intent(in) :: vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, lda, lwork, m, n
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(in) :: tau(*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dorgbr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$orgbr( vect, m, n, k, a, lda, tau, work, lwork, info )
           character, intent(in) :: vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, lda, lwork, m, n
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$orgbr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_cunmbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, lwork, &
               info )
           character, intent(in) :: side, trans, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, lda, ldc, lwork, m, n
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_cunmbr

     pure module subroutine stdlib${ii}$_zunmbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, lwork, &
               info )
           character, intent(in) :: side, trans, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, lda, ldc, lwork, m, n
           complex(dp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(dp), intent(in) :: tau(*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zunmbr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$unmbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, lwork, &
               info )
           character, intent(in) :: side, trans, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, lda, ldc, lwork, m, n
           complex(${ck}$), intent(inout) :: a(lda,*), c(ldc,*)
           complex(${ck}$), intent(in) :: tau(*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$unmbr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sormbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, lwork, &
               info )
           character, intent(in) :: side, trans, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, lda, ldc, lwork, m, n
           real(sp), intent(inout) :: a(lda,*), c(ldc,*)
           real(sp), intent(in) :: tau(*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_sormbr

     pure module subroutine stdlib${ii}$_dormbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, lwork, &
               info )
           character, intent(in) :: side, trans, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, lda, ldc, lwork, m, n
           real(dp), intent(inout) :: a(lda,*), c(ldc,*)
           real(dp), intent(in) :: tau(*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dormbr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$ormbr( vect, side, trans, m, n, k, a, lda, tau, c,ldc, work, lwork, &
               info )
           character, intent(in) :: side, trans, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, lda, ldc, lwork, m, n
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$ormbr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
           integer(${ik}$), intent(in) :: lda, ldx, ldy, m, n, nb
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: d(*), e(*), taup(*), tauq(*), x(ldx,*), y(ldy,*)
     end subroutine stdlib${ii}$_slabrd

     pure module subroutine stdlib${ii}$_dlabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
           integer(${ik}$), intent(in) :: lda, ldx, ldy, m, n, nb
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: d(*), e(*), taup(*), tauq(*), x(ldx,*), y(ldy,*)
     end subroutine stdlib${ii}$_dlabrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$labrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
           integer(${ik}$), intent(in) :: lda, ldx, ldy, m, n, nb
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: d(*), e(*), taup(*), tauq(*), x(ldx,*), y(ldy,*)
     end subroutine stdlib${ii}$_${ri}$labrd

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_clabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
           integer(${ik}$), intent(in) :: lda, ldx, ldy, m, n, nb
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: taup(*), tauq(*), x(ldx,*), y(ldy,*)
     end subroutine stdlib${ii}$_clabrd

     pure module subroutine stdlib${ii}$_zlabrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
           integer(${ik}$), intent(in) :: lda, ldx, ldy, m, n, nb
           real(dp), intent(out) :: d(*), e(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: taup(*), tauq(*), x(ldx,*), y(ldy,*)
     end subroutine stdlib${ii}$_zlabrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$labrd( m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y,ldy )
           integer(${ik}$), intent(in) :: lda, ldx, ldy, m, n, nb
           real(${ck}$), intent(out) :: d(*), e(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: taup(*), tauq(*), x(ldx,*), y(ldy,*)
     end subroutine stdlib${ii}$_${ci}$labrd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slas2( f, g, h, ssmin, ssmax )
           real(sp), intent(in) :: f, g, h
           real(sp), intent(out) :: ssmax, ssmin
     end subroutine stdlib${ii}$_slas2

     pure module subroutine stdlib${ii}$_dlas2( f, g, h, ssmin, ssmax )
           real(dp), intent(in) :: f, g, h
           real(dp), intent(out) :: ssmax, ssmin
     end subroutine stdlib${ii}$_dlas2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$las2( f, g, h, ssmin, ssmax )
           real(${rk}$), intent(in) :: f, g, h
           real(${rk}$), intent(out) :: ssmax, ssmin
     end subroutine stdlib${ii}$_${ri}$las2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasv2( f, g, h, ssmin, ssmax, snr, csr, snl, csl )
           real(sp), intent(out) :: csl, csr, snl, snr, ssmax, ssmin
           real(sp), intent(in) :: f, g, h
     end subroutine stdlib${ii}$_slasv2

     pure module subroutine stdlib${ii}$_dlasv2( f, g, h, ssmin, ssmax, snr, csr, snl, csl )
           real(dp), intent(out) :: csl, csr, snl, snr, ssmax, ssmin
           real(dp), intent(in) :: f, g, h
     end subroutine stdlib${ii}$_dlasv2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasv2( f, g, h, ssmin, ssmax, snr, csr, snl, csl )
           real(${rk}$), intent(out) :: csl, csr, snl, snr, ssmax, ssmin
           real(${rk}$), intent(in) :: f, g, h
     end subroutine stdlib${ii}$_${ri}$lasv2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slartgs( x, y, sigma, cs, sn )
           real(sp), intent(out) :: cs, sn
           real(sp), intent(in) :: sigma, x, y
     end subroutine stdlib${ii}$_slartgs

     pure module subroutine stdlib${ii}$_dlartgs( x, y, sigma, cs, sn )
           real(dp), intent(out) :: cs, sn
           real(dp), intent(in) :: sigma, x, y
     end subroutine stdlib${ii}$_dlartgs

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lartgs( x, y, sigma, cs, sn )
           real(${rk}$), intent(out) :: cs, sn
           real(${rk}$), intent(in) :: sigma, x, y
     end subroutine stdlib${ii}$_${ri}$lartgs

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slags2( upper, a1, a2, a3, b1, b2, b3, csu, snu, csv,snv, csq, snq )
               
           logical(lk), intent(in) :: upper
           real(sp), intent(in) :: a1, a2, a3, b1, b2, b3
           real(sp), intent(out) :: csq, csu, csv, snq, snu, snv
     end subroutine stdlib${ii}$_slags2

     pure module subroutine stdlib${ii}$_dlags2( upper, a1, a2, a3, b1, b2, b3, csu, snu, csv,snv, csq, snq )
               
           logical(lk), intent(in) :: upper
           real(dp), intent(in) :: a1, a2, a3, b1, b2, b3
           real(dp), intent(out) :: csq, csu, csv, snq, snu, snv
     end subroutine stdlib${ii}$_dlags2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lags2( upper, a1, a2, a3, b1, b2, b3, csu, snu, csv,snv, csq, snq )
               
           logical(lk), intent(in) :: upper
           real(${rk}$), intent(in) :: a1, a2, a3, b1, b2, b3
           real(${rk}$), intent(out) :: csq, csu, csv, snq, snu, snv
     end subroutine stdlib${ii}$_${ri}$lags2

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_clags2( upper, a1, a2, a3, b1, b2, b3, csu, snu, csv,snv, csq, snq )
               
           logical(lk), intent(in) :: upper
           real(sp), intent(in) :: a1, a3, b1, b3
           real(sp), intent(out) :: csq, csu, csv
           complex(sp), intent(in) :: a2, b2
           complex(sp), intent(out) :: snq, snu, snv
     end subroutine stdlib${ii}$_clags2

     pure module subroutine stdlib${ii}$_zlags2( upper, a1, a2, a3, b1, b2, b3, csu, snu, csv,snv, csq, snq )
               
           logical(lk), intent(in) :: upper
           real(dp), intent(in) :: a1, a3, b1, b3
           real(dp), intent(out) :: csq, csu, csv
           complex(dp), intent(in) :: a2, b2
           complex(dp), intent(out) :: snq, snu, snv
     end subroutine stdlib${ii}$_zlags2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$lags2( upper, a1, a2, a3, b1, b2, b3, csu, snu, csv,snv, csq, snq )
               
           logical(lk), intent(in) :: upper
           real(${ck}$), intent(in) :: a1, a3, b1, b3
           real(${ck}$), intent(out) :: csq, csu, csv
           complex(${ck}$), intent(in) :: a2, b2
           complex(${ck}$), intent(out) :: snq, snu, snv
     end subroutine stdlib${ii}$_${ci}$lags2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slapll( n, x, incx, y, incy, ssmin )
           integer(${ik}$), intent(in) :: incx, incy, n
           real(sp), intent(out) :: ssmin
           real(sp), intent(inout) :: x(*), y(*)
     end subroutine stdlib${ii}$_slapll

     pure module subroutine stdlib${ii}$_dlapll( n, x, incx, y, incy, ssmin )
           integer(${ik}$), intent(in) :: incx, incy, n
           real(dp), intent(out) :: ssmin
           real(dp), intent(inout) :: x(*), y(*)
     end subroutine stdlib${ii}$_dlapll

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lapll( n, x, incx, y, incy, ssmin )
           integer(${ik}$), intent(in) :: incx, incy, n
           real(${rk}$), intent(out) :: ssmin
           real(${rk}$), intent(inout) :: x(*), y(*)
     end subroutine stdlib${ii}$_${ri}$lapll

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_clapll( n, x, incx, y, incy, ssmin )
           integer(${ik}$), intent(in) :: incx, incy, n
           real(sp), intent(out) :: ssmin
           complex(sp), intent(inout) :: x(*), y(*)
     end subroutine stdlib${ii}$_clapll

     pure module subroutine stdlib${ii}$_zlapll( n, x, incx, y, incy, ssmin )
           integer(${ik}$), intent(in) :: incx, incy, n
           real(dp), intent(out) :: ssmin
           complex(dp), intent(inout) :: x(*), y(*)
     end subroutine stdlib${ii}$_zlapll

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$lapll( n, x, incx, y, incy, ssmin )
           integer(${ik}$), intent(in) :: incx, incy, n
           real(${ck}$), intent(out) :: ssmin
           complex(${ck}$), intent(inout) :: x(*), y(*)
     end subroutine stdlib${ii}$_${ci}$lapll

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_ssygst( itype, uplo, n, a, lda, b, ldb, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, n
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(in) :: b(ldb,*)
     end subroutine stdlib${ii}$_ssygst

     pure module subroutine stdlib${ii}$_dsygst( itype, uplo, n, a, lda, b, ldb, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, n
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(in) :: b(ldb,*)
     end subroutine stdlib${ii}$_dsygst

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$sygst( itype, uplo, n, a, lda, b, ldb, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, n
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: b(ldb,*)
     end subroutine stdlib${ii}$_${ri}$sygst

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_ssygs2( itype, uplo, n, a, lda, b, ldb, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, n
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(in) :: b(ldb,*)
     end subroutine stdlib${ii}$_ssygs2

     pure module subroutine stdlib${ii}$_dsygs2( itype, uplo, n, a, lda, b, ldb, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, n
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(in) :: b(ldb,*)
     end subroutine stdlib${ii}$_dsygs2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$sygs2( itype, uplo, n, a, lda, b, ldb, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, n
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: b(ldb,*)
     end subroutine stdlib${ii}$_${ri}$sygs2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sspgst( itype, uplo, n, ap, bp, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, n
           real(sp), intent(inout) :: ap(*)
           real(sp), intent(in) :: bp(*)
     end subroutine stdlib${ii}$_sspgst

     pure module subroutine stdlib${ii}$_dspgst( itype, uplo, n, ap, bp, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, n
           real(dp), intent(inout) :: ap(*)
           real(dp), intent(in) :: bp(*)
     end subroutine stdlib${ii}$_dspgst

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$spgst( itype, uplo, n, ap, bp, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, n
           real(${rk}$), intent(inout) :: ap(*)
           real(${rk}$), intent(in) :: bp(*)
     end subroutine stdlib${ii}$_${ri}$spgst

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_ssbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, info )
               
           character, intent(in) :: uplo, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldx, n
           real(sp), intent(inout) :: ab(ldab,*)
           real(sp), intent(in) :: bb(ldbb,*)
           real(sp), intent(out) :: work(*), x(ldx,*)
     end subroutine stdlib${ii}$_ssbgst

     pure module subroutine stdlib${ii}$_dsbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, info )
               
           character, intent(in) :: uplo, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldx, n
           real(dp), intent(inout) :: ab(ldab,*)
           real(dp), intent(in) :: bb(ldbb,*)
           real(dp), intent(out) :: work(*), x(ldx,*)
     end subroutine stdlib${ii}$_dsbgst

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$sbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, info )
               
           character, intent(in) :: uplo, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldx, n
           real(${rk}$), intent(inout) :: ab(ldab,*)
           real(${rk}$), intent(in) :: bb(ldbb,*)
           real(${rk}$), intent(out) :: work(*), x(ldx,*)
     end subroutine stdlib${ii}$_${ri}$sbgst

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_chegst( itype, uplo, n, a, lda, b, ldb, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, n
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
     end subroutine stdlib${ii}$_chegst

     pure module subroutine stdlib${ii}$_zhegst( itype, uplo, n, a, lda, b, ldb, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, n
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
     end subroutine stdlib${ii}$_zhegst

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$hegst( itype, uplo, n, a, lda, b, ldb, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, n
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
     end subroutine stdlib${ii}$_${ci}$hegst

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_chegs2( itype, uplo, n, a, lda, b, ldb, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, n
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
     end subroutine stdlib${ii}$_chegs2

     pure module subroutine stdlib${ii}$_zhegs2( itype, uplo, n, a, lda, b, ldb, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, n
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
     end subroutine stdlib${ii}$_zhegs2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$hegs2( itype, uplo, n, a, lda, b, ldb, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, n
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
     end subroutine stdlib${ii}$_${ci}$hegs2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_chpgst( itype, uplo, n, ap, bp, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, n
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(in) :: bp(*)
     end subroutine stdlib${ii}$_chpgst

     pure module subroutine stdlib${ii}$_zhpgst( itype, uplo, n, ap, bp, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, n
           complex(dp), intent(inout) :: ap(*)
           complex(dp), intent(in) :: bp(*)
     end subroutine stdlib${ii}$_zhpgst

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$hpgst( itype, uplo, n, ap, bp, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, n
           complex(${ck}$), intent(inout) :: ap(*)
           complex(${ck}$), intent(in) :: bp(*)
     end subroutine stdlib${ii}$_${ci}$hpgst

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_chbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, rwork,&
                info )
           character, intent(in) :: uplo, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldx, n
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: ab(ldab,*)
           complex(sp), intent(in) :: bb(ldbb,*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
     end subroutine stdlib${ii}$_chbgst

     pure module subroutine stdlib${ii}$_zhbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, rwork,&
                info )
           character, intent(in) :: uplo, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldx, n
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: ab(ldab,*)
           complex(dp), intent(in) :: bb(ldbb,*)
           complex(dp), intent(out) :: work(*), x(ldx,*)
     end subroutine stdlib${ii}$_zhbgst

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$hbgst( vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x,ldx, work, rwork,&
                info )
           character, intent(in) :: uplo, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldx, n
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: ab(ldab,*)
           complex(${ck}$), intent(in) :: bb(ldbb,*)
           complex(${ck}$), intent(out) :: work(*), x(ldx,*)
     end subroutine stdlib${ii}$_${ci}$hbgst

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_spbstf( uplo, n, kd, ab, ldab, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, n
           real(sp), intent(inout) :: ab(ldab,*)
     end subroutine stdlib${ii}$_spbstf

     pure module subroutine stdlib${ii}$_dpbstf( uplo, n, kd, ab, ldab, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, n
           real(dp), intent(inout) :: ab(ldab,*)
     end subroutine stdlib${ii}$_dpbstf

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$pbstf( uplo, n, kd, ab, ldab, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, n
           real(${rk}$), intent(inout) :: ab(ldab,*)
     end subroutine stdlib${ii}$_${ri}$pbstf

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cpbstf( uplo, n, kd, ab, ldab, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, n
           complex(sp), intent(inout) :: ab(ldab,*)
     end subroutine stdlib${ii}$_cpbstf

     pure module subroutine stdlib${ii}$_zpbstf( uplo, n, kd, ab, ldab, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, n
           complex(dp), intent(inout) :: ab(ldab,*)
     end subroutine stdlib${ii}$_zpbstf

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$pbstf( uplo, n, kd, ab, ldab, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, n
           complex(${ck}$), intent(inout) :: ab(ldab,*)
     end subroutine stdlib${ii}$_${ci}$pbstf

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slag2( a, lda, b, ldb, safmin, scale1, scale2, wr1,wr2, wi )
           integer(${ik}$), intent(in) :: lda, ldb
           real(sp), intent(in) :: safmin
           real(sp), intent(out) :: scale1, scale2, wi, wr1, wr2
           real(sp), intent(in) :: a(lda,*), b(ldb,*)
     end subroutine stdlib${ii}$_slag2

     pure module subroutine stdlib${ii}$_dlag2( a, lda, b, ldb, safmin, scale1, scale2, wr1,wr2, wi )
           integer(${ik}$), intent(in) :: lda, ldb
           real(dp), intent(in) :: safmin
           real(dp), intent(out) :: scale1, scale2, wi, wr1, wr2
           real(dp), intent(in) :: a(lda,*), b(ldb,*)
     end subroutine stdlib${ii}$_dlag2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lag2( a, lda, b, ldb, safmin, scale1, scale2, wr1,wr2, wi )
           integer(${ik}$), intent(in) :: lda, ldb
           real(${rk}$), intent(in) :: safmin
           real(${rk}$), intent(out) :: scale1, scale2, wi, wr1, wr2
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*)
     end subroutine stdlib${ii}$_${ri}$lag2

#:endif
#:endfor

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_dlag2${ri}$( m, n, sa, ldsa, a, lda, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldsa, m, n
           real(dp), intent(in) :: sa(ldsa,*)
           real(${rk}$), intent(out) :: a(lda,*)
     end subroutine stdlib${ii}$_dlag2${ri}$

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sorm22( side, trans, m, n, n1, n2, q, ldq, c, ldc,work, lwork, info )
               
           character, intent(in) :: side, trans
           integer(${ik}$), intent(in) :: m, n, n1, n2, ldq, ldc, lwork
           integer(${ik}$), intent(out) :: info
           real(sp), intent(in) :: q(ldq,*)
           real(sp), intent(inout) :: c(ldc,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_sorm22

     pure module subroutine stdlib${ii}$_dorm22( side, trans, m, n, n1, n2, q, ldq, c, ldc,work, lwork, info )
               
           character, intent(in) :: side, trans
           integer(${ik}$), intent(in) :: m, n, n1, n2, ldq, ldc, lwork
           integer(${ik}$), intent(out) :: info
           real(dp), intent(in) :: q(ldq,*)
           real(dp), intent(inout) :: c(ldc,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dorm22

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$orm22( side, trans, m, n, n1, n2, q, ldq, c, ldc,work, lwork, info )
               
           character, intent(in) :: side, trans
           integer(${ik}$), intent(in) :: m, n, n1, n2, ldq, ldc, lwork
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(in) :: q(ldq,*)
           real(${rk}$), intent(inout) :: c(ldc,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$orm22

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sdisna( job, m, n, d, sep, info )
           character, intent(in) :: job
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: m, n
           real(sp), intent(in) :: d(*)
           real(sp), intent(out) :: sep(*)
     end subroutine stdlib${ii}$_sdisna

     pure module subroutine stdlib${ii}$_ddisna( job, m, n, d, sep, info )
           character, intent(in) :: job
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: m, n
           real(dp), intent(in) :: d(*)
           real(dp), intent(out) :: sep(*)
     end subroutine stdlib${ii}$_ddisna

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$disna( job, m, n, d, sep, info )
           character, intent(in) :: job
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: m, n
           real(${rk}$), intent(in) :: d(*)
           real(${rk}$), intent(out) :: sep(*)
     end subroutine stdlib${ii}$_${ri}$disna

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
           character, intent(in) :: uplo
           integer(${ik}$), intent(in) :: lda, ldw, n, nb
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: e(*), tau(*), w(ldw,*)
     end subroutine stdlib${ii}$_slatrd

     pure module subroutine stdlib${ii}$_dlatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
           character, intent(in) :: uplo
           integer(${ik}$), intent(in) :: lda, ldw, n, nb
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: e(*), tau(*), w(ldw,*)
     end subroutine stdlib${ii}$_dlatrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$latrd( uplo, n, nb, a, lda, e, tau, w, ldw )
           character, intent(in) :: uplo
           integer(${ik}$), intent(in) :: lda, ldw, n, nb
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: e(*), tau(*), w(ldw,*)
     end subroutine stdlib${ii}$_${ri}$latrd

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_clatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
           character, intent(in) :: uplo
           integer(${ik}$), intent(in) :: lda, ldw, n, nb
           real(sp), intent(out) :: e(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), w(ldw,*)
     end subroutine stdlib${ii}$_clatrd

     pure module subroutine stdlib${ii}$_zlatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
           character, intent(in) :: uplo
           integer(${ik}$), intent(in) :: lda, ldw, n, nb
           real(dp), intent(out) :: e(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: tau(*), w(ldw,*)
     end subroutine stdlib${ii}$_zlatrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$latrd( uplo, n, nb, a, lda, e, tau, w, ldw )
           character, intent(in) :: uplo
           integer(${ik}$), intent(in) :: lda, ldw, n, nb
           real(${ck}$), intent(out) :: e(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: tau(*), w(ldw,*)
     end subroutine stdlib${ii}$_${ci}$latrd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slae2( a, b, c, rt1, rt2 )
           real(sp), intent(in) :: a, b, c
           real(sp), intent(out) :: rt1, rt2
     end subroutine stdlib${ii}$_slae2

     pure module subroutine stdlib${ii}$_dlae2( a, b, c, rt1, rt2 )
           real(dp), intent(in) :: a, b, c
           real(dp), intent(out) :: rt1, rt2
     end subroutine stdlib${ii}$_dlae2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lae2( a, b, c, rt1, rt2 )
           real(${rk}$), intent(in) :: a, b, c
           real(${rk}$), intent(out) :: rt1, rt2
     end subroutine stdlib${ii}$_${ri}$lae2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_claesy( a, b, c, rt1, rt2, evscal, cs1, sn1 )
           complex(sp), intent(in) :: a, b, c
           complex(sp), intent(out) :: cs1, evscal, rt1, rt2, sn1
     end subroutine stdlib${ii}$_claesy

     pure module subroutine stdlib${ii}$_zlaesy( a, b, c, rt1, rt2, evscal, cs1, sn1 )
           complex(dp), intent(in) :: a, b, c
           complex(dp), intent(out) :: cs1, evscal, rt1, rt2, sn1
     end subroutine stdlib${ii}$_zlaesy

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$laesy( a, b, c, rt1, rt2, evscal, cs1, sn1 )
           complex(${ck}$), intent(in) :: a, b, c
           complex(${ck}$), intent(out) :: cs1, evscal, rt1, rt2, sn1
     end subroutine stdlib${ii}$_${ci}$laesy

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaev2( a, b, c, rt1, rt2, cs1, sn1 )
           real(sp), intent(in) :: a, b, c
           real(sp), intent(out) :: cs1, rt1, rt2, sn1
     end subroutine stdlib${ii}$_slaev2

     pure module subroutine stdlib${ii}$_dlaev2( a, b, c, rt1, rt2, cs1, sn1 )
           real(dp), intent(in) :: a, b, c
           real(dp), intent(out) :: cs1, rt1, rt2, sn1
     end subroutine stdlib${ii}$_dlaev2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laev2( a, b, c, rt1, rt2, cs1, sn1 )
           real(${rk}$), intent(in) :: a, b, c
           real(${rk}$), intent(out) :: cs1, rt1, rt2, sn1
     end subroutine stdlib${ii}$_${ri}$laev2

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_claev2( a, b, c, rt1, rt2, cs1, sn1 )
           real(sp), intent(out) :: cs1, rt1, rt2
           complex(sp), intent(in) :: a, b, c
           complex(sp), intent(out) :: sn1
     end subroutine stdlib${ii}$_claev2

     pure module subroutine stdlib${ii}$_zlaev2( a, b, c, rt1, rt2, cs1, sn1 )
           real(dp), intent(out) :: cs1, rt1, rt2
           complex(dp), intent(in) :: a, b, c
           complex(dp), intent(out) :: sn1
     end subroutine stdlib${ii}$_zlaev2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$laev2( a, b, c, rt1, rt2, cs1, sn1 )
           real(${ck}$), intent(out) :: cs1, rt1, rt2
           complex(${ck}$), intent(in) :: a, b, c
           complex(${ck}$), intent(out) :: sn1
     end subroutine stdlib${ii}$_${ci}$laev2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slagtf( n, a, lambda, b, c, tol, d, in, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(sp), intent(in) :: lambda, tol
           integer(${ik}$), intent(out) :: in(*)
           real(sp), intent(inout) :: a(*), b(*), c(*)
           real(sp), intent(out) :: d(*)
     end subroutine stdlib${ii}$_slagtf

     pure module subroutine stdlib${ii}$_dlagtf( n, a, lambda, b, c, tol, d, in, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(dp), intent(in) :: lambda, tol
           integer(${ik}$), intent(out) :: in(*)
           real(dp), intent(inout) :: a(*), b(*), c(*)
           real(dp), intent(out) :: d(*)
     end subroutine stdlib${ii}$_dlagtf

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lagtf( n, a, lambda, b, c, tol, d, in, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(${rk}$), intent(in) :: lambda, tol
           integer(${ik}$), intent(out) :: in(*)
           real(${rk}$), intent(inout) :: a(*), b(*), c(*)
           real(${rk}$), intent(out) :: d(*)
     end subroutine stdlib${ii}$_${ri}$lagtf

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slagts( job, n, a, b, c, d, in, y, tol, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: job, n
           real(sp), intent(inout) :: tol
           integer(${ik}$), intent(in) :: in(*)
           real(sp), intent(in) :: a(*), b(*), c(*), d(*)
           real(sp), intent(inout) :: y(*)
     end subroutine stdlib${ii}$_slagts

     pure module subroutine stdlib${ii}$_dlagts( job, n, a, b, c, d, in, y, tol, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: job, n
           real(dp), intent(inout) :: tol
           integer(${ik}$), intent(in) :: in(*)
           real(dp), intent(in) :: a(*), b(*), c(*), d(*)
           real(dp), intent(inout) :: y(*)
     end subroutine stdlib${ii}$_dlagts

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lagts( job, n, a, b, c, d, in, y, tol, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: job, n
           real(${rk}$), intent(inout) :: tol
           integer(${ik}$), intent(in) :: in(*)
           real(${rk}$), intent(in) :: a(*), b(*), c(*), d(*)
           real(${rk}$), intent(inout) :: y(*)
     end subroutine stdlib${ii}$_${ri}$lagts

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_ssptrd( uplo, n, ap, d, e, tau, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(sp), intent(inout) :: ap(*)
           real(sp), intent(out) :: d(*), e(*), tau(*)
     end subroutine stdlib${ii}$_ssptrd

     pure module subroutine stdlib${ii}$_dsptrd( uplo, n, ap, d, e, tau, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(dp), intent(inout) :: ap(*)
           real(dp), intent(out) :: d(*), e(*), tau(*)
     end subroutine stdlib${ii}$_dsptrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$sptrd( uplo, n, ap, d, e, tau, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(${rk}$), intent(inout) :: ap(*)
           real(${rk}$), intent(out) :: d(*), e(*), tau(*)
     end subroutine stdlib${ii}$_${ri}$sptrd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sopgtr( uplo, n, ap, tau, q, ldq, work, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldq, n
           real(sp), intent(in) :: ap(*), tau(*)
           real(sp), intent(out) :: q(ldq,*), work(*)
     end subroutine stdlib${ii}$_sopgtr

     pure module subroutine stdlib${ii}$_dopgtr( uplo, n, ap, tau, q, ldq, work, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldq, n
           real(dp), intent(in) :: ap(*), tau(*)
           real(dp), intent(out) :: q(ldq,*), work(*)
     end subroutine stdlib${ii}$_dopgtr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$opgtr( uplo, n, ap, tau, q, ldq, work, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldq, n
           real(${rk}$), intent(in) :: ap(*), tau(*)
           real(${rk}$), intent(out) :: q(ldq,*), work(*)
     end subroutine stdlib${ii}$_${ri}$opgtr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sopmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
           character, intent(in) :: side, trans, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldc, m, n
           real(sp), intent(inout) :: ap(*), c(ldc,*)
           real(sp), intent(in) :: tau(*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_sopmtr

     pure module subroutine stdlib${ii}$_dopmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
           character, intent(in) :: side, trans, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldc, m, n
           real(dp), intent(inout) :: ap(*), c(ldc,*)
           real(dp), intent(in) :: tau(*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dopmtr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$opmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
           character, intent(in) :: side, trans, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldc, m, n
           real(${rk}$), intent(inout) :: ap(*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$opmtr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_ssbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
           character, intent(in) :: uplo, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldq, n
           real(sp), intent(inout) :: ab(ldab,*), q(ldq,*)
           real(sp), intent(out) :: d(*), e(*), work(*)
     end subroutine stdlib${ii}$_ssbtrd

     pure module subroutine stdlib${ii}$_dsbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
           character, intent(in) :: uplo, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldq, n
           real(dp), intent(inout) :: ab(ldab,*), q(ldq,*)
           real(dp), intent(out) :: d(*), e(*), work(*)
     end subroutine stdlib${ii}$_dsbtrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$sbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
           character, intent(in) :: uplo, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldq, n
           real(${rk}$), intent(inout) :: ab(ldab,*), q(ldq,*)
           real(${rk}$), intent(out) :: d(*), e(*), work(*)
     end subroutine stdlib${ii}$_${ri}$sbtrd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_chptrd( uplo, n, ap, d, e, tau, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(out) :: tau(*)
     end subroutine stdlib${ii}$_chptrd

     pure module subroutine stdlib${ii}$_zhptrd( uplo, n, ap, d, e, tau, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(dp), intent(out) :: d(*), e(*)
           complex(dp), intent(inout) :: ap(*)
           complex(dp), intent(out) :: tau(*)
     end subroutine stdlib${ii}$_zhptrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$hptrd( uplo, n, ap, d, e, tau, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(${ck}$), intent(out) :: d(*), e(*)
           complex(${ck}$), intent(inout) :: ap(*)
           complex(${ck}$), intent(out) :: tau(*)
     end subroutine stdlib${ii}$_${ci}$hptrd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_cupgtr( uplo, n, ap, tau, q, ldq, work, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldq, n
           complex(sp), intent(in) :: ap(*), tau(*)
           complex(sp), intent(out) :: q(ldq,*), work(*)
     end subroutine stdlib${ii}$_cupgtr

     pure module subroutine stdlib${ii}$_zupgtr( uplo, n, ap, tau, q, ldq, work, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldq, n
           complex(dp), intent(in) :: ap(*), tau(*)
           complex(dp), intent(out) :: q(ldq,*), work(*)
     end subroutine stdlib${ii}$_zupgtr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$upgtr( uplo, n, ap, tau, q, ldq, work, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldq, n
           complex(${ck}$), intent(in) :: ap(*), tau(*)
           complex(${ck}$), intent(out) :: q(ldq,*), work(*)
     end subroutine stdlib${ii}$_${ci}$upgtr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_cupmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
           character, intent(in) :: side, trans, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldc, m, n
           complex(sp), intent(inout) :: ap(*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_cupmtr

     pure module subroutine stdlib${ii}$_zupmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
           character, intent(in) :: side, trans, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldc, m, n
           complex(dp), intent(inout) :: ap(*), c(ldc,*)
           complex(dp), intent(in) :: tau(*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zupmtr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$upmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
           character, intent(in) :: side, trans, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldc, m, n
           complex(${ck}$), intent(inout) :: ap(*), c(ldc,*)
           complex(${ck}$), intent(in) :: tau(*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$upmtr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_chbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
           character, intent(in) :: uplo, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldq, n
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: ab(ldab,*), q(ldq,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_chbtrd

     pure module subroutine stdlib${ii}$_zhbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
           character, intent(in) :: uplo, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldq, n
           real(dp), intent(out) :: d(*), e(*)
           complex(dp), intent(inout) :: ab(ldab,*), q(ldq,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zhbtrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$hbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
           character, intent(in) :: uplo, vect
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldq, n
           real(${ck}$), intent(out) :: d(*), e(*)
           complex(${ck}$), intent(inout) :: ab(ldab,*), q(ldq,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$hbtrd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sgeev( jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr,ldvr, work, lwork, &
               info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: vl(ldvl,*), vr(ldvr,*), wi(*), work(*), wr(*)
     end subroutine stdlib${ii}$_sgeev

     module subroutine stdlib${ii}$_dgeev( jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr,ldvr, work, lwork, &
               info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: vl(ldvl,*), vr(ldvr,*), wi(*), work(*), wr(*)
     end subroutine stdlib${ii}$_dgeev

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$geev( jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr,ldvr, work, lwork, &
               info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: vl(ldvl,*), vr(ldvr,*), wi(*), work(*), wr(*)
     end subroutine stdlib${ii}$_${ri}$geev

#:endif
#:endfor

     module subroutine stdlib${ii}$_cgeev( jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr,work, lwork, rwork, &
               info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: vl(ldvl,*), vr(ldvr,*), w(*), work(*)
     end subroutine stdlib${ii}$_cgeev

     module subroutine stdlib${ii}$_zgeev( jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr,work, lwork, rwork, &
               info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: vl(ldvl,*), vr(ldvr,*), w(*), work(*)
     end subroutine stdlib${ii}$_zgeev

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$geev( jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr,work, lwork, rwork, &
               info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: vl(ldvl,*), vr(ldvr,*), w(*), work(*)
     end subroutine stdlib${ii}$_${ci}$geev

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sgeevx( balanc, jobvl, jobvr, sense, n, a, lda, wr, wi,vl, ldvl, vr, ldvr, &
               ilo, ihi, scale, abnrm,rconde, rcondv, work, lwork, iwork, info )
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(sp), intent(out) :: abnrm
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: rconde(*), rcondv(*), scale(*), vl(ldvl,*), vr(ldvr,*), wi(*),&
                      work(*), wr(*)
     end subroutine stdlib${ii}$_sgeevx

     module subroutine stdlib${ii}$_dgeevx( balanc, jobvl, jobvr, sense, n, a, lda, wr, wi,vl, ldvl, vr, ldvr, &
               ilo, ihi, scale, abnrm,rconde, rcondv, work, lwork, iwork, info )
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(dp), intent(out) :: abnrm
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: rconde(*), rcondv(*), scale(*), vl(ldvl,*), vr(ldvr,*), wi(*),&
                      work(*), wr(*)
     end subroutine stdlib${ii}$_dgeevx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$geevx( balanc, jobvl, jobvr, sense, n, a, lda, wr, wi,vl, ldvl, vr, ldvr, &
               ilo, ihi, scale, abnrm,rconde, rcondv, work, lwork, iwork, info )
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(${rk}$), intent(out) :: abnrm
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: rconde(*), rcondv(*), scale(*), vl(ldvl,*), vr(ldvr,*), wi(*),&
                      work(*), wr(*)
     end subroutine stdlib${ii}$_${ri}$geevx

#:endif
#:endfor

     module subroutine stdlib${ii}$_cgeevx( balanc, jobvl, jobvr, sense, n, a, lda, w, vl,ldvl, vr, ldvr, ilo, &
               ihi, scale, abnrm, rconde,rcondv, work, lwork, rwork, info )
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(sp), intent(out) :: abnrm
           real(sp), intent(out) :: rconde(*), rcondv(*), rwork(*), scale(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: vl(ldvl,*), vr(ldvr,*), w(*), work(*)
     end subroutine stdlib${ii}$_cgeevx

     module subroutine stdlib${ii}$_zgeevx( balanc, jobvl, jobvr, sense, n, a, lda, w, vl,ldvl, vr, ldvr, ilo, &
               ihi, scale, abnrm, rconde,rcondv, work, lwork, rwork, info )
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(dp), intent(out) :: abnrm
           real(dp), intent(out) :: rconde(*), rcondv(*), rwork(*), scale(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: vl(ldvl,*), vr(ldvr,*), w(*), work(*)
     end subroutine stdlib${ii}$_zgeevx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$geevx( balanc, jobvl, jobvr, sense, n, a, lda, w, vl,ldvl, vr, ldvr, ilo, &
               ihi, scale, abnrm, rconde,rcondv, work, lwork, rwork, info )
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(${ck}$), intent(out) :: abnrm
           real(${ck}$), intent(out) :: rconde(*), rcondv(*), rwork(*), scale(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: vl(ldvl,*), vr(ldvr,*), w(*), work(*)
     end subroutine stdlib${ii}$_${ci}$geevx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sgees( jobvs, sort, select, n, a, lda, sdim, wr, wi,vs, ldvs, work, lwork, &
               bwork, info )
           character, intent(in) :: jobvs, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldvs, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: vs(ldvs,*), wi(*), work(*), wr(*)
           procedure(stdlib_select_s) :: select
     end subroutine stdlib${ii}$_sgees

     module subroutine stdlib${ii}$_dgees( jobvs, sort, select, n, a, lda, sdim, wr, wi,vs, ldvs, work, lwork, &
               bwork, info )
           character, intent(in) :: jobvs, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldvs, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: vs(ldvs,*), wi(*), work(*), wr(*)
           procedure(stdlib_select_d) :: select
     end subroutine stdlib${ii}$_dgees

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$gees( jobvs, sort, select, n, a, lda, sdim, wr, wi,vs, ldvs, work, lwork, &
               bwork, info )
           character, intent(in) :: jobvs, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldvs, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: vs(ldvs,*), wi(*), work(*), wr(*)
           procedure(stdlib_select_${ri}$) :: select
     end subroutine stdlib${ii}$_${ri}$gees

#:endif
#:endfor

     module subroutine stdlib${ii}$_cgees( jobvs, sort, select, n, a, lda, sdim, w, vs,ldvs, work, lwork, &
               rwork, bwork, info )
           character, intent(in) :: jobvs, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldvs, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: vs(ldvs,*), w(*), work(*)
           procedure(stdlib_select_c) :: select
     end subroutine stdlib${ii}$_cgees

     module subroutine stdlib${ii}$_zgees( jobvs, sort, select, n, a, lda, sdim, w, vs,ldvs, work, lwork, &
               rwork, bwork, info )
           character, intent(in) :: jobvs, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldvs, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: vs(ldvs,*), w(*), work(*)
           procedure(stdlib_select_z) :: select
     end subroutine stdlib${ii}$_zgees

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$gees( jobvs, sort, select, n, a, lda, sdim, w, vs,ldvs, work, lwork, &
               rwork, bwork, info )
           character, intent(in) :: jobvs, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldvs, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: vs(ldvs,*), w(*), work(*)
           procedure(stdlib_select_${ci}$) :: select
     end subroutine stdlib${ii}$_${ci}$gees

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sgeesx( jobvs, sort, select, sense, n, a, lda, sdim,wr, wi, vs, ldvs, &
               rconde, rcondv, work, lwork,iwork, liwork, bwork, info )
           character, intent(in) :: jobvs, sense, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldvs, liwork, lwork, n
           real(sp), intent(out) :: rconde, rcondv
           logical(lk), intent(out) :: bwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: vs(ldvs,*), wi(*), work(*), wr(*)
           procedure(stdlib_select_s) :: select
     end subroutine stdlib${ii}$_sgeesx

     module subroutine stdlib${ii}$_dgeesx( jobvs, sort, select, sense, n, a, lda, sdim,wr, wi, vs, ldvs, &
               rconde, rcondv, work, lwork,iwork, liwork, bwork, info )
           character, intent(in) :: jobvs, sense, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldvs, liwork, lwork, n
           real(dp), intent(out) :: rconde, rcondv
           logical(lk), intent(out) :: bwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: vs(ldvs,*), wi(*), work(*), wr(*)
           procedure(stdlib_select_d) :: select
     end subroutine stdlib${ii}$_dgeesx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$geesx( jobvs, sort, select, sense, n, a, lda, sdim,wr, wi, vs, ldvs, &
               rconde, rcondv, work, lwork,iwork, liwork, bwork, info )
           character, intent(in) :: jobvs, sense, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldvs, liwork, lwork, n
           real(${rk}$), intent(out) :: rconde, rcondv
           logical(lk), intent(out) :: bwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: vs(ldvs,*), wi(*), work(*), wr(*)
           procedure(stdlib_select_${ri}$) :: select
     end subroutine stdlib${ii}$_${ri}$geesx

#:endif
#:endfor

     module subroutine stdlib${ii}$_cgeesx( jobvs, sort, select, sense, n, a, lda, sdim, w,vs, ldvs, rconde, &
               rcondv, work, lwork, rwork,bwork, info )
           character, intent(in) :: jobvs, sense, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldvs, lwork, n
           real(sp), intent(out) :: rconde, rcondv
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: vs(ldvs,*), w(*), work(*)
           procedure(stdlib_select_c) :: select
     end subroutine stdlib${ii}$_cgeesx

     module subroutine stdlib${ii}$_zgeesx( jobvs, sort, select, sense, n, a, lda, sdim, w,vs, ldvs, rconde, &
               rcondv, work, lwork, rwork,bwork, info )
           character, intent(in) :: jobvs, sense, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldvs, lwork, n
           real(dp), intent(out) :: rconde, rcondv
           logical(lk), intent(out) :: bwork(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: vs(ldvs,*), w(*), work(*)
           procedure(stdlib_select_z) :: select
     end subroutine stdlib${ii}$_zgeesx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$geesx( jobvs, sort, select, sense, n, a, lda, sdim, w,vs, ldvs, rconde, &
               rcondv, work, lwork, rwork,bwork, info )
           character, intent(in) :: jobvs, sense, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldvs, lwork, n
           real(${ck}$), intent(out) :: rconde, rcondv
           logical(lk), intent(out) :: bwork(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: vs(ldvs,*), w(*), work(*)
           procedure(stdlib_select_${ci}$) :: select
     end subroutine stdlib${ii}$_${ci}$geesx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sggev3( jobvl, jobvr, n, a, lda, b, ldb, alphar,alphai, beta, vl, ldvl, vr,&
                ldvr, work, lwork,info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
                     
     end subroutine stdlib${ii}$_sggev3

     module subroutine stdlib${ii}$_dggev3( jobvl, jobvr, n, a, lda, b, ldb, alphar,alphai, beta, vl, ldvl, vr,&
                ldvr, work, lwork,info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
                     
     end subroutine stdlib${ii}$_dggev3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$ggev3( jobvl, jobvr, n, a, lda, b, ldb, alphar,alphai, beta, vl, ldvl, vr,&
                ldvr, work, lwork,info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
                     
     end subroutine stdlib${ii}$_${ri}$ggev3

#:endif
#:endfor

     module subroutine stdlib${ii}$_cggev3( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
               work, lwork, rwork, info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
     end subroutine stdlib${ii}$_cggev3

     module subroutine stdlib${ii}$_zggev3( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
               work, lwork, rwork, info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
     end subroutine stdlib${ii}$_zggev3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$ggev3( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
               work, lwork, rwork, info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
     end subroutine stdlib${ii}$_${ci}$ggev3

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,beta, vl, ldvl, vr, &
               ldvr, work, lwork, info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
                     
     end subroutine stdlib${ii}$_sggev

     module subroutine stdlib${ii}$_dggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,beta, vl, ldvl, vr, &
               ldvr, work, lwork, info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
                     
     end subroutine stdlib${ii}$_dggev

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$ggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,beta, vl, ldvl, vr, &
               ldvr, work, lwork, info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
                     
     end subroutine stdlib${ii}$_${ri}$ggev

#:endif
#:endfor

     module subroutine stdlib${ii}$_cggev( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
               work, lwork, rwork, info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
     end subroutine stdlib${ii}$_cggev

     module subroutine stdlib${ii}$_zggev( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
               work, lwork, rwork, info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
     end subroutine stdlib${ii}$_zggev

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$ggev( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
               work, lwork, rwork, info )
           character, intent(in) :: jobvl, jobvr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
     end subroutine stdlib${ii}$_${ci}$ggev

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,alphar, alphai, &
     beta, vl, ldvl, vr, ldvr, ilo,ihi, lscale, rscale, abnrm, bbnrm, rconde,rcondv, work, lwork, &
               iwork, bwork, info )
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(sp), intent(out) :: abnrm, bbnrm
           logical(lk), intent(out) :: bwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), lscale(*), rconde(*), rcondv(*)&
                     , rscale(*), vl(ldvl,*), vr(ldvr,*), work(*)
     end subroutine stdlib${ii}$_sggevx

     module subroutine stdlib${ii}$_dggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,alphar, alphai, &
     beta, vl, ldvl, vr, ldvr, ilo,ihi, lscale, rscale, abnrm, bbnrm, rconde,rcondv, work, lwork, &
               iwork, bwork, info )
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(dp), intent(out) :: abnrm, bbnrm
           logical(lk), intent(out) :: bwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), lscale(*), rconde(*), rcondv(*)&
                     , rscale(*), vl(ldvl,*), vr(ldvr,*), work(*)
     end subroutine stdlib${ii}$_dggevx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$ggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,alphar, alphai, &
     beta, vl, ldvl, vr, ldvr, ilo,ihi, lscale, rscale, abnrm, bbnrm, rconde,rcondv, work, lwork, &
               iwork, bwork, info )
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(${rk}$), intent(out) :: abnrm, bbnrm
           logical(lk), intent(out) :: bwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), lscale(*), rconde(*), rcondv(*)&
                     , rscale(*), vl(ldvl,*), vr(ldvr,*), work(*)
     end subroutine stdlib${ii}$_${ri}$ggevx

#:endif
#:endfor

     module subroutine stdlib${ii}$_cggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,alpha, beta, vl, &
     ldvl, vr, ldvr, ilo, ihi,lscale, rscale, abnrm, bbnrm, rconde, rcondv,work, lwork, rwork, &
               iwork, bwork, info )
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(sp), intent(out) :: abnrm, bbnrm
           logical(lk), intent(out) :: bwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(out) :: lscale(*), rconde(*), rcondv(*), rscale(*), rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
     end subroutine stdlib${ii}$_cggevx

     module subroutine stdlib${ii}$_zggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,alpha, beta, vl, &
     ldvl, vr, ldvr, ilo, ihi,lscale, rscale, abnrm, bbnrm, rconde, rcondv,work, lwork, rwork, &
               iwork, bwork, info )
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(dp), intent(out) :: abnrm, bbnrm
           logical(lk), intent(out) :: bwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(out) :: lscale(*), rconde(*), rcondv(*), rscale(*), rwork(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
     end subroutine stdlib${ii}$_zggevx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$ggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,alpha, beta, vl, &
     ldvl, vr, ldvr, ilo, ihi,lscale, rscale, abnrm, bbnrm, rconde, rcondv,work, lwork, rwork, &
               iwork, bwork, info )
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(${ck}$), intent(out) :: abnrm, bbnrm
           logical(lk), intent(out) :: bwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: lscale(*), rconde(*), rcondv(*), rscale(*), rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
     end subroutine stdlib${ii}$_${ci}$ggevx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sgges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,ldb, sdim, alphar, &
               alphai, beta, vsl, ldvsl,vsr, ldvsr, work, lwork, bwork, info )
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), &
                     work(*)
           procedure(stdlib_selctg_s) :: selctg
     end subroutine stdlib${ii}$_sgges3

     module subroutine stdlib${ii}$_dgges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,ldb, sdim, alphar, &
               alphai, beta, vsl, ldvsl,vsr, ldvsr, work, lwork, bwork, info )
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), &
                     work(*)
           procedure(stdlib_selctg_d) :: selctg
     end subroutine stdlib${ii}$_dgges3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$gges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,ldb, sdim, alphar, &
               alphai, beta, vsl, ldvsl,vsr, ldvsr, work, lwork, bwork, info )
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), &
                     work(*)
           procedure(stdlib_selctg_${ri}$) :: selctg
     end subroutine stdlib${ii}$_${ri}$gges3

#:endif
#:endfor

     module subroutine stdlib${ii}$_cgges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,ldb, sdim, alpha, beta, &
               vsl, ldvsl, vsr, ldvsr,work, lwork, rwork, bwork, info )
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           procedure(stdlib_selctg_c) :: selctg
     end subroutine stdlib${ii}$_cgges3

     module subroutine stdlib${ii}$_zgges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,ldb, sdim, alpha, beta, &
               vsl, ldvsl, vsr, ldvsr,work, lwork, rwork, bwork, info )
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           procedure(stdlib_selctg_z) :: selctg
     end subroutine stdlib${ii}$_zgges3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$gges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,ldb, sdim, alpha, beta, &
               vsl, ldvsl, vsr, ldvsr,work, lwork, rwork, bwork, info )
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           procedure(stdlib_selctg_${ci}$) :: selctg
     end subroutine stdlib${ii}$_${ci}$gges3

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alphar, &
               alphai, beta, vsl, ldvsl, vsr,ldvsr, work, lwork, bwork, info )
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), &
                     work(*)
           procedure(stdlib_selctg_s) :: selctg
     end subroutine stdlib${ii}$_sgges

     module subroutine stdlib${ii}$_dgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alphar, &
               alphai, beta, vsl, ldvsl, vsr,ldvsr, work, lwork, bwork, info )
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), &
                     work(*)
           procedure(stdlib_selctg_d) :: selctg
     end subroutine stdlib${ii}$_dgges

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$gges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alphar, &
               alphai, beta, vsl, ldvsl, vsr,ldvsr, work, lwork, bwork, info )
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), &
                     work(*)
           procedure(stdlib_selctg_${ri}$) :: selctg
     end subroutine stdlib${ii}$_${ri}$gges

#:endif
#:endfor

     module subroutine stdlib${ii}$_cgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alpha, beta, &
               vsl, ldvsl, vsr, ldvsr, work,lwork, rwork, bwork, info )
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           procedure(stdlib_selctg_c) :: selctg
     end subroutine stdlib${ii}$_cgges

     module subroutine stdlib${ii}$_zgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alpha, beta, &
               vsl, ldvsl, vsr, ldvsr, work,lwork, rwork, bwork, info )
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           procedure(stdlib_selctg_z) :: selctg
     end subroutine stdlib${ii}$_zgges

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$gges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alpha, beta, &
               vsl, ldvsl, vsr, ldvsr, work,lwork, rwork, bwork, info )
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           logical(lk), intent(out) :: bwork(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           procedure(stdlib_selctg_${ci}$) :: selctg
     end subroutine stdlib${ii}$_${ci}$gges

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,b, ldb, sdim, &
     alphar, alphai, beta, vsl, ldvsl,vsr, ldvsr, rconde, rcondv, work, lwork, iwork,liwork, &
               bwork, info )
           character, intent(in) :: jobvsl, jobvsr, sense, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, liwork, lwork, n
           logical(lk), intent(out) :: bwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), rconde(2_${ik}$), rcondv(2_${ik}$), vsl(&
                     ldvsl,*), vsr(ldvsr,*), work(*)
           procedure(stdlib_selctg_s) :: selctg
     end subroutine stdlib${ii}$_sggesx

     module subroutine stdlib${ii}$_dggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,b, ldb, sdim, &
     alphar, alphai, beta, vsl, ldvsl,vsr, ldvsr, rconde, rcondv, work, lwork, iwork,liwork, &
               bwork, info )
           character, intent(in) :: jobvsl, jobvsr, sense, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, liwork, lwork, n
           logical(lk), intent(out) :: bwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), rconde(2_${ik}$), rcondv(2_${ik}$), vsl(&
                     ldvsl,*), vsr(ldvsr,*), work(*)
           procedure(stdlib_selctg_d) :: selctg
     end subroutine stdlib${ii}$_dggesx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$ggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,b, ldb, sdim, &
     alphar, alphai, beta, vsl, ldvsl,vsr, ldvsr, rconde, rcondv, work, lwork, iwork,liwork, &
               bwork, info )
           character, intent(in) :: jobvsl, jobvsr, sense, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, liwork, lwork, n
           logical(lk), intent(out) :: bwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), rconde(2_${ik}$), rcondv(2_${ik}$), vsl(&
                     ldvsl,*), vsr(ldvsr,*), work(*)
           procedure(stdlib_selctg_${ri}$) :: selctg
     end subroutine stdlib${ii}$_${ri}$ggesx

#:endif
#:endfor

     module subroutine stdlib${ii}$_cggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,b, ldb, sdim, alpha,&
      beta, vsl, ldvsl, vsr,ldvsr, rconde, rcondv, work, lwork, rwork,iwork, liwork, bwork, info )
                
           character, intent(in) :: jobvsl, jobvsr, sense, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, liwork, lwork, n
           logical(lk), intent(out) :: bwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(out) :: rconde(2_${ik}$), rcondv(2_${ik}$), rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           procedure(stdlib_selctg_c) :: selctg
     end subroutine stdlib${ii}$_cggesx

     module subroutine stdlib${ii}$_zggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,b, ldb, sdim, alpha,&
      beta, vsl, ldvsl, vsr,ldvsr, rconde, rcondv, work, lwork, rwork,iwork, liwork, bwork, info )
                
           character, intent(in) :: jobvsl, jobvsr, sense, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, liwork, lwork, n
           logical(lk), intent(out) :: bwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(out) :: rconde(2_${ik}$), rcondv(2_${ik}$), rwork(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           procedure(stdlib_selctg_z) :: selctg
     end subroutine stdlib${ii}$_zggesx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$ggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,b, ldb, sdim, alpha,&
      beta, vsl, ldvsl, vsr,ldvsr, rconde, rcondv, work, lwork, rwork,iwork, liwork, bwork, info )
                
           character, intent(in) :: jobvsl, jobvsr, sense, sort
           integer(${ik}$), intent(out) :: info, sdim
           integer(${ik}$), intent(in) :: lda, ldb, ldvsl, ldvsr, liwork, lwork, n
           logical(lk), intent(out) :: bwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: rconde(2_${ik}$), rcondv(2_${ik}$), rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           procedure(stdlib_selctg_${ci}$) :: selctg
     end subroutine stdlib${ii}$_${ci}$ggesx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sgebal( job, n, a, lda, ilo, ihi, scale, info )
           character, intent(in) :: job
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, n
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: scale(*)
     end subroutine stdlib${ii}$_sgebal

     pure module subroutine stdlib${ii}$_dgebal( job, n, a, lda, ilo, ihi, scale, info )
           character, intent(in) :: job
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, n
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: scale(*)
     end subroutine stdlib${ii}$_dgebal

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$gebal( job, n, a, lda, ilo, ihi, scale, info )
           character, intent(in) :: job
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, n
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: scale(*)
     end subroutine stdlib${ii}$_${ri}$gebal

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cgebal( job, n, a, lda, ilo, ihi, scale, info )
           character, intent(in) :: job
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, n
           real(sp), intent(out) :: scale(*)
           complex(sp), intent(inout) :: a(lda,*)
     end subroutine stdlib${ii}$_cgebal

     pure module subroutine stdlib${ii}$_zgebal( job, n, a, lda, ilo, ihi, scale, info )
           character, intent(in) :: job
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, n
           real(dp), intent(out) :: scale(*)
           complex(dp), intent(inout) :: a(lda,*)
     end subroutine stdlib${ii}$_zgebal

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$gebal( job, n, a, lda, ilo, ihi, scale, info )
           character, intent(in) :: job
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, n
           real(${ck}$), intent(out) :: scale(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
     end subroutine stdlib${ii}$_${ci}$gebal

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, lwork, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: tau(*), work(*)
     end subroutine stdlib${ii}$_sgehrd

     pure module subroutine stdlib${ii}$_dgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, lwork, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: tau(*), work(*)
     end subroutine stdlib${ii}$_dgehrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$gehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, lwork, n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
     end subroutine stdlib${ii}$_${ri}$gehrd

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, lwork, n
           integer(${ik}$), intent(out) :: info
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
     end subroutine stdlib${ii}$_cgehrd

     pure module subroutine stdlib${ii}$_zgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, lwork, n
           integer(${ik}$), intent(out) :: info
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: tau(*), work(*)
     end subroutine stdlib${ii}$_zgehrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$gehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, lwork, n
           integer(${ik}$), intent(out) :: info
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: tau(*), work(*)
     end subroutine stdlib${ii}$_${ci}$gehrd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sgehd2( n, ilo, ihi, a, lda, tau, work, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: tau(*), work(*)
     end subroutine stdlib${ii}$_sgehd2

     pure module subroutine stdlib${ii}$_dgehd2( n, ilo, ihi, a, lda, tau, work, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: tau(*), work(*)
     end subroutine stdlib${ii}$_dgehd2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$gehd2( n, ilo, ihi, a, lda, tau, work, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
     end subroutine stdlib${ii}$_${ri}$gehd2

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cgehd2( n, ilo, ihi, a, lda, tau, work, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, n
           integer(${ik}$), intent(out) :: info
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
     end subroutine stdlib${ii}$_cgehd2

     pure module subroutine stdlib${ii}$_zgehd2( n, ilo, ihi, a, lda, tau, work, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, n
           integer(${ik}$), intent(out) :: info
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: tau(*), work(*)
     end subroutine stdlib${ii}$_zgehd2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$gehd2( n, ilo, ihi, a, lda, tau, work, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, n
           integer(${ik}$), intent(out) :: info
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: tau(*), work(*)
     end subroutine stdlib${ii}$_${ci}$gehd2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
           character, intent(in) :: job, side
           integer(${ik}$), intent(in) :: ihi, ilo, ldv, m, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(inout) :: v(ldv,*)
           real(sp), intent(in) :: scale(*)
     end subroutine stdlib${ii}$_sgebak

     pure module subroutine stdlib${ii}$_dgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
           character, intent(in) :: job, side
           integer(${ik}$), intent(in) :: ihi, ilo, ldv, m, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(in) :: scale(*)
           real(dp), intent(inout) :: v(ldv,*)
     end subroutine stdlib${ii}$_dgebak

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$gebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
           character, intent(in) :: job, side
           integer(${ik}$), intent(in) :: ihi, ilo, ldv, m, n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(in) :: scale(*)
           real(${rk}$), intent(inout) :: v(ldv,*)
     end subroutine stdlib${ii}$_${ri}$gebak

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
           character, intent(in) :: job, side
           integer(${ik}$), intent(in) :: ihi, ilo, ldv, m, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(in) :: scale(*)
           complex(sp), intent(inout) :: v(ldv,*)
     end subroutine stdlib${ii}$_cgebak

     pure module subroutine stdlib${ii}$_zgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
           character, intent(in) :: job, side
           integer(${ik}$), intent(in) :: ihi, ilo, ldv, m, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(in) :: scale(*)
           complex(dp), intent(inout) :: v(ldv,*)
     end subroutine stdlib${ii}$_zgebak

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$gebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
           character, intent(in) :: job, side
           integer(${ik}$), intent(in) :: ihi, ilo, ldv, m, n
           integer(${ik}$), intent(out) :: info
           real(${ck}$), intent(in) :: scale(*)
           complex(${ck}$), intent(inout) :: v(ldv,*)
     end subroutine stdlib${ii}$_${ci}$gebak

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
           integer(${ik}$), intent(in) :: k, lda, ldt, ldy, n, nb
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
     end subroutine stdlib${ii}$_slahr2

     pure module subroutine stdlib${ii}$_dlahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
           integer(${ik}$), intent(in) :: k, lda, ldt, ldy, n, nb
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
     end subroutine stdlib${ii}$_dlahr2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
           integer(${ik}$), intent(in) :: k, lda, ldt, ldy, n, nb
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
     end subroutine stdlib${ii}$_${ri}$lahr2

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_clahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
           integer(${ik}$), intent(in) :: k, lda, ldt, ldy, n, nb
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
     end subroutine stdlib${ii}$_clahr2

     pure module subroutine stdlib${ii}$_zlahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
           integer(${ik}$), intent(in) :: k, lda, ldt, ldy, n, nb
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
     end subroutine stdlib${ii}$_zlahr2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$lahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
           integer(${ik}$), intent(in) :: k, lda, ldt, ldy, n, nb
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
     end subroutine stdlib${ii}$_${ci}$lahr2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_cunghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, lwork, n
           integer(${ik}$), intent(out) :: info
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_cunghr

     pure module subroutine stdlib${ii}$_zunghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, lwork, n
           integer(${ik}$), intent(out) :: info
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(in) :: tau(*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zunghr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$unghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, lwork, n
           integer(${ik}$), intent(out) :: info
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(in) :: tau(*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$unghr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_cunmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
               info )
           character, intent(in) :: side, trans
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(${ik}$), intent(out) :: info
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_cunmhr

     pure module subroutine stdlib${ii}$_zunmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
               info )
           character, intent(in) :: side, trans
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(${ik}$), intent(out) :: info
           complex(dp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(dp), intent(in) :: tau(*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zunmhr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$unmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
               info )
           character, intent(in) :: side, trans
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(${ik}$), intent(out) :: info
           complex(${ck}$), intent(inout) :: a(lda,*), c(ldc,*)
           complex(${ck}$), intent(in) :: tau(*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$unmhr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sorghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, lwork, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(in) :: tau(*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_sorghr

     pure module subroutine stdlib${ii}$_dorghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, lwork, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(in) :: tau(*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dorghr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$orghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
           integer(${ik}$), intent(in) :: ihi, ilo, lda, lwork, n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$orghr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
               info )
           character, intent(in) :: side, trans
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(inout) :: a(lda,*), c(ldc,*)
           real(sp), intent(in) :: tau(*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_sormhr

     pure module subroutine stdlib${ii}$_dormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
               info )
           character, intent(in) :: side, trans
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(inout) :: a(lda,*), c(ldc,*)
           real(dp), intent(in) :: tau(*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dormhr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$ormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
               info )
           character, intent(in) :: side, trans
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$ormhr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_shseqr( job, compz, n, ilo, ihi, h, ldh, wr, wi, z,ldz, work, lwork, info )
               
           integer(${ik}$), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           character, intent(in) :: compz, job
           real(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(sp), intent(out) :: wi(*), work(*), wr(*)
     end subroutine stdlib${ii}$_shseqr

     module subroutine stdlib${ii}$_dhseqr( job, compz, n, ilo, ihi, h, ldh, wr, wi, z,ldz, work, lwork, info )
               
           integer(${ik}$), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           character, intent(in) :: compz, job
           real(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(dp), intent(out) :: wi(*), work(*), wr(*)
     end subroutine stdlib${ii}$_dhseqr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$hseqr( job, compz, n, ilo, ihi, h, ldh, wr, wi, z,ldz, work, lwork, info )
               
           integer(${ik}$), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           character, intent(in) :: compz, job
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: wi(*), work(*), wr(*)
     end subroutine stdlib${ii}$_${ri}$hseqr

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_chseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,work, lwork, info )
               
           integer(${ik}$), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           character, intent(in) :: compz, job
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_chseqr

     pure module subroutine stdlib${ii}$_zhseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,work, lwork, info )
               
           integer(${ik}$), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           character, intent(in) :: compz, job
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_zhseqr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$hseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,work, lwork, info )
               
           integer(${ik}$), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           character, intent(in) :: compz, job
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_${ci}$hseqr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_shsein( side, eigsrc, initv, select, n, h, ldh, wr, wi,vl, ldvl, vr, ldvr, &
               mm, m, work, ifaill,ifailr, info )
           character, intent(in) :: eigsrc, initv, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldh, ldvl, ldvr, mm, n
           logical(lk), intent(inout) :: select(*)
           integer(${ik}$), intent(out) :: ifaill(*), ifailr(*)
           real(sp), intent(in) :: h(ldh,*), wi(*)
           real(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*), wr(*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_shsein

     module subroutine stdlib${ii}$_dhsein( side, eigsrc, initv, select, n, h, ldh, wr, wi,vl, ldvl, vr, ldvr, &
               mm, m, work, ifaill,ifailr, info )
           character, intent(in) :: eigsrc, initv, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldh, ldvl, ldvr, mm, n
           logical(lk), intent(inout) :: select(*)
           integer(${ik}$), intent(out) :: ifaill(*), ifailr(*)
           real(dp), intent(in) :: h(ldh,*), wi(*)
           real(dp), intent(inout) :: vl(ldvl,*), vr(ldvr,*), wr(*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dhsein

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$hsein( side, eigsrc, initv, select, n, h, ldh, wr, wi,vl, ldvl, vr, ldvr, &
               mm, m, work, ifaill,ifailr, info )
           character, intent(in) :: eigsrc, initv, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldh, ldvl, ldvr, mm, n
           logical(lk), intent(inout) :: select(*)
           integer(${ik}$), intent(out) :: ifaill(*), ifailr(*)
           real(${rk}$), intent(in) :: h(ldh,*), wi(*)
           real(${rk}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*), wr(*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$hsein

#:endif
#:endfor

     module subroutine stdlib${ii}$_chsein( side, eigsrc, initv, select, n, h, ldh, w, vl,ldvl, vr, ldvr, mm, &
               m, work, rwork, ifaill,ifailr, info )
           character, intent(in) :: eigsrc, initv, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldh, ldvl, ldvr, mm, n
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: ifaill(*), ifailr(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(in) :: h(ldh,*)
           complex(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*), w(*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_chsein

     module subroutine stdlib${ii}$_zhsein( side, eigsrc, initv, select, n, h, ldh, w, vl,ldvl, vr, ldvr, mm, &
               m, work, rwork, ifaill,ifailr, info )
           character, intent(in) :: eigsrc, initv, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldh, ldvl, ldvr, mm, n
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: ifaill(*), ifailr(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(in) :: h(ldh,*)
           complex(dp), intent(inout) :: vl(ldvl,*), vr(ldvr,*), w(*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zhsein

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$hsein( side, eigsrc, initv, select, n, h, ldh, w, vl,ldvl, vr, ldvr, mm, &
               m, work, rwork, ifaill,ifailr, info )
           character, intent(in) :: eigsrc, initv, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldh, ldvl, ldvr, mm, n
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: ifaill(*), ifailr(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(in) :: h(ldh,*)
           complex(${ck}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*), w(*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$hsein

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_strevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
               work, info )
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, mm, n
           logical(lk), intent(inout) :: select(*)
           real(sp), intent(in) :: t(ldt,*)
           real(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_strevc

     pure module subroutine stdlib${ii}$_dtrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
               work, info )
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, mm, n
           logical(lk), intent(inout) :: select(*)
           real(dp), intent(in) :: t(ldt,*)
           real(dp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dtrevc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$trevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
               work, info )
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, mm, n
           logical(lk), intent(inout) :: select(*)
           real(${rk}$), intent(in) :: t(ldt,*)
           real(${rk}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$trevc

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_ctrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
               work, rwork, info )
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, mm, n
           logical(lk), intent(in) :: select(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_ctrevc

     pure module subroutine stdlib${ii}$_ztrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
               work, rwork, info )
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, mm, n
           logical(lk), intent(in) :: select(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_ztrevc

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$trevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
               work, rwork, info )
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, mm, n
           logical(lk), intent(in) :: select(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$trevc

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_strevc3( side, howmny, select, n, t, ldt, vl, ldvl,vr, ldvr, mm, m, &
               work, lwork, info )
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, lwork, mm, n
           logical(lk), intent(inout) :: select(*)
           real(sp), intent(in) :: t(ldt,*)
           real(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_strevc3

     pure module subroutine stdlib${ii}$_dtrevc3( side, howmny, select, n, t, ldt, vl, ldvl,vr, ldvr, mm, m, &
               work, lwork, info )
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, lwork, mm, n
           logical(lk), intent(inout) :: select(*)
           real(dp), intent(in) :: t(ldt,*)
           real(dp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dtrevc3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$trevc3( side, howmny, select, n, t, ldt, vl, ldvl,vr, ldvr, mm, m, &
               work, lwork, info )
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, lwork, mm, n
           logical(lk), intent(inout) :: select(*)
           real(${rk}$), intent(in) :: t(ldt,*)
           real(${rk}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$trevc3

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_ctrevc3( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
               work, lwork, rwork, lrwork, info)
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, lwork, lrwork, mm, n
           logical(lk), intent(in) :: select(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_ctrevc3

     pure module subroutine stdlib${ii}$_ztrevc3( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
               work, lwork, rwork, lrwork, info)
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, lwork, lrwork, mm, n
           logical(lk), intent(in) :: select(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_ztrevc3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$trevc3( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
               work, lwork, rwork, lrwork, info)
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, lwork, lrwork, mm, n
           logical(lk), intent(in) :: select(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$trevc3

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaln2( ltrans, na, nw, smin, ca, a, lda, d1, d2, b,ldb, wr, wi, x, &
               ldx, scale, xnorm, info )
           logical(lk), intent(in) :: ltrans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldx, na, nw
           real(sp), intent(in) :: ca, d1, d2, smin, wi, wr
           real(sp), intent(out) :: scale, xnorm
           real(sp), intent(in) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: x(ldx,*)
     end subroutine stdlib${ii}$_slaln2

     pure module subroutine stdlib${ii}$_dlaln2( ltrans, na, nw, smin, ca, a, lda, d1, d2, b,ldb, wr, wi, x, &
               ldx, scale, xnorm, info )
           logical(lk), intent(in) :: ltrans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldx, na, nw
           real(dp), intent(in) :: ca, d1, d2, smin, wi, wr
           real(dp), intent(out) :: scale, xnorm
           real(dp), intent(in) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: x(ldx,*)
     end subroutine stdlib${ii}$_dlaln2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laln2( ltrans, na, nw, smin, ca, a, lda, d1, d2, b,ldb, wr, wi, x, &
               ldx, scale, xnorm, info )
           logical(lk), intent(in) :: ltrans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldx, na, nw
           real(${rk}$), intent(in) :: ca, d1, d2, smin, wi, wr
           real(${rk}$), intent(out) :: scale, xnorm
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: x(ldx,*)
     end subroutine stdlib${ii}$_${ri}$laln2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_strsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
               
           character, intent(in) :: trana, tranb
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: isgn, lda, ldb, ldc, m, n
           real(sp), intent(out) :: scale
           real(sp), intent(in) :: a(lda,*), b(ldb,*)
           real(sp), intent(inout) :: c(ldc,*)
     end subroutine stdlib${ii}$_strsyl

     module subroutine stdlib${ii}$_dtrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
               
           character, intent(in) :: trana, tranb
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: isgn, lda, ldb, ldc, m, n
           real(dp), intent(out) :: scale
           real(dp), intent(in) :: a(lda,*), b(ldb,*)
           real(dp), intent(inout) :: c(ldc,*)
     end subroutine stdlib${ii}$_dtrsyl

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$trsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
               
           character, intent(in) :: trana, tranb
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: isgn, lda, ldb, ldc, m, n
           real(${rk}$), intent(out) :: scale
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(inout) :: c(ldc,*)
     end subroutine stdlib${ii}$_${ri}$trsyl

#:endif
#:endfor

     module subroutine stdlib${ii}$_ctrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
               
           character, intent(in) :: trana, tranb
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: isgn, lda, ldb, ldc, m, n
           real(sp), intent(out) :: scale
           complex(sp), intent(in) :: a(lda,*), b(ldb,*)
           complex(sp), intent(inout) :: c(ldc,*)
     end subroutine stdlib${ii}$_ctrsyl

     module subroutine stdlib${ii}$_ztrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
               
           character, intent(in) :: trana, tranb
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: isgn, lda, ldb, ldc, m, n
           real(dp), intent(out) :: scale
           complex(dp), intent(in) :: a(lda,*), b(ldb,*)
           complex(dp), intent(inout) :: c(ldc,*)
     end subroutine stdlib${ii}$_ztrsyl

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$trsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
               
           character, intent(in) :: trana, tranb
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: isgn, lda, ldb, ldc, m, n
           real(${ck}$), intent(out) :: scale
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(inout) :: c(ldc,*)
     end subroutine stdlib${ii}$_${ci}$trsyl

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasy2( ltranl, ltranr, isgn, n1, n2, tl, ldtl, tr,ldtr, b, ldb, &
               scale, x, ldx, xnorm, info )
           logical(lk), intent(in) :: ltranl, ltranr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: isgn, ldb, ldtl, ldtr, ldx, n1, n2
           real(sp), intent(out) :: scale, xnorm
           real(sp), intent(in) :: b(ldb,*), tl(ldtl,*), tr(ldtr,*)
           real(sp), intent(out) :: x(ldx,*)
     end subroutine stdlib${ii}$_slasy2

     pure module subroutine stdlib${ii}$_dlasy2( ltranl, ltranr, isgn, n1, n2, tl, ldtl, tr,ldtr, b, ldb, &
               scale, x, ldx, xnorm, info )
           logical(lk), intent(in) :: ltranl, ltranr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: isgn, ldb, ldtl, ldtr, ldx, n1, n2
           real(dp), intent(out) :: scale, xnorm
           real(dp), intent(in) :: b(ldb,*), tl(ldtl,*), tr(ldtr,*)
           real(dp), intent(out) :: x(ldx,*)
     end subroutine stdlib${ii}$_dlasy2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasy2( ltranl, ltranr, isgn, n1, n2, tl, ldtl, tr,ldtr, b, ldb, &
               scale, x, ldx, xnorm, info )
           logical(lk), intent(in) :: ltranl, ltranr
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: isgn, ldb, ldtl, ldtr, ldx, n1, n2
           real(${rk}$), intent(out) :: scale, xnorm
           real(${rk}$), intent(in) :: b(ldb,*), tl(ldtl,*), tr(ldtr,*)
           real(${rk}$), intent(out) :: x(ldx,*)
     end subroutine stdlib${ii}$_${ri}$lasy2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_strsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm, m, &
               work, ldwork, iwork,info )
           character, intent(in) :: howmny, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(out) :: s(*), sep(*), work(ldwork,*)
           real(sp), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
     end subroutine stdlib${ii}$_strsna

     module subroutine stdlib${ii}$_dtrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm, m, &
               work, ldwork, iwork,info )
           character, intent(in) :: howmny, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(out) :: s(*), sep(*), work(ldwork,*)
           real(dp), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
     end subroutine stdlib${ii}$_dtrsna

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$trsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm, m, &
               work, ldwork, iwork,info )
           character, intent(in) :: howmny, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(out) :: s(*), sep(*), work(ldwork,*)
           real(${rk}$), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
     end subroutine stdlib${ii}$_${ri}$trsna

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_ctrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm,&
                m, work, ldwork, rwork,info )
           character, intent(in) :: howmny, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           logical(lk), intent(in) :: select(*)
           real(sp), intent(out) :: rwork(*), s(*), sep(*)
           complex(sp), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(ldwork,*)
     end subroutine stdlib${ii}$_ctrsna

     pure module subroutine stdlib${ii}$_ztrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm,&
                m, work, ldwork, rwork,info )
           character, intent(in) :: howmny, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           logical(lk), intent(in) :: select(*)
           real(dp), intent(out) :: rwork(*), s(*), sep(*)
           complex(dp), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(dp), intent(out) :: work(ldwork,*)
     end subroutine stdlib${ii}$_ztrsna

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$trsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm,&
                m, work, ldwork, rwork,info )
           character, intent(in) :: howmny, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           logical(lk), intent(in) :: select(*)
           real(${ck}$), intent(out) :: rwork(*), s(*), sep(*)
           complex(${ck}$), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(${ck}$), intent(out) :: work(ldwork,*)
     end subroutine stdlib${ii}$_${ci}$trsna

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_strexc( compq, n, t, ldt, q, ldq, ifst, ilst, work,info )
           character, intent(in) :: compq
           integer(${ik}$), intent(inout) :: ifst, ilst
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldq, ldt, n
           real(sp), intent(inout) :: q(ldq,*), t(ldt,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_strexc

     module subroutine stdlib${ii}$_dtrexc( compq, n, t, ldt, q, ldq, ifst, ilst, work,info )
           character, intent(in) :: compq
           integer(${ik}$), intent(inout) :: ifst, ilst
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldq, ldt, n
           real(dp), intent(inout) :: q(ldq,*), t(ldt,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dtrexc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$trexc( compq, n, t, ldt, q, ldq, ifst, ilst, work,info )
           character, intent(in) :: compq
           integer(${ik}$), intent(inout) :: ifst, ilst
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldq, ldt, n
           real(${rk}$), intent(inout) :: q(ldq,*), t(ldt,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$trexc

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_ctrexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
           character, intent(in) :: compq
           integer(${ik}$), intent(in) :: ifst, ilst, ldq, ldt, n
           integer(${ik}$), intent(out) :: info
           complex(sp), intent(inout) :: q(ldq,*), t(ldt,*)
     end subroutine stdlib${ii}$_ctrexc

     pure module subroutine stdlib${ii}$_ztrexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
           character, intent(in) :: compq
           integer(${ik}$), intent(in) :: ifst, ilst, ldq, ldt, n
           integer(${ik}$), intent(out) :: info
           complex(dp), intent(inout) :: q(ldq,*), t(ldt,*)
     end subroutine stdlib${ii}$_ztrexc

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$trexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
           character, intent(in) :: compq
           integer(${ik}$), intent(in) :: ifst, ilst, ldq, ldt, n
           integer(${ik}$), intent(out) :: info
           complex(${ck}$), intent(inout) :: q(ldq,*), t(ldt,*)
     end subroutine stdlib${ii}$_${ci}$trexc

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_strsen( job, compq, select, n, t, ldt, q, ldq, wr, wi,m, s, sep, work, &
               lwork, iwork, liwork, info )
           character, intent(in) :: compq, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldq, ldt, liwork, lwork, n
           real(sp), intent(out) :: s, sep
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: q(ldq,*), t(ldt,*)
           real(sp), intent(out) :: wi(*), work(*), wr(*)
     end subroutine stdlib${ii}$_strsen

     module subroutine stdlib${ii}$_dtrsen( job, compq, select, n, t, ldt, q, ldq, wr, wi,m, s, sep, work, &
               lwork, iwork, liwork, info )
           character, intent(in) :: compq, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldq, ldt, liwork, lwork, n
           real(dp), intent(out) :: s, sep
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: q(ldq,*), t(ldt,*)
           real(dp), intent(out) :: wi(*), work(*), wr(*)
     end subroutine stdlib${ii}$_dtrsen

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$trsen( job, compq, select, n, t, ldt, q, ldq, wr, wi,m, s, sep, work, &
               lwork, iwork, liwork, info )
           character, intent(in) :: compq, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldq, ldt, liwork, lwork, n
           real(${rk}$), intent(out) :: s, sep
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: q(ldq,*), t(ldt,*)
           real(${rk}$), intent(out) :: wi(*), work(*), wr(*)
     end subroutine stdlib${ii}$_${ri}$trsen

#:endif
#:endfor

     module subroutine stdlib${ii}$_ctrsen( job, compq, select, n, t, ldt, q, ldq, w, m, s,sep, work, lwork, &
               info )
           character, intent(in) :: compq, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldq, ldt, lwork, n
           real(sp), intent(out) :: s, sep
           logical(lk), intent(in) :: select(*)
           complex(sp), intent(inout) :: q(ldq,*), t(ldt,*)
           complex(sp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_ctrsen

     module subroutine stdlib${ii}$_ztrsen( job, compq, select, n, t, ldt, q, ldq, w, m, s,sep, work, lwork, &
               info )
           character, intent(in) :: compq, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldq, ldt, lwork, n
           real(dp), intent(out) :: s, sep
           logical(lk), intent(in) :: select(*)
           complex(dp), intent(inout) :: q(ldq,*), t(ldt,*)
           complex(dp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_ztrsen

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$trsen( job, compq, select, n, t, ldt, q, ldq, w, m, s,sep, work, lwork, &
               info )
           character, intent(in) :: compq, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldq, ldt, lwork, n
           real(${ck}$), intent(out) :: s, sep
           logical(lk), intent(in) :: select(*)
           complex(${ck}$), intent(inout) :: q(ldq,*), t(ldt,*)
           complex(${ck}$), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_${ci}$trsen

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_slaexc( wantq, n, t, ldt, q, ldq, j1, n1, n2, work,info )
           logical(lk), intent(in) :: wantq
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: j1, ldq, ldt, n, n1, n2
           real(sp), intent(inout) :: q(ldq,*), t(ldt,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_slaexc

     module subroutine stdlib${ii}$_dlaexc( wantq, n, t, ldt, q, ldq, j1, n1, n2, work,info )
           logical(lk), intent(in) :: wantq
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: j1, ldq, ldt, n, n1, n2
           real(dp), intent(inout) :: q(ldq,*), t(ldt,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dlaexc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$laexc( wantq, n, t, ldt, q, ldq, j1, n1, n2, work,info )
           logical(lk), intent(in) :: wantq
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: j1, ldq, ldt, n, n1, n2
           real(${rk}$), intent(inout) :: q(ldq,*), t(ldt,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$laexc

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slanv2( a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn )
           real(sp), intent(inout) :: a, b, c, d
           real(sp), intent(out) :: cs, rt1i, rt1r, rt2i, rt2r, sn
     end subroutine stdlib${ii}$_slanv2

     pure module subroutine stdlib${ii}$_dlanv2( a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn )
           real(dp), intent(inout) :: a, b, c, d
           real(dp), intent(out) :: cs, rt1i, rt1r, rt2i, rt2r, sn
     end subroutine stdlib${ii}$_dlanv2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lanv2( a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn )
           real(${rk}$), intent(inout) :: a, b, c, d
           real(${rk}$), intent(out) :: cs, rt1i, rt1r, rt2i, rt2r, sn
     end subroutine stdlib${ii}$_${ri}$lanv2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,ldb, work, eps3, &
               smlnum, bignum, info )
           logical(lk), intent(in) :: noinit, rightv
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldb, ldh, n
           real(sp), intent(in) :: bignum, eps3, smlnum, wi, wr
           real(sp), intent(out) :: b(ldb,*), work(*)
           real(sp), intent(in) :: h(ldh,*)
           real(sp), intent(inout) :: vi(*), vr(*)
     end subroutine stdlib${ii}$_slaein

     pure module subroutine stdlib${ii}$_dlaein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,ldb, work, eps3, &
               smlnum, bignum, info )
           logical(lk), intent(in) :: noinit, rightv
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldb, ldh, n
           real(dp), intent(in) :: bignum, eps3, smlnum, wi, wr
           real(dp), intent(out) :: b(ldb,*), work(*)
           real(dp), intent(in) :: h(ldh,*)
           real(dp), intent(inout) :: vi(*), vr(*)
     end subroutine stdlib${ii}$_dlaein

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,ldb, work, eps3, &
               smlnum, bignum, info )
           logical(lk), intent(in) :: noinit, rightv
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldb, ldh, n
           real(${rk}$), intent(in) :: bignum, eps3, smlnum, wi, wr
           real(${rk}$), intent(out) :: b(ldb,*), work(*)
           real(${rk}$), intent(in) :: h(ldh,*)
           real(${rk}$), intent(inout) :: vi(*), vr(*)
     end subroutine stdlib${ii}$_${ri}$laein

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_claein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,eps3, smlnum, &
               info )
           logical(lk), intent(in) :: noinit, rightv
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldb, ldh, n
           real(sp), intent(in) :: eps3, smlnum
           complex(sp), intent(in) :: w
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(out) :: b(ldb,*)
           complex(sp), intent(in) :: h(ldh,*)
           complex(sp), intent(inout) :: v(*)
     end subroutine stdlib${ii}$_claein

     pure module subroutine stdlib${ii}$_zlaein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,eps3, smlnum, &
               info )
           logical(lk), intent(in) :: noinit, rightv
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldb, ldh, n
           real(dp), intent(in) :: eps3, smlnum
           complex(dp), intent(in) :: w
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(out) :: b(ldb,*)
           complex(dp), intent(in) :: h(ldh,*)
           complex(dp), intent(inout) :: v(*)
     end subroutine stdlib${ii}$_zlaein

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$laein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,eps3, smlnum, &
               info )
           logical(lk), intent(in) :: noinit, rightv
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldb, ldh, n
           real(${ck}$), intent(in) :: eps3, smlnum
           complex(${ck}$), intent(in) :: w
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(out) :: b(ldb,*)
           complex(${ck}$), intent(in) :: h(ldh,*)
           complex(${ck}$), intent(inout) :: v(*)
     end subroutine stdlib${ii}$_${ci}$laein

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_slaqtr( ltran, lreal, n, t, ldt, b, w, scale, x, work,info )
           logical(lk), intent(in) :: lreal, ltran
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldt, n
           real(sp), intent(out) :: scale
           real(sp), intent(in) :: w
           real(sp), intent(in) :: b(*), t(ldt,*)
           real(sp), intent(out) :: work(*)
           real(sp), intent(inout) :: x(*)
     end subroutine stdlib${ii}$_slaqtr

     module subroutine stdlib${ii}$_dlaqtr( ltran, lreal, n, t, ldt, b, w, scale, x, work,info )
           logical(lk), intent(in) :: lreal, ltran
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldt, n
           real(dp), intent(out) :: scale
           real(dp), intent(in) :: w
           real(dp), intent(in) :: b(*), t(ldt,*)
           real(dp), intent(out) :: work(*)
           real(dp), intent(inout) :: x(*)
     end subroutine stdlib${ii}$_dlaqtr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$laqtr( ltran, lreal, n, t, ldt, b, w, scale, x, work,info )
           logical(lk), intent(in) :: lreal, ltran
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldt, n
           real(${rk}$), intent(out) :: scale
           real(${rk}$), intent(in) :: w
           real(${rk}$), intent(in) :: b(*), t(ldt,*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(inout) :: x(*)
     end subroutine stdlib${ii}$_${ri}$laqtr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
               info )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           real(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(sp), intent(out) :: wi(*), wr(*)
     end subroutine stdlib${ii}$_slahqr

     pure module subroutine stdlib${ii}$_dlahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
               info )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           real(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(dp), intent(out) :: wi(*), wr(*)
     end subroutine stdlib${ii}$_dlahqr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
               info )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: wi(*), wr(*)
     end subroutine stdlib${ii}$_${ri}$lahqr

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, info &
               )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: w(*)
     end subroutine stdlib${ii}$_clahqr

     pure module subroutine stdlib${ii}$_zlahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, info &
               )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: w(*)
     end subroutine stdlib${ii}$_zlahqr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, info &
               )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: w(*)
     end subroutine stdlib${ii}$_${ci}$lahqr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_slaqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, work,&
                lwork, info )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           real(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(sp), intent(out) :: wi(*), work(*), wr(*)
     end subroutine stdlib${ii}$_slaqr0

     module subroutine stdlib${ii}$_dlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, work,&
                lwork, info )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           real(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(dp), intent(out) :: wi(*), work(*), wr(*)
     end subroutine stdlib${ii}$_dlaqr0

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$laqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, work,&
                lwork, info )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: wi(*), work(*), wr(*)
     end subroutine stdlib${ii}$_${ri}$laqr0

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_claqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work,&
                lwork, info )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_claqr0

     pure module subroutine stdlib${ii}$_zlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work,&
                lwork, info )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_zlaqr0

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$laqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work,&
                lwork, info )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_${ci}$laqr0

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaqr1( n, h, ldh, sr1, si1, sr2, si2, v )
           real(sp), intent(in) :: si1, si2, sr1, sr2
           integer(${ik}$), intent(in) :: ldh, n
           real(sp), intent(in) :: h(ldh,*)
           real(sp), intent(out) :: v(*)
     end subroutine stdlib${ii}$_slaqr1

     pure module subroutine stdlib${ii}$_dlaqr1( n, h, ldh, sr1, si1, sr2, si2, v )
           real(dp), intent(in) :: si1, si2, sr1, sr2
           integer(${ik}$), intent(in) :: ldh, n
           real(dp), intent(in) :: h(ldh,*)
           real(dp), intent(out) :: v(*)
     end subroutine stdlib${ii}$_dlaqr1

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laqr1( n, h, ldh, sr1, si1, sr2, si2, v )
           real(${rk}$), intent(in) :: si1, si2, sr1, sr2
           integer(${ik}$), intent(in) :: ldh, n
           real(${rk}$), intent(in) :: h(ldh,*)
           real(${rk}$), intent(out) :: v(*)
     end subroutine stdlib${ii}$_${ri}$laqr1

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_claqr1( n, h, ldh, s1, s2, v )
           complex(sp), intent(in) :: s1, s2
           integer(${ik}$), intent(in) :: ldh, n
           complex(sp), intent(in) :: h(ldh,*)
           complex(sp), intent(out) :: v(*)
     end subroutine stdlib${ii}$_claqr1

     pure module subroutine stdlib${ii}$_zlaqr1( n, h, ldh, s1, s2, v )
           complex(dp), intent(in) :: s1, s2
           integer(${ik}$), intent(in) :: ldh, n
           complex(dp), intent(in) :: h(ldh,*)
           complex(dp), intent(out) :: v(*)
     end subroutine stdlib${ii}$_zlaqr1

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$laqr1( n, h, ldh, s1, s2, v )
           complex(${ck}$), intent(in) :: s1, s2
           integer(${ik}$), intent(in) :: ldh, n
           complex(${ck}$), intent(in) :: h(ldh,*)
           complex(${ck}$), intent(out) :: v(*)
     end subroutine stdlib${ii}$_${ci}$laqr1

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_slaqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, ns, nd,&
                sr, si, v, ldv, nh, t,ldt, nv, wv, ldwv, work, lwork )
           integer(${ik}$), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(${ik}$), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           real(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(sp), intent(out) :: si(*), sr(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
     end subroutine stdlib${ii}$_slaqr2

     module subroutine stdlib${ii}$_dlaqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, ns, nd,&
                sr, si, v, ldv, nh, t,ldt, nv, wv, ldwv, work, lwork )
           integer(${ik}$), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(${ik}$), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           real(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(dp), intent(out) :: si(*), sr(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
     end subroutine stdlib${ii}$_dlaqr2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$laqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, ns, nd,&
                sr, si, v, ldv, nh, t,ldt, nv, wv, ldwv, work, lwork )
           integer(${ik}$), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(${ik}$), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: si(*), sr(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
     end subroutine stdlib${ii}$_${ri}$laqr2

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_claqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
           integer(${ik}$), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(${ik}$), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
     end subroutine stdlib${ii}$_claqr2

     pure module subroutine stdlib${ii}$_zlaqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
           integer(${ik}$), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(${ik}$), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
     end subroutine stdlib${ii}$_zlaqr2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$laqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
           integer(${ik}$), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(${ik}$), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
     end subroutine stdlib${ii}$_${ci}$laqr2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_slaqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, ns, nd,&
                sr, si, v, ldv, nh, t,ldt, nv, wv, ldwv, work, lwork )
           integer(${ik}$), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(${ik}$), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           real(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(sp), intent(out) :: si(*), sr(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
     end subroutine stdlib${ii}$_slaqr3

     module subroutine stdlib${ii}$_dlaqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, ns, nd,&
                sr, si, v, ldv, nh, t,ldt, nv, wv, ldwv, work, lwork )
           integer(${ik}$), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(${ik}$), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           real(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(dp), intent(out) :: si(*), sr(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
     end subroutine stdlib${ii}$_dlaqr3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$laqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, ns, nd,&
                sr, si, v, ldv, nh, t,ldt, nv, wv, ldwv, work, lwork )
           integer(${ik}$), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(${ik}$), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: si(*), sr(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
     end subroutine stdlib${ii}$_${ri}$laqr3

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_claqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
           integer(${ik}$), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(${ik}$), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
     end subroutine stdlib${ii}$_claqr3

     pure module subroutine stdlib${ii}$_zlaqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
           integer(${ik}$), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(${ik}$), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
     end subroutine stdlib${ii}$_zlaqr3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$laqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
           integer(${ik}$), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(${ik}$), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
     end subroutine stdlib${ii}$_${ci}$laqr3

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_slaqr4( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, work,&
                lwork, info )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           real(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(sp), intent(out) :: wi(*), work(*), wr(*)
     end subroutine stdlib${ii}$_slaqr4

     module subroutine stdlib${ii}$_dlaqr4( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, work,&
                lwork, info )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           real(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(dp), intent(out) :: wi(*), work(*), wr(*)
     end subroutine stdlib${ii}$_dlaqr4

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$laqr4( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, work,&
                lwork, info )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: wi(*), work(*), wr(*)
     end subroutine stdlib${ii}$_${ri}$laqr4

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_claqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work,&
                lwork, info )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_claqr4

     pure module subroutine stdlib${ii}$_zlaqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work,&
                lwork, info )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_zlaqr4

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$laqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work,&
                lwork, info )
           integer(${ik}$), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_${ci}$laqr4

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,sr, si, h, ldh, &
               iloz, ihiz, z, ldz, v, ldv, u,ldu, nv, wv, ldwv, nh, wh, ldwh )
           integer(${ik}$), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           real(sp), intent(inout) :: h(ldh,*), si(*), sr(*), z(ldz,*)
           real(sp), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
     end subroutine stdlib${ii}$_slaqr5

     pure module subroutine stdlib${ii}$_dlaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,sr, si, h, ldh, &
               iloz, ihiz, z, ldz, v, ldv, u,ldu, nv, wv, ldwv, nh, wh, ldwh )
           integer(${ik}$), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           real(dp), intent(inout) :: h(ldh,*), si(*), sr(*), z(ldz,*)
           real(dp), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
     end subroutine stdlib${ii}$_dlaqr5

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,sr, si, h, ldh, &
               iloz, ihiz, z, ldz, v, ldv, u,ldu, nv, wv, ldwv, nh, wh, ldwh )
           integer(${ik}$), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           real(${rk}$), intent(inout) :: h(ldh,*), si(*), sr(*), z(ldz,*)
           real(${rk}$), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
     end subroutine stdlib${ii}$_${ri}$laqr5

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_claqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,h, ldh, iloz, &
               ihiz, z, ldz, v, ldv, u, ldu, nv,wv, ldwv, nh, wh, ldwh )
           integer(${ik}$), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           complex(sp), intent(inout) :: h(ldh,*), s(*), z(ldz,*)
           complex(sp), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
     end subroutine stdlib${ii}$_claqr5

     pure module subroutine stdlib${ii}$_zlaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,h, ldh, iloz, &
               ihiz, z, ldz, v, ldv, u, ldu, nv,wv, ldwv, nh, wh, ldwh )
           integer(${ik}$), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           complex(dp), intent(inout) :: h(ldh,*), s(*), z(ldz,*)
           complex(dp), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
     end subroutine stdlib${ii}$_zlaqr5

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$laqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,h, ldh, iloz, &
               ihiz, z, ldz, v, ldv, u, ldu, nv,wv, ldwv, nh, wh, ldwh )
           integer(${ik}$), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           complex(${ck}$), intent(inout) :: h(ldh,*), s(*), z(ldz,*)
           complex(${ck}$), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
     end subroutine stdlib${ii}$_${ci}$laqr5

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     recursive module subroutine stdlib${ii}$_slaqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, alphar, &
               alphai, beta,q, ldq, z, ldz, work, lwork, rec,info )
           character, intent( in ) :: wants, wantq, wantz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,rec
           integer(${ik}$), intent( out ) :: info
           real(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), alphar(&
                      * ), alphai( * ), beta( * ), work( * )
     end subroutine stdlib${ii}$_slaqz0

     recursive module subroutine stdlib${ii}$_dlaqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, alphar, &
               alphai, beta,q, ldq, z, ldz, work, lwork, rec,info )
           character, intent( in ) :: wants, wantq, wantz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,rec
           integer(${ik}$), intent( out ) :: info
           real(dp), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), alphar(&
                      * ),alphai( * ), beta( * ), work( * )
     end subroutine stdlib${ii}$_dlaqz0

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     recursive module subroutine stdlib${ii}$_${ri}$laqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, alphar, &
               alphai, beta,q, ldq, z, ldz, work, lwork, rec,info )
           character, intent( in ) :: wants, wantq, wantz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,rec
           integer(${ik}$), intent( out ) :: info
           real(${rk}$), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), alphar(&
                      * ),alphai( * ), beta( * ), work( * )
     end subroutine stdlib${ii}$_${ri}$laqz0

#:endif
#:endfor

     recursive module subroutine stdlib${ii}$_claqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, alpha, &
               beta, q, ldq, z,ldz, work, lwork, rwork, rec,info )
           character, intent( in ) :: wants, wantq, wantz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,rec
           integer(${ik}$), intent( out ) :: info
           complex(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), &
                     alpha( * ), beta( * ), work( * )
           real(sp), intent( out ) :: rwork( * )
           
     end subroutine stdlib${ii}$_claqz0

     recursive module subroutine stdlib${ii}$_zlaqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, alpha, &
               beta, q, ldq, z,ldz, work, lwork, rwork, rec,info )
           character, intent( in ) :: wants, wantq, wantz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,rec
           integer(${ik}$), intent( out ) :: info
           complex(dp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq,* ), z( ldz, * ), &
                     alpha( * ), beta( * ), work( * )
           real(dp), intent( out ) :: rwork( * )
           
     end subroutine stdlib${ii}$_zlaqz0

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     recursive module subroutine stdlib${ii}$_${ci}$laqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, alpha, &
               beta, q, ldq, z,ldz, work, lwork, rwork, rec,info )
           character, intent( in ) :: wants, wantq, wantz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,rec
           integer(${ik}$), intent( out ) :: info
           complex(${ck}$), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq,* ), z( ldz, * ), &
                     alpha( * ), beta( * ), work( * )
           real(${ck}$), intent( out ) :: rwork( * )
           
     end subroutine stdlib${ii}$_${ci}$laqz0

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaqz1( a, lda, b, ldb, sr1, sr2, si, beta1, beta2,v )
           integer(${ik}$), intent( in ) :: lda, ldb
           real(sp), intent( in ) :: a( lda, * ), b( ldb, * ), sr1, sr2, si,beta1, beta2
           real(sp), intent( out ) :: v( * )
     end subroutine stdlib${ii}$_slaqz1

     pure module subroutine stdlib${ii}$_dlaqz1( a, lda, b, ldb, sr1, sr2, si, beta1, beta2,v )
           integer(${ik}$), intent( in ) :: lda, ldb
           real(dp), intent( in ) :: a( lda, * ), b( ldb, * ), sr1,sr2, si, beta1, beta2
           real(dp), intent( out ) :: v( * )
     end subroutine stdlib${ii}$_dlaqz1

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laqz1( a, lda, b, ldb, sr1, sr2, si, beta1, beta2,v )
           integer(${ik}$), intent( in ) :: lda, ldb
           real(${rk}$), intent( in ) :: a( lda, * ), b( ldb, * ), sr1,sr2, si, beta1, beta2
           real(${rk}$), intent( out ) :: v( * )
     end subroutine stdlib${ii}$_${ri}$laqz1

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_claqz1( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
               q, ldq, nz, zstart, z, ldz )
           logical(lk), intent( in ) :: ilq, ilz
           integer(${ik}$), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           
     end subroutine stdlib${ii}$_claqz1

     pure module subroutine stdlib${ii}$_zlaqz1( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
               q, ldq, nz, zstart, z, ldz )
           logical(lk), intent( in ) :: ilq, ilz
           integer(${ik}$), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           
     end subroutine stdlib${ii}$_zlaqz1

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$laqz1( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
               q, ldq, nz, zstart, z, ldz )
           logical(lk), intent( in ) :: ilq, ilz
           integer(${ik}$), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$laqz1

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaqz2( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
               q, ldq, nz, zstart, z, ldz )
           logical(lk), intent( in ) :: ilq, ilz
           integer(${ik}$), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
     end subroutine stdlib${ii}$_slaqz2

     pure module subroutine stdlib${ii}$_dlaqz2( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
               q, ldq, nz, zstart, z, ldz )
           logical(lk), intent( in ) :: ilq, ilz
           integer(${ik}$), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
     end subroutine stdlib${ii}$_dlaqz2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laqz2( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
               q, ldq, nz, zstart, z, ldz )
           logical(lk), intent( in ) :: ilq, ilz
           integer(${ik}$), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$laqz2

#:endif
#:endfor

     recursive module subroutine stdlib${ii}$_claqz2( ilschur, ilq, ilz, n, ilo, ihi, nw,a, lda, b, ldb, q, &
               ldq, z, ldz, ns,nd, alpha, beta, qc, ldqc, zc, ldzc,work, lwork, rwork, rec, info )
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, nw, lda, ldb, ldq, ldz,ldqc, ldzc, lwork, &
                     rec
           complex(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), &
                     alpha( * ), beta( * )
           integer(${ik}$), intent( out ) :: ns, nd, info
           complex(sp), intent(inout) :: qc(ldqc,*), zc(ldzc,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(out) :: rwork(*)
           
     end subroutine stdlib${ii}$_claqz2

     recursive module subroutine stdlib${ii}$_zlaqz2( ilschur, ilq, ilz, n, ilo, ihi, nw,a, lda, b, ldb, q, &
               ldq, z, ldz, ns,nd, alpha, beta, qc, ldqc, zc, ldzc,work, lwork, rwork, rec, info )
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, nw, lda, ldb, ldq, ldz,ldqc, ldzc, lwork, &
                     rec
           complex(dp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq,* ), z( ldz, * ), &
                     alpha( * ), beta( * )
           integer(${ik}$), intent( out ) :: ns, nd, info
           complex(dp), intent(inout) :: qc(ldqc,*), zc(ldzc,*)
           complex(dp), intent(out) :: work(*)
           real(dp), intent(out) :: rwork(*)
           
     end subroutine stdlib${ii}$_zlaqz2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     recursive module subroutine stdlib${ii}$_${ci}$laqz2( ilschur, ilq, ilz, n, ilo, ihi, nw,a, lda, b, ldb, q, &
               ldq, z, ldz, ns,nd, alpha, beta, qc, ldqc, zc, ldzc,work, lwork, rwork, rec, info )
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, nw, lda, ldb, ldq, ldz,ldqc, ldzc, lwork, &
                     rec
           complex(${ck}$), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq,* ), z( ldz, * ), &
                     alpha( * ), beta( * )
           integer(${ik}$), intent( out ) :: ns, nd, info
           complex(${ck}$), intent(inout) :: qc(ldqc,*), zc(ldzc,*)
           complex(${ck}$), intent(out) :: work(*)
           real(${ck}$), intent(out) :: rwork(*)
           
     end subroutine stdlib${ii}$_${ci}$laqz2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     recursive module subroutine stdlib${ii}$_slaqz3( ilschur, ilq, ilz, n, ilo, ihi, nw,a, lda, b, ldb, q, &
               ldq, z, ldz, ns,nd, alphar, alphai, beta, qc, ldqc,zc, ldzc, work, lwork, rec, info )
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, nw, lda, ldb, ldq, ldz,ldqc, ldzc, lwork, &
                     rec
           real(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), alphar(&
                      * ), alphai( * ), beta( * )
           integer(${ik}$), intent( out ) :: ns, nd, info
           real(sp), intent(inout) :: qc(ldqc,*), zc(ldzc,*)
           real(sp), intent(out) :: work(*)
           
     end subroutine stdlib${ii}$_slaqz3

     recursive module subroutine stdlib${ii}$_dlaqz3( ilschur, ilq, ilz, n, ilo, ihi, nw,a, lda, b, ldb, q, &
               ldq, z, ldz, ns,nd, alphar, alphai, beta, qc, ldqc,zc, ldzc, work, lwork, rec, info )
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, nw, lda, ldb, ldq, ldz,ldqc, ldzc, lwork, &
                     rec
           real(dp), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), alphar(&
                      * ),alphai( * ), beta( * )
           integer(${ik}$), intent( out ) :: ns, nd, info
           real(dp), intent(inout) :: qc(ldqc,*), zc(ldzc,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dlaqz3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     recursive module subroutine stdlib${ii}$_${ri}$laqz3( ilschur, ilq, ilz, n, ilo, ihi, nw,a, lda, b, ldb, q, &
               ldq, z, ldz, ns,nd, alphar, alphai, beta, qc, ldqc,zc, ldzc, work, lwork, rec, info )
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, nw, lda, ldb, ldq, ldz,ldqc, ldzc, lwork, &
                     rec
           real(${rk}$), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), alphar(&
                      * ),alphai( * ), beta( * )
           integer(${ik}$), intent( out ) :: ns, nd, info
           real(${rk}$), intent(inout) :: qc(ldqc,*), zc(ldzc,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$laqz3

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_claqz3( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, alpha,&
                beta, a, lda, b, ldb,q, ldq, z, ldz, qc, ldqc, zc, ldzc, work,lwork, info )
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_desired, ldqc, ldzc
           complex(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), qc( &
                     ldqc, * ), zc( ldzc, * ), work( * ),alpha( * ), beta( * )
           integer(${ik}$), intent( out ) :: info
           
     end subroutine stdlib${ii}$_claqz3

     pure module subroutine stdlib${ii}$_zlaqz3( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, alpha,&
                beta, a, lda, b, ldb,q, ldq, z, ldz, qc, ldqc, zc, ldzc, work,lwork, info )
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_desired, ldqc, ldzc
           complex(dp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq,* ), z( ldz, * ), qc( &
                     ldqc, * ), zc( ldzc, * ), work( * ),alpha( * ), beta( * )
           integer(${ik}$), intent( out ) :: info
           
     end subroutine stdlib${ii}$_zlaqz3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$laqz3( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_qesired, alpha,&
                beta, a, lda, b, ldb,q, ldq, z, ldz, qc, ldqc, zc, ldzc, work,lwork, info )
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_qesired, ldqc, ldzc
           complex(${ck}$), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq,* ), z( ldz, * ), qc( &
                     ldqc, * ), zc( ldzc, * ), work( * ),alpha( * ), beta( * )
           integer(${ik}$), intent( out ) :: info
           
     end subroutine stdlib${ii}$_${ci}$laqz3

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaqz4( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, sr, &
               si, ss, a, lda, b, ldb, q,ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork,info )
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_desired, ldqc, ldzc
           real(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), qc( &
                     ldqc, * ), zc( ldzc, * ), work( * ), sr( * ),si( * ), ss( * )
           integer(${ik}$), intent( out ) :: info
     end subroutine stdlib${ii}$_slaqz4

     pure module subroutine stdlib${ii}$_dlaqz4( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, sr, &
               si, ss, a, lda, b, ldb, q,ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork,info )
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_desired, ldqc, ldzc
           real(dp), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), qc( &
                     ldqc, * ),zc( ldzc, * ), work( * ), sr( * ), si( * ),ss( * )
           integer(${ik}$), intent( out ) :: info
     end subroutine stdlib${ii}$_dlaqz4

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laqz4( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_qesired, sr, &
               si, ss, a, lda, b, ldb, q,ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork,info )
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(${ik}$), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_qesired, ldqc, ldzc
           real(${rk}$), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), qc( &
                     ldqc, * ),zc( ldzc, * ), work( * ), sr( * ), si( * ),ss( * )
           integer(${ik}$), intent( out ) :: info
     end subroutine stdlib${ii}$_${ri}$laqz4

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
               
           character, intent(in) :: job
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldb, n
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: lscale(*), rscale(*), work(*)
     end subroutine stdlib${ii}$_sggbal

     pure module subroutine stdlib${ii}$_dggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
               
           character, intent(in) :: job
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldb, n
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: lscale(*), rscale(*), work(*)
     end subroutine stdlib${ii}$_dggbal

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$ggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
               
           character, intent(in) :: job
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldb, n
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: lscale(*), rscale(*), work(*)
     end subroutine stdlib${ii}$_${ri}$ggbal

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
               
           character, intent(in) :: job
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldb, n
           real(sp), intent(out) :: lscale(*), rscale(*), work(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
     end subroutine stdlib${ii}$_cggbal

     pure module subroutine stdlib${ii}$_zggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
               
           character, intent(in) :: job
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldb, n
           real(dp), intent(out) :: lscale(*), rscale(*), work(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
     end subroutine stdlib${ii}$_zggbal

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$ggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
               
           character, intent(in) :: job
           integer(${ik}$), intent(out) :: ihi, ilo, info
           integer(${ik}$), intent(in) :: lda, ldb, n
           real(${ck}$), intent(out) :: lscale(*), rscale(*), work(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
     end subroutine stdlib${ii}$_${ci}$ggbal

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
               info )
           character, intent(in) :: compq, compz
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
     end subroutine stdlib${ii}$_sgghrd

     pure module subroutine stdlib${ii}$_dgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
               info )
           character, intent(in) :: compq, compz
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
     end subroutine stdlib${ii}$_dgghrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$gghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
               info )
           character, intent(in) :: compq, compz
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$gghrd

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
               info )
           character, intent(in) :: compq, compz
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(${ik}$), intent(out) :: info
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
     end subroutine stdlib${ii}$_cgghrd

     pure module subroutine stdlib${ii}$_zgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
               info )
           character, intent(in) :: compq, compz
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(${ik}$), intent(out) :: info
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
     end subroutine stdlib${ii}$_zgghrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$gghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
               info )
           character, intent(in) :: compq, compz
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(${ik}$), intent(out) :: info
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$gghrd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
               work, lwork, info )
           character, intent(in) :: compq, compz
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(${ik}$), intent(out) :: info
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_sgghd3

     pure module subroutine stdlib${ii}$_dgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
               work, lwork, info )
           character, intent(in) :: compq, compz
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(${ik}$), intent(out) :: info
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dgghd3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$gghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
               work, lwork, info )
           character, intent(in) :: compq, compz
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$gghd3

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
               work, lwork, info )
           character, intent(in) :: compq, compz
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(${ik}$), intent(out) :: info
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_cgghd3

     pure module subroutine stdlib${ii}$_zgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
               work, lwork, info )
           character, intent(in) :: compq, compz
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(${ik}$), intent(out) :: info
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zgghd3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$gghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
               work, lwork, info )
           character, intent(in) :: compq, compz
           integer(${ik}$), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(${ik}$), intent(out) :: info
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$gghd3

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_shgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alphar, alphai, &
               beta, q, ldq, z, ldz, work,lwork, info )
           character, intent(in) :: compq, compz, job
           integer(${ik}$), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), work(*)
           real(sp), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
     end subroutine stdlib${ii}$_shgeqz

     module subroutine stdlib${ii}$_dhgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alphar, alphai, &
               beta, q, ldq, z, ldz, work,lwork, info )
           character, intent(in) :: compq, compz, job
           integer(${ik}$), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), work(*)
           real(dp), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
     end subroutine stdlib${ii}$_dhgeqz

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$hgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alphar, alphai, &
               beta, q, ldq, z, ldz, work,lwork, info )
           character, intent(in) :: compq, compz, job
           integer(${ik}$), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), work(*)
           real(${rk}$), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$hgeqz

#:endif
#:endfor

     module subroutine stdlib${ii}$_chgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alpha, beta, q, ldq,&
                z, ldz, work, lwork,rwork, info )
           character, intent(in) :: compq, compz, job
           integer(${ik}$), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(out) :: alpha(*), beta(*), work(*)
           complex(sp), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
     end subroutine stdlib${ii}$_chgeqz

     module subroutine stdlib${ii}$_zhgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alpha, beta, q, ldq,&
                z, ldz, work, lwork,rwork, info )
           character, intent(in) :: compq, compz, job
           integer(${ik}$), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(out) :: alpha(*), beta(*), work(*)
           complex(dp), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
     end subroutine stdlib${ii}$_zhgeqz

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$hgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alpha, beta, q, ldq,&
                z, ldz, work, lwork,rwork, info )
           character, intent(in) :: compq, compz, job
           integer(${ik}$), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(${ik}$), intent(out) :: info
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), work(*)
           complex(${ck}$), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$hgeqz

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
               
           character, intent(in) :: job, side
           integer(${ik}$), intent(in) :: ihi, ilo, ldv, m, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(in) :: lscale(*), rscale(*)
           real(sp), intent(inout) :: v(ldv,*)
     end subroutine stdlib${ii}$_sggbak

     pure module subroutine stdlib${ii}$_dggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
               
           character, intent(in) :: job, side
           integer(${ik}$), intent(in) :: ihi, ilo, ldv, m, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(in) :: lscale(*), rscale(*)
           real(dp), intent(inout) :: v(ldv,*)
     end subroutine stdlib${ii}$_dggbak

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$ggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
               
           character, intent(in) :: job, side
           integer(${ik}$), intent(in) :: ihi, ilo, ldv, m, n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(in) :: lscale(*), rscale(*)
           real(${rk}$), intent(inout) :: v(ldv,*)
     end subroutine stdlib${ii}$_${ri}$ggbak

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
               
           character, intent(in) :: job, side
           integer(${ik}$), intent(in) :: ihi, ilo, ldv, m, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(in) :: lscale(*), rscale(*)
           complex(sp), intent(inout) :: v(ldv,*)
     end subroutine stdlib${ii}$_cggbak

     pure module subroutine stdlib${ii}$_zggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
               
           character, intent(in) :: job, side
           integer(${ik}$), intent(in) :: ihi, ilo, ldv, m, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(in) :: lscale(*), rscale(*)
           complex(dp), intent(inout) :: v(ldv,*)
     end subroutine stdlib${ii}$_zggbak

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$ggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
               
           character, intent(in) :: job, side
           integer(${ik}$), intent(in) :: ihi, ilo, ldv, m, n
           integer(${ik}$), intent(out) :: info
           real(${ck}$), intent(in) :: lscale(*), rscale(*)
           complex(${ck}$), intent(inout) :: v(ldv,*)
     end subroutine stdlib${ii}$_${ci}$ggbak

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_stgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alphar, alphai, &
               beta, q, ldq, z, ldz, m, pl,pr, dif, work, lwork, iwork, liwork, info )
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(out) :: pl, pr
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), dif(*), work(*)
     end subroutine stdlib${ii}$_stgsen

     pure module subroutine stdlib${ii}$_dtgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alphar, alphai, &
               beta, q, ldq, z, ldz, m, pl,pr, dif, work, lwork, iwork, liwork, info )
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(out) :: pl, pr
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), dif(*), work(*)
     end subroutine stdlib${ii}$_dtgsen

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$tgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alphar, alphai, &
               beta, q, ldq, z, ldz, m, pl,pr, dif, work, lwork, iwork, liwork, info )
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(${rk}$), intent(out) :: pl, pr
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), dif(*), work(*)
     end subroutine stdlib${ii}$_${ri}$tgsen

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_ctgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alpha, beta, q, &
               ldq, z, ldz, m, pl, pr, dif,work, lwork, iwork, liwork, info )
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(out) :: pl, pr
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(out) :: dif(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(sp), intent(out) :: alpha(*), beta(*), work(*)
     end subroutine stdlib${ii}$_ctgsen

     pure module subroutine stdlib${ii}$_ztgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alpha, beta, q, &
               ldq, z, ldz, m, pl, pr, dif,work, lwork, iwork, liwork, info )
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(out) :: pl, pr
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(out) :: dif(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(dp), intent(out) :: alpha(*), beta(*), work(*)
     end subroutine stdlib${ii}$_ztgsen

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$tgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alpha, beta, q, &
               ldq, z, ldz, m, pl, pr, dif,work, lwork, iwork, liwork, info )
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(${ck}$), intent(out) :: pl, pr
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: dif(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), work(*)
     end subroutine stdlib${ii}$_${ci}$tgsen

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_stgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
               dif, mm, m, work, lwork,iwork, info )
           character, intent(in) :: howmny, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           real(sp), intent(out) :: dif(*), s(*), work(*)
     end subroutine stdlib${ii}$_stgsna

     pure module subroutine stdlib${ii}$_dtgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
               dif, mm, m, work, lwork,iwork, info )
           character, intent(in) :: howmny, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           real(dp), intent(out) :: dif(*), s(*), work(*)
     end subroutine stdlib${ii}$_dtgsna

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$tgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
               dif, mm, m, work, lwork,iwork, info )
           character, intent(in) :: howmny, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           real(${rk}$), intent(out) :: dif(*), s(*), work(*)
     end subroutine stdlib${ii}$_${ri}$tgsna

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_ctgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
               dif, mm, m, work, lwork,iwork, info )
           character, intent(in) :: howmny, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(out) :: dif(*), s(*)
           complex(sp), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_ctgsna

     pure module subroutine stdlib${ii}$_ztgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
               dif, mm, m, work, lwork,iwork, info )
           character, intent(in) :: howmny, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(out) :: dif(*), s(*)
           complex(dp), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_ztgsna

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$tgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
               dif, mm, m, work, lwork,iwork, info )
           character, intent(in) :: howmny, job
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           logical(lk), intent(in) :: select(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: dif(*), s(*)
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$tgsna

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_stgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
               ldf, scale, dif, work, lwork,iwork, info )
           character, intent(in) :: trans
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(out) :: dif, scale
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(sp), intent(inout) :: c(ldc,*), f(ldf,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_stgsyl

     pure module subroutine stdlib${ii}$_dtgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
               ldf, scale, dif, work, lwork,iwork, info )
           character, intent(in) :: trans
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(out) :: dif, scale
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(dp), intent(inout) :: c(ldc,*), f(ldf,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dtgsyl

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$tgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
               ldf, scale, dif, work, lwork,iwork, info )
           character, intent(in) :: trans
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(out) :: dif, scale
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(${rk}$), intent(inout) :: c(ldc,*), f(ldf,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$tgsyl

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_ctgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
               ldf, scale, dif, work, lwork,iwork, info )
           character, intent(in) :: trans
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(out) :: dif, scale
           integer(${ik}$), intent(out) :: iwork(*)
           complex(sp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(sp), intent(inout) :: c(ldc,*), f(ldf,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_ctgsyl

     pure module subroutine stdlib${ii}$_ztgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
               ldf, scale, dif, work, lwork,iwork, info )
           character, intent(in) :: trans
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(out) :: dif, scale
           integer(${ik}$), intent(out) :: iwork(*)
           complex(dp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(dp), intent(inout) :: c(ldc,*), f(ldf,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_ztgsyl

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$tgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
               ldf, scale, dif, work, lwork,iwork, info )
           character, intent(in) :: trans
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(${ik}$), intent(out) :: info
           real(${ck}$), intent(out) :: dif, scale
           integer(${ik}$), intent(out) :: iwork(*)
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(${ck}$), intent(inout) :: c(ldc,*), f(ldf,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$tgsyl

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_stgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
               ldf, scale, rdsum, rdscal,iwork, pq, info )
           character, intent(in) :: trans
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(${ik}$), intent(out) :: info, pq
           real(sp), intent(inout) :: rdscal, rdsum
           real(sp), intent(out) :: scale
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(sp), intent(inout) :: c(ldc,*), f(ldf,*)
     end subroutine stdlib${ii}$_stgsy2

     pure module subroutine stdlib${ii}$_dtgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
               ldf, scale, rdsum, rdscal,iwork, pq, info )
           character, intent(in) :: trans
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(${ik}$), intent(out) :: info, pq
           real(dp), intent(inout) :: rdscal, rdsum
           real(dp), intent(out) :: scale
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(dp), intent(inout) :: c(ldc,*), f(ldf,*)
     end subroutine stdlib${ii}$_dtgsy2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$tgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
               ldf, scale, rdsum, rdscal,iwork, pq, info )
           character, intent(in) :: trans
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(${ik}$), intent(out) :: info, pq
           real(${rk}$), intent(inout) :: rdscal, rdsum
           real(${rk}$), intent(out) :: scale
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(${rk}$), intent(inout) :: c(ldc,*), f(ldf,*)
     end subroutine stdlib${ii}$_${ri}$tgsy2

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_ctgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
               ldf, scale, rdsum, rdscal,info )
           character, intent(in) :: trans
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(inout) :: rdscal, rdsum
           real(sp), intent(out) :: scale
           complex(sp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(sp), intent(inout) :: c(ldc,*), f(ldf,*)
     end subroutine stdlib${ii}$_ctgsy2

     pure module subroutine stdlib${ii}$_ztgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
               ldf, scale, rdsum, rdscal,info )
           character, intent(in) :: trans
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(inout) :: rdscal, rdsum
           real(dp), intent(out) :: scale
           complex(dp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(dp), intent(inout) :: c(ldc,*), f(ldf,*)
     end subroutine stdlib${ii}$_ztgsy2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$tgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
               ldf, scale, rdsum, rdscal,info )
           character, intent(in) :: trans
           integer(${ik}$), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(${ik}$), intent(out) :: info
           real(${ck}$), intent(inout) :: rdscal, rdsum
           real(${ck}$), intent(out) :: scale
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(${ck}$), intent(inout) :: c(ldc,*), f(ldf,*)
     end subroutine stdlib${ii}$_${ci}$tgsy2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slagv2( a, lda, b, ldb, alphar, alphai, beta, csl, snl,csr, snr )
               
           integer(${ik}$), intent(in) :: lda, ldb
           real(sp), intent(out) :: csl, csr, snl, snr
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: alphai(2_${ik}$), alphar(2_${ik}$), beta(2_${ik}$)
     end subroutine stdlib${ii}$_slagv2

     pure module subroutine stdlib${ii}$_dlagv2( a, lda, b, ldb, alphar, alphai, beta, csl, snl,csr, snr )
               
           integer(${ik}$), intent(in) :: lda, ldb
           real(dp), intent(out) :: csl, csr, snl, snr
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: alphai(2_${ik}$), alphar(2_${ik}$), beta(2_${ik}$)
     end subroutine stdlib${ii}$_dlagv2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lagv2( a, lda, b, ldb, alphar, alphai, beta, csl, snl,csr, snr )
               
           integer(${ik}$), intent(in) :: lda, ldb
           real(${rk}$), intent(out) :: csl, csr, snl, snr
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(2_${ik}$), alphar(2_${ik}$), beta(2_${ik}$)
     end subroutine stdlib${ii}$_${ri}$lagv2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_stgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
               mm, m, work, info )
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           logical(lk), intent(in) :: select(*)
           real(sp), intent(in) :: p(ldp,*), s(lds,*)
           real(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_stgevc

     pure module subroutine stdlib${ii}$_dtgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
               mm, m, work, info )
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           logical(lk), intent(in) :: select(*)
           real(dp), intent(in) :: p(ldp,*), s(lds,*)
           real(dp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dtgevc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$tgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
               mm, m, work, info )
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           logical(lk), intent(in) :: select(*)
           real(${rk}$), intent(in) :: p(ldp,*), s(lds,*)
           real(${rk}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$tgevc

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_ctgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
               mm, m, work, rwork, info )
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           logical(lk), intent(in) :: select(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(in) :: p(ldp,*), s(lds,*)
           complex(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_ctgevc

     pure module subroutine stdlib${ii}$_ztgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
               mm, m, work, rwork, info )
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           logical(lk), intent(in) :: select(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(in) :: p(ldp,*), s(lds,*)
           complex(dp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_ztgevc

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$tgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
               mm, m, work, rwork, info )
           character, intent(in) :: howmny, side
           integer(${ik}$), intent(out) :: info, m
           integer(${ik}$), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           logical(lk), intent(in) :: select(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(in) :: p(ldp,*), s(lds,*)
           complex(${ck}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$tgevc

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_stgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
               work, lwork, info )
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(inout) :: ifst, ilst
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldq, ldz, lwork, n
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_stgexc

     pure module subroutine stdlib${ii}$_dtgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
               work, lwork, info )
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(inout) :: ifst, ilst
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldq, ldz, lwork, n
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dtgexc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$tgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
               work, lwork, info )
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(inout) :: ifst, ilst
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, ldq, ldz, lwork, n
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$tgexc

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_ctgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
               info )
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(in) :: ifst, lda, ldb, ldq, ldz, n
           integer(${ik}$), intent(inout) :: ilst
           integer(${ik}$), intent(out) :: info
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
     end subroutine stdlib${ii}$_ctgexc

     pure module subroutine stdlib${ii}$_ztgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
               info )
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(in) :: ifst, lda, ldb, ldq, ldz, n
           integer(${ik}$), intent(inout) :: ilst
           integer(${ik}$), intent(out) :: info
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
     end subroutine stdlib${ii}$_ztgexc

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$tgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
               info )
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(in) :: ifst, lda, ldb, ldq, ldz, n
           integer(${ik}$), intent(inout) :: ilst
           integer(${ik}$), intent(out) :: info
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$tgexc

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, n1, n2, &
               work, lwork, info )
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: j1, lda, ldb, ldq, ldz, lwork, n, n1, n2
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_stgex2

     pure module subroutine stdlib${ii}$_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, n1, n2, &
               work, lwork, info )
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: j1, lda, ldb, ldq, ldz, lwork, n, n1, n2
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dtgex2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, n1, n2, &
               work, lwork, info )
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: j1, lda, ldb, ldq, ldz, lwork, n, n1, n2
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$tgex2

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_ctgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, info )
               
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: j1, lda, ldb, ldq, ldz, n
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
     end subroutine stdlib${ii}$_ctgex2

     pure module subroutine stdlib${ii}$_ztgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, info )
               
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: j1, lda, ldb, ldq, ldz, n
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
     end subroutine stdlib${ii}$_ztgex2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, info )
               
           logical(lk), intent(in) :: wantq, wantz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: j1, lda, ldb, ldq, ldz, n
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$tgex2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaebz( ijob, nitmax, n, mmax, minp, nbmin, abstol,reltol, pivmin, d, &
               e, e2, nval, ab, c, mout,nab, work, iwork, info )
           integer(${ik}$), intent(in) :: ijob, minp, mmax, n, nbmin, nitmax
           integer(${ik}$), intent(out) :: info, mout
           real(sp), intent(in) :: abstol, pivmin, reltol
           integer(${ik}$), intent(out) :: iwork(*)
           integer(${ik}$), intent(inout) :: nab(mmax,*), nval(*)
           real(sp), intent(inout) :: ab(mmax,*), c(*)
           real(sp), intent(in) :: d(*), e(*), e2(*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_slaebz

     pure module subroutine stdlib${ii}$_dlaebz( ijob, nitmax, n, mmax, minp, nbmin, abstol,reltol, pivmin, d, &
               e, e2, nval, ab, c, mout,nab, work, iwork, info )
           integer(${ik}$), intent(in) :: ijob, minp, mmax, n, nbmin, nitmax
           integer(${ik}$), intent(out) :: info, mout
           real(dp), intent(in) :: abstol, pivmin, reltol
           integer(${ik}$), intent(out) :: iwork(*)
           integer(${ik}$), intent(inout) :: nab(mmax,*), nval(*)
           real(dp), intent(inout) :: ab(mmax,*), c(*)
           real(dp), intent(in) :: d(*), e(*), e2(*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dlaebz

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laebz( ijob, nitmax, n, mmax, minp, nbmin, abstol,reltol, pivmin, d, &
               e, e2, nval, ab, c, mout,nab, work, iwork, info )
           integer(${ik}$), intent(in) :: ijob, minp, mmax, n, nbmin, nitmax
           integer(${ik}$), intent(out) :: info, mout
           real(${rk}$), intent(in) :: abstol, pivmin, reltol
           integer(${ik}$), intent(out) :: iwork(*)
           integer(${ik}$), intent(inout) :: nab(mmax,*), nval(*)
           real(${rk}$), intent(inout) :: ab(mmax,*), c(*)
           real(${rk}$), intent(in) :: d(*), e(*), e2(*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$laebz

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure integer(${ik}$) module function stdlib${ii}$_slaneg( n, d, lld, sigma, pivmin, r )
           integer(${ik}$), intent(in) :: n, r
           real(sp), intent(in) :: pivmin, sigma
           real(sp), intent(in) :: d(*), lld(*)
     end function stdlib${ii}$_slaneg

     pure integer(${ik}$) module function stdlib${ii}$_dlaneg( n, d, lld, sigma, pivmin, r )
           integer(${ik}$), intent(in) :: n, r
           real(dp), intent(in) :: pivmin, sigma
           real(dp), intent(in) :: d(*), lld(*)
     end function stdlib${ii}$_dlaneg

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure integer(${ik}$) module function stdlib${ii}$_${ri}$laneg( n, d, lld, sigma, pivmin, r )
           integer(${ik}$), intent(in) :: n, r
           real(${rk}$), intent(in) :: pivmin, sigma
           real(${rk}$), intent(in) :: d(*), lld(*)
     end function stdlib${ii}$_${ri}$laneg

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaed0( icompq, qsiz, n, d, e, q, ldq, qstore, ldqs,work, iwork, info &
               )
           integer(${ik}$), intent(in) :: icompq, ldq, ldqs, n, qsiz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), e(*), q(ldq,*)
           real(sp), intent(out) :: qstore(ldqs,*), work(*)
     end subroutine stdlib${ii}$_slaed0

     pure module subroutine stdlib${ii}$_dlaed0( icompq, qsiz, n, d, e, q, ldq, qstore, ldqs,work, iwork, info &
               )
           integer(${ik}$), intent(in) :: icompq, ldq, ldqs, n, qsiz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: d(*), e(*), q(ldq,*)
           real(dp), intent(out) :: qstore(ldqs,*), work(*)
     end subroutine stdlib${ii}$_dlaed0

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laed0( icompq, qsiz, n, d, e, q, ldq, qstore, ldqs,work, iwork, info &
               )
           integer(${ik}$), intent(in) :: icompq, ldq, ldqs, n, qsiz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*), q(ldq,*)
           real(${rk}$), intent(out) :: qstore(ldqs,*), work(*)
     end subroutine stdlib${ii}$_${ri}$laed0

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_claed0( qsiz, n, d, e, q, ldq, qstore, ldqs, rwork,iwork, info )
               
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldq, ldqs, n, qsiz
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: q(ldq,*)
           complex(sp), intent(out) :: qstore(ldqs,*)
     end subroutine stdlib${ii}$_claed0

     pure module subroutine stdlib${ii}$_zlaed0( qsiz, n, d, e, q, ldq, qstore, ldqs, rwork,iwork, info )
               
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldq, ldqs, n, qsiz
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: q(ldq,*)
           complex(dp), intent(out) :: qstore(ldqs,*)
     end subroutine stdlib${ii}$_zlaed0

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$laed0( qsiz, n, d, e, q, ldq, qstore, ldqs, rwork,iwork, info )
               
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldq, ldqs, n, qsiz
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(inout) :: d(*), e(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: q(ldq,*)
           complex(${ck}$), intent(out) :: qstore(ldqs,*)
     end subroutine stdlib${ii}$_${ci}$laed0

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaed1( n, d, q, ldq, indxq, rho, cutpnt, work, iwork,info )
           integer(${ik}$), intent(in) :: cutpnt, ldq, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(inout) :: rho
           integer(${ik}$), intent(inout) :: indxq(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), q(ldq,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_slaed1

     pure module subroutine stdlib${ii}$_dlaed1( n, d, q, ldq, indxq, rho, cutpnt, work, iwork,info )
           integer(${ik}$), intent(in) :: cutpnt, ldq, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(inout) :: rho
           integer(${ik}$), intent(inout) :: indxq(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: d(*), q(ldq,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dlaed1

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laed1( n, d, q, ldq, indxq, rho, cutpnt, work, iwork,info )
           integer(${ik}$), intent(in) :: cutpnt, ldq, n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(inout) :: rho
           integer(${ik}$), intent(inout) :: indxq(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: d(*), q(ldq,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$laed1

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaed2( k, n, n1, d, q, ldq, indxq, rho, z, dlamda, w,q2, indx, indxc,&
                indxp, coltyp, info )
           integer(${ik}$), intent(out) :: info, k
           integer(${ik}$), intent(in) :: ldq, n, n1
           real(sp), intent(inout) :: rho
           integer(${ik}$), intent(out) :: coltyp(*), indx(*), indxc(*), indxp(*)
           integer(${ik}$), intent(inout) :: indxq(*)
           real(sp), intent(inout) :: d(*), q(ldq,*), z(*)
           real(sp), intent(out) :: dlamda(*), q2(*), w(*)
     end subroutine stdlib${ii}$_slaed2

     pure module subroutine stdlib${ii}$_dlaed2( k, n, n1, d, q, ldq, indxq, rho, z, dlamda, w,q2, indx, indxc,&
                indxp, coltyp, info )
           integer(${ik}$), intent(out) :: info, k
           integer(${ik}$), intent(in) :: ldq, n, n1
           real(dp), intent(inout) :: rho
           integer(${ik}$), intent(out) :: coltyp(*), indx(*), indxc(*), indxp(*)
           integer(${ik}$), intent(inout) :: indxq(*)
           real(dp), intent(inout) :: d(*), q(ldq,*), z(*)
           real(dp), intent(out) :: dlamda(*), q2(*), w(*)
     end subroutine stdlib${ii}$_dlaed2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laed2( k, n, n1, d, q, ldq, indxq, rho, z, dlamda, w,q2, indx, indxc,&
                indxp, coltyp, info )
           integer(${ik}$), intent(out) :: info, k
           integer(${ik}$), intent(in) :: ldq, n, n1
           real(${rk}$), intent(inout) :: rho
           integer(${ik}$), intent(out) :: coltyp(*), indx(*), indxc(*), indxp(*)
           integer(${ik}$), intent(inout) :: indxq(*)
           real(${rk}$), intent(inout) :: d(*), q(ldq,*), z(*)
           real(${rk}$), intent(out) :: dlamda(*), q2(*), w(*)
     end subroutine stdlib${ii}$_${ri}$laed2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaed3( k, n, n1, d, q, ldq, rho, dlamda, q2, indx,ctot, w, s, info )
               
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, ldq, n, n1
           real(sp), intent(in) :: rho
           integer(${ik}$), intent(in) :: ctot(*), indx(*)
           real(sp), intent(out) :: d(*), q(ldq,*), s(*)
           real(sp), intent(inout) :: dlamda(*), w(*)
           real(sp), intent(in) :: q2(*)
     end subroutine stdlib${ii}$_slaed3

     pure module subroutine stdlib${ii}$_dlaed3( k, n, n1, d, q, ldq, rho, dlamda, q2, indx,ctot, w, s, info )
               
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, ldq, n, n1
           real(dp), intent(in) :: rho
           integer(${ik}$), intent(in) :: ctot(*), indx(*)
           real(dp), intent(out) :: d(*), q(ldq,*), s(*)
           real(dp), intent(inout) :: dlamda(*), w(*)
           real(dp), intent(in) :: q2(*)
     end subroutine stdlib${ii}$_dlaed3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laed3( k, n, n1, d, q, ldq, rho, dlamda, q2, indx,ctot, w, s, info )
               
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, ldq, n, n1
           real(${rk}$), intent(in) :: rho
           integer(${ik}$), intent(in) :: ctot(*), indx(*)
           real(${rk}$), intent(out) :: d(*), q(ldq,*), s(*)
           real(${rk}$), intent(inout) :: dlamda(*), w(*)
           real(${rk}$), intent(in) :: q2(*)
     end subroutine stdlib${ii}$_${ri}$laed3

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaed4( n, i, d, z, delta, rho, dlam, info )
           integer(${ik}$), intent(in) :: i, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(out) :: dlam
           real(sp), intent(in) :: rho
           real(sp), intent(in) :: d(*), z(*)
           real(sp), intent(out) :: delta(*)
     end subroutine stdlib${ii}$_slaed4

     pure module subroutine stdlib${ii}$_dlaed4( n, i, d, z, delta, rho, dlam, info )
           integer(${ik}$), intent(in) :: i, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(out) :: dlam
           real(dp), intent(in) :: rho
           real(dp), intent(in) :: d(*), z(*)
           real(dp), intent(out) :: delta(*)
     end subroutine stdlib${ii}$_dlaed4

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laed4( n, i, d, z, delta, rho, dlam, info )
           integer(${ik}$), intent(in) :: i, n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(out) :: dlam
           real(${rk}$), intent(in) :: rho
           real(${rk}$), intent(in) :: d(*), z(*)
           real(${rk}$), intent(out) :: delta(*)
     end subroutine stdlib${ii}$_${ri}$laed4

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaed5( i, d, z, delta, rho, dlam )
           integer(${ik}$), intent(in) :: i
           real(sp), intent(out) :: dlam
           real(sp), intent(in) :: rho
           real(sp), intent(in) :: d(2_${ik}$), z(2_${ik}$)
           real(sp), intent(out) :: delta(2_${ik}$)
     end subroutine stdlib${ii}$_slaed5

     pure module subroutine stdlib${ii}$_dlaed5( i, d, z, delta, rho, dlam )
           integer(${ik}$), intent(in) :: i
           real(dp), intent(out) :: dlam
           real(dp), intent(in) :: rho
           real(dp), intent(in) :: d(2_${ik}$), z(2_${ik}$)
           real(dp), intent(out) :: delta(2_${ik}$)
     end subroutine stdlib${ii}$_dlaed5

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laed5( i, d, z, delta, rho, dlam )
           integer(${ik}$), intent(in) :: i
           real(${rk}$), intent(out) :: dlam
           real(${rk}$), intent(in) :: rho
           real(${rk}$), intent(in) :: d(2_${ik}$), z(2_${ik}$)
           real(${rk}$), intent(out) :: delta(2_${ik}$)
     end subroutine stdlib${ii}$_${ri}$laed5

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaed6( kniter, orgati, rho, d, z, finit, tau, info )
           logical(lk), intent(in) :: orgati
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kniter
           real(sp), intent(in) :: finit, rho
           real(sp), intent(out) :: tau
           real(sp), intent(in) :: d(3_${ik}$), z(3_${ik}$)
     end subroutine stdlib${ii}$_slaed6

     pure module subroutine stdlib${ii}$_dlaed6( kniter, orgati, rho, d, z, finit, tau, info )
           logical(lk), intent(in) :: orgati
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kniter
           real(dp), intent(in) :: finit, rho
           real(dp), intent(out) :: tau
           real(dp), intent(in) :: d(3_${ik}$), z(3_${ik}$)
     end subroutine stdlib${ii}$_dlaed6

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laed6( kniter, orgati, rho, d, z, finit, tau, info )
           logical(lk), intent(in) :: orgati
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kniter
           real(${rk}$), intent(in) :: finit, rho
           real(${rk}$), intent(out) :: tau
           real(${rk}$), intent(in) :: d(3_${ik}$), z(3_${ik}$)
     end subroutine stdlib${ii}$_${ri}$laed6

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaed7( icompq, n, qsiz, tlvls, curlvl, curpbm, d, q,ldq, indxq, rho, &
               cutpnt, qstore, qptr, prmptr,perm, givptr, givcol, givnum, work, iwork,info )
           integer(${ik}$), intent(in) :: curlvl, curpbm, cutpnt, icompq, ldq, n, qsiz, tlvls
           integer(${ik}$), intent(out) :: info
           real(sp), intent(inout) :: rho
           integer(${ik}$), intent(inout) :: givcol(2_${ik}$,*), givptr(*), perm(*), prmptr(*), qptr(*)
                     
           integer(${ik}$), intent(out) :: indxq(*), iwork(*)
           real(sp), intent(inout) :: d(*), givnum(2_${ik}$,*), q(ldq,*), qstore(*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_slaed7

     pure module subroutine stdlib${ii}$_dlaed7( icompq, n, qsiz, tlvls, curlvl, curpbm, d, q,ldq, indxq, rho, &
               cutpnt, qstore, qptr, prmptr,perm, givptr, givcol, givnum, work, iwork,info )
           integer(${ik}$), intent(in) :: curlvl, curpbm, cutpnt, icompq, ldq, n, qsiz, tlvls
           integer(${ik}$), intent(out) :: info
           real(dp), intent(inout) :: rho
           integer(${ik}$), intent(inout) :: givcol(2_${ik}$,*), givptr(*), perm(*), prmptr(*), qptr(*)
                     
           integer(${ik}$), intent(out) :: indxq(*), iwork(*)
           real(dp), intent(inout) :: d(*), givnum(2_${ik}$,*), q(ldq,*), qstore(*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dlaed7

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laed7( icompq, n, qsiz, tlvls, curlvl, curpbm, d, q,ldq, indxq, rho, &
               cutpnt, qstore, qptr, prmptr,perm, givptr, givcol, givnum, work, iwork,info )
           integer(${ik}$), intent(in) :: curlvl, curpbm, cutpnt, icompq, ldq, n, qsiz, tlvls
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(inout) :: rho
           integer(${ik}$), intent(inout) :: givcol(2_${ik}$,*), givptr(*), perm(*), prmptr(*), qptr(*)
                     
           integer(${ik}$), intent(out) :: indxq(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), givnum(2_${ik}$,*), q(ldq,*), qstore(*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$laed7

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_claed7( n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q,ldq, rho, indxq, &
               qstore, qptr, prmptr, perm,givptr, givcol, givnum, work, rwork, iwork,info )
           integer(${ik}$), intent(in) :: curlvl, curpbm, cutpnt, ldq, n, qsiz, tlvls
           integer(${ik}$), intent(out) :: info
           real(sp), intent(inout) :: rho
           integer(${ik}$), intent(inout) :: givcol(2_${ik}$,*), givptr(*), perm(*), prmptr(*), qptr(*)
                     
           integer(${ik}$), intent(out) :: indxq(*), iwork(*)
           real(sp), intent(inout) :: d(*), givnum(2_${ik}$,*), qstore(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: q(ldq,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_claed7

     pure module subroutine stdlib${ii}$_zlaed7( n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q,ldq, rho, indxq, &
               qstore, qptr, prmptr, perm,givptr, givcol, givnum, work, rwork, iwork,info )
           integer(${ik}$), intent(in) :: curlvl, curpbm, cutpnt, ldq, n, qsiz, tlvls
           integer(${ik}$), intent(out) :: info
           real(dp), intent(inout) :: rho
           integer(${ik}$), intent(inout) :: givcol(2_${ik}$,*), givptr(*), perm(*), prmptr(*), qptr(*)
                     
           integer(${ik}$), intent(out) :: indxq(*), iwork(*)
           real(dp), intent(inout) :: d(*), givnum(2_${ik}$,*), qstore(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: q(ldq,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zlaed7

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$laed7( n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q,ldq, rho, indxq, &
               qstore, qptr, prmptr, perm,givptr, givcol, givnum, work, rwork, iwork,info )
           integer(${ik}$), intent(in) :: curlvl, curpbm, cutpnt, ldq, n, qsiz, tlvls
           integer(${ik}$), intent(out) :: info
           real(${ck}$), intent(inout) :: rho
           integer(${ik}$), intent(inout) :: givcol(2_${ik}$,*), givptr(*), perm(*), prmptr(*), qptr(*)
                     
           integer(${ik}$), intent(out) :: indxq(*), iwork(*)
           real(${ck}$), intent(inout) :: d(*), givnum(2_${ik}$,*), qstore(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: q(ldq,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$laed7

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho,cutpnt, z, dlamda, &
               q2, ldq2, w, perm, givptr,givcol, givnum, indxp, indx, info )
           integer(${ik}$), intent(in) :: cutpnt, icompq, ldq, ldq2, n, qsiz
           integer(${ik}$), intent(out) :: givptr, info, k
           real(sp), intent(inout) :: rho
           integer(${ik}$), intent(out) :: givcol(2_${ik}$,*), indx(*), indxp(*), perm(*)
           integer(${ik}$), intent(inout) :: indxq(*)
           real(sp), intent(inout) :: d(*), q(ldq,*), z(*)
           real(sp), intent(out) :: dlamda(*), givnum(2_${ik}$,*), q2(ldq2,*), w(*)
     end subroutine stdlib${ii}$_slaed8

     pure module subroutine stdlib${ii}$_dlaed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho,cutpnt, z, dlamda, &
               q2, ldq2, w, perm, givptr,givcol, givnum, indxp, indx, info )
           integer(${ik}$), intent(in) :: cutpnt, icompq, ldq, ldq2, n, qsiz
           integer(${ik}$), intent(out) :: givptr, info, k
           real(dp), intent(inout) :: rho
           integer(${ik}$), intent(out) :: givcol(2_${ik}$,*), indx(*), indxp(*), perm(*)
           integer(${ik}$), intent(inout) :: indxq(*)
           real(dp), intent(inout) :: d(*), q(ldq,*), z(*)
           real(dp), intent(out) :: dlamda(*), givnum(2_${ik}$,*), q2(ldq2,*), w(*)
     end subroutine stdlib${ii}$_dlaed8

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho,cutpnt, z, dlamda, &
               q2, ldq2, w, perm, givptr,givcol, givnum, indxp, indx, info )
           integer(${ik}$), intent(in) :: cutpnt, icompq, ldq, ldq2, n, qsiz
           integer(${ik}$), intent(out) :: givptr, info, k
           real(${rk}$), intent(inout) :: rho
           integer(${ik}$), intent(out) :: givcol(2_${ik}$,*), indx(*), indxp(*), perm(*)
           integer(${ik}$), intent(inout) :: indxq(*)
           real(${rk}$), intent(inout) :: d(*), q(ldq,*), z(*)
           real(${rk}$), intent(out) :: dlamda(*), givnum(2_${ik}$,*), q2(ldq2,*), w(*)
     end subroutine stdlib${ii}$_${ri}$laed8

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_claed8( k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda,q2, ldq2, w, &
               indxp, indx, indxq, perm, givptr,givcol, givnum, info )
           integer(${ik}$), intent(in) :: cutpnt, ldq, ldq2, n, qsiz
           integer(${ik}$), intent(out) :: givptr, info, k
           real(sp), intent(inout) :: rho
           integer(${ik}$), intent(out) :: givcol(2_${ik}$,*), indx(*), indxp(*), perm(*)
           integer(${ik}$), intent(inout) :: indxq(*)
           real(sp), intent(inout) :: d(*), z(*)
           real(sp), intent(out) :: dlamda(*), givnum(2_${ik}$,*), w(*)
           complex(sp), intent(inout) :: q(ldq,*)
           complex(sp), intent(out) :: q2(ldq2,*)
     end subroutine stdlib${ii}$_claed8

     pure module subroutine stdlib${ii}$_zlaed8( k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda,q2, ldq2, w, &
               indxp, indx, indxq, perm, givptr,givcol, givnum, info )
           integer(${ik}$), intent(in) :: cutpnt, ldq, ldq2, n, qsiz
           integer(${ik}$), intent(out) :: givptr, info, k
           real(dp), intent(inout) :: rho
           integer(${ik}$), intent(out) :: givcol(2_${ik}$,*), indx(*), indxp(*), perm(*)
           integer(${ik}$), intent(inout) :: indxq(*)
           real(dp), intent(inout) :: d(*), z(*)
           real(dp), intent(out) :: dlamda(*), givnum(2_${ik}$,*), w(*)
           complex(dp), intent(inout) :: q(ldq,*)
           complex(dp), intent(out) :: q2(ldq2,*)
     end subroutine stdlib${ii}$_zlaed8

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$laed8( k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda,q2, ldq2, w, &
               indxp, indx, indxq, perm, givptr,givcol, givnum, info )
           integer(${ik}$), intent(in) :: cutpnt, ldq, ldq2, n, qsiz
           integer(${ik}$), intent(out) :: givptr, info, k
           real(${ck}$), intent(inout) :: rho
           integer(${ik}$), intent(out) :: givcol(2_${ik}$,*), indx(*), indxp(*), perm(*)
           integer(${ik}$), intent(inout) :: indxq(*)
           real(${ck}$), intent(inout) :: d(*), z(*)
           real(${ck}$), intent(out) :: dlamda(*), givnum(2_${ik}$,*), w(*)
           complex(${ck}$), intent(inout) :: q(ldq,*)
           complex(${ck}$), intent(out) :: q2(ldq2,*)
     end subroutine stdlib${ii}$_${ci}$laed8

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaed9( k, kstart, kstop, n, d, q, ldq, rho, dlamda, w,s, lds, info )
               
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, kstart, kstop, ldq, lds, n
           real(sp), intent(in) :: rho
           real(sp), intent(out) :: d(*), q(ldq,*), s(lds,*)
           real(sp), intent(inout) :: dlamda(*), w(*)
     end subroutine stdlib${ii}$_slaed9

     pure module subroutine stdlib${ii}$_dlaed9( k, kstart, kstop, n, d, q, ldq, rho, dlamda, w,s, lds, info )
               
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, kstart, kstop, ldq, lds, n
           real(dp), intent(in) :: rho
           real(dp), intent(out) :: d(*), q(ldq,*), s(lds,*)
           real(dp), intent(inout) :: dlamda(*), w(*)
     end subroutine stdlib${ii}$_dlaed9

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laed9( k, kstart, kstop, n, d, q, ldq, rho, dlamda, w,s, lds, info )
               
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, kstart, kstop, ldq, lds, n
           real(${rk}$), intent(in) :: rho
           real(${rk}$), intent(out) :: d(*), q(ldq,*), s(lds,*)
           real(${rk}$), intent(inout) :: dlamda(*), w(*)
     end subroutine stdlib${ii}$_${ri}$laed9

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slamrg( n1, n2, a, strd1, strd2, index )
           integer(${ik}$), intent(in) :: n1, n2, strd1, strd2
           integer(${ik}$), intent(out) :: index(*)
           real(sp), intent(in) :: a(*)
     end subroutine stdlib${ii}$_slamrg

     pure module subroutine stdlib${ii}$_dlamrg( n1, n2, a, dtrd1, dtrd2, index )
           integer(${ik}$), intent(in) :: dtrd1, dtrd2, n1, n2
           integer(${ik}$), intent(out) :: index(*)
           real(dp), intent(in) :: a(*)
     end subroutine stdlib${ii}$_dlamrg

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lamrg( n1, n2, a, dtrd1, dtrd2, index )
           integer(${ik}$), intent(in) :: dtrd1, dtrd2, n1, n2
           integer(${ik}$), intent(out) :: index(*)
           real(${rk}$), intent(in) :: a(*)
     end subroutine stdlib${ii}$_${ri}$lamrg

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, givnum,&
                q, qptr, z, ztemp, info )
           integer(${ik}$), intent(in) :: curlvl, curpbm, n, tlvls
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: givcol(2_${ik}$,*), givptr(*), perm(*), prmptr(*), qptr(*)
           real(sp), intent(in) :: givnum(2_${ik}$,*), q(*)
           real(sp), intent(out) :: z(*), ztemp(*)
     end subroutine stdlib${ii}$_slaeda

     pure module subroutine stdlib${ii}$_dlaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, givnum,&
                q, qptr, z, ztemp, info )
           integer(${ik}$), intent(in) :: curlvl, curpbm, n, tlvls
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: givcol(2_${ik}$,*), givptr(*), perm(*), prmptr(*), qptr(*)
           real(dp), intent(in) :: givnum(2_${ik}$,*), q(*)
           real(dp), intent(out) :: z(*), ztemp(*)
     end subroutine stdlib${ii}$_dlaeda

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, givnum,&
                q, qptr, z, ztemp, info )
           integer(${ik}$), intent(in) :: curlvl, curpbm, n, tlvls
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: givcol(2_${ik}$,*), givptr(*), perm(*), prmptr(*), qptr(*)
           real(${rk}$), intent(in) :: givnum(2_${ik}$,*), q(*)
           real(${rk}$), intent(out) :: z(*), ztemp(*)
     end subroutine stdlib${ii}$_${ri}$laeda

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slarra( n, d, e, e2, spltol, tnrm,nsplit, isplit, info )
           integer(${ik}$), intent(out) :: info, nsplit
           integer(${ik}$), intent(in) :: n
           real(sp), intent(in) :: spltol, tnrm
           integer(${ik}$), intent(out) :: isplit(*)
           real(sp), intent(in) :: d(*)
           real(sp), intent(inout) :: e(*), e2(*)
     end subroutine stdlib${ii}$_slarra

     pure module subroutine stdlib${ii}$_dlarra( n, d, e, e2, spltol, tnrm,nsplit, isplit, info )
           integer(${ik}$), intent(out) :: info, nsplit
           integer(${ik}$), intent(in) :: n
           real(dp), intent(in) :: spltol, tnrm
           integer(${ik}$), intent(out) :: isplit(*)
           real(dp), intent(in) :: d(*)
           real(dp), intent(inout) :: e(*), e2(*)
     end subroutine stdlib${ii}$_dlarra

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$larra( n, d, e, e2, spltol, tnrm,nsplit, isplit, info )
           integer(${ik}$), intent(out) :: info, nsplit
           integer(${ik}$), intent(in) :: n
           real(${rk}$), intent(in) :: spltol, tnrm
           integer(${ik}$), intent(out) :: isplit(*)
           real(${rk}$), intent(in) :: d(*)
           real(${rk}$), intent(inout) :: e(*), e2(*)
     end subroutine stdlib${ii}$_${ri}$larra

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slarrb( n, d, lld, ifirst, ilast, rtol1,rtol2, offset, w, wgap, werr, &
               work, iwork,pivmin, spdiam, twist, info )
           integer(${ik}$), intent(in) :: ifirst, ilast, n, offset, twist
           integer(${ik}$), intent(out) :: info
           real(sp), intent(in) :: pivmin, rtol1, rtol2, spdiam
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(in) :: d(*), lld(*)
           real(sp), intent(inout) :: w(*), werr(*), wgap(*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_slarrb

     pure module subroutine stdlib${ii}$_dlarrb( n, d, lld, ifirst, ilast, rtol1,rtol2, offset, w, wgap, werr, &
               work, iwork,pivmin, spdiam, twist, info )
           integer(${ik}$), intent(in) :: ifirst, ilast, n, offset, twist
           integer(${ik}$), intent(out) :: info
           real(dp), intent(in) :: pivmin, rtol1, rtol2, spdiam
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(in) :: d(*), lld(*)
           real(dp), intent(inout) :: w(*), werr(*), wgap(*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dlarrb

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$larrb( n, d, lld, ifirst, ilast, rtol1,rtol2, offset, w, wgap, werr, &
               work, iwork,pivmin, spdiam, twist, info )
           integer(${ik}$), intent(in) :: ifirst, ilast, n, offset, twist
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(in) :: pivmin, rtol1, rtol2, spdiam
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: d(*), lld(*)
           real(${rk}$), intent(inout) :: w(*), werr(*), wgap(*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$larrb

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slarrc( jobt, n, vl, vu, d, e, pivmin,eigcnt, lcnt, rcnt, info )
               
           character, intent(in) :: jobt
           integer(${ik}$), intent(out) :: eigcnt, info, lcnt, rcnt
           integer(${ik}$), intent(in) :: n
           real(sp), intent(in) :: pivmin, vl, vu
           real(sp), intent(in) :: d(*), e(*)
     end subroutine stdlib${ii}$_slarrc

     pure module subroutine stdlib${ii}$_dlarrc( jobt, n, vl, vu, d, e, pivmin,eigcnt, lcnt, rcnt, info )
               
           character, intent(in) :: jobt
           integer(${ik}$), intent(out) :: eigcnt, info, lcnt, rcnt
           integer(${ik}$), intent(in) :: n
           real(dp), intent(in) :: pivmin, vl, vu
           real(dp), intent(in) :: d(*), e(*)
     end subroutine stdlib${ii}$_dlarrc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$larrc( jobt, n, vl, vu, d, e, pivmin,eigcnt, lcnt, rcnt, info )
               
           character, intent(in) :: jobt
           integer(${ik}$), intent(out) :: eigcnt, info, lcnt, rcnt
           integer(${ik}$), intent(in) :: n
           real(${rk}$), intent(in) :: pivmin, vl, vu
           real(${rk}$), intent(in) :: d(*), e(*)
     end subroutine stdlib${ii}$_${ri}$larrc

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slarrd( range, order, n, vl, vu, il, iu, gers,reltol, d, e, e2, &
               pivmin, nsplit, isplit,m, w, werr, wl, wu, iblock, indexw,work, iwork, info )
           character, intent(in) :: order, range
           integer(${ik}$), intent(in) :: il, iu, n, nsplit
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: pivmin, reltol, vl, vu
           real(sp), intent(out) :: wl, wu
           integer(${ik}$), intent(out) :: iblock(*), indexw(*), iwork(*)
           integer(${ik}$), intent(in) :: isplit(*)
           real(sp), intent(in) :: d(*), e(*), e2(*), gers(*)
           real(sp), intent(out) :: w(*), werr(*), work(*)
     end subroutine stdlib${ii}$_slarrd

     pure module subroutine stdlib${ii}$_dlarrd( range, order, n, vl, vu, il, iu, gers,reltol, d, e, e2, &
               pivmin, nsplit, isplit,m, w, werr, wl, wu, iblock, indexw,work, iwork, info )
           character, intent(in) :: order, range
           integer(${ik}$), intent(in) :: il, iu, n, nsplit
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: pivmin, reltol, vl, vu
           real(dp), intent(out) :: wl, wu
           integer(${ik}$), intent(out) :: iblock(*), indexw(*), iwork(*)
           integer(${ik}$), intent(in) :: isplit(*)
           real(dp), intent(in) :: d(*), e(*), e2(*), gers(*)
           real(dp), intent(out) :: w(*), werr(*), work(*)
     end subroutine stdlib${ii}$_dlarrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$larrd( range, order, n, vl, vu, il, iu, gers,reltol, d, e, e2, &
               pivmin, nsplit, isplit,m, w, werr, wl, wu, iblock, indexw,work, iwork, info )
           character, intent(in) :: order, range
           integer(${ik}$), intent(in) :: il, iu, n, nsplit
           integer(${ik}$), intent(out) :: info, m
           real(${rk}$), intent(in) :: pivmin, reltol, vl, vu
           real(${rk}$), intent(out) :: wl, wu
           integer(${ik}$), intent(out) :: iblock(*), indexw(*), iwork(*)
           integer(${ik}$), intent(in) :: isplit(*)
           real(${rk}$), intent(in) :: d(*), e(*), e2(*), gers(*)
           real(${rk}$), intent(out) :: w(*), werr(*), work(*)
     end subroutine stdlib${ii}$_${ri}$larrd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slarre( range, n, vl, vu, il, iu, d, e, e2,rtol1, rtol2, spltol, &
               nsplit, isplit, m,w, werr, wgap, iblock, indexw, gers, pivmin,work, iwork, info )
           character, intent(in) :: range
           integer(${ik}$), intent(in) :: il, iu, n
           integer(${ik}$), intent(out) :: info, m, nsplit
           real(sp), intent(out) :: pivmin
           real(sp), intent(in) :: rtol1, rtol2, spltol
           real(sp), intent(inout) :: vl, vu
           integer(${ik}$), intent(out) :: iblock(*), isplit(*), iwork(*), indexw(*)
           real(sp), intent(inout) :: d(*), e(*), e2(*)
           real(sp), intent(out) :: gers(*), w(*), werr(*), wgap(*), work(*)
     end subroutine stdlib${ii}$_slarre

     pure module subroutine stdlib${ii}$_dlarre( range, n, vl, vu, il, iu, d, e, e2,rtol1, rtol2, spltol, &
               nsplit, isplit, m,w, werr, wgap, iblock, indexw, gers, pivmin,work, iwork, info )
           character, intent(in) :: range
           integer(${ik}$), intent(in) :: il, iu, n
           integer(${ik}$), intent(out) :: info, m, nsplit
           real(dp), intent(out) :: pivmin
           real(dp), intent(in) :: rtol1, rtol2, spltol
           real(dp), intent(inout) :: vl, vu
           integer(${ik}$), intent(out) :: iblock(*), isplit(*), iwork(*), indexw(*)
           real(dp), intent(inout) :: d(*), e(*), e2(*)
           real(dp), intent(out) :: gers(*), w(*), werr(*), wgap(*), work(*)
     end subroutine stdlib${ii}$_dlarre

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$larre( range, n, vl, vu, il, iu, d, e, e2,rtol1, rtol2, spltol, &
               nsplit, isplit, m,w, werr, wgap, iblock, indexw, gers, pivmin,work, iwork, info )
           character, intent(in) :: range
           integer(${ik}$), intent(in) :: il, iu, n
           integer(${ik}$), intent(out) :: info, m, nsplit
           real(${rk}$), intent(out) :: pivmin
           real(${rk}$), intent(in) :: rtol1, rtol2, spltol
           real(${rk}$), intent(inout) :: vl, vu
           integer(${ik}$), intent(out) :: iblock(*), isplit(*), iwork(*), indexw(*)
           real(${rk}$), intent(inout) :: d(*), e(*), e2(*)
           real(${rk}$), intent(out) :: gers(*), w(*), werr(*), wgap(*), work(*)
     end subroutine stdlib${ii}$_${ri}$larre

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slarrf( n, d, l, ld, clstrt, clend,w, wgap, werr,spdiam, clgapl, &
               clgapr, pivmin, sigma,dplus, lplus, work, info )
           integer(${ik}$), intent(in) :: clstrt, clend, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(in) :: clgapl, clgapr, pivmin, spdiam
           real(sp), intent(out) :: sigma
           real(sp), intent(in) :: d(*), l(*), ld(*), w(*), werr(*)
           real(sp), intent(out) :: dplus(*), lplus(*), work(*)
           real(sp), intent(inout) :: wgap(*)
     end subroutine stdlib${ii}$_slarrf

     pure module subroutine stdlib${ii}$_dlarrf( n, d, l, ld, clstrt, clend,w, wgap, werr,spdiam, clgapl, &
               clgapr, pivmin, sigma,dplus, lplus, work, info )
           integer(${ik}$), intent(in) :: clstrt, clend, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(in) :: clgapl, clgapr, pivmin, spdiam
           real(dp), intent(out) :: sigma
           real(dp), intent(in) :: d(*), l(*), ld(*), w(*), werr(*)
           real(dp), intent(out) :: dplus(*), lplus(*), work(*)
           real(dp), intent(inout) :: wgap(*)
     end subroutine stdlib${ii}$_dlarrf

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$larrf( n, d, l, ld, clstrt, clend,w, wgap, werr,spdiam, clgapl, &
               clgapr, pivmin, sigma,dplus, lplus, work, info )
           integer(${ik}$), intent(in) :: clstrt, clend, n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(in) :: clgapl, clgapr, pivmin, spdiam
           real(${rk}$), intent(out) :: sigma
           real(${rk}$), intent(in) :: d(*), l(*), ld(*), w(*), werr(*)
           real(${rk}$), intent(out) :: dplus(*), lplus(*), work(*)
           real(${rk}$), intent(inout) :: wgap(*)
     end subroutine stdlib${ii}$_${ri}$larrf

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slarrj( n, d, e2, ifirst, ilast,rtol, offset, w, werr, work, iwork,&
               pivmin, spdiam, info )
           integer(${ik}$), intent(in) :: ifirst, ilast, n, offset
           integer(${ik}$), intent(out) :: info
           real(sp), intent(in) :: pivmin, rtol, spdiam
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(in) :: d(*), e2(*)
           real(sp), intent(inout) :: w(*), werr(*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_slarrj

     pure module subroutine stdlib${ii}$_dlarrj( n, d, e2, ifirst, ilast,rtol, offset, w, werr, work, iwork,&
               pivmin, spdiam, info )
           integer(${ik}$), intent(in) :: ifirst, ilast, n, offset
           integer(${ik}$), intent(out) :: info
           real(dp), intent(in) :: pivmin, rtol, spdiam
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(in) :: d(*), e2(*)
           real(dp), intent(inout) :: w(*), werr(*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dlarrj

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$larrj( n, d, e2, ifirst, ilast,rtol, offset, w, werr, work, iwork,&
               pivmin, spdiam, info )
           integer(${ik}$), intent(in) :: ifirst, ilast, n, offset
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(in) :: pivmin, rtol, spdiam
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: d(*), e2(*)
           real(${rk}$), intent(inout) :: w(*), werr(*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$larrj

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slarrk( n, iw, gl, gu,d, e2, pivmin, reltol, w, werr, info)
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: iw, n
           real(sp), intent(in) :: pivmin, reltol, gl, gu
           real(sp), intent(out) :: w, werr
           real(sp), intent(in) :: d(*), e2(*)
     end subroutine stdlib${ii}$_slarrk

     pure module subroutine stdlib${ii}$_dlarrk( n, iw, gl, gu,d, e2, pivmin, reltol, w, werr, info)
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: iw, n
           real(dp), intent(in) :: pivmin, reltol, gl, gu
           real(dp), intent(out) :: w, werr
           real(dp), intent(in) :: d(*), e2(*)
     end subroutine stdlib${ii}$_dlarrk

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$larrk( n, iw, gl, gu,d, e2, pivmin, reltol, w, werr, info)
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: iw, n
           real(${rk}$), intent(in) :: pivmin, reltol, gl, gu
           real(${rk}$), intent(out) :: w, werr
           real(${rk}$), intent(in) :: d(*), e2(*)
     end subroutine stdlib${ii}$_${ri}$larrk

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slarrr( n, d, e, info )
           integer(${ik}$), intent(in) :: n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(in) :: d(*)
           real(sp), intent(inout) :: e(*)
     end subroutine stdlib${ii}$_slarrr

     pure module subroutine stdlib${ii}$_dlarrr( n, d, e, info )
           integer(${ik}$), intent(in) :: n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(in) :: d(*)
           real(dp), intent(inout) :: e(*)
     end subroutine stdlib${ii}$_dlarrr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$larrr( n, d, e, info )
           integer(${ik}$), intent(in) :: n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(in) :: d(*)
           real(${rk}$), intent(inout) :: e(*)
     end subroutine stdlib${ii}$_${ri}$larrr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
           integer(${ik}$), intent(in) :: dol, dou, ldz, m, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(in) :: minrgp, pivmin, vl, vu
           real(sp), intent(inout) :: rtol1, rtol2
           integer(${ik}$), intent(in) :: iblock(*), indexw(*), isplit(*)
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), l(*), w(*), werr(*), wgap(*)
           real(sp), intent(in) :: gers(*)
           real(sp), intent(out) :: work(*)
           real(sp), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_slarrv

     pure module subroutine stdlib${ii}$_dlarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
           integer(${ik}$), intent(in) :: dol, dou, ldz, m, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(in) :: minrgp, pivmin, vl, vu
           real(dp), intent(inout) :: rtol1, rtol2
           integer(${ik}$), intent(in) :: iblock(*), indexw(*), isplit(*)
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(dp), intent(inout) :: d(*), l(*), w(*), werr(*), wgap(*)
           real(dp), intent(in) :: gers(*)
           real(dp), intent(out) :: work(*)
           real(dp), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_dlarrv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$larrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
           integer(${ik}$), intent(in) :: dol, dou, ldz, m, n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(in) :: minrgp, pivmin, vl, vu
           real(${rk}$), intent(inout) :: rtol1, rtol2
           integer(${ik}$), intent(in) :: iblock(*), indexw(*), isplit(*)
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), l(*), w(*), werr(*), wgap(*)
           real(${rk}$), intent(in) :: gers(*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$larrv

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_clarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
           integer(${ik}$), intent(in) :: dol, dou, ldz, m, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(in) :: minrgp, pivmin, vl, vu
           real(sp), intent(inout) :: rtol1, rtol2
           integer(${ik}$), intent(in) :: iblock(*), indexw(*), isplit(*)
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), l(*), w(*), werr(*), wgap(*)
           real(sp), intent(in) :: gers(*)
           real(sp), intent(out) :: work(*)
           complex(sp), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_clarrv

     pure module subroutine stdlib${ii}$_zlarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
           integer(${ik}$), intent(in) :: dol, dou, ldz, m, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(in) :: minrgp, pivmin, vl, vu
           real(dp), intent(inout) :: rtol1, rtol2
           integer(${ik}$), intent(in) :: iblock(*), indexw(*), isplit(*)
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(dp), intent(inout) :: d(*), l(*), w(*), werr(*), wgap(*)
           real(dp), intent(in) :: gers(*)
           real(dp), intent(out) :: work(*)
           complex(dp), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_zlarrv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$larrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
           integer(${ik}$), intent(in) :: dol, dou, ldz, m, n
           integer(${ik}$), intent(out) :: info
           real(${ck}$), intent(in) :: minrgp, pivmin, vl, vu
           real(${ck}$), intent(inout) :: rtol1, rtol2
           integer(${ik}$), intent(in) :: iblock(*), indexw(*), isplit(*)
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(${ck}$), intent(inout) :: d(*), l(*), w(*), werr(*), wgap(*)
           real(${ck}$), intent(in) :: gers(*)
           real(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$larrv

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc, &
               negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
           logical(lk), intent(in) :: wantnc
           integer(${ik}$), intent(in) :: b1, bn, n
           integer(${ik}$), intent(out) :: negcnt
           integer(${ik}$), intent(inout) :: r
           real(sp), intent(in) :: gaptol, lambda, pivmin
           real(sp), intent(out) :: mingma, nrminv, resid, rqcorr, ztz
           integer(${ik}$), intent(out) :: isuppz(*)
           real(sp), intent(in) :: d(*), l(*), ld(*), lld(*)
           real(sp), intent(out) :: work(*)
           real(sp), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_slar1v

     pure module subroutine stdlib${ii}$_dlar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc, &
               negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
           logical(lk), intent(in) :: wantnc
           integer(${ik}$), intent(in) :: b1, bn, n
           integer(${ik}$), intent(out) :: negcnt
           integer(${ik}$), intent(inout) :: r
           real(dp), intent(in) :: gaptol, lambda, pivmin
           real(dp), intent(out) :: mingma, nrminv, resid, rqcorr, ztz
           integer(${ik}$), intent(out) :: isuppz(*)
           real(dp), intent(in) :: d(*), l(*), ld(*), lld(*)
           real(dp), intent(out) :: work(*)
           real(dp), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_dlar1v

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc, &
               negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
           logical(lk), intent(in) :: wantnc
           integer(${ik}$), intent(in) :: b1, bn, n
           integer(${ik}$), intent(out) :: negcnt
           integer(${ik}$), intent(inout) :: r
           real(${rk}$), intent(in) :: gaptol, lambda, pivmin
           real(${rk}$), intent(out) :: mingma, nrminv, resid, rqcorr, ztz
           integer(${ik}$), intent(out) :: isuppz(*)
           real(${rk}$), intent(in) :: d(*), l(*), ld(*), lld(*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_${ri}$lar1v

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_clar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc, &
               negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
           logical(lk), intent(in) :: wantnc
           integer(${ik}$), intent(in) :: b1, bn, n
           integer(${ik}$), intent(out) :: negcnt
           integer(${ik}$), intent(inout) :: r
           real(sp), intent(in) :: gaptol, lambda, pivmin
           real(sp), intent(out) :: mingma, nrminv, resid, rqcorr, ztz
           integer(${ik}$), intent(out) :: isuppz(*)
           real(sp), intent(in) :: d(*), l(*), ld(*), lld(*)
           real(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_clar1v

     pure module subroutine stdlib${ii}$_zlar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc, &
               negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
           logical(lk), intent(in) :: wantnc
           integer(${ik}$), intent(in) :: b1, bn, n
           integer(${ik}$), intent(out) :: negcnt
           integer(${ik}$), intent(inout) :: r
           real(dp), intent(in) :: gaptol, lambda, pivmin
           real(dp), intent(out) :: mingma, nrminv, resid, rqcorr, ztz
           integer(${ik}$), intent(out) :: isuppz(*)
           real(dp), intent(in) :: d(*), l(*), ld(*), lld(*)
           real(dp), intent(out) :: work(*)
           complex(dp), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_zlar1v

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$lar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc, &
               negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
           logical(lk), intent(in) :: wantnc
           integer(${ik}$), intent(in) :: b1, bn, n
           integer(${ik}$), intent(out) :: negcnt
           integer(${ik}$), intent(inout) :: r
           real(${ck}$), intent(in) :: gaptol, lambda, pivmin
           real(${ck}$), intent(out) :: mingma, nrminv, resid, rqcorr, ztz
           integer(${ik}$), intent(out) :: isuppz(*)
           real(${ck}$), intent(in) :: d(*), l(*), ld(*), lld(*)
           real(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_${ci}$lar1v

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sstev( jobz, n, d, e, z, ldz, work, info )
           character, intent(in) :: jobz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_sstev

     pure module subroutine stdlib${ii}$_dstev( jobz, n, d, e, z, ldz, work, info )
           character, intent(in) :: jobz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dstev

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$stev( jobz, n, d, e, z, ldz, work, info )
           character, intent(in) :: jobz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$stev

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sstevd( jobz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
               
           character, intent(in) :: jobz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_sstevd

     pure module subroutine stdlib${ii}$_dstevd( jobz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
               
           character, intent(in) :: jobz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dstevd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$stevd( jobz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
               
           character, intent(in) :: jobz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$stevd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sstevr( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
               isuppz, work, lwork, iwork,liwork, info )
           character, intent(in) :: jobz, range
           integer(${ik}$), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_sstevr

     pure module subroutine stdlib${ii}$_dstevr( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
               isuppz, work, lwork, iwork,liwork, info )
           character, intent(in) :: jobz, range
           integer(${ik}$), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dstevr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$stevr( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
               isuppz, work, lwork, iwork,liwork, info )
           character, intent(in) :: jobz, range
           integer(${ik}$), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$stevr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sstevx( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
               work, iwork, ifail, info )
           character, intent(in) :: jobz, range
           integer(${ik}$), intent(in) :: il, iu, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_sstevx

     pure module subroutine stdlib${ii}$_dstevx( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
               work, iwork, ifail, info )
           character, intent(in) :: jobz, range
           integer(${ik}$), intent(in) :: il, iu, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dstevx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$stevx( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
               work, iwork, ifail, info )
           character, intent(in) :: jobz, range
           integer(${ik}$), intent(in) :: il, iu, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$stevx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_spteqr( compz, n, d, e, z, ldz, work, info )
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(sp), intent(inout) :: d(*), e(*), z(ldz,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_spteqr

     pure module subroutine stdlib${ii}$_dpteqr( compz, n, d, e, z, ldz, work, info )
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(dp), intent(inout) :: d(*), e(*), z(ldz,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dpteqr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$pteqr( compz, n, d, e, z, ldz, work, info )
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(${rk}$), intent(inout) :: d(*), e(*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$pteqr

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cpteqr( compz, n, d, e, z, ldz, work, info )
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: z(ldz,*)
     end subroutine stdlib${ii}$_cpteqr

     pure module subroutine stdlib${ii}$_zpteqr( compz, n, d, e, z, ldz, work, info )
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: work(*)
           complex(dp), intent(inout) :: z(ldz,*)
     end subroutine stdlib${ii}$_zpteqr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$pteqr( compz, n, d, e, z, ldz, work, info )
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(${ck}$), intent(inout) :: d(*), e(*)
           real(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(inout) :: z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$pteqr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sstebz( range, order, n, vl, vu, il, iu, abstol, d, e,m, nsplit, w, &
               iblock, isplit, work, iwork,info )
           character, intent(in) :: order, range
           integer(${ik}$), intent(in) :: il, iu, n
           integer(${ik}$), intent(out) :: info, m, nsplit
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: iblock(*), isplit(*), iwork(*)
           real(sp), intent(in) :: d(*), e(*)
           real(sp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_sstebz

     pure module subroutine stdlib${ii}$_dstebz( range, order, n, vl, vu, il, iu, abstol, d, e,m, nsplit, w, &
               iblock, isplit, work, iwork,info )
           character, intent(in) :: order, range
           integer(${ik}$), intent(in) :: il, iu, n
           integer(${ik}$), intent(out) :: info, m, nsplit
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: iblock(*), isplit(*), iwork(*)
           real(dp), intent(in) :: d(*), e(*)
           real(dp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_dstebz

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$stebz( range, order, n, vl, vu, il, iu, abstol, d, e,m, nsplit, w, &
               iblock, isplit, work, iwork,info )
           character, intent(in) :: order, range
           integer(${ik}$), intent(in) :: il, iu, n
           integer(${ik}$), intent(out) :: info, m, nsplit
           real(${rk}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: iblock(*), isplit(*), iwork(*)
           real(${rk}$), intent(in) :: d(*), e(*)
           real(${rk}$), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_${ri}$stebz

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_ssterf( n, d, e, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(sp), intent(inout) :: d(*), e(*)
     end subroutine stdlib${ii}$_ssterf

     pure module subroutine stdlib${ii}$_dsterf( n, d, e, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(dp), intent(inout) :: d(*), e(*)
     end subroutine stdlib${ii}$_dsterf

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$sterf( n, d, e, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(${rk}$), intent(inout) :: d(*), e(*)
     end subroutine stdlib${ii}$_${ri}$sterf

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sstedc( compz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
               
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), e(*), z(ldz,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_sstedc

     pure module subroutine stdlib${ii}$_dstedc( compz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
               
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: d(*), e(*), z(ldz,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dstedc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$stedc( compz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
               
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$stedc

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cstedc( compz, n, d, e, z, ldz, work, lwork, rwork,lrwork, iwork, &
               liwork, info )
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: z(ldz,*)
     end subroutine stdlib${ii}$_cstedc

     pure module subroutine stdlib${ii}$_zstedc( compz, n, d, e, z, ldz, work, lwork, rwork,lrwork, iwork, &
               liwork, info )
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(out) :: work(*)
           complex(dp), intent(inout) :: z(ldz,*)
     end subroutine stdlib${ii}$_zstedc

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$stedc( compz, n, d, e, z, ldz, work, lwork, rwork,lrwork, iwork, &
               liwork, info )
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(inout) :: d(*), e(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(inout) :: z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$stedc

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
               isuppz, work, lwork, iwork,liwork, info )
           character, intent(in) :: jobz, range
           integer(${ik}$), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: w(*), work(*)
           real(sp), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_sstegr

     pure module subroutine stdlib${ii}$_dstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
               isuppz, work, lwork, iwork,liwork, info )
           character, intent(in) :: jobz, range
           integer(${ik}$), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: w(*), work(*)
           real(dp), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_dstegr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$stegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
               isuppz, work, lwork, iwork,liwork, info )
           character, intent(in) :: jobz, range
           integer(${ik}$), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: w(*), work(*)
           real(${rk}$), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$stegr

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
               isuppz, work, lwork, iwork,liwork, info )
           character, intent(in) :: jobz, range
           integer(${ik}$), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: w(*), work(*)
           complex(sp), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_cstegr

     pure module subroutine stdlib${ii}$_zstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
               isuppz, work, lwork, iwork,liwork, info )
           character, intent(in) :: jobz, range
           integer(${ik}$), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: w(*), work(*)
           complex(dp), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_zstegr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$stegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
               isuppz, work, lwork, iwork,liwork, info )
           character, intent(in) :: jobz, range
           integer(${ik}$), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(${ck}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(${ck}$), intent(inout) :: d(*), e(*)
           real(${ck}$), intent(out) :: w(*), work(*)
           complex(${ck}$), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$stegr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
               info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, m, n
           integer(${ik}$), intent(in) :: iblock(*), isplit(*)
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(in) :: d(*), e(*), w(*)
           real(sp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_sstein

     pure module subroutine stdlib${ii}$_dstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
               info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, m, n
           integer(${ik}$), intent(in) :: iblock(*), isplit(*)
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(in) :: d(*), e(*), w(*)
           real(dp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dstein

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$stein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
               info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, m, n
           integer(${ik}$), intent(in) :: iblock(*), isplit(*)
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(in) :: d(*), e(*), w(*)
           real(${rk}$), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$stein

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
               info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, m, n
           integer(${ik}$), intent(in) :: iblock(*), isplit(*)
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(in) :: d(*), e(*), w(*)
           real(sp), intent(out) :: work(*)
           complex(sp), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_cstein

     pure module subroutine stdlib${ii}$_zstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
               info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, m, n
           integer(${ik}$), intent(in) :: iblock(*), isplit(*)
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(in) :: d(*), e(*), w(*)
           real(dp), intent(out) :: work(*)
           complex(dp), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_zstein

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$stein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
               info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, m, n
           integer(${ik}$), intent(in) :: iblock(*), isplit(*)
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(${ck}$), intent(in) :: d(*), e(*), w(*)
           real(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$stein

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
               isuppz, tryrac, work, lwork,iwork, liwork, info )
           character, intent(in) :: jobz, range
           logical(lk), intent(inout) :: tryrac
           integer(${ik}$), intent(in) :: il, iu, ldz, nzc, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: w(*), work(*)
           real(sp), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_sstemr

     pure module subroutine stdlib${ii}$_dstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
               isuppz, tryrac, work, lwork,iwork, liwork, info )
           character, intent(in) :: jobz, range
           logical(lk), intent(inout) :: tryrac
           integer(${ik}$), intent(in) :: il, iu, ldz, nzc, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: w(*), work(*)
           real(dp), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_dstemr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$stemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
               isuppz, tryrac, work, lwork,iwork, liwork, info )
           character, intent(in) :: jobz, range
           logical(lk), intent(inout) :: tryrac
           integer(${ik}$), intent(in) :: il, iu, ldz, nzc, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(${rk}$), intent(in) :: vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: w(*), work(*)
           real(${rk}$), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$stemr

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
               isuppz, tryrac, work, lwork,iwork, liwork, info )
           character, intent(in) :: jobz, range
           logical(lk), intent(inout) :: tryrac
           integer(${ik}$), intent(in) :: il, iu, ldz, nzc, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: w(*), work(*)
           complex(sp), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_cstemr

     pure module subroutine stdlib${ii}$_zstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
               isuppz, tryrac, work, lwork,iwork, liwork, info )
           character, intent(in) :: jobz, range
           logical(lk), intent(inout) :: tryrac
           integer(${ik}$), intent(in) :: il, iu, ldz, nzc, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: w(*), work(*)
           complex(dp), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_zstemr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$stemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
               isuppz, tryrac, work, lwork,iwork, liwork, info )
           character, intent(in) :: jobz, range
           logical(lk), intent(inout) :: tryrac
           integer(${ik}$), intent(in) :: il, iu, ldz, nzc, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(${ck}$), intent(in) :: vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(${ck}$), intent(inout) :: d(*), e(*)
           real(${ck}$), intent(out) :: w(*), work(*)
           complex(${ck}$), intent(out) :: z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$stemr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_ssteqr( compz, n, d, e, z, ldz, work, info )
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(sp), intent(inout) :: d(*), e(*), z(ldz,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_ssteqr

     pure module subroutine stdlib${ii}$_dsteqr( compz, n, d, e, z, ldz, work, info )
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(dp), intent(inout) :: d(*), e(*), z(ldz,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dsteqr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$steqr( compz, n, d, e, z, ldz, work, info )
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(${rk}$), intent(inout) :: d(*), e(*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$steqr

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_csteqr( compz, n, d, e, z, ldz, work, info )
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: z(ldz,*)
     end subroutine stdlib${ii}$_csteqr

     pure module subroutine stdlib${ii}$_zsteqr( compz, n, d, e, z, ldz, work, info )
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: work(*)
           complex(dp), intent(inout) :: z(ldz,*)
     end subroutine stdlib${ii}$_zsteqr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$steqr( compz, n, d, e, z, ldz, work, info )
           character, intent(in) :: compz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(${ck}$), intent(inout) :: d(*), e(*)
           real(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(inout) :: z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$steqr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasd0( n, sqre, d, e, u, ldu, vt, ldvt, smlsiz, iwork,work, info )
               
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu, ldvt, n, smlsiz, sqre
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_slasd0

     pure module subroutine stdlib${ii}$_dlasd0( n, sqre, d, e, u, ldu, vt, ldvt, smlsiz, iwork,work, info )
               
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu, ldvt, n, smlsiz, sqre
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_dlasd0

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasd0( n, sqre, d, e, u, ldu, vt, ldvt, smlsiz, iwork,work, info )
               
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu, ldvt, n, smlsiz, sqre
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_${ri}$lasd0

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasdt( n, lvl, nd, inode, ndiml, ndimr, msub )
           integer(${ik}$), intent(out) :: lvl, nd
           integer(${ik}$), intent(in) :: msub, n
           integer(${ik}$), intent(out) :: inode(*), ndiml(*), ndimr(*)
     end subroutine stdlib${ii}$_slasdt

     pure module subroutine stdlib${ii}$_dlasdt( n, lvl, nd, inode, ndiml, ndimr, msub )
           integer(${ik}$), intent(out) :: lvl, nd
           integer(${ik}$), intent(in) :: msub, n
           integer(${ik}$), intent(out) :: inode(*), ndiml(*), ndimr(*)
     end subroutine stdlib${ii}$_dlasdt

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasdt( n, lvl, nd, inode, ndiml, ndimr, msub )
           integer(${ik}$), intent(out) :: lvl, nd
           integer(${ik}$), intent(in) :: msub, n
           integer(${ik}$), intent(out) :: inode(*), ndiml(*), ndimr(*)
     end subroutine stdlib${ii}$_${ri}$lasdt

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasd1( nl, nr, sqre, d, alpha, beta, u, ldu, vt, ldvt,idxq, iwork, &
               work, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu, ldvt, nl, nr, sqre
           real(sp), intent(inout) :: alpha, beta
           integer(${ik}$), intent(inout) :: idxq(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), u(ldu,*), vt(ldvt,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_slasd1

     pure module subroutine stdlib${ii}$_dlasd1( nl, nr, sqre, d, alpha, beta, u, ldu, vt, ldvt,idxq, iwork, &
               work, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu, ldvt, nl, nr, sqre
           real(dp), intent(inout) :: alpha, beta
           integer(${ik}$), intent(inout) :: idxq(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: d(*), u(ldu,*), vt(ldvt,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dlasd1

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasd1( nl, nr, sqre, d, alpha, beta, u, ldu, vt, ldvt,idxq, iwork, &
               work, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu, ldvt, nl, nr, sqre
           real(${rk}$), intent(inout) :: alpha, beta
           integer(${ik}$), intent(inout) :: idxq(*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: d(*), u(ldu,*), vt(ldvt,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$lasd1

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasd2( nl, nr, sqre, k, d, z, alpha, beta, u, ldu, vt,ldvt, dsigma, &
               u2, ldu2, vt2, ldvt2, idxp, idx,idxc, idxq, coltyp, info )
           integer(${ik}$), intent(out) :: info, k
           integer(${ik}$), intent(in) :: ldu, ldu2, ldvt, ldvt2, nl, nr, sqre
           real(sp), intent(in) :: alpha, beta
           integer(${ik}$), intent(out) :: coltyp(*), idx(*), idxc(*), idxp(*)
           integer(${ik}$), intent(inout) :: idxq(*)
           real(sp), intent(inout) :: d(*), u(ldu,*), vt(ldvt,*)
           real(sp), intent(out) :: dsigma(*), u2(ldu2,*), vt2(ldvt2,*), z(*)
     end subroutine stdlib${ii}$_slasd2

     pure module subroutine stdlib${ii}$_dlasd2( nl, nr, sqre, k, d, z, alpha, beta, u, ldu, vt,ldvt, dsigma, &
               u2, ldu2, vt2, ldvt2, idxp, idx,idxc, idxq, coltyp, info )
           integer(${ik}$), intent(out) :: info, k
           integer(${ik}$), intent(in) :: ldu, ldu2, ldvt, ldvt2, nl, nr, sqre
           real(dp), intent(in) :: alpha, beta
           integer(${ik}$), intent(out) :: coltyp(*), idx(*), idxc(*), idxp(*)
           integer(${ik}$), intent(inout) :: idxq(*)
           real(dp), intent(inout) :: d(*), u(ldu,*), vt(ldvt,*)
           real(dp), intent(out) :: dsigma(*), u2(ldu2,*), vt2(ldvt2,*), z(*)
     end subroutine stdlib${ii}$_dlasd2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasd2( nl, nr, sqre, k, d, z, alpha, beta, u, ldu, vt,ldvt, dsigma, &
               u2, ldu2, vt2, ldvt2, idxp, idx,idxc, idxq, coltyp, info )
           integer(${ik}$), intent(out) :: info, k
           integer(${ik}$), intent(in) :: ldu, ldu2, ldvt, ldvt2, nl, nr, sqre
           real(${rk}$), intent(in) :: alpha, beta
           integer(${ik}$), intent(out) :: coltyp(*), idx(*), idxc(*), idxp(*)
           integer(${ik}$), intent(inout) :: idxq(*)
           real(${rk}$), intent(inout) :: d(*), u(ldu,*), vt(ldvt,*)
           real(${rk}$), intent(out) :: dsigma(*), u2(ldu2,*), vt2(ldvt2,*), z(*)
     end subroutine stdlib${ii}$_${ri}$lasd2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasd3( nl, nr, sqre, k, d, q, ldq, dsigma, u, ldu, u2,ldu2, vt, ldvt,&
                vt2, ldvt2, idxc, ctot, z,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, ldq, ldu, ldu2, ldvt, ldvt2, nl, nr, sqre
           integer(${ik}$), intent(in) :: ctot(*), idxc(*)
           real(sp), intent(out) :: d(*), q(ldq,*), u(ldu,*), vt(ldvt,*)
           real(sp), intent(inout) :: dsigma(*), vt2(ldvt2,*), z(*)
           real(sp), intent(in) :: u2(ldu2,*)
     end subroutine stdlib${ii}$_slasd3

     pure module subroutine stdlib${ii}$_dlasd3( nl, nr, sqre, k, d, q, ldq, dsigma, u, ldu, u2,ldu2, vt, ldvt,&
                vt2, ldvt2, idxc, ctot, z,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, ldq, ldu, ldu2, ldvt, ldvt2, nl, nr, sqre
           integer(${ik}$), intent(in) :: ctot(*), idxc(*)
           real(dp), intent(out) :: d(*), q(ldq,*), u(ldu,*), vt(ldvt,*)
           real(dp), intent(inout) :: dsigma(*), vt2(ldvt2,*), z(*)
           real(dp), intent(in) :: u2(ldu2,*)
     end subroutine stdlib${ii}$_dlasd3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasd3( nl, nr, sqre, k, d, q, ldq, dsigma, u, ldu, u2,ldu2, vt, ldvt,&
                vt2, ldvt2, idxc, ctot, z,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: k, ldq, ldu, ldu2, ldvt, ldvt2, nl, nr, sqre
           integer(${ik}$), intent(in) :: ctot(*), idxc(*)
           real(${rk}$), intent(out) :: d(*), q(ldq,*), u(ldu,*), vt(ldvt,*)
           real(${rk}$), intent(inout) :: dsigma(*), vt2(ldvt2,*), z(*)
           real(${rk}$), intent(in) :: u2(ldu2,*)
     end subroutine stdlib${ii}$_${ri}$lasd3

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasd4( n, i, d, z, delta, rho, sigma, work, info )
           integer(${ik}$), intent(in) :: i, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(in) :: rho
           real(sp), intent(out) :: sigma
           real(sp), intent(in) :: d(*), z(*)
           real(sp), intent(out) :: delta(*), work(*)
     end subroutine stdlib${ii}$_slasd4

     pure module subroutine stdlib${ii}$_dlasd4( n, i, d, z, delta, rho, sigma, work, info )
           integer(${ik}$), intent(in) :: i, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(in) :: rho
           real(dp), intent(out) :: sigma
           real(dp), intent(in) :: d(*), z(*)
           real(dp), intent(out) :: delta(*), work(*)
     end subroutine stdlib${ii}$_dlasd4

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasd4( n, i, d, z, delta, rho, sigma, work, info )
           integer(${ik}$), intent(in) :: i, n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(in) :: rho
           real(${rk}$), intent(out) :: sigma
           real(${rk}$), intent(in) :: d(*), z(*)
           real(${rk}$), intent(out) :: delta(*), work(*)
     end subroutine stdlib${ii}$_${ri}$lasd4

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasd5( i, d, z, delta, rho, dsigma, work )
           integer(${ik}$), intent(in) :: i
           real(sp), intent(out) :: dsigma
           real(sp), intent(in) :: rho
           real(sp), intent(in) :: d(2_${ik}$), z(2_${ik}$)
           real(sp), intent(out) :: delta(2_${ik}$), work(2_${ik}$)
     end subroutine stdlib${ii}$_slasd5

     pure module subroutine stdlib${ii}$_dlasd5( i, d, z, delta, rho, dsigma, work )
           integer(${ik}$), intent(in) :: i
           real(dp), intent(out) :: dsigma
           real(dp), intent(in) :: rho
           real(dp), intent(in) :: d(2_${ik}$), z(2_${ik}$)
           real(dp), intent(out) :: delta(2_${ik}$), work(2_${ik}$)
     end subroutine stdlib${ii}$_dlasd5

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasd5( i, d, z, delta, rho, dsigma, work )
           integer(${ik}$), intent(in) :: i
           real(${rk}$), intent(out) :: dsigma
           real(${rk}$), intent(in) :: rho
           real(${rk}$), intent(in) :: d(2_${ik}$), z(2_${ik}$)
           real(${rk}$), intent(out) :: delta(2_${ik}$), work(2_${ik}$)
     end subroutine stdlib${ii}$_${ri}$lasd5

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasdq( uplo, sqre, n, ncvt, nru, ncc, d, e, vt, ldvt,u, ldu, c, ldc, &
               work, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru, sqre
           real(sp), intent(inout) :: c(ldc,*), d(*), e(*), u(ldu,*), vt(ldvt,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_slasdq

     pure module subroutine stdlib${ii}$_dlasdq( uplo, sqre, n, ncvt, nru, ncc, d, e, vt, ldvt,u, ldu, c, ldc, &
               work, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru, sqre
           real(dp), intent(inout) :: c(ldc,*), d(*), e(*), u(ldu,*), vt(ldvt,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dlasdq

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasdq( uplo, sqre, n, ncvt, nru, ncc, d, e, vt, ldvt,u, ldu, c, ldc, &
               work, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru, sqre
           real(${rk}$), intent(inout) :: c(ldc,*), d(*), e(*), u(ldu,*), vt(ldvt,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$lasdq

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasda( icompq, smlsiz, n, sqre, d, e, u, ldu, vt, k,difl, difr, z, &
               poles, givptr, givcol, ldgcol,perm, givnum, c, s, work, iwork, info )
           integer(${ik}$), intent(in) :: icompq, ldgcol, ldu, n, smlsiz, sqre
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(out) :: givcol(ldgcol,*), givptr(*), iwork(*), k(*), perm(ldgcol,&
                     *)
           real(sp), intent(out) :: c(*), difl(ldu,*), difr(ldu,*), givnum(ldu,*), poles(ldu,*), &
                     s(*), u(ldu,*), vt(ldu,*), work(*), z(ldu,*)
           real(sp), intent(inout) :: d(*), e(*)
     end subroutine stdlib${ii}$_slasda

     pure module subroutine stdlib${ii}$_dlasda( icompq, smlsiz, n, sqre, d, e, u, ldu, vt, k,difl, difr, z, &
               poles, givptr, givcol, ldgcol,perm, givnum, c, s, work, iwork, info )
           integer(${ik}$), intent(in) :: icompq, ldgcol, ldu, n, smlsiz, sqre
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(out) :: givcol(ldgcol,*), givptr(*), iwork(*), k(*), perm(ldgcol,&
                     *)
           real(dp), intent(out) :: c(*), difl(ldu,*), difr(ldu,*), givnum(ldu,*), poles(ldu,*), &
                     s(*), u(ldu,*), vt(ldu,*), work(*), z(ldu,*)
           real(dp), intent(inout) :: d(*), e(*)
     end subroutine stdlib${ii}$_dlasda

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasda( icompq, smlsiz, n, sqre, d, e, u, ldu, vt, k,difl, difr, z, &
               poles, givptr, givcol, ldgcol,perm, givnum, c, s, work, iwork, info )
           integer(${ik}$), intent(in) :: icompq, ldgcol, ldu, n, smlsiz, sqre
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(out) :: givcol(ldgcol,*), givptr(*), iwork(*), k(*), perm(ldgcol,&
                     *)
           real(${rk}$), intent(out) :: c(*), difl(ldu,*), difr(ldu,*), givnum(ldu,*), poles(ldu,*), &
                     s(*), u(ldu,*), vt(ldu,*), work(*), z(ldu,*)
           real(${rk}$), intent(inout) :: d(*), e(*)
     end subroutine stdlib${ii}$_${ri}$lasda

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasd6( icompq, nl, nr, sqre, d, vf, vl, alpha, beta,idxq, perm, &
     givptr, givcol, ldgcol, givnum,ldgnum, poles, difl, difr, z, k, c, s, work,iwork, info )
               
           integer(${ik}$), intent(out) :: givptr, info, k
           integer(${ik}$), intent(in) :: icompq, ldgcol, ldgnum, nl, nr, sqre
           real(sp), intent(inout) :: alpha, beta
           real(sp), intent(out) :: c, s
           integer(${ik}$), intent(out) :: givcol(ldgcol,*), iwork(*), perm(*)
           integer(${ik}$), intent(inout) :: idxq(*)
           real(sp), intent(inout) :: d(*), vf(*), vl(*)
           real(sp), intent(out) :: difl(*), difr(*), givnum(ldgnum,*), poles(ldgnum,*), work(*), &
                     z(*)
     end subroutine stdlib${ii}$_slasd6

     pure module subroutine stdlib${ii}$_dlasd6( icompq, nl, nr, sqre, d, vf, vl, alpha, beta,idxq, perm, &
     givptr, givcol, ldgcol, givnum,ldgnum, poles, difl, difr, z, k, c, s, work,iwork, info )
               
           integer(${ik}$), intent(out) :: givptr, info, k
           integer(${ik}$), intent(in) :: icompq, ldgcol, ldgnum, nl, nr, sqre
           real(dp), intent(inout) :: alpha, beta
           real(dp), intent(out) :: c, s
           integer(${ik}$), intent(out) :: givcol(ldgcol,*), iwork(*), perm(*)
           integer(${ik}$), intent(inout) :: idxq(*)
           real(dp), intent(inout) :: d(*), vf(*), vl(*)
           real(dp), intent(out) :: difl(*), difr(*), givnum(ldgnum,*), poles(ldgnum,*), work(*), &
                     z(*)
     end subroutine stdlib${ii}$_dlasd6

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasd6( icompq, nl, nr, sqre, d, vf, vl, alpha, beta,idxq, perm, &
     givptr, givcol, ldgcol, givnum,ldgnum, poles, difl, difr, z, k, c, s, work,iwork, info )
               
           integer(${ik}$), intent(out) :: givptr, info, k
           integer(${ik}$), intent(in) :: icompq, ldgcol, ldgnum, nl, nr, sqre
           real(${rk}$), intent(inout) :: alpha, beta
           real(${rk}$), intent(out) :: c, s
           integer(${ik}$), intent(out) :: givcol(ldgcol,*), iwork(*), perm(*)
           integer(${ik}$), intent(inout) :: idxq(*)
           real(${rk}$), intent(inout) :: d(*), vf(*), vl(*)
           real(${rk}$), intent(out) :: difl(*), difr(*), givnum(ldgnum,*), poles(ldgnum,*), work(*), &
                     z(*)
     end subroutine stdlib${ii}$_${ri}$lasd6

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasd7( icompq, nl, nr, sqre, k, d, z, zw, vf, vfw, vl,vlw, alpha, &
     beta, dsigma, idx, idxp, idxq,perm, givptr, givcol, ldgcol, givnum, ldgnum,c, s, info )
               
           integer(${ik}$), intent(out) :: givptr, info, k
           integer(${ik}$), intent(in) :: icompq, ldgcol, ldgnum, nl, nr, sqre
           real(sp), intent(in) :: alpha, beta
           real(sp), intent(out) :: c, s
           integer(${ik}$), intent(out) :: givcol(ldgcol,*), idx(*), idxp(*), perm(*)
           integer(${ik}$), intent(inout) :: idxq(*)
           real(sp), intent(inout) :: d(*), vf(*), vl(*)
           real(sp), intent(out) :: dsigma(*), givnum(ldgnum,*), vfw(*), vlw(*), z(*), zw(*)
                     
     end subroutine stdlib${ii}$_slasd7

     pure module subroutine stdlib${ii}$_dlasd7( icompq, nl, nr, sqre, k, d, z, zw, vf, vfw, vl,vlw, alpha, &
     beta, dsigma, idx, idxp, idxq,perm, givptr, givcol, ldgcol, givnum, ldgnum,c, s, info )
               
           integer(${ik}$), intent(out) :: givptr, info, k
           integer(${ik}$), intent(in) :: icompq, ldgcol, ldgnum, nl, nr, sqre
           real(dp), intent(in) :: alpha, beta
           real(dp), intent(out) :: c, s
           integer(${ik}$), intent(out) :: givcol(ldgcol,*), idx(*), idxp(*), perm(*)
           integer(${ik}$), intent(inout) :: idxq(*)
           real(dp), intent(inout) :: d(*), vf(*), vl(*)
           real(dp), intent(out) :: dsigma(*), givnum(ldgnum,*), vfw(*), vlw(*), z(*), zw(*)
                     
     end subroutine stdlib${ii}$_dlasd7

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasd7( icompq, nl, nr, sqre, k, d, z, zw, vf, vfw, vl,vlw, alpha, &
     beta, dsigma, idx, idxp, idxq,perm, givptr, givcol, ldgcol, givnum, ldgnum,c, s, info )
               
           integer(${ik}$), intent(out) :: givptr, info, k
           integer(${ik}$), intent(in) :: icompq, ldgcol, ldgnum, nl, nr, sqre
           real(${rk}$), intent(in) :: alpha, beta
           real(${rk}$), intent(out) :: c, s
           integer(${ik}$), intent(out) :: givcol(ldgcol,*), idx(*), idxp(*), perm(*)
           integer(${ik}$), intent(inout) :: idxq(*)
           real(${rk}$), intent(inout) :: d(*), vf(*), vl(*)
           real(${rk}$), intent(out) :: dsigma(*), givnum(ldgnum,*), vfw(*), vlw(*), z(*), zw(*)
                     
     end subroutine stdlib${ii}$_${ri}$lasd7

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasd8( icompq, k, d, z, vf, vl, difl, difr, lddifr,dsigma, work, &
               info )
           integer(${ik}$), intent(in) :: icompq, k, lddifr
           integer(${ik}$), intent(out) :: info
           real(sp), intent(out) :: d(*), difl(*), difr(lddifr,*), work(*)
           real(sp), intent(inout) :: dsigma(*), vf(*), vl(*), z(*)
     end subroutine stdlib${ii}$_slasd8

     pure module subroutine stdlib${ii}$_dlasd8( icompq, k, d, z, vf, vl, difl, difr, lddifr,dsigma, work, &
               info )
           integer(${ik}$), intent(in) :: icompq, k, lddifr
           integer(${ik}$), intent(out) :: info
           real(dp), intent(out) :: d(*), difl(*), difr(lddifr,*), work(*)
           real(dp), intent(inout) :: dsigma(*), vf(*), vl(*), z(*)
     end subroutine stdlib${ii}$_dlasd8

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasd8( icompq, k, d, z, vf, vl, difl, difr, lddifr,dsigma, work, &
               info )
           integer(${ik}$), intent(in) :: icompq, k, lddifr
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(out) :: d(*), difl(*), difr(lddifr,*), work(*)
           real(${rk}$), intent(inout) :: dsigma(*), vf(*), vl(*), z(*)
     end subroutine stdlib${ii}$_${ri}$lasd8

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, info )
               
           character, intent(in) :: jobu, jobvt
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldvt, lwork, m, n
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: s(*), u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_sgesvd

     module subroutine stdlib${ii}$_dgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,vt, ldvt, work, lwork, info )
               
           character, intent(in) :: jobu, jobvt
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldvt, lwork, m, n
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: s(*), u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_dgesvd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$gesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,vt, ldvt, work, lwork, info )
               
           character, intent(in) :: jobu, jobvt
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldvt, lwork, m, n
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: s(*), u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_${ri}$gesvd

#:endif
#:endfor

     module subroutine stdlib${ii}$_cgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, rwork, &
               info )
           character, intent(in) :: jobu, jobvt
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldvt, lwork, m, n
           real(sp), intent(out) :: rwork(*), s(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_cgesvd

     module subroutine stdlib${ii}$_zgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,vt, ldvt, work, lwork, rwork, &
               info )
           character, intent(in) :: jobu, jobvt
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldvt, lwork, m, n
           real(dp), intent(out) :: rwork(*), s(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_zgesvd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$gesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,vt, ldvt, work, lwork, rwork, &
               info )
           character, intent(in) :: jobu, jobvt
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldvt, lwork, m, n
           real(${ck}$), intent(out) :: rwork(*), s(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_${ci}$gesvd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
               numrank, iwork, liwork,work, lwork, rwork, lrwork, info )
           character, intent(in) :: joba, jobp, jobr, jobu, jobv
           integer(${ik}$), intent(in) :: m, n, lda, ldu, ldv, liwork, lrwork
           integer(${ik}$), intent(out) :: numrank, info
           integer(${ik}$), intent(inout) :: lwork
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: u(ldu,*), v(ldv,*), work(*)
           real(sp), intent(out) :: s(*), rwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
     end subroutine stdlib${ii}$_sgesvdq

     module subroutine stdlib${ii}$_dgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
               numrank, iwork, liwork,work, lwork, rwork, lrwork, info )
           character, intent(in) :: joba, jobp, jobr, jobu, jobv
           integer(${ik}$), intent(in) :: m, n, lda, ldu, ldv, liwork, lrwork
           integer(${ik}$), intent(out) :: numrank, info
           integer(${ik}$), intent(inout) :: lwork
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: u(ldu,*), v(ldv,*), work(*)
           real(dp), intent(out) :: s(*), rwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
     end subroutine stdlib${ii}$_dgesvdq

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$gesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
               numrank, iwork, liwork,work, lwork, rwork, lrwork, info )
           character, intent(in) :: joba, jobp, jobr, jobu, jobv
           integer(${ik}$), intent(in) :: m, n, lda, ldu, ldv, liwork, lrwork
           integer(${ik}$), intent(out) :: numrank, info
           integer(${ik}$), intent(inout) :: lwork
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: u(ldu,*), v(ldv,*), work(*)
           real(${rk}$), intent(out) :: s(*), rwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
     end subroutine stdlib${ii}$_${ri}$gesvdq

#:endif
#:endfor

     module subroutine stdlib${ii}$_cgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
               numrank, iwork, liwork,cwork, lcwork, rwork, lrwork, info )
           character, intent(in) :: joba, jobp, jobr, jobu, jobv
           integer(${ik}$), intent(in) :: m, n, lda, ldu, ldv, liwork, lrwork
           integer(${ik}$), intent(out) :: numrank, info
           integer(${ik}$), intent(inout) :: lcwork
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: u(ldu,*), v(ldv,*), cwork(*)
           real(sp), intent(out) :: s(*), rwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
     end subroutine stdlib${ii}$_cgesvdq

     module subroutine stdlib${ii}$_zgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
               numrank, iwork, liwork,cwork, lcwork, rwork, lrwork, info )
           character, intent(in) :: joba, jobp, jobr, jobu, jobv
           integer(${ik}$), intent(in) :: m, n, lda, ldu, ldv, liwork, lrwork
           integer(${ik}$), intent(out) :: numrank, info
           integer(${ik}$), intent(inout) :: lcwork
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: u(ldu,*), v(ldv,*), cwork(*)
           real(dp), intent(out) :: s(*), rwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
     end subroutine stdlib${ii}$_zgesvdq

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$gesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
               numrank, iwork, liwork,cwork, lcwork, rwork, lrwork, info )
           character, intent(in) :: joba, jobp, jobr, jobu, jobv
           integer(${ik}$), intent(in) :: m, n, lda, ldu, ldv, liwork, lrwork
           integer(${ik}$), intent(out) :: numrank, info
           integer(${ik}$), intent(inout) :: lcwork
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: u(ldu,*), v(ldv,*), cwork(*)
           real(${ck}$), intent(out) :: s(*), rwork(*)
           integer(${ik}$), intent(out) :: iwork(*)
     end subroutine stdlib${ii}$_${ci}$gesvdq

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, iwork, info )
               
           character, intent(in) :: jobz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldvt, lwork, m, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: s(*), u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_sgesdd

     module subroutine stdlib${ii}$_dgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, iwork, info )
               
           character, intent(in) :: jobz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldvt, lwork, m, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: s(*), u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_dgesdd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$gesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, iwork, info )
               
           character, intent(in) :: jobz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldvt, lwork, m, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: s(*), u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_${ri}$gesdd

#:endif
#:endfor

     module subroutine stdlib${ii}$_cgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, rwork, iwork, &
               info )
           character, intent(in) :: jobz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldvt, lwork, m, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), s(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_cgesdd

     module subroutine stdlib${ii}$_zgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, rwork, iwork, &
               info )
           character, intent(in) :: jobz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldvt, lwork, m, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(out) :: rwork(*), s(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_zgesdd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$gesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, rwork, iwork, &
               info )
           character, intent(in) :: jobz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldvt, lwork, m, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: rwork(*), s(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_${ci}$gesdd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, ldu, &
               v, ldv,work, lwork, iwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldv, lwork, m, n
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: sva(n), u(ldu,*), v(ldv,*), work(lwork)
           integer(${ik}$), intent(out) :: iwork(*)
           character, intent(in) :: joba, jobp, jobr, jobt, jobu, jobv
     end subroutine stdlib${ii}$_sgejsv

     pure module subroutine stdlib${ii}$_dgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, ldu, &
               v, ldv,work, lwork, iwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldv, lwork, m, n
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: sva(n), u(ldu,*), v(ldv,*), work(lwork)
           integer(${ik}$), intent(out) :: iwork(*)
           character, intent(in) :: joba, jobp, jobr, jobt, jobu, jobv
     end subroutine stdlib${ii}$_dgejsv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$gejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, ldu, &
               v, ldv,work, lwork, iwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldv, lwork, m, n
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: sva(n), u(ldu,*), v(ldv,*), work(lwork)
           integer(${ik}$), intent(out) :: iwork(*)
           character, intent(in) :: joba, jobp, jobr, jobt, jobu, jobv
     end subroutine stdlib${ii}$_${ri}$gejsv

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, ldu, &
               v, ldv,cwork, lwork, rwork, lrwork, iwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldv, lwork, lrwork, m, n
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: u(ldu,*), v(ldv,*), cwork(lwork)
           real(sp), intent(out) :: sva(n), rwork(lrwork)
           integer(${ik}$), intent(out) :: iwork(*)
           character, intent(in) :: joba, jobp, jobr, jobt, jobu, jobv
     end subroutine stdlib${ii}$_cgejsv

     pure module subroutine stdlib${ii}$_zgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, ldu, &
               v, ldv,cwork, lwork, rwork, lrwork, iwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldv, lwork, lrwork, m, n
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: u(ldu,*), v(ldv,*), cwork(lwork)
           real(dp), intent(out) :: sva(n), rwork(lrwork)
           integer(${ik}$), intent(out) :: iwork(*)
           character, intent(in) :: joba, jobp, jobr, jobt, jobu, jobv
     end subroutine stdlib${ii}$_zgejsv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$gejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, ldu, &
               v, ldv,cwork, lwork, rwork, lrwork, iwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldu, ldv, lwork, lrwork, m, n
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: u(ldu,*), v(ldv,*), cwork(lwork)
           real(${ck}$), intent(out) :: sva(n), rwork(lrwork)
           integer(${ik}$), intent(out) :: iwork(*)
           character, intent(in) :: joba, jobp, jobr, jobt, jobu, jobv
     end subroutine stdlib${ii}$_${ci}$gejsv

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, work, lwork, &
               info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           real(sp), intent(inout) :: a(lda,*), v(ldv,*), work(lwork)
           real(sp), intent(out) :: sva(n)
     end subroutine stdlib${ii}$_sgesvj

     pure module subroutine stdlib${ii}$_dgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, work, lwork, &
               info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           real(dp), intent(inout) :: a(lda,*), v(ldv,*), work(lwork)
           real(dp), intent(out) :: sva(n)
     end subroutine stdlib${ii}$_dgesvj

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$gesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, work, lwork, &
               info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           real(${rk}$), intent(inout) :: a(lda,*), v(ldv,*), work(lwork)
           real(${rk}$), intent(out) :: sva(n)
     end subroutine stdlib${ii}$_${ri}$gesvj

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, cwork, lwork, &
               rwork, lrwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, lrwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           complex(sp), intent(inout) :: a(lda,*), v(ldv,*), cwork(lwork)
           real(sp), intent(inout) :: rwork(lrwork)
           real(sp), intent(out) :: sva(n)
     end subroutine stdlib${ii}$_cgesvj

     pure module subroutine stdlib${ii}$_zgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, cwork, lwork, &
               rwork, lrwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, lrwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           complex(dp), intent(inout) :: a(lda,*), v(ldv,*), cwork(lwork)
           real(dp), intent(inout) :: rwork(lrwork)
           real(dp), intent(out) :: sva(n)
     end subroutine stdlib${ii}$_zgesvj

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$gesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, cwork, lwork, &
               rwork, lrwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldv, lwork, lrwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           complex(${ck}$), intent(inout) :: a(lda,*), v(ldv,*), cwork(lwork)
           real(${ck}$), intent(inout) :: rwork(lrwork)
           real(${ck}$), intent(out) :: sva(n)
     end subroutine stdlib${ii}$_${ci}$gesvj

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, work, &
               info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           real(sp), intent(inout) :: c(ldc,*), d(*), e(*), u(ldu,*), vt(ldvt,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_sbdsqr

     pure module subroutine stdlib${ii}$_dbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, work, &
               info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           real(dp), intent(inout) :: c(ldc,*), d(*), e(*), u(ldu,*), vt(ldvt,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dbdsqr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$bdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, work, &
               info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           real(${rk}$), intent(inout) :: c(ldc,*), d(*), e(*), u(ldu,*), vt(ldvt,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$bdsqr

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, rwork,&
                info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: c(ldc,*), u(ldu,*), vt(ldvt,*)
     end subroutine stdlib${ii}$_cbdsqr

     pure module subroutine stdlib${ii}$_zbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, rwork,&
                info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: c(ldc,*), u(ldu,*), vt(ldvt,*)
     end subroutine stdlib${ii}$_zbdsqr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$bdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, rwork,&
                info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           real(${ck}$), intent(inout) :: d(*), e(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: c(ldc,*), u(ldu,*), vt(ldvt,*)
     end subroutine stdlib${ii}$_${ci}$bdsqr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sbdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,work, iwork, &
               info )
           character, intent(in) :: compq, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu, ldvt, n
           integer(${ik}$), intent(out) :: iq(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: q(*), u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_sbdsdc

     pure module subroutine stdlib${ii}$_dbdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,work, iwork, &
               info )
           character, intent(in) :: compq, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu, ldvt, n
           integer(${ik}$), intent(out) :: iq(*), iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: q(*), u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_dbdsdc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$bdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,work, iwork, &
               info )
           character, intent(in) :: compq, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu, ldvt, n
           integer(${ik}$), intent(out) :: iq(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: q(*), u(ldu,*), vt(ldvt,*), work(*)
     end subroutine stdlib${ii}$_${ri}$bdsdc

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_ssyev( jobz, uplo, n, a, lda, w, work, lwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_ssyev

     module subroutine stdlib${ii}$_dsyev( jobz, uplo, n, a, lda, w, work, lwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_dsyev

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$syev( jobz, uplo, n, a, lda, w, work, lwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_${ri}$syev

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_ssyevd( jobz, uplo, n, a, lda, w, work, lwork, iwork,liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_ssyevd

     module subroutine stdlib${ii}$_dsyevd( jobz, uplo, n, a, lda, w, work, lwork, iwork,liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_dsyevd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$syevd( jobz, uplo, n, a, lda, w, work, lwork, iwork,liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_${ri}$syevd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_ssyevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, ldz, &
               isuppz, work, lwork,iwork, liwork, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, lda, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_ssyevr

     module subroutine stdlib${ii}$_dsyevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, ldz, &
               isuppz, work, lwork,iwork, liwork, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, lda, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dsyevr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$syevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, ldz, &
               isuppz, work, lwork,iwork, liwork, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, lda, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$syevr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_ssyevx( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, ldz, &
               work, lwork, iwork,ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, lda, ldz, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_ssyevx

     module subroutine stdlib${ii}$_dsyevx( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, ldz, &
               work, lwork, iwork,ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, lda, ldz, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dsyevx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$syevx( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, ldz, &
               work, lwork, iwork,ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, lda, ldz, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$syevx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sspev( jobz, uplo, n, ap, w, z, ldz, work, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(sp), intent(inout) :: ap(*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_sspev

     module subroutine stdlib${ii}$_dspev( jobz, uplo, n, ap, w, z, ldz, work, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(dp), intent(inout) :: ap(*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dspev

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$spev( jobz, uplo, n, ap, w, z, ldz, work, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(${rk}$), intent(inout) :: ap(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$spev

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sspevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,iwork, liwork, info )
               
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: ap(*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_sspevd

     module subroutine stdlib${ii}$_dspevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,iwork, liwork, info )
               
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: ap(*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dspevd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$spevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,iwork, liwork, info )
               
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: ap(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$spevd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sspevx( jobz, range, uplo, n, ap, vl, vu, il, iu,abstol, m, w, z, ldz, &
               work, iwork, ifail,info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(inout) :: ap(*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_sspevx

     module subroutine stdlib${ii}$_dspevx( jobz, range, uplo, n, ap, vl, vu, il, iu,abstol, m, w, z, ldz, &
               work, iwork, ifail,info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(inout) :: ap(*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dspevx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$spevx( jobz, range, uplo, n, ap, vl, vu, il, iu,abstol, m, w, z, ldz, &
               work, iwork, ifail,info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(inout) :: ap(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$spevx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_ssbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldz, n
           real(sp), intent(inout) :: ab(ldab,*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_ssbev

     module subroutine stdlib${ii}$_dsbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldz, n
           real(dp), intent(inout) :: ab(ldab,*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dsbev

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$sbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldz, n
           real(${rk}$), intent(inout) :: ab(ldab,*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$sbev

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_ssbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, iwork, liwork, &
               info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: ab(ldab,*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_ssbevd

     module subroutine stdlib${ii}$_dsbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, iwork, liwork, &
               info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: ab(ldab,*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dsbevd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$sbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, iwork, liwork, &
               info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: ab(ldab,*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$sbevd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_ssbevx( jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl,vu, il, iu, abstol, &
               m, w, z, ldz, work, iwork,ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, kd, ldab, ldq, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(inout) :: ab(ldab,*)
           real(sp), intent(out) :: q(ldq,*), w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_ssbevx

     module subroutine stdlib${ii}$_dsbevx( jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl,vu, il, iu, abstol, &
               m, w, z, ldz, work, iwork,ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, kd, ldab, ldq, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(inout) :: ab(ldab,*)
           real(dp), intent(out) :: q(ldq,*), w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dsbevx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$sbevx( jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl,vu, il, iu, abstol, &
               m, w, z, ldz, work, iwork,ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, kd, ldab, ldq, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(inout) :: ab(ldab,*)
           real(${rk}$), intent(out) :: q(ldq,*), w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$sbevx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_cheev( jobz, uplo, n, a, lda, w, work, lwork, rwork,info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_cheev

     module subroutine stdlib${ii}$_zheev( jobz, uplo, n, a, lda, w, work, lwork, rwork,info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zheev

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$heev( jobz, uplo, n, a, lda, w, work, lwork, rwork,info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$heev

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_cheevd( jobz, uplo, n, a, lda, w, work, lwork, rwork,lrwork, iwork, liwork,&
                info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_cheevd

     module subroutine stdlib${ii}$_zheevd( jobz, uplo, n, a, lda, w, work, lwork, rwork,lrwork, iwork, liwork,&
                info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zheevd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$heevd( jobz, uplo, n, a, lda, w, work, lwork, rwork,lrwork, iwork, liwork,&
                info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$heevd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_cheevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, ldz, &
               isuppz, work, lwork,rwork, lrwork, iwork, liwork, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, lda, ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_cheevr

     module subroutine stdlib${ii}$_zheevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, ldz, &
               isuppz, work, lwork,rwork, lrwork, iwork, liwork, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, lda, ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_zheevr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$heevr( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, ldz, &
               isuppz, work, lwork,rwork, lrwork, iwork, liwork, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, lda, ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(${ck}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: isuppz(*), iwork(*)
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$heevr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_cheevx( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, ldz, &
               work, lwork, rwork,iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, lda, ldz, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_cheevx

     module subroutine stdlib${ii}$_zheevx( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, ldz, &
               work, lwork, rwork,iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, lda, ldz, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_zheevx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$heevx( jobz, range, uplo, n, a, lda, vl, vu, il, iu,abstol, m, w, z, ldz, &
               work, lwork, rwork,iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, lda, ldz, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(${ck}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$heevx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_chpev( jobz, uplo, n, ap, w, z, ldz, work, rwork,info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_chpev

     module subroutine stdlib${ii}$_zhpev( jobz, uplo, n, ap, w, z, ldz, work, rwork,info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: ap(*)
           complex(dp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_zhpev

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$hpev( jobz, uplo, n, ap, w, z, ldz, work, rwork,info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, n
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: ap(*)
           complex(${ck}$), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$hpev

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_chpevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,rwork, lrwork, iwork, &
               liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_chpevd

     module subroutine stdlib${ii}$_zhpevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,rwork, lrwork, iwork, &
               liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: ap(*)
           complex(dp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_zhpevd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$hpevd( jobz, uplo, n, ap, w, z, ldz, work, lwork,rwork, lrwork, iwork, &
               liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: ap(*)
           complex(${ck}$), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$hpevd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_chpevx( jobz, range, uplo, n, ap, vl, vu, il, iu,abstol, m, w, z, ldz, &
               work, rwork, iwork,ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_chpevx

     module subroutine stdlib${ii}$_zhpevx( jobz, range, uplo, n, ap, vl, vu, il, iu,abstol, m, w, z, ldz, &
               work, rwork, iwork,ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: ap(*)
           complex(dp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_zhpevx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$hpevx( jobz, range, uplo, n, ap, vl, vu, il, iu,abstol, m, w, z, ldz, &
               work, rwork, iwork,ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(${ck}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: ap(*)
           complex(${ck}$), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$hpevx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_chbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,rwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldz, n
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ab(ldab,*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_chbev

     module subroutine stdlib${ii}$_zhbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,rwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldz, n
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: ab(ldab,*)
           complex(dp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_zhbev

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$hbev( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,rwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldz, n
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: ab(ldab,*)
           complex(${ck}$), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$hbev

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_chbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, rwork, lrwork, &
               iwork, liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ab(ldab,*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_chbevd

     module subroutine stdlib${ii}$_zhbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, rwork, lrwork, &
               iwork, liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: ab(ldab,*)
           complex(dp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_zhbevd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$hbevd( jobz, uplo, n, kd, ab, ldab, w, z, ldz, work,lwork, rwork, lrwork, &
               iwork, liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: kd, ldab, ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: ab(ldab,*)
           complex(${ck}$), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$hbevd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_chbevx( jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl,vu, il, iu, abstol, &
               m, w, z, ldz, work, rwork,iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, kd, ldab, ldq, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ab(ldab,*)
           complex(sp), intent(out) :: q(ldq,*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_chbevx

     module subroutine stdlib${ii}$_zhbevx( jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl,vu, il, iu, abstol, &
               m, w, z, ldz, work, rwork,iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, kd, ldab, ldq, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: ab(ldab,*)
           complex(dp), intent(out) :: q(ldq,*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_zhbevx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$hbevx( jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl,vu, il, iu, abstol, &
               m, w, z, ldz, work, rwork,iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, kd, ldab, ldq, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(${ck}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: ab(ldab,*)
           complex(${ck}$), intent(out) :: q(ldq,*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$hbevx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasq1( n, d, e, work, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_slasq1

     pure module subroutine stdlib${ii}$_dlasq1( n, d, e, work, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dlasq1

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasq1( n, d, e, work, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$lasq1

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasq2( n, z, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(sp), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_slasq2

     pure module subroutine stdlib${ii}$_dlasq2( n, z, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(dp), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_dlasq2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasq2( n, z, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: n
           real(${rk}$), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_${ri}$lasq2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasq3( i0, n0, z, pp, dmin, sigma, desig, qmax, nfail,iter, ndiv, &
               ieee, ttype, dmin1, dmin2, dn, dn1,dn2, g, tau )
           logical(lk), intent(in) :: ieee
           integer(${ik}$), intent(in) :: i0
           integer(${ik}$), intent(inout) :: iter, n0, ndiv, nfail, pp
           real(sp), intent(inout) :: desig, dmin1, dmin2, dn, dn1, dn2, g, qmax, tau
           real(sp), intent(out) :: dmin, sigma
           integer(${ik}$), intent(inout) :: ttype
           real(sp), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_slasq3

     pure module subroutine stdlib${ii}$_dlasq3( i0, n0, z, pp, dmin, sigma, desig, qmax, nfail,iter, ndiv, &
               ieee, ttype, dmin1, dmin2, dn, dn1,dn2, g, tau )
           logical(lk), intent(in) :: ieee
           integer(${ik}$), intent(in) :: i0
           integer(${ik}$), intent(inout) :: iter, n0, ndiv, nfail, pp
           real(dp), intent(inout) :: desig, dmin1, dmin2, dn, dn1, dn2, g, qmax, tau
           real(dp), intent(out) :: dmin, sigma
           integer(${ik}$), intent(inout) :: ttype
           real(dp), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_dlasq3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasq3( i0, n0, z, pp, dmin, sigma, desig, qmax, nfail,iter, ndiv, &
               ieee, ttype, dmin1, dmin2, dn, dn1,dn2, g, tau )
           logical(lk), intent(in) :: ieee
           integer(${ik}$), intent(in) :: i0
           integer(${ik}$), intent(inout) :: iter, n0, ndiv, nfail, pp
           real(${rk}$), intent(inout) :: desig, dmin1, dmin2, dn, dn1, dn2, g, qmax, tau
           real(${rk}$), intent(out) :: dmin, sigma
           integer(${ik}$), intent(inout) :: ttype
           real(${rk}$), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_${ri}$lasq3

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasq4( i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn,dn1, dn2, tau, &
               ttype, g )
           integer(${ik}$), intent(in) :: i0, n0, n0in, pp
           integer(${ik}$), intent(out) :: ttype
           real(sp), intent(in) :: dmin, dmin1, dmin2, dn, dn1, dn2
           real(sp), intent(inout) :: g
           real(sp), intent(out) :: tau
           real(sp), intent(in) :: z(*)
     end subroutine stdlib${ii}$_slasq4

     pure module subroutine stdlib${ii}$_dlasq4( i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn,dn1, dn2, tau, &
               ttype, g )
           integer(${ik}$), intent(in) :: i0, n0, n0in, pp
           integer(${ik}$), intent(out) :: ttype
           real(dp), intent(in) :: dmin, dmin1, dmin2, dn, dn1, dn2
           real(dp), intent(inout) :: g
           real(dp), intent(out) :: tau
           real(dp), intent(in) :: z(*)
     end subroutine stdlib${ii}$_dlasq4

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasq4( i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn,dn1, dn2, tau, &
               ttype, g )
           integer(${ik}$), intent(in) :: i0, n0, n0in, pp
           integer(${ik}$), intent(out) :: ttype
           real(${rk}$), intent(in) :: dmin, dmin1, dmin2, dn, dn1, dn2
           real(${rk}$), intent(inout) :: g
           real(${rk}$), intent(out) :: tau
           real(${rk}$), intent(in) :: z(*)
     end subroutine stdlib${ii}$_${ri}$lasq4

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasq5( i0, n0, z, pp, tau, sigma, dmin, dmin1, dmin2,dn, dnm1, dnm2, &
               ieee, eps )
           logical(lk), intent(in) :: ieee
           integer(${ik}$), intent(in) :: i0, n0, pp
           real(sp), intent(out) :: dmin, dmin1, dmin2, dn, dnm1, dnm2
           real(sp), intent(inout) :: tau
           real(sp), intent(in) :: sigma, eps
           real(sp), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_slasq5

     pure module subroutine stdlib${ii}$_dlasq5( i0, n0, z, pp, tau, sigma, dmin, dmin1, dmin2,dn, dnm1, dnm2, &
               ieee, eps )
           logical(lk), intent(in) :: ieee
           integer(${ik}$), intent(in) :: i0, n0, pp
           real(dp), intent(out) :: dmin, dmin1, dmin2, dn, dnm1, dnm2
           real(dp), intent(inout) :: tau
           real(dp), intent(in) :: sigma, eps
           real(dp), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_dlasq5

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasq5( i0, n0, z, pp, tau, sigma, dmin, dmin1, dmin2,dn, dnm1, dnm2, &
               ieee, eps )
           logical(lk), intent(in) :: ieee
           integer(${ik}$), intent(in) :: i0, n0, pp
           real(${rk}$), intent(out) :: dmin, dmin1, dmin2, dn, dnm1, dnm2
           real(${rk}$), intent(inout) :: tau
           real(${rk}$), intent(in) :: sigma, eps
           real(${rk}$), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_${ri}$lasq5

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slasq6( i0, n0, z, pp, dmin, dmin1, dmin2, dn,dnm1, dnm2 )
           integer(${ik}$), intent(in) :: i0, n0, pp
           real(sp), intent(out) :: dmin, dmin1, dmin2, dn, dnm1, dnm2
           real(sp), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_slasq6

     pure module subroutine stdlib${ii}$_dlasq6( i0, n0, z, pp, dmin, dmin1, dmin2, dn,dnm1, dnm2 )
           integer(${ik}$), intent(in) :: i0, n0, pp
           real(dp), intent(out) :: dmin, dmin1, dmin2, dn, dnm1, dnm2
           real(dp), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_dlasq6

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lasq6( i0, n0, z, pp, dmin, dmin1, dmin2, dn,dnm1, dnm2 )
           integer(${ik}$), intent(in) :: i0, n0, pp
           real(${rk}$), intent(out) :: dmin, dmin1, dmin2, dn, dnm1, dnm2
           real(${rk}$), intent(inout) :: z(*)
     end subroutine stdlib${ii}$_${ri}$lasq6

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, u1, &
     ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d, b22e, work, &
               lwork, info )
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, lwork, m, p, q
           real(sp), intent(out) :: b11d(*), b11e(*), b12d(*), b12e(*), b21d(*), b21e(*), b22d(*),&
                      b22e(*), work(*)
           real(sp), intent(inout) :: phi(*), theta(*)
           real(sp), intent(inout) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*)
     end subroutine stdlib${ii}$_sbbcsd

     pure module subroutine stdlib${ii}$_dbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, u1, &
     ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d, b22e, work, &
               lwork, info )
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, lwork, m, p, q
           real(dp), intent(out) :: b11d(*), b11e(*), b12d(*), b12e(*), b21d(*), b21e(*), b22d(*),&
                      b22e(*), work(*)
           real(dp), intent(inout) :: phi(*), theta(*)
           real(dp), intent(inout) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*)
     end subroutine stdlib${ii}$_dbbcsd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$bbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, u1, &
     ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d, b22e, work, &
               lwork, info )
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, lwork, m, p, q
           real(${rk}$), intent(out) :: b11d(*), b11e(*), b12d(*), b12e(*), b21d(*), b21e(*), b22d(*),&
                      b22e(*), work(*)
           real(${rk}$), intent(inout) :: phi(*), theta(*)
           real(${rk}$), intent(inout) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*)
     end subroutine stdlib${ii}$_${ri}$bbcsd

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, u1, &
     ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d, b22e, rwork, &
               lrwork, info )
     
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, lrwork, m, p, q
           real(sp), intent(out) :: b11d(*), b11e(*), b12d(*), b12e(*), b21d(*), b21e(*), b22d(*),&
                      b22e(*), rwork(*)
           real(sp), intent(inout) :: phi(*), theta(*)
           complex(sp), intent(inout) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*)
                     
     end subroutine stdlib${ii}$_cbbcsd

     pure module subroutine stdlib${ii}$_zbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, u1, &
     ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d, b22e, rwork, &
               lrwork, info )
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, lrwork, m, p, q
           real(dp), intent(out) :: b11d(*), b11e(*), b12d(*), b12e(*), b21d(*), b21e(*), b22d(*),&
                      b22e(*), rwork(*)
           real(dp), intent(inout) :: phi(*), theta(*)
           complex(dp), intent(inout) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*)
                     
     end subroutine stdlib${ii}$_zbbcsd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$bbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, u1, &
     ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d, b22e, rwork, &
               lrwork, info )
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, lrwork, m, p, q
           real(${ck}$), intent(out) :: b11d(*), b11e(*), b12d(*), b12e(*), b21d(*), b21e(*), b22d(*),&
                      b22e(*), rwork(*)
           real(${ck}$), intent(inout) :: phi(*), theta(*)
           complex(${ck}$), intent(inout) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*)
                     
     end subroutine stdlib${ii}$_${ci}$bbcsd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     recursive module subroutine stdlib${ii}$_cuncsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, x11, &
     ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, ldv1t, v2t,ldv2t, &
               work, lwork, rwork, lrwork,iwork, info )
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, signs, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, ldx11, ldx12, ldx21, ldx22, &
                     lrwork, lwork, m, p, q
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(out) :: theta(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(out) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*), work(*)
                     
           complex(sp), intent(inout) :: x11(ldx11,*), x12(ldx12,*), x21(ldx21,*), x22(ldx22,*)
                     
     end subroutine stdlib${ii}$_cuncsd

     recursive module subroutine stdlib${ii}$_zuncsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, x11, &
     ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, ldv1t, v2t,ldv2t, &
               work, lwork, rwork, lrwork,iwork, info )
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, signs, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, ldx11, ldx12, ldx21, ldx22, &
                     lrwork, lwork, m, p, q
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(out) :: theta(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(out) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*), work(*)
                     
           complex(dp), intent(inout) :: x11(ldx11,*), x12(ldx12,*), x21(ldx21,*), x22(ldx22,*)
                     
     end subroutine stdlib${ii}$_zuncsd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     recursive module subroutine stdlib${ii}$_${ci}$uncsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, x11, &
     ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, ldv1t, v2t,ldv2t, &
               work, lwork, rwork, lrwork,iwork, info )
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, signs, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, ldx11, ldx12, ldx21, ldx22, &
                     lrwork, lwork, m, p, q
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: theta(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(out) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*), work(*)
                     
           complex(${ck}$), intent(inout) :: x11(ldx11,*), x12(ldx12,*), x21(ldx21,*), x22(ldx22,*)
                     
     end subroutine stdlib${ii}$_${ci}$uncsd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_cuncsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta, &
               u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, rwork, lrwork, iwork,info )
           character, intent(in) :: jobu1, jobu2, jobv1t
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, lwork, ldx11, ldx21, m, p, q
           integer(${ik}$), intent(in) :: lrwork
           integer(${ik}$) :: lrworkmin, lrworkopt
           real(sp), intent(out) :: rwork(*)
           real(sp), intent(out) :: theta(*)
           complex(sp), intent(out) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), work(*)
           complex(sp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
           integer(${ik}$), intent(out) :: iwork(*)
     end subroutine stdlib${ii}$_cuncsd2by1

     module subroutine stdlib${ii}$_zuncsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta, &
               u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, rwork, lrwork, iwork,info )
           character, intent(in) :: jobu1, jobu2, jobv1t
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, lwork, ldx11, ldx21, m, p, q
           integer(${ik}$), intent(in) :: lrwork
           integer(${ik}$) :: lrworkmin, lrworkopt
           real(dp), intent(out) :: rwork(*)
           real(dp), intent(out) :: theta(*)
           complex(dp), intent(out) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), work(*)
           complex(dp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
           integer(${ik}$), intent(out) :: iwork(*)
     end subroutine stdlib${ii}$_zuncsd2by1

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$uncsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta, &
               u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, rwork, lrwork, iwork,info )
           character, intent(in) :: jobu1, jobu2, jobv1t
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, lwork, ldx11, ldx21, m, p, q
           integer(${ik}$), intent(in) :: lrwork
           integer(${ik}$) :: lrworkmin, lrworkopt
           real(${ck}$), intent(out) :: rwork(*)
           real(${ck}$), intent(out) :: theta(*)
           complex(${ck}$), intent(out) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), work(*)
           complex(${ck}$), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
           integer(${ik}$), intent(out) :: iwork(*)
     end subroutine stdlib${ii}$_${ci}$uncsd2by1

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_cunbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
               ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
           character, intent(in) :: signs, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldx11, ldx12, ldx21, ldx22, lwork, m, p, q
           real(sp), intent(out) :: phi(*), theta(*)
           complex(sp), intent(out) :: taup1(*), taup2(*), tauq1(*), tauq2(*), work(*)
           complex(sp), intent(inout) :: x11(ldx11,*), x12(ldx12,*), x21(ldx21,*), x22(ldx22,*)
                     
     end subroutine stdlib${ii}$_cunbdb

     module subroutine stdlib${ii}$_zunbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
               ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
           character, intent(in) :: signs, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldx11, ldx12, ldx21, ldx22, lwork, m, p, q
           real(dp), intent(out) :: phi(*), theta(*)
           complex(dp), intent(out) :: taup1(*), taup2(*), tauq1(*), tauq2(*), work(*)
           complex(dp), intent(inout) :: x11(ldx11,*), x12(ldx12,*), x21(ldx21,*), x22(ldx22,*)
                     
     end subroutine stdlib${ii}$_zunbdb

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$unbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
               ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
           character, intent(in) :: signs, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldx11, ldx12, ldx21, ldx22, lwork, m, p, q
           real(${ck}$), intent(out) :: phi(*), theta(*)
           complex(${ck}$), intent(out) :: taup1(*), taup2(*), tauq1(*), tauq2(*), work(*)
           complex(${ck}$), intent(inout) :: x11(ldx11,*), x12(ldx12,*), x21(ldx21,*), x22(ldx22,*)
                     
     end subroutine stdlib${ii}$_${ci}$unbdb

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_cunbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(sp), intent(out) :: phi(*), theta(*)
           complex(sp), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           complex(sp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_cunbdb1

     module subroutine stdlib${ii}$_zunbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(dp), intent(out) :: phi(*), theta(*)
           complex(dp), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           complex(dp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_zunbdb1

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$unbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(${ck}$), intent(out) :: phi(*), theta(*)
           complex(${ck}$), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           complex(${ck}$), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_${ci}$unbdb1

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_cunbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(sp), intent(out) :: phi(*), theta(*)
           complex(sp), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           complex(sp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_cunbdb2

     module subroutine stdlib${ii}$_zunbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(dp), intent(out) :: phi(*), theta(*)
           complex(dp), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           complex(dp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_zunbdb2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$unbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(${ck}$), intent(out) :: phi(*), theta(*)
           complex(${ck}$), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           complex(${ck}$), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_${ci}$unbdb2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_cunbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(sp), intent(out) :: phi(*), theta(*)
           complex(sp), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           complex(sp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_cunbdb3

     module subroutine stdlib${ii}$_zunbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(dp), intent(out) :: phi(*), theta(*)
           complex(dp), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           complex(dp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_zunbdb3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$unbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(${ck}$), intent(out) :: phi(*), theta(*)
           complex(${ck}$), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           complex(${ck}$), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_${ci}$unbdb3

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_cunbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               phantom, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(sp), intent(out) :: phi(*), theta(*)
           complex(sp), intent(out) :: phantom(*), taup1(*), taup2(*), tauq1(*), work(*)
           complex(sp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_cunbdb4

     module subroutine stdlib${ii}$_zunbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               phantom, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(dp), intent(out) :: phi(*), theta(*)
           complex(dp), intent(out) :: phantom(*), taup1(*), taup2(*), tauq1(*), work(*)
           complex(dp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_zunbdb4

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$unbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               phantom, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(${ck}$), intent(out) :: phi(*), theta(*)
           complex(${ck}$), intent(out) :: phantom(*), taup1(*), taup2(*), tauq1(*), work(*)
           complex(${ck}$), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_${ci}$unbdb4

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_cunbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
               lwork, info )
           integer(${ik}$), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(${ik}$), intent(out) :: info
           complex(sp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x1(*), x2(*)
     end subroutine stdlib${ii}$_cunbdb5

     pure module subroutine stdlib${ii}$_zunbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
               lwork, info )
           integer(${ik}$), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(${ik}$), intent(out) :: info
           complex(dp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           complex(dp), intent(out) :: work(*)
           complex(dp), intent(inout) :: x1(*), x2(*)
     end subroutine stdlib${ii}$_zunbdb5

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$unbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
               lwork, info )
           integer(${ik}$), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(${ik}$), intent(out) :: info
           complex(${ck}$), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           complex(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(inout) :: x1(*), x2(*)
     end subroutine stdlib${ii}$_${ci}$unbdb5

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_cunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, lwork, info )
               
           integer(${ik}$), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(${ik}$), intent(out) :: info
           complex(sp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x1(*), x2(*)
     end subroutine stdlib${ii}$_cunbdb6

     pure module subroutine stdlib${ii}$_zunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
               lwork, info )
           integer(${ik}$), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(${ik}$), intent(out) :: info
           complex(dp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           complex(dp), intent(out) :: work(*)
           complex(dp), intent(inout) :: x1(*), x2(*)
     end subroutine stdlib${ii}$_zunbdb6

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$unbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
               lwork, info )
           integer(${ik}$), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(${ik}$), intent(out) :: info
           complex(${ck}$), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           complex(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(inout) :: x1(*), x2(*)
     end subroutine stdlib${ii}$_${ci}$unbdb6

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     recursive module subroutine stdlib${ii}$_sorcsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, x11, &
     ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, ldv1t, v2t,ldv2t, &
               work, lwork, iwork, info )
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, signs, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, ldx11, ldx12, ldx21, ldx22, &
                     lwork, m, p, q
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(out) :: theta(*)
           real(sp), intent(out) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*), work(*)
                     
           real(sp), intent(inout) :: x11(ldx11,*), x12(ldx12,*), x21(ldx21,*), x22(ldx22,*)
                     
     end subroutine stdlib${ii}$_sorcsd

     recursive module subroutine stdlib${ii}$_dorcsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, x11, &
     ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, ldv1t, v2t,ldv2t, &
               work, lwork, iwork, info )
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, signs, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, ldx11, ldx12, ldx21, ldx22, &
                     lwork, m, p, q
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(out) :: theta(*)
           real(dp), intent(out) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*), work(*)
                     
           real(dp), intent(inout) :: x11(ldx11,*), x12(ldx12,*), x21(ldx21,*), x22(ldx22,*)
                     
     end subroutine stdlib${ii}$_dorcsd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     recursive module subroutine stdlib${ii}$_${ri}$orcsd( jobu1, jobu2, jobv1t, jobv2t, trans,signs, m, p, q, x11, &
     ldx11, x12,ldx12, x21, ldx21, x22, ldx22, theta,u1, ldu1, u2, ldu2, v1t, ldv1t, v2t,ldv2t, &
               work, lwork, iwork, info )
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, signs, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, ldx11, ldx12, ldx21, ldx22, &
                     lwork, m, p, q
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(out) :: theta(*)
           real(${rk}$), intent(out) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*), work(*)
                     
           real(${rk}$), intent(inout) :: x11(ldx11,*), x12(ldx12,*), x21(ldx21,*), x22(ldx22,*)
                     
     end subroutine stdlib${ii}$_${ri}$orcsd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sorcsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta, &
               u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, iwork, info )
           character, intent(in) :: jobu1, jobu2, jobv1t
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, lwork, ldx11, ldx21, m, p, q
           real(sp), intent(out) :: theta(*)
           real(sp), intent(out) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), work(*)
           real(sp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
           integer(${ik}$), intent(out) :: iwork(*)
     end subroutine stdlib${ii}$_sorcsd2by1

     module subroutine stdlib${ii}$_dorcsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta, &
               u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, iwork, info )
           character, intent(in) :: jobu1, jobu2, jobv1t
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, lwork, ldx11, ldx21, m, p, q
           real(dp), intent(out) :: theta(*)
           real(dp), intent(out) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), work(*)
           real(dp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
           integer(${ik}$), intent(out) :: iwork(*)
     end subroutine stdlib${ii}$_dorcsd2by1

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$orcsd2by1( jobu1, jobu2, jobv1t, m, p, q, x11, ldx11,x21, ldx21, theta, &
               u1, ldu1, u2, ldu2, v1t,ldv1t, work, lwork, iwork, info )
           character, intent(in) :: jobu1, jobu2, jobv1t
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldu1, ldu2, ldv1t, lwork, ldx11, ldx21, m, p, q
           real(${rk}$), intent(out) :: theta(*)
           real(${rk}$), intent(out) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), work(*)
           real(${rk}$), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
           integer(${ik}$), intent(out) :: iwork(*)
     end subroutine stdlib${ii}$_${ri}$orcsd2by1

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sorbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
               ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
           character, intent(in) :: signs, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldx11, ldx12, ldx21, ldx22, lwork, m, p, q
           real(sp), intent(out) :: phi(*), theta(*)
           real(sp), intent(out) :: taup1(*), taup2(*), tauq1(*), tauq2(*), work(*)
           real(sp), intent(inout) :: x11(ldx11,*), x12(ldx12,*), x21(ldx21,*), x22(ldx22,*)
                     
     end subroutine stdlib${ii}$_sorbdb

     module subroutine stdlib${ii}$_dorbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
               ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
           character, intent(in) :: signs, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldx11, ldx12, ldx21, ldx22, lwork, m, p, q
           real(dp), intent(out) :: phi(*), theta(*)
           real(dp), intent(out) :: taup1(*), taup2(*), tauq1(*), tauq2(*), work(*)
           real(dp), intent(inout) :: x11(ldx11,*), x12(ldx12,*), x21(ldx21,*), x22(ldx22,*)
                     
     end subroutine stdlib${ii}$_dorbdb

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$orbdb( trans, signs, m, p, q, x11, ldx11, x12, ldx12,x21, ldx21, x22, &
               ldx22, theta, phi, taup1,taup2, tauq1, tauq2, work, lwork, info )
           character, intent(in) :: signs, trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ldx11, ldx12, ldx21, ldx22, lwork, m, p, q
           real(${rk}$), intent(out) :: phi(*), theta(*)
           real(${rk}$), intent(out) :: taup1(*), taup2(*), tauq1(*), tauq2(*), work(*)
           real(${rk}$), intent(inout) :: x11(ldx11,*), x12(ldx12,*), x21(ldx21,*), x22(ldx22,*)
                     
     end subroutine stdlib${ii}$_${ri}$orbdb

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sorbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(sp), intent(out) :: phi(*), theta(*)
           real(sp), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           real(sp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_sorbdb1

     module subroutine stdlib${ii}$_dorbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(dp), intent(out) :: phi(*), theta(*)
           real(dp), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           real(dp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_dorbdb1

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$orbdb1( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(${rk}$), intent(out) :: phi(*), theta(*)
           real(${rk}$), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           real(${rk}$), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_${ri}$orbdb1

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sorbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(sp), intent(out) :: phi(*), theta(*)
           real(sp), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           real(sp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_sorbdb2

     module subroutine stdlib${ii}$_dorbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(dp), intent(out) :: phi(*), theta(*)
           real(dp), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           real(dp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_dorbdb2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$orbdb2( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(${rk}$), intent(out) :: phi(*), theta(*)
           real(${rk}$), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           real(${rk}$), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_${ri}$orbdb2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sorbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(sp), intent(out) :: phi(*), theta(*)
           real(sp), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           real(sp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_sorbdb3

     module subroutine stdlib${ii}$_dorbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(dp), intent(out) :: phi(*), theta(*)
           real(dp), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           real(dp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_dorbdb3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$orbdb3( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               work, lwork, info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(${rk}$), intent(out) :: phi(*), theta(*)
           real(${rk}$), intent(out) :: taup1(*), taup2(*), tauq1(*), work(*)
           real(${rk}$), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_${ri}$orbdb3

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sorbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               phantom, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(sp), intent(out) :: phi(*), theta(*)
           real(sp), intent(out) :: phantom(*), taup1(*), taup2(*), tauq1(*), work(*)
           real(sp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_sorbdb4

     module subroutine stdlib${ii}$_dorbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               phantom, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(dp), intent(out) :: phi(*), theta(*)
           real(dp), intent(out) :: phantom(*), taup1(*), taup2(*), tauq1(*), work(*)
           real(dp), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_dorbdb4

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$orbdb4( m, p, q, x11, ldx11, x21, ldx21, theta, phi,taup1, taup2, tauq1, &
               phantom, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lwork, m, p, q, ldx11, ldx21
           real(${rk}$), intent(out) :: phi(*), theta(*)
           real(${rk}$), intent(out) :: phantom(*), taup1(*), taup2(*), tauq1(*), work(*)
           real(${rk}$), intent(inout) :: x11(ldx11,*), x21(ldx21,*)
     end subroutine stdlib${ii}$_${ri}$orbdb4

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sorbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
               lwork, info )
           integer(${ik}$), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           real(sp), intent(out) :: work(*)
           real(sp), intent(inout) :: x1(*), x2(*)
     end subroutine stdlib${ii}$_sorbdb5

     pure module subroutine stdlib${ii}$_dorbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
               lwork, info )
           integer(${ik}$), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           real(dp), intent(out) :: work(*)
           real(dp), intent(inout) :: x1(*), x2(*)
     end subroutine stdlib${ii}$_dorbdb5

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$orbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
               lwork, info )
           integer(${ik}$), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(inout) :: x1(*), x2(*)
     end subroutine stdlib${ii}$_${ri}$orbdb5

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
               lwork, info )
           integer(${ik}$), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(${ik}$), intent(out) :: info
           real(sp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           real(sp), intent(out) :: work(*)
           real(sp), intent(inout) :: x1(*), x2(*)
     end subroutine stdlib${ii}$_sorbdb6

     pure module subroutine stdlib${ii}$_dorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
               lwork, info )
           integer(${ik}$), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(${ik}$), intent(out) :: info
           real(dp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           real(dp), intent(out) :: work(*)
           real(dp), intent(inout) :: x1(*), x2(*)
     end subroutine stdlib${ii}$_dorbdb6

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$orbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
               lwork, info )
           integer(${ik}$), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(inout) :: x1(*), x2(*)
     end subroutine stdlib${ii}$_${ri}$orbdb6

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slapmr( forwrd, m, n, x, ldx, k )
           logical(lk), intent(in) :: forwrd
           integer(${ik}$), intent(in) :: ldx, m, n
           integer(${ik}$), intent(inout) :: k(*)
           real(sp), intent(inout) :: x(ldx,*)
     end subroutine stdlib${ii}$_slapmr

     pure module subroutine stdlib${ii}$_dlapmr( forwrd, m, n, x, ldx, k )
           logical(lk), intent(in) :: forwrd
           integer(${ik}$), intent(in) :: ldx, m, n
           integer(${ik}$), intent(inout) :: k(*)
           real(dp), intent(inout) :: x(ldx,*)
     end subroutine stdlib${ii}$_dlapmr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lapmr( forwrd, m, n, x, ldx, k )
           logical(lk), intent(in) :: forwrd
           integer(${ik}$), intent(in) :: ldx, m, n
           integer(${ik}$), intent(inout) :: k(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
     end subroutine stdlib${ii}$_${ri}$lapmr

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_clapmr( forwrd, m, n, x, ldx, k )
           logical(lk), intent(in) :: forwrd
           integer(${ik}$), intent(in) :: ldx, m, n
           integer(${ik}$), intent(inout) :: k(*)
           complex(sp), intent(inout) :: x(ldx,*)
     end subroutine stdlib${ii}$_clapmr

     pure module subroutine stdlib${ii}$_zlapmr( forwrd, m, n, x, ldx, k )
           logical(lk), intent(in) :: forwrd
           integer(${ik}$), intent(in) :: ldx, m, n
           integer(${ik}$), intent(inout) :: k(*)
           complex(dp), intent(inout) :: x(ldx,*)
     end subroutine stdlib${ii}$_zlapmr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$lapmr( forwrd, m, n, x, ldx, k )
           logical(lk), intent(in) :: forwrd
           integer(${ik}$), intent(in) :: ldx, m, n
           integer(${ik}$), intent(inout) :: k(*)
           complex(${ck}$), intent(inout) :: x(ldx,*)
     end subroutine stdlib${ii}$_${ci}$lapmr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slapmt( forwrd, m, n, x, ldx, k )
           logical(lk), intent(in) :: forwrd
           integer(${ik}$), intent(in) :: ldx, m, n
           integer(${ik}$), intent(inout) :: k(*)
           real(sp), intent(inout) :: x(ldx,*)
     end subroutine stdlib${ii}$_slapmt

     pure module subroutine stdlib${ii}$_dlapmt( forwrd, m, n, x, ldx, k )
           logical(lk), intent(in) :: forwrd
           integer(${ik}$), intent(in) :: ldx, m, n
           integer(${ik}$), intent(inout) :: k(*)
           real(dp), intent(inout) :: x(ldx,*)
     end subroutine stdlib${ii}$_dlapmt

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lapmt( forwrd, m, n, x, ldx, k )
           logical(lk), intent(in) :: forwrd
           integer(${ik}$), intent(in) :: ldx, m, n
           integer(${ik}$), intent(inout) :: k(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
     end subroutine stdlib${ii}$_${ri}$lapmt

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_clapmt( forwrd, m, n, x, ldx, k )
           logical(lk), intent(in) :: forwrd
           integer(${ik}$), intent(in) :: ldx, m, n
           integer(${ik}$), intent(inout) :: k(*)
           complex(sp), intent(inout) :: x(ldx,*)
     end subroutine stdlib${ii}$_clapmt

     pure module subroutine stdlib${ii}$_zlapmt( forwrd, m, n, x, ldx, k )
           logical(lk), intent(in) :: forwrd
           integer(${ik}$), intent(in) :: ldx, m, n
           integer(${ik}$), intent(inout) :: k(*)
           complex(dp), intent(inout) :: x(ldx,*)
     end subroutine stdlib${ii}$_zlapmt

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$lapmt( forwrd, m, n, x, ldx, k )
           logical(lk), intent(in) :: forwrd
           integer(${ik}$), intent(in) :: ldx, m, n
           integer(${ik}$), intent(inout) :: k(*)
           complex(${ck}$), intent(inout) :: x(ldx,*)
     end subroutine stdlib${ii}$_${ci}$lapmt

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_ssygv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, lwork, n
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_ssygv

     module subroutine stdlib${ii}$_dsygv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, lwork, n
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_dsygv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$sygv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, lwork, n
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_${ri}$sygv

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_ssygvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, iwork, liwork,&
                info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_ssygvd

     module subroutine stdlib${ii}$_dsygvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, iwork, liwork,&
                info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_dsygvd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$sygvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, iwork, liwork,&
                info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: w(*), work(*)
     end subroutine stdlib${ii}$_${ri}$sygvd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_ssygvx( itype, jobz, range, uplo, n, a, lda, b, ldb,vl, vu, il, iu, abstol,&
                m, w, z, ldz, work,lwork, iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, itype, iu, lda, ldb, ldz, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_ssygvx

     module subroutine stdlib${ii}$_dsygvx( itype, jobz, range, uplo, n, a, lda, b, ldb,vl, vu, il, iu, abstol,&
                m, w, z, ldz, work,lwork, iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, itype, iu, lda, ldb, ldz, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dsygvx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$sygvx( itype, jobz, range, uplo, n, a, lda, b, ldb,vl, vu, il, iu, abstol,&
                m, w, z, ldz, work,lwork, iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, itype, iu, lda, ldb, ldz, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$sygvx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sspgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, ldz, n
           real(sp), intent(inout) :: ap(*), bp(*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_sspgv

     module subroutine stdlib${ii}$_dspgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, ldz, n
           real(dp), intent(inout) :: ap(*), bp(*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dspgv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$spgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, ldz, n
           real(${rk}$), intent(inout) :: ap(*), bp(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$spgv

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sspgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, iwork, liwork,&
                info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: ap(*), bp(*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_sspgvd

     module subroutine stdlib${ii}$_dspgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, iwork, liwork,&
                info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: ap(*), bp(*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dspgvd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$spgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, iwork, liwork,&
                info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: ap(*), bp(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$spgvd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sspgvx( itype, jobz, range, uplo, n, ap, bp, vl, vu,il, iu, abstol, m, w, &
               z, ldz, work, iwork,ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, itype, iu, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(inout) :: ap(*), bp(*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_sspgvx

     module subroutine stdlib${ii}$_dspgvx( itype, jobz, range, uplo, n, ap, bp, vl, vu,il, iu, abstol, m, w, &
               z, ldz, work, iwork,ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, itype, iu, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(inout) :: ap(*), bp(*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dspgvx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$spgvx( itype, jobz, range, uplo, n, ap, bp, vl, vu,il, iu, abstol, m, w, &
               z, ldz, work, iwork,ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, itype, iu, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(inout) :: ap(*), bp(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$spgvx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_ssbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
               info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldz, n
           real(sp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_ssbgv

     pure module subroutine stdlib${ii}$_dsbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
               info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldz, n
           real(dp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dsbgv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$sbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
               info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldz, n
           real(${rk}$), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$sbgv

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_ssbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
               lwork, iwork, liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_ssbgvd

     pure module subroutine stdlib${ii}$_dsbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
               lwork, iwork, liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dsbgvd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$sbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
               lwork, iwork, liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldz, liwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$sbgvd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_ssbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,ldbb, q, ldq, vl, &
               vu, il, iu, abstol, m, w, z,ldz, work, iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, ka, kb, ldab, ldbb, ldq, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(sp), intent(out) :: q(ldq,*), w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_ssbgvx

     pure module subroutine stdlib${ii}$_dsbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,ldbb, q, ldq, vl, &
               vu, il, iu, abstol, m, w, z,ldz, work, iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, ka, kb, ldab, ldbb, ldq, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(dp), intent(out) :: q(ldq,*), w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_dsbgvx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$sbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,ldbb, q, ldq, vl, &
               vu, il, iu, abstol, m, w, z,ldz, work, iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, ka, kb, ldab, ldbb, ldq, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(${rk}$), intent(out) :: q(ldq,*), w(*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ri}$sbgvx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_ssytrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: d(*), e(*), tau(*), work(*)
     end subroutine stdlib${ii}$_ssytrd

     pure module subroutine stdlib${ii}$_dsytrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: d(*), e(*), tau(*), work(*)
     end subroutine stdlib${ii}$_dsytrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$sytrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: d(*), e(*), tau(*), work(*)
     end subroutine stdlib${ii}$_${ri}$sytrd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_ssytd2( uplo, n, a, lda, d, e, tau, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, n
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: d(*), e(*), tau(*)
     end subroutine stdlib${ii}$_ssytd2

     pure module subroutine stdlib${ii}$_dsytd2( uplo, n, a, lda, d, e, tau, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, n
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: d(*), e(*), tau(*)
     end subroutine stdlib${ii}$_dsytd2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$sytd2( uplo, n, a, lda, d, e, tau, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, n
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: d(*), e(*), tau(*)
     end subroutine stdlib${ii}$_${ri}$sytd2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sorgtr( uplo, n, a, lda, tau, work, lwork, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(in) :: tau(*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_sorgtr

     pure module subroutine stdlib${ii}$_dorgtr( uplo, n, a, lda, tau, work, lwork, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(in) :: tau(*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dorgtr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$orgtr( uplo, n, a, lda, tau, work, lwork, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$orgtr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sormtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
               info )
           character, intent(in) :: side, trans, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldc, lwork, m, n
           real(sp), intent(inout) :: a(lda,*), c(ldc,*)
           real(sp), intent(in) :: tau(*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_sormtr

     pure module subroutine stdlib${ii}$_dormtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
               info )
           character, intent(in) :: side, trans, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldc, lwork, m, n
           real(dp), intent(inout) :: a(lda,*), c(ldc,*)
           real(dp), intent(in) :: tau(*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dormtr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$ormtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
               info )
           character, intent(in) :: side, trans, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldc, lwork, m, n
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$ormtr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_ssb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, lda, &
               v, tau, ldvt, work)
           character, intent(in) :: uplo
           logical(lk), intent(in) :: wantz
           integer(${ik}$), intent(in) :: ttype, st, ed, sweep, n, nb, ib, lda, ldvt
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: v(*), tau(*), work(*)
     end subroutine stdlib${ii}$_ssb2st_kernels

     pure module subroutine stdlib${ii}$_dsb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, lda, &
               v, tau, ldvt, work)
           character, intent(in) :: uplo
           logical(lk), intent(in) :: wantz
           integer(${ik}$), intent(in) :: ttype, st, ed, sweep, n, nb, ib, lda, ldvt
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: v(*), tau(*), work(*)
     end subroutine stdlib${ii}$_dsb2st_kernels

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$sb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, lda, &
               v, tau, ldvt, work)
           character, intent(in) :: uplo
           logical(lk), intent(in) :: wantz
           integer(${ik}$), intent(in) :: ttype, st, ed, sweep, n, nb, ib, lda, ldvt
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: v(*), tau(*), work(*)
     end subroutine stdlib${ii}$_${ri}$sb2st_kernels

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_chegv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, info )
               
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, lwork, n
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_chegv

     module subroutine stdlib${ii}$_zhegv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, info )
               
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, lwork, n
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zhegv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$hegv( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, info )
               
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, lwork, n
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$hegv

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_chegvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, lrwork,&
                iwork, liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_chegvd

     module subroutine stdlib${ii}$_zhegvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, lrwork,&
                iwork, liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zhegvd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$hegvd( itype, jobz, uplo, n, a, lda, b, ldb, w, work,lwork, rwork, lrwork,&
                iwork, liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, lda, ldb, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$hegvd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_chegvx( itype, jobz, range, uplo, n, a, lda, b, ldb,vl, vu, il, iu, abstol,&
                m, w, z, ldz, work,lwork, rwork, iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, itype, iu, lda, ldb, ldz, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_chegvx

     module subroutine stdlib${ii}$_zhegvx( itype, jobz, range, uplo, n, a, lda, b, ldb,vl, vu, il, iu, abstol,&
                m, w, z, ldz, work,lwork, rwork, iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, itype, iu, lda, ldb, ldz, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_zhegvx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$hegvx( itype, jobz, range, uplo, n, a, lda, b, ldb,vl, vu, il, iu, abstol,&
                m, w, z, ldz, work,lwork, rwork, iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, itype, iu, lda, ldb, ldz, lwork, n
           integer(${ik}$), intent(out) :: info, m
           real(${ck}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$hegvx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_chpgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,rwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, ldz, n
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ap(*), bp(*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_chpgv

     module subroutine stdlib${ii}$_zhpgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,rwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, ldz, n
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: ap(*), bp(*)
           complex(dp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_zhpgv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$hpgv( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,rwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, ldz, n
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: ap(*), bp(*)
           complex(${ck}$), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$hpgv

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_chpgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, rwork, lrwork,&
                iwork, liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ap(*), bp(*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_chpgvd

     module subroutine stdlib${ii}$_zhpgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, rwork, lrwork,&
                iwork, liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: ap(*), bp(*)
           complex(dp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_zhpgvd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$hpgvd( itype, jobz, uplo, n, ap, bp, w, z, ldz, work,lwork, rwork, lrwork,&
                iwork, liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: itype, ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: ap(*), bp(*)
           complex(${ck}$), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$hpgvd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_chpgvx( itype, jobz, range, uplo, n, ap, bp, vl, vu,il, iu, abstol, m, w, &
               z, ldz, work, rwork,iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, itype, iu, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ap(*), bp(*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_chpgvx

     module subroutine stdlib${ii}$_zhpgvx( itype, jobz, range, uplo, n, ap, bp, vl, vu,il, iu, abstol, m, w, &
               z, ldz, work, rwork,iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, itype, iu, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: ap(*), bp(*)
           complex(dp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_zhpgvx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$hpgvx( itype, jobz, range, uplo, n, ap, bp, vl, vu,il, iu, abstol, m, w, &
               z, ldz, work, rwork,iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, itype, iu, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(${ck}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: ap(*), bp(*)
           complex(${ck}$), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$hpgvx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_chbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
               rwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldz, n
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_chbgv

     pure module subroutine stdlib${ii}$_zhbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
               rwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldz, n
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(dp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_zhbgv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$hbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
               rwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldz, n
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(${ck}$), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$hbgv

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_chbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
               lwork, rwork, lrwork, iwork,liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_chbgvd

     pure module subroutine stdlib${ii}$_zhbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
               lwork, rwork, lrwork, iwork,liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(dp), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_zhbgvd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$hbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
               lwork, rwork, lrwork, iwork,liwork, info )
           character, intent(in) :: jobz, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: ka, kb, ldab, ldbb, ldz, liwork, lrwork, lwork, n
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(${ck}$), intent(out) :: work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$hbgvd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_chbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,ldbb, q, ldq, vl, &
               vu, il, iu, abstol, m, w, z,ldz, work, rwork, iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, ka, kb, ldab, ldbb, ldq, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(sp), intent(out) :: q(ldq,*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_chbgvx

     pure module subroutine stdlib${ii}$_zhbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,ldbb, q, ldq, vl, &
               vu, il, iu, abstol, m, w, z,ldz, work, rwork, iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, ka, kb, ldab, ldbb, ldq, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(dp), intent(out) :: q(ldq,*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_zhbgvx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$hbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,ldbb, q, ldq, vl, &
               vu, il, iu, abstol, m, w, z,ldz, work, rwork, iwork, ifail, info )
           character, intent(in) :: jobz, range, uplo
           integer(${ik}$), intent(in) :: il, iu, ka, kb, ldab, ldbb, ldq, ldz, n
           integer(${ik}$), intent(out) :: info, m
           real(${ck}$), intent(in) :: abstol, vl, vu
           integer(${ik}$), intent(out) :: ifail(*), iwork(*)
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(${ck}$), intent(out) :: q(ldq,*), work(*), z(ldz,*)
     end subroutine stdlib${ii}$_${ci}$hbgvx

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_chetrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
     end subroutine stdlib${ii}$_chetrd

     pure module subroutine stdlib${ii}$_zhetrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           real(dp), intent(out) :: d(*), e(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: tau(*), work(*)
     end subroutine stdlib${ii}$_zhetrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$hetrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           real(${ck}$), intent(out) :: d(*), e(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: tau(*), work(*)
     end subroutine stdlib${ii}$_${ci}$hetrd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_chetd2( uplo, n, a, lda, d, e, tau, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, n
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*)
     end subroutine stdlib${ii}$_chetd2

     pure module subroutine stdlib${ii}$_zhetd2( uplo, n, a, lda, d, e, tau, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, n
           real(dp), intent(out) :: d(*), e(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: tau(*)
     end subroutine stdlib${ii}$_zhetd2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$hetd2( uplo, n, a, lda, d, e, tau, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, n
           real(${ck}$), intent(out) :: d(*), e(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: tau(*)
     end subroutine stdlib${ii}$_${ci}$hetd2

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_cungtr( uplo, n, a, lda, tau, work, lwork, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_cungtr

     pure module subroutine stdlib${ii}$_zungtr( uplo, n, a, lda, tau, work, lwork, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(in) :: tau(*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zungtr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$ungtr( uplo, n, a, lda, tau, work, lwork, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, lwork, n
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(in) :: tau(*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$ungtr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_cunmtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
               info )
           character, intent(in) :: side, trans, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldc, lwork, m, n
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_cunmtr

     pure module subroutine stdlib${ii}$_zunmtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
               info )
           character, intent(in) :: side, trans, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldc, lwork, m, n
           complex(dp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(dp), intent(in) :: tau(*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zunmtr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$unmtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
               info )
           character, intent(in) :: side, trans, uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldc, lwork, m, n
           complex(${ck}$), intent(inout) :: a(lda,*), c(ldc,*)
           complex(${ck}$), intent(in) :: tau(*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$unmtr

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_chetrd_he2hb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info )
               
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldab, lwork, n, kd
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: ab(ldab,*), tau(*), work(*)
     end subroutine stdlib${ii}$_chetrd_he2hb

     module subroutine stdlib${ii}$_zhetrd_he2hb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info )
               
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldab, lwork, n, kd
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: ab(ldab,*), tau(*), work(*)
     end subroutine stdlib${ii}$_zhetrd_he2hb

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$hetrd_he2hb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info )
               
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldab, lwork, n, kd
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: ab(ldab,*), tau(*), work(*)
     end subroutine stdlib${ii}$_${ci}$hetrd_he2hb

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_chetrd_hb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, lhous, &
               work, lwork, info )
           character, intent(in) :: stage1, uplo, vect
           integer(${ik}$), intent(in) :: n, kd, ldab, lhous, lwork
           integer(${ik}$), intent(out) :: info
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: ab(ldab,*)
           complex(sp), intent(out) :: hous(*), work(*)
     end subroutine stdlib${ii}$_chetrd_hb2st

     module subroutine stdlib${ii}$_zhetrd_hb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, lhous, &
               work, lwork, info )
           character, intent(in) :: stage1, uplo, vect
           integer(${ik}$), intent(in) :: n, kd, ldab, lhous, lwork
           integer(${ik}$), intent(out) :: info
           real(dp), intent(out) :: d(*), e(*)
           complex(dp), intent(inout) :: ab(ldab,*)
           complex(dp), intent(out) :: hous(*), work(*)
     end subroutine stdlib${ii}$_zhetrd_hb2st

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$hetrd_hb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, lhous, &
               work, lwork, info )
           character, intent(in) :: stage1, uplo, vect
           integer(${ik}$), intent(in) :: n, kd, ldab, lhous, lwork
           integer(${ik}$), intent(out) :: info
           real(${ck}$), intent(out) :: d(*), e(*)
           complex(${ck}$), intent(inout) :: ab(ldab,*)
           complex(${ck}$), intent(out) :: hous(*), work(*)
     end subroutine stdlib${ii}$_${ci}$hetrd_hb2st

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_chb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, lda, &
               v, tau, ldvt, work)
           character, intent(in) :: uplo
           logical(lk), intent(in) :: wantz
           integer(${ik}$), intent(in) :: ttype, st, ed, sweep, n, nb, ib, lda, ldvt
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: v(*), tau(*), work(*)
     end subroutine stdlib${ii}$_chb2st_kernels

     pure module subroutine stdlib${ii}$_zhb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, lda, &
               v, tau, ldvt, work)
           character, intent(in) :: uplo
           logical(lk), intent(in) :: wantz
           integer(${ik}$), intent(in) :: ttype, st, ed, sweep, n, nb, ib, lda, ldvt
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: v(*), tau(*), work(*)
     end subroutine stdlib${ii}$_zhb2st_kernels

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$hb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, lda, &
               v, tau, ldvt, work)
           character, intent(in) :: uplo
           logical(lk), intent(in) :: wantz
           integer(${ik}$), intent(in) :: ttype, st, ed, sweep, n, nb, ib, lda, ldvt
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: v(*), tau(*), work(*)
     end subroutine stdlib${ii}$_${ci}$hb2st_kernels

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_ssytrd_sb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, lhous, &
               work, lwork, info )
           character, intent(in) :: stage1, uplo, vect
           integer(${ik}$), intent(in) :: n, kd, ldab, lhous, lwork
           integer(${ik}$), intent(out) :: info
           real(sp), intent(out) :: d(*), e(*)
           real(sp), intent(inout) :: ab(ldab,*)
           real(sp), intent(out) :: hous(*), work(*)
     end subroutine stdlib${ii}$_ssytrd_sb2st

     module subroutine stdlib${ii}$_dsytrd_sb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, lhous, &
               work, lwork, info )
           character, intent(in) :: stage1, uplo, vect
           integer(${ik}$), intent(in) :: n, kd, ldab, lhous, lwork
           integer(${ik}$), intent(out) :: info
           real(dp), intent(out) :: d(*), e(*)
           real(dp), intent(inout) :: ab(ldab,*)
           real(dp), intent(out) :: hous(*), work(*)
     end subroutine stdlib${ii}$_dsytrd_sb2st

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$sytrd_sb2st( stage1, vect, uplo, n, kd, ab, ldab,d, e, hous, lhous, &
               work, lwork, info )
           character, intent(in) :: stage1, uplo, vect
           integer(${ik}$), intent(in) :: n, kd, ldab, lhous, lwork
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(out) :: d(*), e(*)
           real(${rk}$), intent(inout) :: ab(ldab,*)
           real(${rk}$), intent(out) :: hous(*), work(*)
     end subroutine stdlib${ii}$_${ri}$sytrd_sb2st

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_ssytrd_sy2sb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info )
               
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldab, lwork, n, kd
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: ab(ldab,*), tau(*), work(*)
     end subroutine stdlib${ii}$_ssytrd_sy2sb

     module subroutine stdlib${ii}$_dsytrd_sy2sb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info )
               
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldab, lwork, n, kd
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: ab(ldab,*), tau(*), work(*)
     end subroutine stdlib${ii}$_dsytrd_sy2sb

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$sytrd_sy2sb( uplo, n, kd, a, lda, ab, ldab, tau,work, lwork, info )
               
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldab, lwork, n, kd
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: ab(ldab,*), tau(*), work(*)
     end subroutine stdlib${ii}$_${ri}$sytrd_sy2sb

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slaic1( job, j, x, sest, w, gamma, sestpr, s, c )
           integer(${ik}$), intent(in) :: j, job
           real(sp), intent(out) :: c, s, sestpr
           real(sp), intent(in) :: gamma, sest
           real(sp), intent(in) :: w(j), x(j)
     end subroutine stdlib${ii}$_slaic1

     pure module subroutine stdlib${ii}$_dlaic1( job, j, x, sest, w, gamma, sestpr, s, c )
           integer(${ik}$), intent(in) :: j, job
           real(dp), intent(out) :: c, s, sestpr
           real(dp), intent(in) :: gamma, sest
           real(dp), intent(in) :: w(j), x(j)
     end subroutine stdlib${ii}$_dlaic1

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$laic1( job, j, x, sest, w, gamma, sestpr, s, c )
           integer(${ik}$), intent(in) :: j, job
           real(${rk}$), intent(out) :: c, s, sestpr
           real(${rk}$), intent(in) :: gamma, sest
           real(${rk}$), intent(in) :: w(j), x(j)
     end subroutine stdlib${ii}$_${ri}$laic1

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_claic1( job, j, x, sest, w, gamma, sestpr, s, c )
           integer(${ik}$), intent(in) :: j, job
           real(sp), intent(in) :: sest
           real(sp), intent(out) :: sestpr
           complex(sp), intent(out) :: c, s
           complex(sp), intent(in) :: gamma
           complex(sp), intent(in) :: w(j), x(j)
     end subroutine stdlib${ii}$_claic1

     pure module subroutine stdlib${ii}$_zlaic1( job, j, x, sest, w, gamma, sestpr, s, c )
           integer(${ik}$), intent(in) :: j, job
           real(dp), intent(in) :: sest
           real(dp), intent(out) :: sestpr
           complex(dp), intent(out) :: c, s
           complex(dp), intent(in) :: gamma
           complex(dp), intent(in) :: w(j), x(j)
     end subroutine stdlib${ii}$_zlaic1

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$laic1( job, j, x, sest, w, gamma, sestpr, s, c )
           integer(${ik}$), intent(in) :: j, job
           real(${ck}$), intent(in) :: sest
           real(${ck}$), intent(out) :: sestpr
           complex(${ck}$), intent(out) :: c, s
           complex(${ck}$), intent(in) :: gamma
           complex(${ck}$), intent(in) :: w(j), x(j)
     end subroutine stdlib${ii}$_${ci}$laic1

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
               givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, work, info )
           integer(${ik}$), intent(in) :: givptr, icompq, k, ldb, ldbx, ldgcol, ldgnum, nl, nr, nrhs,&
                      sqre
           integer(${ik}$), intent(out) :: info
           real(sp), intent(in) :: c, s
           integer(${ik}$), intent(in) :: givcol(ldgcol,*), perm(*)
           real(sp), intent(inout) :: b(ldb,*)
           real(sp), intent(out) :: bx(ldbx,*), work(*)
           real(sp), intent(in) :: difl(*), difr(ldgnum,*), givnum(ldgnum,*), poles(ldgnum,*), z(&
                     *)
     end subroutine stdlib${ii}$_slals0

     pure module subroutine stdlib${ii}$_dlals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
               givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, work, info )
           integer(${ik}$), intent(in) :: givptr, icompq, k, ldb, ldbx, ldgcol, ldgnum, nl, nr, nrhs,&
                      sqre
           integer(${ik}$), intent(out) :: info
           real(dp), intent(in) :: c, s
           integer(${ik}$), intent(in) :: givcol(ldgcol,*), perm(*)
           real(dp), intent(inout) :: b(ldb,*)
           real(dp), intent(out) :: bx(ldbx,*), work(*)
           real(dp), intent(in) :: difl(*), difr(ldgnum,*), givnum(ldgnum,*), poles(ldgnum,*), z(&
                     *)
     end subroutine stdlib${ii}$_dlals0

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
               givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, work, info )
           integer(${ik}$), intent(in) :: givptr, icompq, k, ldb, ldbx, ldgcol, ldgnum, nl, nr, nrhs,&
                      sqre
           integer(${ik}$), intent(out) :: info
           real(${rk}$), intent(in) :: c, s
           integer(${ik}$), intent(in) :: givcol(ldgcol,*), perm(*)
           real(${rk}$), intent(inout) :: b(ldb,*)
           real(${rk}$), intent(out) :: bx(ldbx,*), work(*)
           real(${rk}$), intent(in) :: difl(*), difr(ldgnum,*), givnum(ldgnum,*), poles(ldgnum,*), z(&
                     *)
     end subroutine stdlib${ii}$_${ri}$lals0

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_clals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
               givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, rwork, info )
           integer(${ik}$), intent(in) :: givptr, icompq, k, ldb, ldbx, ldgcol, ldgnum, nl, nr, nrhs,&
                      sqre
           integer(${ik}$), intent(out) :: info
           real(sp), intent(in) :: c, s
           integer(${ik}$), intent(in) :: givcol(ldgcol,*), perm(*)
           real(sp), intent(in) :: difl(*), difr(ldgnum,*), givnum(ldgnum,*), poles(ldgnum,*), z(&
                     *)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: b(ldb,*)
           complex(sp), intent(out) :: bx(ldbx,*)
     end subroutine stdlib${ii}$_clals0

     pure module subroutine stdlib${ii}$_zlals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
               givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, rwork, info )
           integer(${ik}$), intent(in) :: givptr, icompq, k, ldb, ldbx, ldgcol, ldgnum, nl, nr, nrhs,&
                      sqre
           integer(${ik}$), intent(out) :: info
           real(dp), intent(in) :: c, s
           integer(${ik}$), intent(in) :: givcol(ldgcol,*), perm(*)
           real(dp), intent(in) :: difl(*), difr(ldgnum,*), givnum(ldgnum,*), poles(ldgnum,*), z(&
                     *)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: b(ldb,*)
           complex(dp), intent(out) :: bx(ldbx,*)
     end subroutine stdlib${ii}$_zlals0

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$lals0( icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx,perm, givptr, &
               givcol, ldgcol, givnum, ldgnum,poles, difl, difr, z, k, c, s, rwork, info )
           integer(${ik}$), intent(in) :: givptr, icompq, k, ldb, ldbx, ldgcol, ldgnum, nl, nr, nrhs,&
                      sqre
           integer(${ik}$), intent(out) :: info
           real(${ck}$), intent(in) :: c, s
           integer(${ik}$), intent(in) :: givcol(ldgcol,*), perm(*)
           real(${ck}$), intent(in) :: difl(*), difr(ldgnum,*), givnum(ldgnum,*), poles(ldgnum,*), z(&
                     *)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: b(ldb,*)
           complex(${ck}$), intent(out) :: bx(ldbx,*)
     end subroutine stdlib${ii}$_${ci}$lals0

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, difl,&
                difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, work,iwork, info )
           integer(${ik}$), intent(in) :: icompq, ldb, ldbx, ldgcol, ldu, n, nrhs, smlsiz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: givcol(ldgcol,*), givptr(*), k(*), perm(ldgcol,*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: b(ldb,*)
           real(sp), intent(out) :: bx(ldbx,*), work(*)
           real(sp), intent(in) :: c(*), difl(ldu,*), difr(ldu,*), givnum(ldu,*), poles(ldu,*), s(&
                     *), u(ldu,*), vt(ldu,*), z(ldu,*)
     end subroutine stdlib${ii}$_slalsa

     pure module subroutine stdlib${ii}$_dlalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, difl,&
                difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, work,iwork, info )
           integer(${ik}$), intent(in) :: icompq, ldb, ldbx, ldgcol, ldu, n, nrhs, smlsiz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: givcol(ldgcol,*), givptr(*), k(*), perm(ldgcol,*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: b(ldb,*)
           real(dp), intent(out) :: bx(ldbx,*), work(*)
           real(dp), intent(in) :: c(*), difl(ldu,*), difr(ldu,*), givnum(ldu,*), poles(ldu,*), s(&
                     *), u(ldu,*), vt(ldu,*), z(ldu,*)
     end subroutine stdlib${ii}$_dlalsa

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, difl,&
                difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, work,iwork, info )
           integer(${ik}$), intent(in) :: icompq, ldb, ldbx, ldgcol, ldu, n, nrhs, smlsiz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: givcol(ldgcol,*), givptr(*), k(*), perm(ldgcol,*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: b(ldb,*)
           real(${rk}$), intent(out) :: bx(ldbx,*), work(*)
           real(${rk}$), intent(in) :: c(*), difl(ldu,*), difr(ldu,*), givnum(ldu,*), poles(ldu,*), s(&
                     *), u(ldu,*), vt(ldu,*), z(ldu,*)
     end subroutine stdlib${ii}$_${ri}$lalsa

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_clalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, difl,&
                difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, rwork,iwork, info )
           integer(${ik}$), intent(in) :: icompq, ldb, ldbx, ldgcol, ldu, n, nrhs, smlsiz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: givcol(ldgcol,*), givptr(*), k(*), perm(ldgcol,*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(in) :: c(*), difl(ldu,*), difr(ldu,*), givnum(ldu,*), poles(ldu,*), s(&
                     *), u(ldu,*), vt(ldu,*), z(ldu,*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: b(ldb,*)
           complex(sp), intent(out) :: bx(ldbx,*)
     end subroutine stdlib${ii}$_clalsa

     pure module subroutine stdlib${ii}$_zlalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, difl,&
                difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, rwork,iwork, info )
           integer(${ik}$), intent(in) :: icompq, ldb, ldbx, ldgcol, ldu, n, nrhs, smlsiz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: givcol(ldgcol,*), givptr(*), k(*), perm(ldgcol,*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(in) :: c(*), difl(ldu,*), difr(ldu,*), givnum(ldu,*), poles(ldu,*), s(&
                     *), u(ldu,*), vt(ldu,*), z(ldu,*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: b(ldb,*)
           complex(dp), intent(out) :: bx(ldbx,*)
     end subroutine stdlib${ii}$_zlalsa

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$lalsa( icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u,ldu, vt, k, difl,&
                difr, z, poles, givptr,givcol, ldgcol, perm, givnum, c, s, rwork,iwork, info )
           integer(${ik}$), intent(in) :: icompq, ldb, ldbx, ldgcol, ldu, n, nrhs, smlsiz
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: givcol(ldgcol,*), givptr(*), k(*), perm(ldgcol,*)
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(in) :: c(*), difl(ldu,*), difr(ldu,*), givnum(ldu,*), poles(ldu,*), s(&
                     *), u(ldu,*), vt(ldu,*), z(ldu,*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: b(ldb,*)
           complex(${ck}$), intent(out) :: bx(ldbx,*)
     end subroutine stdlib${ii}$_${ci}$lalsa

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_slalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, iwork, &
               info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: ldb, n, nrhs, smlsiz
           real(sp), intent(in) :: rcond
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: b(ldb,*), d(*), e(*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_slalsd

     pure module subroutine stdlib${ii}$_dlalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, iwork, &
               info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: ldb, n, nrhs, smlsiz
           real(dp), intent(in) :: rcond
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: b(ldb,*), d(*), e(*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dlalsd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$lalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, iwork, &
               info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: ldb, n, nrhs, smlsiz
           real(${rk}$), intent(in) :: rcond
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: b(ldb,*), d(*), e(*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$lalsd

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_clalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, rwork, &
               iwork, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: ldb, n, nrhs, smlsiz
           real(sp), intent(in) :: rcond
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: b(ldb,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_clalsd

     pure module subroutine stdlib${ii}$_zlalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, rwork, &
               iwork, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: ldb, n, nrhs, smlsiz
           real(dp), intent(in) :: rcond
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: b(ldb,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zlalsd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$lalsd( uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond,rank, work, rwork, &
               iwork, info )
           character, intent(in) :: uplo
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: ldb, n, nrhs, smlsiz
           real(${ck}$), intent(in) :: rcond
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(inout) :: d(*), e(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$lalsd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, info )
               
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(sp), intent(in) :: rcond
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: s(*), work(*)
     end subroutine stdlib${ii}$_sgelss

     module subroutine stdlib${ii}$_dgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, info )
               
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(dp), intent(in) :: rcond
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: s(*), work(*)
     end subroutine stdlib${ii}$_dgelss

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$gelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, info )
               
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(${rk}$), intent(in) :: rcond
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: s(*), work(*)
     end subroutine stdlib${ii}$_${ri}$gelss

#:endif
#:endfor

     module subroutine stdlib${ii}$_cgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
               info )
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(sp), intent(in) :: rcond
           real(sp), intent(out) :: rwork(*), s(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_cgelss

     module subroutine stdlib${ii}$_zgelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
               info )
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(dp), intent(in) :: rcond
           real(dp), intent(out) :: rwork(*), s(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zgelss

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$gelss( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
               info )
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(${ck}$), intent(in) :: rcond
           real(${ck}$), intent(out) :: rwork(*), s(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$gelss

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, info )
               
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(sp), intent(in) :: rcond
           integer(${ik}$), intent(inout) :: jpvt(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_sgelsy

     module subroutine stdlib${ii}$_dgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, info )
               
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(dp), intent(in) :: rcond
           integer(${ik}$), intent(inout) :: jpvt(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dgelsy

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$gelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, info )
               
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(${rk}$), intent(in) :: rcond
           integer(${ik}$), intent(inout) :: jpvt(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$gelsy

#:endif
#:endfor

     module subroutine stdlib${ii}$_cgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, rwork, &
               info )
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(sp), intent(in) :: rcond
           integer(${ik}$), intent(inout) :: jpvt(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_cgelsy

     module subroutine stdlib${ii}$_zgelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, rwork, &
               info )
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(dp), intent(in) :: rcond
           integer(${ik}$), intent(inout) :: jpvt(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zgelsy

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$gelsy( m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank,work, lwork, rwork, &
               info )
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(${ck}$), intent(in) :: rcond
           integer(${ik}$), intent(inout) :: jpvt(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$gelsy

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
           character, intent(in) :: trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_sgels

     module subroutine stdlib${ii}$_dgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
           character, intent(in) :: trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dgels

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$gels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
           character, intent(in) :: trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$gels

#:endif
#:endfor

     module subroutine stdlib${ii}$_cgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
           character, intent(in) :: trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_cgels

     module subroutine stdlib${ii}$_zgels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
           character, intent(in) :: trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zgels

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$gels( trans, m, n, nrhs, a, lda, b, ldb, work, lwork,info )
           character, intent(in) :: trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$gels

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond,rank, work, lwork, iwork, &
               info )
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(sp), intent(in) :: rcond
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: s(*), work(*)
     end subroutine stdlib${ii}$_sgelsd

     module subroutine stdlib${ii}$_dgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, iwork, &
               info )
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(dp), intent(in) :: rcond
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: s(*), work(*)
     end subroutine stdlib${ii}$_dgelsd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$gelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, iwork, &
               info )
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(${rk}$), intent(in) :: rcond
           integer(${ik}$), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: s(*), work(*)
     end subroutine stdlib${ii}$_${ri}$gelsd

#:endif
#:endfor

     module subroutine stdlib${ii}$_cgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
               iwork, info )
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(sp), intent(in) :: rcond
           integer(${ik}$), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), s(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_cgelsd

     module subroutine stdlib${ii}$_zgelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
               iwork, info )
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(dp), intent(in) :: rcond
           integer(${ik}$), intent(out) :: iwork(*)
           real(dp), intent(out) :: rwork(*), s(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zgelsd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$gelsd( m, n, nrhs, a, lda, b, ldb, s, rcond, rank,work, lwork, rwork, &
               iwork, info )
           integer(${ik}$), intent(out) :: info, rank
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(${ck}$), intent(in) :: rcond
           integer(${ik}$), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: rwork(*), s(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$gelsd

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     module subroutine stdlib${ii}$_sgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
           character, intent(in) :: trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_sgetsls

     module subroutine stdlib${ii}$_dgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
           character, intent(in) :: trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_dgetsls

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib${ii}$_${ri}$getsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
           character, intent(in) :: trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ri}$getsls

#:endif
#:endfor

     module subroutine stdlib${ii}$_cgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
           character, intent(in) :: trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_cgetsls

     module subroutine stdlib${ii}$_zgetsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
           character, intent(in) :: trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
     end subroutine stdlib${ii}$_zgetsls

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib${ii}$_${ci}$getsls( trans, m, n, nrhs, a, lda, b, ldb,work, lwork, info )
           character, intent(in) :: trans
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, nrhs
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
     end subroutine stdlib${ii}$_${ci}$getsls

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, p
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), c(*), d(*)
           real(sp), intent(out) :: work(*), x(*)
     end subroutine stdlib${ii}$_sgglse

     pure module subroutine stdlib${ii}$_dgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, p
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), c(*), d(*)
           real(dp), intent(out) :: work(*), x(*)
     end subroutine stdlib${ii}$_dgglse

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$gglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, p
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), c(*), d(*)
           real(${rk}$), intent(out) :: work(*), x(*)
     end subroutine stdlib${ii}$_${ri}$gglse

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, p
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), c(*), d(*)
           complex(sp), intent(out) :: work(*), x(*)
     end subroutine stdlib${ii}$_cgglse

     pure module subroutine stdlib${ii}$_zgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, p
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), c(*), d(*)
           complex(dp), intent(out) :: work(*), x(*)
     end subroutine stdlib${ii}$_zgglse

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$gglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, p
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), c(*), d(*)
           complex(${ck}$), intent(out) :: work(*), x(*)
     end subroutine stdlib${ii}$_${ci}$gglse

#:endif
#:endfor

#:endfor
end interface 


interface 
#:for ik,it,ii in LINALG_INT_KINDS_TYPES
     pure module subroutine stdlib${ii}$_sggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, p
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), d(*)
           real(sp), intent(out) :: work(*), x(*), y(*)
     end subroutine stdlib${ii}$_sggglm

     pure module subroutine stdlib${ii}$_dggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, p
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), d(*)
           real(dp), intent(out) :: work(*), x(*), y(*)
     end subroutine stdlib${ii}$_dggglm

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ri}$ggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, p
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), d(*)
           real(${rk}$), intent(out) :: work(*), x(*), y(*)
     end subroutine stdlib${ii}$_${ri}$ggglm

#:endif
#:endfor

     pure module subroutine stdlib${ii}$_cggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, p
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), d(*)
           complex(sp), intent(out) :: work(*), x(*), y(*)
     end subroutine stdlib${ii}$_cggglm

     pure module subroutine stdlib${ii}$_zggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, p
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), d(*)
           complex(dp), intent(out) :: work(*), x(*), y(*)
     end subroutine stdlib${ii}$_zggglm

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib${ii}$_${ci}$ggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
           integer(${ik}$), intent(out) :: info
           integer(${ik}$), intent(in) :: lda, ldb, lwork, m, n, p
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), d(*)
           complex(${ck}$), intent(out) :: work(*), x(*), y(*)
     end subroutine stdlib${ii}$_${ci}$ggglm

#:endif
#:endfor

#:endfor
end interface 

end module stdlib_lapack_eig_svd_lsq
